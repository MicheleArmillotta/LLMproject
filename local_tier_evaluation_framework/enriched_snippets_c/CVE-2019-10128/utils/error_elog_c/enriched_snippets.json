[
  {
    "function_name": "trace_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3750-3758",
    "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
  },
  {
    "function_name": "is_log_level_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3714-3733",
    "snippet": "static bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *error_severity(int elevel);",
      "static bool is_log_level_output(int elevel, int log_min_level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\nstatic bool is_log_level_output(int elevel, int log_min_level);\n\nstatic bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "write_stderr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3668-3703",
    "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 3702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_console",
          "args": [
            "errbuf",
            "strlen(errbuf)"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "write_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2154-2220",
          "snippet": "static void\nwrite_console(const char *line, int len)\n{\n\tint\t\t\trc;\n\n#ifdef WIN32\n\n\t/*\n\t * Try to convert the message to UTF16 and write it with WriteConsoleW().\n\t * Fall back on write() if anything fails.\n\t *\n\t * In contrast to write_eventlog(), don't skip straight to write() based\n\t * on the applicable encodings.  Unlike WriteConsoleW(), write() depends\n\t * on the suitability of the console output code page.  Since we put\n\t * stderr into binary mode in SubPostmasterMain(), write() skips the\n\t * necessary translation anyway.\n\t *\n\t * WriteConsoleW() will fail if stderr is redirected, so just fall through\n\t * to writing unconverted to the logfile in this case.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\t!redirection_done &&\n\t\tCurrentMemoryContext != NULL)\n\t{\n\t\tWCHAR\t   *utf16;\n\t\tint\t\t\tutf16len;\n\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, &utf16len);\n\t\tif (utf16 != NULL)\n\t\t{\n\t\t\tHANDLE\t\tstdHandle;\n\t\t\tDWORD\t\twritten;\n\n\t\t\tstdHandle = GetStdHandle(STD_ERROR_HANDLE);\n\t\t\tif (WriteConsoleW(stdHandle, utf16, utf16len, &written, NULL))\n\t\t\t{\n\t\t\t\tpfree(utf16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In case WriteConsoleW() failed, fall back to writing the\n\t\t\t * message unconverted.\n\t\t\t */\n\t\t\tpfree(utf16);\n\t\t}\n\t}\n#else\n\n\t/*\n\t * Conversion on non-win32 platforms is not implemented yet. It requires\n\t * non-throw version of pg_do_encoding_conversion(), that converts\n\t * unconvertable characters to '?' without errors.\n\t */\n#endif\n\n\t/*\n\t * We ignore any error from write() here.  We have no useful way to report\n\t * it ... certainly whining on stderr isn't likely to be productive.\n\t */\n\trc = write(fileno(stderr), line, len);\n\t(void) rc;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool redirection_done;",
            "static void write_console(const char *line, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nextern bool redirection_done;\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_console(const char *line, int len)\n{\n\tint\t\t\trc;\n\n#ifdef WIN32\n\n\t/*\n\t * Try to convert the message to UTF16 and write it with WriteConsoleW().\n\t * Fall back on write() if anything fails.\n\t *\n\t * In contrast to write_eventlog(), don't skip straight to write() based\n\t * on the applicable encodings.  Unlike WriteConsoleW(), write() depends\n\t * on the suitability of the console output code page.  Since we put\n\t * stderr into binary mode in SubPostmasterMain(), write() skips the\n\t * necessary translation anyway.\n\t *\n\t * WriteConsoleW() will fail if stderr is redirected, so just fall through\n\t * to writing unconverted to the logfile in this case.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\t!redirection_done &&\n\t\tCurrentMemoryContext != NULL)\n\t{\n\t\tWCHAR\t   *utf16;\n\t\tint\t\t\tutf16len;\n\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, &utf16len);\n\t\tif (utf16 != NULL)\n\t\t{\n\t\t\tHANDLE\t\tstdHandle;\n\t\t\tDWORD\t\twritten;\n\n\t\t\tstdHandle = GetStdHandle(STD_ERROR_HANDLE);\n\t\t\tif (WriteConsoleW(stdHandle, utf16, utf16len, &written, NULL))\n\t\t\t{\n\t\t\t\tpfree(utf16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In case WriteConsoleW() failed, fall back to writing the\n\t\t\t * message unconverted.\n\t\t\t */\n\t\t\tpfree(utf16);\n\t\t}\n\t}\n#else\n\n\t/*\n\t * Conversion on non-win32 platforms is not implemented yet. It requires\n\t * non-throw version of pg_do_encoding_conversion(), that converts\n\t * unconvertable characters to '?' without errors.\n\t */\n#endif\n\n\t/*\n\t * We ignore any error from write() here.  We have no useful way to report\n\t * it ... certainly whining on stderr isn't likely to be productive.\n\t */\n\trc = write(fileno(stderr), line, len);\n\t(void) rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "errbuf"
          ],
          "line": 3698
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_eventlog",
          "args": [
            "ERROR",
            "errbuf",
            "strlen(errbuf)"
          ],
          "line": 3693
        },
        "resolved": true,
        "details": {
          "function_name": "write_eventlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2065-2151",
          "snippet": "static void\nwrite_eventlog(int level, const char *line, int len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\tstatic HANDLE evtHandle = INVALID_HANDLE_VALUE;\n\n\tif (evtHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tevtHandle = RegisterEventSource(NULL,\n\t\t\t\t\t\t\t\t\t\tevent_source ? event_source : DEFAULT_EVENT_SOURCE);\n\t\tif (evtHandle == NULL)\n\t\t{\n\t\t\tevtHandle = INVALID_HANDLE_VALUE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (level)\n\t{\n\t\tcase DEBUG5:\n\t\tcase DEBUG4:\n\t\tcase DEBUG3:\n\t\tcase DEBUG2:\n\t\tcase DEBUG1:\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\tcase INFO:\n\t\tcase NOTICE:\n\t\t\teventlevel = EVENTLOG_INFORMATION_TYPE;\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\teventlevel = EVENTLOG_WARNING_TYPE;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\tcase FATAL:\n\t\tcase PANIC:\n\t\tdefault:\n\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If message character encoding matches the encoding expected by\n\t * ReportEventA(), call it to avoid the hazards of conversion.  Otherwise,\n\t * try to convert the message to UTF16 and write it with ReportEventW().\n\t * Fall back on ReportEventA() if conversion failed.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t *\n\t * Also verify that we are not on our way into error recursion trouble due\n\t * to error messages thrown deep inside pgwin32_message_to_UTF16().\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\tCurrentMemoryContext != NULL &&\n\t\tGetMessageEncoding() != GetACPEncoding())\n\t{\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, NULL);\n\t\tif (utf16)\n\t\t{\n\t\t\tReportEventW(evtHandle,\n\t\t\t\t\t\t eventlevel,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t 0,\t\t/* All events are Id 0 */\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 1,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t (LPCWSTR *) &utf16,\n\t\t\t\t\t\t NULL);\n\t\t\t/* XXX Try ReportEventA() when ReportEventW() fails? */\n\n\t\t\tpfree(utf16);\n\t\t\treturn;\n\t\t}\n\t}\n\tReportEventA(evtHandle,\n\t\t\t\t eventlevel,\n\t\t\t\t 0,\n\t\t\t\t 0,\t\t\t\t/* All events are Id 0 */\n\t\t\t\t NULL,\n\t\t\t\t 1,\n\t\t\t\t 0,\n\t\t\t\t &line,\n\t\t\t\t NULL);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_console(const char *line, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_eventlog(int level, const char *line, int len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\tstatic HANDLE evtHandle = INVALID_HANDLE_VALUE;\n\n\tif (evtHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tevtHandle = RegisterEventSource(NULL,\n\t\t\t\t\t\t\t\t\t\tevent_source ? event_source : DEFAULT_EVENT_SOURCE);\n\t\tif (evtHandle == NULL)\n\t\t{\n\t\t\tevtHandle = INVALID_HANDLE_VALUE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (level)\n\t{\n\t\tcase DEBUG5:\n\t\tcase DEBUG4:\n\t\tcase DEBUG3:\n\t\tcase DEBUG2:\n\t\tcase DEBUG1:\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\tcase INFO:\n\t\tcase NOTICE:\n\t\t\teventlevel = EVENTLOG_INFORMATION_TYPE;\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\teventlevel = EVENTLOG_WARNING_TYPE;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\tcase FATAL:\n\t\tcase PANIC:\n\t\tdefault:\n\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If message character encoding matches the encoding expected by\n\t * ReportEventA(), call it to avoid the hazards of conversion.  Otherwise,\n\t * try to convert the message to UTF16 and write it with ReportEventW().\n\t * Fall back on ReportEventA() if conversion failed.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t *\n\t * Also verify that we are not on our way into error recursion trouble due\n\t * to error messages thrown deep inside pgwin32_message_to_UTF16().\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\tCurrentMemoryContext != NULL &&\n\t\tGetMessageEncoding() != GetACPEncoding())\n\t{\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, NULL);\n\t\tif (utf16)\n\t\t{\n\t\t\tReportEventW(evtHandle,\n\t\t\t\t\t\t eventlevel,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t 0,\t\t/* All events are Id 0 */\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 1,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t (LPCWSTR *) &utf16,\n\t\t\t\t\t\t NULL);\n\t\t\t/* XXX Try ReportEventA() when ReportEventW() fails? */\n\n\t\t\tpfree(utf16);\n\t\t\treturn;\n\t\t}\n\t}\n\tReportEventA(evtHandle,\n\t\t\t\t eventlevel,\n\t\t\t\t 0,\n\t\t\t\t 0,\t\t\t\t/* All events are Id 0 */\n\t\t\t\t NULL,\n\t\t\t\t 1,\n\t\t\t\t 0,\n\t\t\t\t &line,\n\t\t\t\t NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgwin32_is_service",
          "args": [],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "errbuf",
            "sizeof(errbuf)",
            "fmt",
            "ap"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "stderr",
            "fmt",
            "ap"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "fmt"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "fmt"
          ],
          "line": 3677
        },
        "resolved": true,
        "details": {
          "function_name": "trace_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3750-3758",
          "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
  },
  {
    "function_name": "append_with_tabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3649-3660",
    "snippet": "static void\nappend_with_tabs(StringInfo buf, const char *str)\n{\n\tchar\t\tch;\n\n\twhile ((ch = *str++) != '\\0')\n\t{\n\t\tappendStringInfoCharMacro(buf, ch);\n\t\tif (ch == '\\n')\n\t\t\tappendStringInfoCharMacro(buf, '\\t');\n\t}\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
      "static void append_with_tabs(StringInfo buf, const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "'\\t'"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "ch"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic void\nappend_with_tabs(StringInfo buf, const char *str)\n{\n\tchar\t\tch;\n\n\twhile ((ch = *str++) != '\\0')\n\t{\n\t\tappendStringInfoCharMacro(buf, ch);\n\t\tif (ch == '\\n')\n\t\t\tappendStringInfoCharMacro(buf, '\\t');\n\t}\n}"
  },
  {
    "function_name": "error_severity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3598-3640",
    "snippet": "static const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"PANIC\""
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"FATAL\""
          ],
          "line": 3629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"ERROR\""
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"WARNING\""
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"NOTICE\""
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"INFO\""
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"LOG\""
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettext_noop",
          "args": [
            "\"DEBUG\""
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\n\nstatic const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}"
  },
  {
    "function_name": "get_errno_symbol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3423-3589",
    "snippet": "static const char *\nget_errno_symbol(int errnum)\n{\n\tswitch (errnum)\n\t{\n\t\tcase E2BIG:\n\t\t\treturn \"E2BIG\";\n\t\tcase EACCES:\n\t\t\treturn \"EACCES\";\n#ifdef EADDRINUSE\n\t\tcase EADDRINUSE:\n\t\t\treturn \"EADDRINUSE\";\n#endif\n#ifdef EADDRNOTAVAIL\n\t\tcase EADDRNOTAVAIL:\n\t\t\treturn \"EADDRNOTAVAIL\";\n#endif\n\t\tcase EAFNOSUPPORT:\n\t\t\treturn \"EAFNOSUPPORT\";\n#ifdef EAGAIN\n\t\tcase EAGAIN:\n\t\t\treturn \"EAGAIN\";\n#endif\n#ifdef EALREADY\n\t\tcase EALREADY:\n\t\t\treturn \"EALREADY\";\n#endif\n\t\tcase EBADF:\n\t\t\treturn \"EBADF\";\n#ifdef EBADMSG\n\t\tcase EBADMSG:\n\t\t\treturn \"EBADMSG\";\n#endif\n\t\tcase EBUSY:\n\t\t\treturn \"EBUSY\";\n\t\tcase ECHILD:\n\t\t\treturn \"ECHILD\";\n#ifdef ECONNABORTED\n\t\tcase ECONNABORTED:\n\t\t\treturn \"ECONNABORTED\";\n#endif\n\t\tcase ECONNREFUSED:\n\t\t\treturn \"ECONNREFUSED\";\n#ifdef ECONNRESET\n\t\tcase ECONNRESET:\n\t\t\treturn \"ECONNRESET\";\n#endif\n\t\tcase EDEADLK:\n\t\t\treturn \"EDEADLK\";\n\t\tcase EDOM:\n\t\t\treturn \"EDOM\";\n\t\tcase EEXIST:\n\t\t\treturn \"EEXIST\";\n\t\tcase EFAULT:\n\t\t\treturn \"EFAULT\";\n\t\tcase EFBIG:\n\t\t\treturn \"EFBIG\";\n#ifdef EHOSTUNREACH\n\t\tcase EHOSTUNREACH:\n\t\t\treturn \"EHOSTUNREACH\";\n#endif\n\t\tcase EIDRM:\n\t\t\treturn \"EIDRM\";\n\t\tcase EINPROGRESS:\n\t\t\treturn \"EINPROGRESS\";\n\t\tcase EINTR:\n\t\t\treturn \"EINTR\";\n\t\tcase EINVAL:\n\t\t\treturn \"EINVAL\";\n\t\tcase EIO:\n\t\t\treturn \"EIO\";\n#ifdef EISCONN\n\t\tcase EISCONN:\n\t\t\treturn \"EISCONN\";\n#endif\n\t\tcase EISDIR:\n\t\t\treturn \"EISDIR\";\n#ifdef ELOOP\n\t\tcase ELOOP:\n\t\t\treturn \"ELOOP\";\n#endif\n\t\tcase EMFILE:\n\t\t\treturn \"EMFILE\";\n\t\tcase EMLINK:\n\t\t\treturn \"EMLINK\";\n\t\tcase EMSGSIZE:\n\t\t\treturn \"EMSGSIZE\";\n\t\tcase ENAMETOOLONG:\n\t\t\treturn \"ENAMETOOLONG\";\n\t\tcase ENFILE:\n\t\t\treturn \"ENFILE\";\n\t\tcase ENOBUFS:\n\t\t\treturn \"ENOBUFS\";\n\t\tcase ENODEV:\n\t\t\treturn \"ENODEV\";\n\t\tcase ENOENT:\n\t\t\treturn \"ENOENT\";\n\t\tcase ENOEXEC:\n\t\t\treturn \"ENOEXEC\";\n\t\tcase ENOMEM:\n\t\t\treturn \"ENOMEM\";\n\t\tcase ENOSPC:\n\t\t\treturn \"ENOSPC\";\n\t\tcase ENOSYS:\n\t\t\treturn \"ENOSYS\";\n#ifdef ENOTCONN\n\t\tcase ENOTCONN:\n\t\t\treturn \"ENOTCONN\";\n#endif\n\t\tcase ENOTDIR:\n\t\t\treturn \"ENOTDIR\";\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\n\t\t\treturn \"ENOTEMPTY\";\n#endif\n#ifdef ENOTSOCK\n\t\tcase ENOTSOCK:\n\t\t\treturn \"ENOTSOCK\";\n#endif\n#ifdef ENOTSUP\n\t\tcase ENOTSUP:\n\t\t\treturn \"ENOTSUP\";\n#endif\n\t\tcase ENOTTY:\n\t\t\treturn \"ENOTTY\";\n\t\tcase ENXIO:\n\t\t\treturn \"ENXIO\";\n#if defined(EOPNOTSUPP) && (!defined(ENOTSUP) || (EOPNOTSUPP != ENOTSUP))\n\t\tcase EOPNOTSUPP:\n\t\t\treturn \"EOPNOTSUPP\";\n#endif\n#ifdef EOVERFLOW\n\t\tcase EOVERFLOW:\n\t\t\treturn \"EOVERFLOW\";\n#endif\n\t\tcase EPERM:\n\t\t\treturn \"EPERM\";\n\t\tcase EPIPE:\n\t\t\treturn \"EPIPE\";\n\t\tcase EPROTONOSUPPORT:\n\t\t\treturn \"EPROTONOSUPPORT\";\n\t\tcase ERANGE:\n\t\t\treturn \"ERANGE\";\n#ifdef EROFS\n\t\tcase EROFS:\n\t\t\treturn \"EROFS\";\n#endif\n\t\tcase ESRCH:\n\t\t\treturn \"ESRCH\";\n#ifdef ETIMEDOUT\n\t\tcase ETIMEDOUT:\n\t\t\treturn \"ETIMEDOUT\";\n#endif\n#ifdef ETXTBSY\n\t\tcase ETXTBSY:\n\t\t\treturn \"ETXTBSY\";\n#endif\n#if defined(EWOULDBLOCK) && (!defined(EAGAIN) || (EWOULDBLOCK != EAGAIN))\n\t\tcase EWOULDBLOCK:\n\t\t\treturn \"EWOULDBLOCK\";\n#endif\n\t\tcase EXDEV:\n\t\t\treturn \"EXDEV\";\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *useful_strerror(int errnum);",
      "static const char *get_errno_symbol(int errnum);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *useful_strerror(int errnum);\nstatic const char *get_errno_symbol(int errnum);\n\nstatic const char *\nget_errno_symbol(int errnum)\n{\n\tswitch (errnum)\n\t{\n\t\tcase E2BIG:\n\t\t\treturn \"E2BIG\";\n\t\tcase EACCES:\n\t\t\treturn \"EACCES\";\n#ifdef EADDRINUSE\n\t\tcase EADDRINUSE:\n\t\t\treturn \"EADDRINUSE\";\n#endif\n#ifdef EADDRNOTAVAIL\n\t\tcase EADDRNOTAVAIL:\n\t\t\treturn \"EADDRNOTAVAIL\";\n#endif\n\t\tcase EAFNOSUPPORT:\n\t\t\treturn \"EAFNOSUPPORT\";\n#ifdef EAGAIN\n\t\tcase EAGAIN:\n\t\t\treturn \"EAGAIN\";\n#endif\n#ifdef EALREADY\n\t\tcase EALREADY:\n\t\t\treturn \"EALREADY\";\n#endif\n\t\tcase EBADF:\n\t\t\treturn \"EBADF\";\n#ifdef EBADMSG\n\t\tcase EBADMSG:\n\t\t\treturn \"EBADMSG\";\n#endif\n\t\tcase EBUSY:\n\t\t\treturn \"EBUSY\";\n\t\tcase ECHILD:\n\t\t\treturn \"ECHILD\";\n#ifdef ECONNABORTED\n\t\tcase ECONNABORTED:\n\t\t\treturn \"ECONNABORTED\";\n#endif\n\t\tcase ECONNREFUSED:\n\t\t\treturn \"ECONNREFUSED\";\n#ifdef ECONNRESET\n\t\tcase ECONNRESET:\n\t\t\treturn \"ECONNRESET\";\n#endif\n\t\tcase EDEADLK:\n\t\t\treturn \"EDEADLK\";\n\t\tcase EDOM:\n\t\t\treturn \"EDOM\";\n\t\tcase EEXIST:\n\t\t\treturn \"EEXIST\";\n\t\tcase EFAULT:\n\t\t\treturn \"EFAULT\";\n\t\tcase EFBIG:\n\t\t\treturn \"EFBIG\";\n#ifdef EHOSTUNREACH\n\t\tcase EHOSTUNREACH:\n\t\t\treturn \"EHOSTUNREACH\";\n#endif\n\t\tcase EIDRM:\n\t\t\treturn \"EIDRM\";\n\t\tcase EINPROGRESS:\n\t\t\treturn \"EINPROGRESS\";\n\t\tcase EINTR:\n\t\t\treturn \"EINTR\";\n\t\tcase EINVAL:\n\t\t\treturn \"EINVAL\";\n\t\tcase EIO:\n\t\t\treturn \"EIO\";\n#ifdef EISCONN\n\t\tcase EISCONN:\n\t\t\treturn \"EISCONN\";\n#endif\n\t\tcase EISDIR:\n\t\t\treturn \"EISDIR\";\n#ifdef ELOOP\n\t\tcase ELOOP:\n\t\t\treturn \"ELOOP\";\n#endif\n\t\tcase EMFILE:\n\t\t\treturn \"EMFILE\";\n\t\tcase EMLINK:\n\t\t\treturn \"EMLINK\";\n\t\tcase EMSGSIZE:\n\t\t\treturn \"EMSGSIZE\";\n\t\tcase ENAMETOOLONG:\n\t\t\treturn \"ENAMETOOLONG\";\n\t\tcase ENFILE:\n\t\t\treturn \"ENFILE\";\n\t\tcase ENOBUFS:\n\t\t\treturn \"ENOBUFS\";\n\t\tcase ENODEV:\n\t\t\treturn \"ENODEV\";\n\t\tcase ENOENT:\n\t\t\treturn \"ENOENT\";\n\t\tcase ENOEXEC:\n\t\t\treturn \"ENOEXEC\";\n\t\tcase ENOMEM:\n\t\t\treturn \"ENOMEM\";\n\t\tcase ENOSPC:\n\t\t\treturn \"ENOSPC\";\n\t\tcase ENOSYS:\n\t\t\treturn \"ENOSYS\";\n#ifdef ENOTCONN\n\t\tcase ENOTCONN:\n\t\t\treturn \"ENOTCONN\";\n#endif\n\t\tcase ENOTDIR:\n\t\t\treturn \"ENOTDIR\";\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\n\t\t\treturn \"ENOTEMPTY\";\n#endif\n#ifdef ENOTSOCK\n\t\tcase ENOTSOCK:\n\t\t\treturn \"ENOTSOCK\";\n#endif\n#ifdef ENOTSUP\n\t\tcase ENOTSUP:\n\t\t\treturn \"ENOTSUP\";\n#endif\n\t\tcase ENOTTY:\n\t\t\treturn \"ENOTTY\";\n\t\tcase ENXIO:\n\t\t\treturn \"ENXIO\";\n#if defined(EOPNOTSUPP) && (!defined(ENOTSUP) || (EOPNOTSUPP != ENOTSUP))\n\t\tcase EOPNOTSUPP:\n\t\t\treturn \"EOPNOTSUPP\";\n#endif\n#ifdef EOVERFLOW\n\t\tcase EOVERFLOW:\n\t\t\treturn \"EOVERFLOW\";\n#endif\n\t\tcase EPERM:\n\t\t\treturn \"EPERM\";\n\t\tcase EPIPE:\n\t\t\treturn \"EPIPE\";\n\t\tcase EPROTONOSUPPORT:\n\t\t\treturn \"EPROTONOSUPPORT\";\n\t\tcase ERANGE:\n\t\t\treturn \"ERANGE\";\n#ifdef EROFS\n\t\tcase EROFS:\n\t\t\treturn \"EROFS\";\n#endif\n\t\tcase ESRCH:\n\t\t\treturn \"ESRCH\";\n#ifdef ETIMEDOUT\n\t\tcase ETIMEDOUT:\n\t\t\treturn \"ETIMEDOUT\";\n#endif\n#ifdef ETXTBSY\n\t\tcase ETXTBSY:\n\t\t\treturn \"ETXTBSY\";\n#endif\n#if defined(EWOULDBLOCK) && (!defined(EAGAIN) || (EWOULDBLOCK != EAGAIN))\n\t\tcase EWOULDBLOCK:\n\t\t\treturn \"EWOULDBLOCK\";\n#endif\n\t\tcase EXDEV:\n\t\t\treturn \"EXDEV\";\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "useful_strerror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3382-3417",
    "snippet": "static const char *\nuseful_strerror(int errnum)\n{\n\t/* this buffer is only used if strerror() and get_errno_symbol() fail */\n\tstatic char errorstr_buf[48];\n\tconst char *str;\n\n#ifdef WIN32\n\t/* Winsock error code range, per WinError.h */\n\tif (errnum >= 10000 && errnum <= 11999)\n\t\treturn pgwin32_socket_strerror(errnum);\n#endif\n\tstr = strerror(errnum);\n\n\t/*\n\t * Some strerror()s return an empty string for out-of-range errno.  This\n\t * is ANSI C spec compliant, but not exactly useful.  Also, we may get\n\t * back strings of question marks if libc cannot transcode the message to\n\t * the codeset specified by LC_CTYPE.  If we get nothing useful, first try\n\t * get_errno_symbol(), and if that fails, print the numeric errno.\n\t */\n\tif (str == NULL || *str == '\\0' || *str == '?')\n\t\tstr = get_errno_symbol(errnum);\n\n\tif (str == NULL)\n\t{\n\t\tsnprintf(errorstr_buf, sizeof(errorstr_buf),\n\t\t/*------\n\t\t  translator: This string will be truncated at 47\n\t\t  characters expanded. */\n\t\t\t\t _(\"operating system error %d\"), errnum);\n\t\tstr = errorstr_buf;\n\t}\n\n\treturn str;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
      "static const char *useful_strerror(int errnum);",
      "static const char *get_errno_symbol(int errnum);",
      "static void append_with_tabs(StringInfo buf, const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "errorstr_buf",
            "sizeof(errorstr_buf)",
            "/*------\n\t\t  translator: This string will be truncated at 47\n\t\t  characters expanded. */_(\"operating system error %d\")",
            "errnum"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"operating system error %d\""
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "trace_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3750-3758",
          "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_errno_symbol",
          "args": [
            "errnum"
          ],
          "line": 3404
        },
        "resolved": true,
        "details": {
          "function_name": "get_errno_symbol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3423-3589",
          "snippet": "static const char *\nget_errno_symbol(int errnum)\n{\n\tswitch (errnum)\n\t{\n\t\tcase E2BIG:\n\t\t\treturn \"E2BIG\";\n\t\tcase EACCES:\n\t\t\treturn \"EACCES\";\n#ifdef EADDRINUSE\n\t\tcase EADDRINUSE:\n\t\t\treturn \"EADDRINUSE\";\n#endif\n#ifdef EADDRNOTAVAIL\n\t\tcase EADDRNOTAVAIL:\n\t\t\treturn \"EADDRNOTAVAIL\";\n#endif\n\t\tcase EAFNOSUPPORT:\n\t\t\treturn \"EAFNOSUPPORT\";\n#ifdef EAGAIN\n\t\tcase EAGAIN:\n\t\t\treturn \"EAGAIN\";\n#endif\n#ifdef EALREADY\n\t\tcase EALREADY:\n\t\t\treturn \"EALREADY\";\n#endif\n\t\tcase EBADF:\n\t\t\treturn \"EBADF\";\n#ifdef EBADMSG\n\t\tcase EBADMSG:\n\t\t\treturn \"EBADMSG\";\n#endif\n\t\tcase EBUSY:\n\t\t\treturn \"EBUSY\";\n\t\tcase ECHILD:\n\t\t\treturn \"ECHILD\";\n#ifdef ECONNABORTED\n\t\tcase ECONNABORTED:\n\t\t\treturn \"ECONNABORTED\";\n#endif\n\t\tcase ECONNREFUSED:\n\t\t\treturn \"ECONNREFUSED\";\n#ifdef ECONNRESET\n\t\tcase ECONNRESET:\n\t\t\treturn \"ECONNRESET\";\n#endif\n\t\tcase EDEADLK:\n\t\t\treturn \"EDEADLK\";\n\t\tcase EDOM:\n\t\t\treturn \"EDOM\";\n\t\tcase EEXIST:\n\t\t\treturn \"EEXIST\";\n\t\tcase EFAULT:\n\t\t\treturn \"EFAULT\";\n\t\tcase EFBIG:\n\t\t\treturn \"EFBIG\";\n#ifdef EHOSTUNREACH\n\t\tcase EHOSTUNREACH:\n\t\t\treturn \"EHOSTUNREACH\";\n#endif\n\t\tcase EIDRM:\n\t\t\treturn \"EIDRM\";\n\t\tcase EINPROGRESS:\n\t\t\treturn \"EINPROGRESS\";\n\t\tcase EINTR:\n\t\t\treturn \"EINTR\";\n\t\tcase EINVAL:\n\t\t\treturn \"EINVAL\";\n\t\tcase EIO:\n\t\t\treturn \"EIO\";\n#ifdef EISCONN\n\t\tcase EISCONN:\n\t\t\treturn \"EISCONN\";\n#endif\n\t\tcase EISDIR:\n\t\t\treturn \"EISDIR\";\n#ifdef ELOOP\n\t\tcase ELOOP:\n\t\t\treturn \"ELOOP\";\n#endif\n\t\tcase EMFILE:\n\t\t\treturn \"EMFILE\";\n\t\tcase EMLINK:\n\t\t\treturn \"EMLINK\";\n\t\tcase EMSGSIZE:\n\t\t\treturn \"EMSGSIZE\";\n\t\tcase ENAMETOOLONG:\n\t\t\treturn \"ENAMETOOLONG\";\n\t\tcase ENFILE:\n\t\t\treturn \"ENFILE\";\n\t\tcase ENOBUFS:\n\t\t\treturn \"ENOBUFS\";\n\t\tcase ENODEV:\n\t\t\treturn \"ENODEV\";\n\t\tcase ENOENT:\n\t\t\treturn \"ENOENT\";\n\t\tcase ENOEXEC:\n\t\t\treturn \"ENOEXEC\";\n\t\tcase ENOMEM:\n\t\t\treturn \"ENOMEM\";\n\t\tcase ENOSPC:\n\t\t\treturn \"ENOSPC\";\n\t\tcase ENOSYS:\n\t\t\treturn \"ENOSYS\";\n#ifdef ENOTCONN\n\t\tcase ENOTCONN:\n\t\t\treturn \"ENOTCONN\";\n#endif\n\t\tcase ENOTDIR:\n\t\t\treturn \"ENOTDIR\";\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\n\t\t\treturn \"ENOTEMPTY\";\n#endif\n#ifdef ENOTSOCK\n\t\tcase ENOTSOCK:\n\t\t\treturn \"ENOTSOCK\";\n#endif\n#ifdef ENOTSUP\n\t\tcase ENOTSUP:\n\t\t\treturn \"ENOTSUP\";\n#endif\n\t\tcase ENOTTY:\n\t\t\treturn \"ENOTTY\";\n\t\tcase ENXIO:\n\t\t\treturn \"ENXIO\";\n#if defined(EOPNOTSUPP) && (!defined(ENOTSUP) || (EOPNOTSUPP != ENOTSUP))\n\t\tcase EOPNOTSUPP:\n\t\t\treturn \"EOPNOTSUPP\";\n#endif\n#ifdef EOVERFLOW\n\t\tcase EOVERFLOW:\n\t\t\treturn \"EOVERFLOW\";\n#endif\n\t\tcase EPERM:\n\t\t\treturn \"EPERM\";\n\t\tcase EPIPE:\n\t\t\treturn \"EPIPE\";\n\t\tcase EPROTONOSUPPORT:\n\t\t\treturn \"EPROTONOSUPPORT\";\n\t\tcase ERANGE:\n\t\t\treturn \"ERANGE\";\n#ifdef EROFS\n\t\tcase EROFS:\n\t\t\treturn \"EROFS\";\n#endif\n\t\tcase ESRCH:\n\t\t\treturn \"ESRCH\";\n#ifdef ETIMEDOUT\n\t\tcase ETIMEDOUT:\n\t\t\treturn \"ETIMEDOUT\";\n#endif\n#ifdef ETXTBSY\n\t\tcase ETXTBSY:\n\t\t\treturn \"ETXTBSY\";\n#endif\n#if defined(EWOULDBLOCK) && (!defined(EAGAIN) || (EWOULDBLOCK != EAGAIN))\n\t\tcase EWOULDBLOCK:\n\t\t\treturn \"EWOULDBLOCK\";\n#endif\n\t\tcase EXDEV:\n\t\t\treturn \"EXDEV\";\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *useful_strerror(int errnum);",
            "static const char *get_errno_symbol(int errnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *useful_strerror(int errnum);\nstatic const char *get_errno_symbol(int errnum);\n\nstatic const char *\nget_errno_symbol(int errnum)\n{\n\tswitch (errnum)\n\t{\n\t\tcase E2BIG:\n\t\t\treturn \"E2BIG\";\n\t\tcase EACCES:\n\t\t\treturn \"EACCES\";\n#ifdef EADDRINUSE\n\t\tcase EADDRINUSE:\n\t\t\treturn \"EADDRINUSE\";\n#endif\n#ifdef EADDRNOTAVAIL\n\t\tcase EADDRNOTAVAIL:\n\t\t\treturn \"EADDRNOTAVAIL\";\n#endif\n\t\tcase EAFNOSUPPORT:\n\t\t\treturn \"EAFNOSUPPORT\";\n#ifdef EAGAIN\n\t\tcase EAGAIN:\n\t\t\treturn \"EAGAIN\";\n#endif\n#ifdef EALREADY\n\t\tcase EALREADY:\n\t\t\treturn \"EALREADY\";\n#endif\n\t\tcase EBADF:\n\t\t\treturn \"EBADF\";\n#ifdef EBADMSG\n\t\tcase EBADMSG:\n\t\t\treturn \"EBADMSG\";\n#endif\n\t\tcase EBUSY:\n\t\t\treturn \"EBUSY\";\n\t\tcase ECHILD:\n\t\t\treturn \"ECHILD\";\n#ifdef ECONNABORTED\n\t\tcase ECONNABORTED:\n\t\t\treturn \"ECONNABORTED\";\n#endif\n\t\tcase ECONNREFUSED:\n\t\t\treturn \"ECONNREFUSED\";\n#ifdef ECONNRESET\n\t\tcase ECONNRESET:\n\t\t\treturn \"ECONNRESET\";\n#endif\n\t\tcase EDEADLK:\n\t\t\treturn \"EDEADLK\";\n\t\tcase EDOM:\n\t\t\treturn \"EDOM\";\n\t\tcase EEXIST:\n\t\t\treturn \"EEXIST\";\n\t\tcase EFAULT:\n\t\t\treturn \"EFAULT\";\n\t\tcase EFBIG:\n\t\t\treturn \"EFBIG\";\n#ifdef EHOSTUNREACH\n\t\tcase EHOSTUNREACH:\n\t\t\treturn \"EHOSTUNREACH\";\n#endif\n\t\tcase EIDRM:\n\t\t\treturn \"EIDRM\";\n\t\tcase EINPROGRESS:\n\t\t\treturn \"EINPROGRESS\";\n\t\tcase EINTR:\n\t\t\treturn \"EINTR\";\n\t\tcase EINVAL:\n\t\t\treturn \"EINVAL\";\n\t\tcase EIO:\n\t\t\treturn \"EIO\";\n#ifdef EISCONN\n\t\tcase EISCONN:\n\t\t\treturn \"EISCONN\";\n#endif\n\t\tcase EISDIR:\n\t\t\treturn \"EISDIR\";\n#ifdef ELOOP\n\t\tcase ELOOP:\n\t\t\treturn \"ELOOP\";\n#endif\n\t\tcase EMFILE:\n\t\t\treturn \"EMFILE\";\n\t\tcase EMLINK:\n\t\t\treturn \"EMLINK\";\n\t\tcase EMSGSIZE:\n\t\t\treturn \"EMSGSIZE\";\n\t\tcase ENAMETOOLONG:\n\t\t\treturn \"ENAMETOOLONG\";\n\t\tcase ENFILE:\n\t\t\treturn \"ENFILE\";\n\t\tcase ENOBUFS:\n\t\t\treturn \"ENOBUFS\";\n\t\tcase ENODEV:\n\t\t\treturn \"ENODEV\";\n\t\tcase ENOENT:\n\t\t\treturn \"ENOENT\";\n\t\tcase ENOEXEC:\n\t\t\treturn \"ENOEXEC\";\n\t\tcase ENOMEM:\n\t\t\treturn \"ENOMEM\";\n\t\tcase ENOSPC:\n\t\t\treturn \"ENOSPC\";\n\t\tcase ENOSYS:\n\t\t\treturn \"ENOSYS\";\n#ifdef ENOTCONN\n\t\tcase ENOTCONN:\n\t\t\treturn \"ENOTCONN\";\n#endif\n\t\tcase ENOTDIR:\n\t\t\treturn \"ENOTDIR\";\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\n\t\t\treturn \"ENOTEMPTY\";\n#endif\n#ifdef ENOTSOCK\n\t\tcase ENOTSOCK:\n\t\t\treturn \"ENOTSOCK\";\n#endif\n#ifdef ENOTSUP\n\t\tcase ENOTSUP:\n\t\t\treturn \"ENOTSUP\";\n#endif\n\t\tcase ENOTTY:\n\t\t\treturn \"ENOTTY\";\n\t\tcase ENXIO:\n\t\t\treturn \"ENXIO\";\n#if defined(EOPNOTSUPP) && (!defined(ENOTSUP) || (EOPNOTSUPP != ENOTSUP))\n\t\tcase EOPNOTSUPP:\n\t\t\treturn \"EOPNOTSUPP\";\n#endif\n#ifdef EOVERFLOW\n\t\tcase EOVERFLOW:\n\t\t\treturn \"EOVERFLOW\";\n#endif\n\t\tcase EPERM:\n\t\t\treturn \"EPERM\";\n\t\tcase EPIPE:\n\t\t\treturn \"EPIPE\";\n\t\tcase EPROTONOSUPPORT:\n\t\t\treturn \"EPROTONOSUPPORT\";\n\t\tcase ERANGE:\n\t\t\treturn \"ERANGE\";\n#ifdef EROFS\n\t\tcase EROFS:\n\t\t\treturn \"EROFS\";\n#endif\n\t\tcase ESRCH:\n\t\t\treturn \"ESRCH\";\n#ifdef ETIMEDOUT\n\t\tcase ETIMEDOUT:\n\t\t\treturn \"ETIMEDOUT\";\n#endif\n#ifdef ETXTBSY\n\t\tcase ETXTBSY:\n\t\t\treturn \"ETXTBSY\";\n#endif\n#if defined(EWOULDBLOCK) && (!defined(EAGAIN) || (EWOULDBLOCK != EAGAIN))\n\t\tcase EWOULDBLOCK:\n\t\t\treturn \"EWOULDBLOCK\";\n#endif\n\t\tcase EXDEV:\n\t\t\treturn \"EXDEV\";\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errnum"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "useful_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3382-3417",
          "snippet": "static const char *\nuseful_strerror(int errnum)\n{\n\t/* this buffer is only used if strerror() and get_errno_symbol() fail */\n\tstatic char errorstr_buf[48];\n\tconst char *str;\n\n#ifdef WIN32\n\t/* Winsock error code range, per WinError.h */\n\tif (errnum >= 10000 && errnum <= 11999)\n\t\treturn pgwin32_socket_strerror(errnum);\n#endif\n\tstr = strerror(errnum);\n\n\t/*\n\t * Some strerror()s return an empty string for out-of-range errno.  This\n\t * is ANSI C spec compliant, but not exactly useful.  Also, we may get\n\t * back strings of question marks if libc cannot transcode the message to\n\t * the codeset specified by LC_CTYPE.  If we get nothing useful, first try\n\t * get_errno_symbol(), and if that fails, print the numeric errno.\n\t */\n\tif (str == NULL || *str == '\\0' || *str == '?')\n\t\tstr = get_errno_symbol(errnum);\n\n\tif (str == NULL)\n\t{\n\t\tsnprintf(errorstr_buf, sizeof(errorstr_buf),\n\t\t/*------\n\t\t  translator: This string will be truncated at 47\n\t\t  characters expanded. */\n\t\t\t\t _(\"operating system error %d\"), errnum);\n\t\tstr = errorstr_buf;\n\t}\n\n\treturn str;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pgwin32_socket_strerror",
          "args": [
            "errnum"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic const char *useful_strerror(int errnum);\nstatic const char *get_errno_symbol(int errnum);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic const char *\nuseful_strerror(int errnum)\n{\n\t/* this buffer is only used if strerror() and get_errno_symbol() fail */\n\tstatic char errorstr_buf[48];\n\tconst char *str;\n\n#ifdef WIN32\n\t/* Winsock error code range, per WinError.h */\n\tif (errnum >= 10000 && errnum <= 11999)\n\t\treturn pgwin32_socket_strerror(errnum);\n#endif\n\tstr = strerror(errnum);\n\n\t/*\n\t * Some strerror()s return an empty string for out-of-range errno.  This\n\t * is ANSI C spec compliant, but not exactly useful.  Also, we may get\n\t * back strings of question marks if libc cannot transcode the message to\n\t * the codeset specified by LC_CTYPE.  If we get nothing useful, first try\n\t * get_errno_symbol(), and if that fails, print the numeric errno.\n\t */\n\tif (str == NULL || *str == '\\0' || *str == '?')\n\t\tstr = get_errno_symbol(errnum);\n\n\tif (str == NULL)\n\t{\n\t\tsnprintf(errorstr_buf, sizeof(errorstr_buf),\n\t\t/*------\n\t\t  translator: This string will be truncated at 47\n\t\t  characters expanded. */\n\t\t\t\t _(\"operating system error %d\"), errnum);\n\t\tstr = errorstr_buf;\n\t}\n\n\treturn str;\n}"
  },
  {
    "function_name": "expand_fmt_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3334-3376",
    "snippet": "static char *\nexpand_fmt_string(const char *fmt, ErrorData *edata)\n{\n\tStringInfoData buf;\n\tconst char *cp;\n\n\tinitStringInfo(&buf);\n\n\tfor (cp = fmt; *cp; cp++)\n\t{\n\t\tif (cp[0] == '%' && cp[1] != '\\0')\n\t\t{\n\t\t\tcp++;\n\t\t\tif (*cp == 'm')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Replace %m by system error string.  If there are any %'s in\n\t\t\t\t * the string, we'd better double them so that vsnprintf won't\n\t\t\t\t * misinterpret.\n\t\t\t\t */\n\t\t\t\tconst char *cp2;\n\n\t\t\t\tcp2 = useful_strerror(edata->saved_errno);\n\t\t\t\tfor (; *cp2; cp2++)\n\t\t\t\t{\n\t\t\t\t\tif (*cp2 == '%')\n\t\t\t\t\t\tappendStringInfoCharMacro(&buf, '%');\n\t\t\t\t\tappendStringInfoCharMacro(&buf, *cp2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* copy % and next char --- this avoids trouble with %%m */\n\t\t\t\tappendStringInfoCharMacro(&buf, '%');\n\t\t\t\tappendStringInfoCharMacro(&buf, *cp);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tappendStringInfoCharMacro(&buf, *cp);\n\t}\n\n\treturn buf.data;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "*cp"
          ],
          "line": 3372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "*cp"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "'%'"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "*cp2"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "&buf",
            "'%'"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "useful_strerror",
          "args": [
            "edata->saved_errno"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "useful_strerror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3382-3417",
          "snippet": "static const char *\nuseful_strerror(int errnum)\n{\n\t/* this buffer is only used if strerror() and get_errno_symbol() fail */\n\tstatic char errorstr_buf[48];\n\tconst char *str;\n\n#ifdef WIN32\n\t/* Winsock error code range, per WinError.h */\n\tif (errnum >= 10000 && errnum <= 11999)\n\t\treturn pgwin32_socket_strerror(errnum);\n#endif\n\tstr = strerror(errnum);\n\n\t/*\n\t * Some strerror()s return an empty string for out-of-range errno.  This\n\t * is ANSI C spec compliant, but not exactly useful.  Also, we may get\n\t * back strings of question marks if libc cannot transcode the message to\n\t * the codeset specified by LC_CTYPE.  If we get nothing useful, first try\n\t * get_errno_symbol(), and if that fails, print the numeric errno.\n\t */\n\tif (str == NULL || *str == '\\0' || *str == '?')\n\t\tstr = get_errno_symbol(errnum);\n\n\tif (str == NULL)\n\t{\n\t\tsnprintf(errorstr_buf, sizeof(errorstr_buf),\n\t\t/*------\n\t\t  translator: This string will be truncated at 47\n\t\t  characters expanded. */\n\t\t\t\t _(\"operating system error %d\"), errnum);\n\t\tstr = errorstr_buf;\n\t}\n\n\treturn str;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static const char *useful_strerror(int errnum);",
            "static const char *get_errno_symbol(int errnum);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic const char *useful_strerror(int errnum);\nstatic const char *get_errno_symbol(int errnum);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic const char *\nuseful_strerror(int errnum)\n{\n\t/* this buffer is only used if strerror() and get_errno_symbol() fail */\n\tstatic char errorstr_buf[48];\n\tconst char *str;\n\n#ifdef WIN32\n\t/* Winsock error code range, per WinError.h */\n\tif (errnum >= 10000 && errnum <= 11999)\n\t\treturn pgwin32_socket_strerror(errnum);\n#endif\n\tstr = strerror(errnum);\n\n\t/*\n\t * Some strerror()s return an empty string for out-of-range errno.  This\n\t * is ANSI C spec compliant, but not exactly useful.  Also, we may get\n\t * back strings of question marks if libc cannot transcode the message to\n\t * the codeset specified by LC_CTYPE.  If we get nothing useful, first try\n\t * get_errno_symbol(), and if that fails, print the numeric errno.\n\t */\n\tif (str == NULL || *str == '\\0' || *str == '?')\n\t\tstr = get_errno_symbol(errnum);\n\n\tif (str == NULL)\n\t{\n\t\tsnprintf(errorstr_buf, sizeof(errorstr_buf),\n\t\t/*------\n\t\t  translator: This string will be truncated at 47\n\t\t  characters expanded. */\n\t\t\t\t _(\"operating system error %d\"), errnum);\n\t\tstr = errorstr_buf;\n\t}\n\n\treturn str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nstatic char *\nexpand_fmt_string(const char *fmt, ErrorData *edata)\n{\n\tStringInfoData buf;\n\tconst char *cp;\n\n\tinitStringInfo(&buf);\n\n\tfor (cp = fmt; *cp; cp++)\n\t{\n\t\tif (cp[0] == '%' && cp[1] != '\\0')\n\t\t{\n\t\t\tcp++;\n\t\t\tif (*cp == 'm')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Replace %m by system error string.  If there are any %'s in\n\t\t\t\t * the string, we'd better double them so that vsnprintf won't\n\t\t\t\t * misinterpret.\n\t\t\t\t */\n\t\t\t\tconst char *cp2;\n\n\t\t\t\tcp2 = useful_strerror(edata->saved_errno);\n\t\t\t\tfor (; *cp2; cp2++)\n\t\t\t\t{\n\t\t\t\t\tif (*cp2 == '%')\n\t\t\t\t\t\tappendStringInfoCharMacro(&buf, '%');\n\t\t\t\t\tappendStringInfoCharMacro(&buf, *cp2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* copy % and next char --- this avoids trouble with %%m */\n\t\t\t\tappendStringInfoCharMacro(&buf, '%');\n\t\t\t\tappendStringInfoCharMacro(&buf, *cp);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tappendStringInfoCharMacro(&buf, *cp);\n\t}\n\n\treturn buf.data;\n}"
  },
  {
    "function_name": "send_message_to_frontend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3144-3318",
    "snippet": "static void\nsend_message_to_frontend(ErrorData *edata)\n{\n\tStringInfoData msgbuf;\n\n\t/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */\n\tpq_beginmessage(&msgbuf, (edata->elevel < ERROR) ? 'N' : 'E');\n\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)\n\t{\n\t\t/* New style with separate fields */\n\t\tconst char *sev;\n\t\tchar\t\ttbuf[12];\n\t\tint\t\t\tssval;\n\t\tint\t\t\ti;\n\n\t\tsev = error_severity(edata->elevel);\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY);\n\t\terr_sendstring(&msgbuf, _(sev));\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY_NONLOCALIZED);\n\t\terr_sendstring(&msgbuf, sev);\n\n\t\t/* unpack MAKE_SQLSTATE code */\n\t\tssval = edata->sqlerrcode;\n\t\tfor (i = 0; i < 5; i++)\n\t\t{\n\t\t\ttbuf[i] = PGUNSIXBIT(ssval);\n\t\t\tssval >>= 6;\n\t\t}\n\t\ttbuf[i] = '\\0';\n\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SQLSTATE);\n\t\terr_sendstring(&msgbuf, tbuf);\n\n\t\t/* M field is required per protocol, so always send something */\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_PRIMARY);\n\t\tif (edata->message)\n\t\t\terr_sendstring(&msgbuf, edata->message);\n\t\telse\n\t\t\terr_sendstring(&msgbuf, _(\"missing error text\"));\n\n\t\tif (edata->detail)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_DETAIL);\n\t\t\terr_sendstring(&msgbuf, edata->detail);\n\t\t}\n\n\t\t/* detail_log is intentionally not used here */\n\n\t\tif (edata->hint)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_HINT);\n\t\t\terr_sendstring(&msgbuf, edata->hint);\n\t\t}\n\n\t\tif (edata->context)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONTEXT);\n\t\t\terr_sendstring(&msgbuf, edata->context);\n\t\t}\n\n\t\tif (edata->schema_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SCHEMA_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->schema_name);\n\t\t}\n\n\t\tif (edata->table_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_TABLE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->table_name);\n\t\t}\n\n\t\tif (edata->column_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_COLUMN_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->column_name);\n\t\t}\n\n\t\tif (edata->datatype_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_DATATYPE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->datatype_name);\n\t\t}\n\n\t\tif (edata->constraint_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONSTRAINT_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->constraint_name);\n\t\t}\n\n\t\tif (edata->cursorpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->cursorpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_STATEMENT_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->internalpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_QUERY);\n\t\t\terr_sendstring(&msgbuf, edata->internalquery);\n\t\t}\n\n\t\tif (edata->filename)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FILE);\n\t\t\terr_sendstring(&msgbuf, edata->filename);\n\t\t}\n\n\t\tif (edata->lineno > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->lineno);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_LINE);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->funcname)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FUNCTION);\n\t\t\terr_sendstring(&msgbuf, edata->funcname);\n\t\t}\n\n\t\tpq_sendbyte(&msgbuf, '\\0'); /* terminator */\n\t}\n\telse\n\t{\n\t\t/* Old style --- gin up a backwards-compatible message */\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\t\tif (edata->show_funcname && edata->funcname)\n\t\t\tappendStringInfo(&buf, \"%s: \", edata->funcname);\n\n\t\tif (edata->message)\n\t\t\tappendStringInfoString(&buf, edata->message);\n\t\telse\n\t\t\tappendStringInfoString(&buf, _(\"missing error text\"));\n\n\t\tif (edata->cursorpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->cursorpos);\n\t\telse if (edata->internalpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->internalpos);\n\n\t\tappendStringInfoChar(&buf, '\\n');\n\n\t\terr_sendstring(&msgbuf, buf.data);\n\n\t\tpfree(buf.data);\n\t}\n\n\tpq_endmessage(&msgbuf);\n\n\t/*\n\t * This flush is normally not necessary, since postgres.c will flush out\n\t * waiting data when control returns to the main loop. But it seems best\n\t * to leave it here, so that the client has some clue what happened if the\n\t * backend dies before getting back to the main loop ... error/notice\n\t * messages should not be a performance-critical path anyway, so an extra\n\t * flush won't hurt much ...\n\t */\n\tpq_flush();\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pq_flush",
          "args": [],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_endmessage",
          "args": [
            "&msgbuf"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "buf.data"
          ],
          "line": 3304
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "err_sendstring",
          "args": [
            "&msgbuf",
            "buf.data"
          ],
          "line": 3302
        },
        "resolved": true,
        "details": {
          "function_name": "err_sendstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3132-3139",
          "snippet": "static void\nerr_sendstring(StringInfo buf, const char *str)\n{\n\tif (in_error_recursion_trouble())\n\t\tpq_send_ascii_string(buf, str);\n\telse\n\t\tpq_sendstring(buf, str);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic void\nerr_sendstring(StringInfo buf, const char *str)\n{\n\tif (in_error_recursion_trouble())\n\t\tpq_send_ascii_string(buf, str);\n\telse\n\t\tpq_sendstring(buf, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "_(\" at character %d\")",
            "edata->internalpos"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\" at character %d\""
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "trace_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3750-3758",
          "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "_(\" at character %d\")",
            "edata->cursorpos"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(\"missing error text\")"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "edata->message"
          ],
          "line": 3289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s: \"",
            "edata->funcname"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s:  \"",
            "_(error_severity(edata->elevel))"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_severity",
          "args": [
            "edata->elevel"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "error_severity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3598-3640",
          "snippet": "static const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\n\nstatic const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "'\\0'"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_SOURCE_FUNCTION"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_SOURCE_LINE"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"%d\"",
            "edata->lineno"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_SOURCE_FILE"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_INTERNAL_QUERY"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_INTERNAL_POSITION"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"%d\"",
            "edata->internalpos"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_STATEMENT_POSITION"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"%d\"",
            "edata->cursorpos"
          ],
          "line": 3237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_CONSTRAINT_NAME"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_DATATYPE_NAME"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_COLUMN_NAME"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_TABLE_NAME"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_SCHEMA_NAME"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_CONTEXT"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_MESSAGE_HINT"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_MESSAGE_DETAIL"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_MESSAGE_PRIMARY"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_SQLSTATE"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PGUNSIXBIT",
          "args": [
            "ssval"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_SEVERITY_NONLOCALIZED"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_sendbyte",
          "args": [
            "&msgbuf",
            "PG_DIAG_SEVERITY"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_PROTOCOL_MAJOR",
          "args": [
            "FrontendProtocol"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_beginmessage",
          "args": [
            "&msgbuf",
            "(edata->elevel < ERROR) ? 'N' : 'E'"
          ],
          "line": 3150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nstatic void\nsend_message_to_frontend(ErrorData *edata)\n{\n\tStringInfoData msgbuf;\n\n\t/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */\n\tpq_beginmessage(&msgbuf, (edata->elevel < ERROR) ? 'N' : 'E');\n\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)\n\t{\n\t\t/* New style with separate fields */\n\t\tconst char *sev;\n\t\tchar\t\ttbuf[12];\n\t\tint\t\t\tssval;\n\t\tint\t\t\ti;\n\n\t\tsev = error_severity(edata->elevel);\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY);\n\t\terr_sendstring(&msgbuf, _(sev));\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY_NONLOCALIZED);\n\t\terr_sendstring(&msgbuf, sev);\n\n\t\t/* unpack MAKE_SQLSTATE code */\n\t\tssval = edata->sqlerrcode;\n\t\tfor (i = 0; i < 5; i++)\n\t\t{\n\t\t\ttbuf[i] = PGUNSIXBIT(ssval);\n\t\t\tssval >>= 6;\n\t\t}\n\t\ttbuf[i] = '\\0';\n\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SQLSTATE);\n\t\terr_sendstring(&msgbuf, tbuf);\n\n\t\t/* M field is required per protocol, so always send something */\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_PRIMARY);\n\t\tif (edata->message)\n\t\t\terr_sendstring(&msgbuf, edata->message);\n\t\telse\n\t\t\terr_sendstring(&msgbuf, _(\"missing error text\"));\n\n\t\tif (edata->detail)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_DETAIL);\n\t\t\terr_sendstring(&msgbuf, edata->detail);\n\t\t}\n\n\t\t/* detail_log is intentionally not used here */\n\n\t\tif (edata->hint)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_HINT);\n\t\t\terr_sendstring(&msgbuf, edata->hint);\n\t\t}\n\n\t\tif (edata->context)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONTEXT);\n\t\t\terr_sendstring(&msgbuf, edata->context);\n\t\t}\n\n\t\tif (edata->schema_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SCHEMA_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->schema_name);\n\t\t}\n\n\t\tif (edata->table_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_TABLE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->table_name);\n\t\t}\n\n\t\tif (edata->column_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_COLUMN_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->column_name);\n\t\t}\n\n\t\tif (edata->datatype_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_DATATYPE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->datatype_name);\n\t\t}\n\n\t\tif (edata->constraint_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONSTRAINT_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->constraint_name);\n\t\t}\n\n\t\tif (edata->cursorpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->cursorpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_STATEMENT_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->internalpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_QUERY);\n\t\t\terr_sendstring(&msgbuf, edata->internalquery);\n\t\t}\n\n\t\tif (edata->filename)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FILE);\n\t\t\terr_sendstring(&msgbuf, edata->filename);\n\t\t}\n\n\t\tif (edata->lineno > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->lineno);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_LINE);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->funcname)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FUNCTION);\n\t\t\terr_sendstring(&msgbuf, edata->funcname);\n\t\t}\n\n\t\tpq_sendbyte(&msgbuf, '\\0'); /* terminator */\n\t}\n\telse\n\t{\n\t\t/* Old style --- gin up a backwards-compatible message */\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\t\tif (edata->show_funcname && edata->funcname)\n\t\t\tappendStringInfo(&buf, \"%s: \", edata->funcname);\n\n\t\tif (edata->message)\n\t\t\tappendStringInfoString(&buf, edata->message);\n\t\telse\n\t\t\tappendStringInfoString(&buf, _(\"missing error text\"));\n\n\t\tif (edata->cursorpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->cursorpos);\n\t\telse if (edata->internalpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->internalpos);\n\n\t\tappendStringInfoChar(&buf, '\\n');\n\n\t\terr_sendstring(&msgbuf, buf.data);\n\n\t\tpfree(buf.data);\n\t}\n\n\tpq_endmessage(&msgbuf);\n\n\t/*\n\t * This flush is normally not necessary, since postgres.c will flush out\n\t * waiting data when control returns to the main loop. But it seems best\n\t * to leave it here, so that the client has some clue what happened if the\n\t * backend dies before getting back to the main loop ... error/notice\n\t * messages should not be a performance-critical path anyway, so an extra\n\t * flush won't hurt much ...\n\t */\n\tpq_flush();\n}"
  },
  {
    "function_name": "err_sendstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3132-3139",
    "snippet": "static void\nerr_sendstring(StringInfo buf, const char *str)\n{\n\tif (in_error_recursion_trouble())\n\t\tpq_send_ascii_string(buf, str);\n\telse\n\t\tpq_sendstring(buf, str);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
      "static void append_with_tabs(StringInfo buf, const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pq_sendstring",
          "args": [
            "buf",
            "str"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pq_send_ascii_string",
          "args": [
            "buf",
            "str"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_error_recursion_trouble",
          "args": [],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "in_error_recursion_trouble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "195-200",
          "snippet": "bool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trecursion_depth = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\trecursion_depth = 0;\n\nbool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic void\nerr_sendstring(StringInfo buf, const char *str)\n{\n\tif (in_error_recursion_trouble())\n\t\tpq_send_ascii_string(buf, str);\n\telse\n\t\tpq_sendstring(buf, str);\n}"
  },
  {
    "function_name": "write_pipe_chunks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "3088-3118",
    "snippet": "static void\nwrite_pipe_chunks(char *data, int len, int dest)\n{\n\tPipeProtoChunk p;\n\tint\t\t\tfd = fileno(stderr);\n\tint\t\t\trc;\n\n\tAssert(len > 0);\n\n\tp.proto.nuls[0] = p.proto.nuls[1] = '\\0';\n\tp.proto.pid = MyProcPid;\n\n\t/* write all but the last chunk */\n\twhile (len > PIPE_MAX_PAYLOAD)\n\t{\n\t\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'F' : 'f');\n\t\tp.proto.len = PIPE_MAX_PAYLOAD;\n\t\tmemcpy(p.proto.data, data, PIPE_MAX_PAYLOAD);\n\t\trc = write(fd, &p, PIPE_HEADER_SIZE + PIPE_MAX_PAYLOAD);\n\t\t(void) rc;\n\t\tdata += PIPE_MAX_PAYLOAD;\n\t\tlen -= PIPE_MAX_PAYLOAD;\n\t}\n\n\t/* write the last chunk */\n\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'T' : 't');\n\tp.proto.len = len;\n\tmemcpy(p.proto.data, data, len);\n\trc = write(fd, &p, PIPE_HEADER_SIZE + len);\n\t(void) rc;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void write_console(const char *line, int len);",
      "static void write_pipe_chunks(char *data, int len, int dest);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "&p",
            "PIPE_HEADER_SIZE + len"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p.proto.data",
            "data",
            "len"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p.proto.data",
            "data",
            "PIPE_MAX_PAYLOAD"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "len > 0"
          ],
          "line": 3095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "pg_filenode_relation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "919-932",
          "snippet": "Datum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void write_console(const char *line, int len);\nstatic void write_pipe_chunks(char *data, int len, int dest);\n\nstatic void\nwrite_pipe_chunks(char *data, int len, int dest)\n{\n\tPipeProtoChunk p;\n\tint\t\t\tfd = fileno(stderr);\n\tint\t\t\trc;\n\n\tAssert(len > 0);\n\n\tp.proto.nuls[0] = p.proto.nuls[1] = '\\0';\n\tp.proto.pid = MyProcPid;\n\n\t/* write all but the last chunk */\n\twhile (len > PIPE_MAX_PAYLOAD)\n\t{\n\t\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'F' : 'f');\n\t\tp.proto.len = PIPE_MAX_PAYLOAD;\n\t\tmemcpy(p.proto.data, data, PIPE_MAX_PAYLOAD);\n\t\trc = write(fd, &p, PIPE_HEADER_SIZE + PIPE_MAX_PAYLOAD);\n\t\t(void) rc;\n\t\tdata += PIPE_MAX_PAYLOAD;\n\t\tlen -= PIPE_MAX_PAYLOAD;\n\t}\n\n\t/* write the last chunk */\n\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'T' : 't');\n\tp.proto.len = len;\n\tmemcpy(p.proto.data, data, len);\n\trc = write(fd, &p, PIPE_HEADER_SIZE + len);\n\t(void) rc;\n}"
  },
  {
    "function_name": "send_message_to_server_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2861-3066",
    "snippet": "static void\nsend_message_to_server_log(ErrorData *edata)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\tsaved_timeval_set = false;\n\tformatted_log_time[0] = '\\0';\n\n\tlog_line_prefix(&buf, edata);\n\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\tappendStringInfo(&buf, \"%s: \", unpack_sql_state(edata->sqlerrcode));\n\n\tif (edata->message)\n\t\tappend_with_tabs(&buf, edata->message);\n\telse\n\t\tappend_with_tabs(&buf, _(\"missing error text\"));\n\n\tif (edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->cursorpos);\n\telse if (edata->internalpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->internalpos);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\tif (Log_error_verbosity >= PGERROR_DEFAULT)\n\t{\n\t\tif (edata->detail_log)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail_log);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\telse if (edata->detail)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->hint)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"HINT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->hint);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"QUERY:  \"));\n\t\t\tappend_with_tabs(&buf, edata->internalquery);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->context && !edata->hide_ctx)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"CONTEXT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->context);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\t{\n\t\t\t/* assume no newlines in funcname or filename... */\n\t\t\tif (edata->funcname && edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s, %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t\t edata->lineno);\n\t\t\t}\n\t\t\telse if (edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the user wants the query that generated this error logged, do it.\n\t */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t{\n\t\tlog_line_prefix(&buf, edata);\n\t\tappendStringInfoString(&buf, _(\"STATEMENT:  \"));\n\t\tappend_with_tabs(&buf, debug_query_string);\n\t\tappendStringInfoChar(&buf, '\\n');\n\t}\n\n#ifdef HAVE_SYSLOG\n\t/* Write to syslog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_SYSLOG)\n\t{\n\t\tint\t\t\tsyslog_level;\n\n\t\tswitch (edata->elevel)\n\t\t{\n\t\t\tcase DEBUG5:\n\t\t\tcase DEBUG4:\n\t\t\tcase DEBUG3:\n\t\t\tcase DEBUG2:\n\t\t\tcase DEBUG1:\n\t\t\t\tsyslog_level = LOG_DEBUG;\n\t\t\t\tbreak;\n\t\t\tcase LOG:\n\t\t\tcase LOG_SERVER_ONLY:\n\t\t\tcase INFO:\n\t\t\t\tsyslog_level = LOG_INFO;\n\t\t\t\tbreak;\n\t\t\tcase NOTICE:\n\t\t\tcase WARNING:\n\t\t\t\tsyslog_level = LOG_NOTICE;\n\t\t\t\tbreak;\n\t\t\tcase ERROR:\n\t\t\t\tsyslog_level = LOG_WARNING;\n\t\t\t\tbreak;\n\t\t\tcase FATAL:\n\t\t\t\tsyslog_level = LOG_ERR;\n\t\t\t\tbreak;\n\t\t\tcase PANIC:\n\t\t\tdefault:\n\t\t\t\tsyslog_level = LOG_CRIT;\n\t\t\t\tbreak;\n\t\t}\n\n\t\twrite_syslog(syslog_level, buf.data);\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_SYSLOG */\n\n#ifdef WIN32\n\t/* Write to eventlog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_EVENTLOG)\n\t{\n\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t/* Write to stderr, if enabled */\n\tif ((Log_destination & LOG_DESTINATION_STDERR) || whereToSendOutput == DestDebug)\n\t{\n\t\t/*\n\t\t * Use the chunking protocol if we know the syslogger should be\n\t\t * catching stderr output, and we are not ourselves the syslogger.\n\t\t * Otherwise, just do a vanilla write to stderr.\n\t\t */\n\t\tif (redirection_done && !am_syslogger)\n\t\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_STDERR);\n#ifdef WIN32\n\n\t\t/*\n\t\t * In a win32 service environment, there is no usable stderr. Capture\n\t\t * anything going there and write it to the eventlog instead.\n\t\t *\n\t\t * If stderr redirection is active, it was OK to write to stderr above\n\t\t * because that's really a pipe to the syslogger process.\n\t\t */\n\t\telse if (pgwin32_is_service())\n\t\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n#endif\n\t\telse\n\t\t\twrite_console(buf.data, buf.len);\n\t}\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_STDERR);\n\n\t/* Write to CSV log if enabled */\n\tif (Log_destination & LOG_DESTINATION_CSVLOG)\n\t{\n\t\tif (redirection_done || am_syslogger)\n\t\t{\n\t\t\t/*\n\t\t\t * send CSV data if it's safe to do so (syslogger doesn't need the\n\t\t\t * pipe). First get back the space in the message buffer.\n\t\t\t */\n\t\t\tpfree(buf.data);\n\t\t\twrite_csvlog(edata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * syslogger not up (yet), so just dump the message to stderr,\n\t\t\t * unless we already did so above.\n\t\t\t */\n\t\t\tif (!(Log_destination & LOG_DESTINATION_STDERR) &&\n\t\t\t\twhereToSendOutput != DestDebug)\n\t\t\t\twrite_console(buf.data, buf.len);\n\t\t\tpfree(buf.data);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpfree(buf.data);\n\t}\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool redirection_done;",
      "int\t\t\tLog_error_verbosity = PGERROR_VERBOSE;",
      "int\t\t\tLog_destination = LOG_DESTINATION_STDERR;",
      "static bool saved_timeval_set = false;",
      "static char formatted_log_time[FORMATTED_TS_LEN];",
      "static void write_console(const char *line, int len);",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "buf.data"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_console",
          "args": [
            "buf.data",
            "buf.len"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "write_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2154-2220",
          "snippet": "static void\nwrite_console(const char *line, int len)\n{\n\tint\t\t\trc;\n\n#ifdef WIN32\n\n\t/*\n\t * Try to convert the message to UTF16 and write it with WriteConsoleW().\n\t * Fall back on write() if anything fails.\n\t *\n\t * In contrast to write_eventlog(), don't skip straight to write() based\n\t * on the applicable encodings.  Unlike WriteConsoleW(), write() depends\n\t * on the suitability of the console output code page.  Since we put\n\t * stderr into binary mode in SubPostmasterMain(), write() skips the\n\t * necessary translation anyway.\n\t *\n\t * WriteConsoleW() will fail if stderr is redirected, so just fall through\n\t * to writing unconverted to the logfile in this case.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\t!redirection_done &&\n\t\tCurrentMemoryContext != NULL)\n\t{\n\t\tWCHAR\t   *utf16;\n\t\tint\t\t\tutf16len;\n\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, &utf16len);\n\t\tif (utf16 != NULL)\n\t\t{\n\t\t\tHANDLE\t\tstdHandle;\n\t\t\tDWORD\t\twritten;\n\n\t\t\tstdHandle = GetStdHandle(STD_ERROR_HANDLE);\n\t\t\tif (WriteConsoleW(stdHandle, utf16, utf16len, &written, NULL))\n\t\t\t{\n\t\t\t\tpfree(utf16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In case WriteConsoleW() failed, fall back to writing the\n\t\t\t * message unconverted.\n\t\t\t */\n\t\t\tpfree(utf16);\n\t\t}\n\t}\n#else\n\n\t/*\n\t * Conversion on non-win32 platforms is not implemented yet. It requires\n\t * non-throw version of pg_do_encoding_conversion(), that converts\n\t * unconvertable characters to '?' without errors.\n\t */\n#endif\n\n\t/*\n\t * We ignore any error from write() here.  We have no useful way to report\n\t * it ... certainly whining on stderr isn't likely to be productive.\n\t */\n\trc = write(fileno(stderr), line, len);\n\t(void) rc;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool redirection_done;",
            "static void write_console(const char *line, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nextern bool redirection_done;\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_console(const char *line, int len)\n{\n\tint\t\t\trc;\n\n#ifdef WIN32\n\n\t/*\n\t * Try to convert the message to UTF16 and write it with WriteConsoleW().\n\t * Fall back on write() if anything fails.\n\t *\n\t * In contrast to write_eventlog(), don't skip straight to write() based\n\t * on the applicable encodings.  Unlike WriteConsoleW(), write() depends\n\t * on the suitability of the console output code page.  Since we put\n\t * stderr into binary mode in SubPostmasterMain(), write() skips the\n\t * necessary translation anyway.\n\t *\n\t * WriteConsoleW() will fail if stderr is redirected, so just fall through\n\t * to writing unconverted to the logfile in this case.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\t!redirection_done &&\n\t\tCurrentMemoryContext != NULL)\n\t{\n\t\tWCHAR\t   *utf16;\n\t\tint\t\t\tutf16len;\n\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, &utf16len);\n\t\tif (utf16 != NULL)\n\t\t{\n\t\t\tHANDLE\t\tstdHandle;\n\t\t\tDWORD\t\twritten;\n\n\t\t\tstdHandle = GetStdHandle(STD_ERROR_HANDLE);\n\t\t\tif (WriteConsoleW(stdHandle, utf16, utf16len, &written, NULL))\n\t\t\t{\n\t\t\t\tpfree(utf16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In case WriteConsoleW() failed, fall back to writing the\n\t\t\t * message unconverted.\n\t\t\t */\n\t\t\tpfree(utf16);\n\t\t}\n\t}\n#else\n\n\t/*\n\t * Conversion on non-win32 platforms is not implemented yet. It requires\n\t * non-throw version of pg_do_encoding_conversion(), that converts\n\t * unconvertable characters to '?' without errors.\n\t */\n#endif\n\n\t/*\n\t * We ignore any error from write() here.  We have no useful way to report\n\t * it ... certainly whining on stderr isn't likely to be productive.\n\t */\n\trc = write(fileno(stderr), line, len);\n\t(void) rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_csvlog",
          "args": [
            "edata"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "write_csvlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2644-2835",
          "snippet": "static void\nwrite_csvlog(ErrorData *edata)\n{\n\tStringInfoData buf;\n\tbool\t\tprint_stmt = false;\n\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tinitStringInfo(&buf);\n\n\t/*\n\t * timestamp with milliseconds\n\t *\n\t * Check if the timestamp is already calculated for the syslog message,\n\t * and use it if so.  Otherwise, get the current timestamp.  This is done\n\t * to put same timestamp in both syslog and csvlog messages.\n\t */\n\tif (formatted_log_time[0] == '\\0')\n\t\tsetup_formatted_log_time();\n\n\tappendStringInfoString(&buf, formatted_log_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* username */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->user_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* database name */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->database_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Process id  */\n\tif (MyProcPid != 0)\n\t\tappendStringInfo(&buf, \"%d\", MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Remote host and port */\n\tif (MyProcPort && MyProcPort->remote_host)\n\t{\n\t\tappendStringInfoChar(&buf, '\"');\n\t\tappendStringInfoString(&buf, MyProcPort->remote_host);\n\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t{\n\t\t\tappendStringInfoChar(&buf, ':');\n\t\t\tappendStringInfoString(&buf, MyProcPort->remote_port);\n\t\t}\n\t\tappendStringInfoChar(&buf, '\"');\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session id */\n\tappendStringInfo(&buf, \"%lx.%x\", (long) MyStartTime, MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Line number */\n\tappendStringInfo(&buf, \"%ld\", log_line_number);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* PS display */\n\tif (MyProcPort)\n\t{\n\t\tStringInfoData msgbuf;\n\t\tconst char *psdisp;\n\t\tint\t\t\tdisplen;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tpsdisp = get_ps_display(&displen);\n\t\tappendBinaryStringInfo(&msgbuf, psdisp, displen);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session start timestamp */\n\tif (formatted_start_time[0] == '\\0')\n\t\tsetup_formatted_start_time();\n\tappendStringInfoString(&buf, formatted_start_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Virtual transaction id */\n\t/* keep VXID format in sync with lockfuncs.c */\n\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\tappendStringInfo(&buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Transaction id */\n\tappendStringInfo(&buf, \"%u\", GetTopTransactionIdIfAny());\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Error severity */\n\tappendStringInfoString(&buf, _(error_severity(edata->elevel)));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* SQL state code */\n\tappendStringInfoString(&buf, unpack_sql_state(edata->sqlerrcode));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errmessage */\n\tappendCSVLiteral(&buf, edata->message);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errdetail or errdetail_log */\n\tif (edata->detail_log)\n\t\tappendCSVLiteral(&buf, edata->detail_log);\n\telse\n\t\tappendCSVLiteral(&buf, edata->detail);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errhint */\n\tappendCSVLiteral(&buf, edata->hint);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* internal query */\n\tappendCSVLiteral(&buf, edata->internalquery);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* if printed internal query, print internal pos too */\n\tif (edata->internalpos > 0 && edata->internalquery != NULL)\n\t\tappendStringInfo(&buf, \"%d\", edata->internalpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errcontext */\n\tif (!edata->hide_ctx)\n\t\tappendCSVLiteral(&buf, edata->context);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* user query --- only reported if not disabled by the caller */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t\tprint_stmt = true;\n\tif (print_stmt)\n\t\tappendCSVLiteral(&buf, debug_query_string);\n\tappendStringInfoChar(&buf, ',');\n\tif (print_stmt && edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, \"%d\", edata->cursorpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* file error location */\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t{\n\t\tStringInfoData msgbuf;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tif (edata->funcname && edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s, %s:%d\",\n\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t edata->lineno);\n\t\telse if (edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s:%d\",\n\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* application name */\n\tif (application_name)\n\t\tappendCSVLiteral(&buf, application_name);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\telse\n\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\n\tpfree(buf.data);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int\t\t\tLog_error_verbosity = PGERROR_VERBOSE;",
            "static char formatted_start_time[FORMATTED_TS_LEN];",
            "static char formatted_log_time[FORMATTED_TS_LEN];",
            "static void write_console(const char *line, int len);",
            "static void setup_formatted_log_time(void);",
            "static void setup_formatted_start_time(void);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\t\t\tLog_error_verbosity = PGERROR_VERBOSE;\nstatic char formatted_start_time[FORMATTED_TS_LEN];\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void write_console(const char *line, int len);\nstatic void setup_formatted_log_time(void);\nstatic void setup_formatted_start_time(void);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nstatic void\nwrite_csvlog(ErrorData *edata)\n{\n\tStringInfoData buf;\n\tbool\t\tprint_stmt = false;\n\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tinitStringInfo(&buf);\n\n\t/*\n\t * timestamp with milliseconds\n\t *\n\t * Check if the timestamp is already calculated for the syslog message,\n\t * and use it if so.  Otherwise, get the current timestamp.  This is done\n\t * to put same timestamp in both syslog and csvlog messages.\n\t */\n\tif (formatted_log_time[0] == '\\0')\n\t\tsetup_formatted_log_time();\n\n\tappendStringInfoString(&buf, formatted_log_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* username */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->user_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* database name */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->database_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Process id  */\n\tif (MyProcPid != 0)\n\t\tappendStringInfo(&buf, \"%d\", MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Remote host and port */\n\tif (MyProcPort && MyProcPort->remote_host)\n\t{\n\t\tappendStringInfoChar(&buf, '\"');\n\t\tappendStringInfoString(&buf, MyProcPort->remote_host);\n\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t{\n\t\t\tappendStringInfoChar(&buf, ':');\n\t\t\tappendStringInfoString(&buf, MyProcPort->remote_port);\n\t\t}\n\t\tappendStringInfoChar(&buf, '\"');\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session id */\n\tappendStringInfo(&buf, \"%lx.%x\", (long) MyStartTime, MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Line number */\n\tappendStringInfo(&buf, \"%ld\", log_line_number);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* PS display */\n\tif (MyProcPort)\n\t{\n\t\tStringInfoData msgbuf;\n\t\tconst char *psdisp;\n\t\tint\t\t\tdisplen;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tpsdisp = get_ps_display(&displen);\n\t\tappendBinaryStringInfo(&msgbuf, psdisp, displen);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session start timestamp */\n\tif (formatted_start_time[0] == '\\0')\n\t\tsetup_formatted_start_time();\n\tappendStringInfoString(&buf, formatted_start_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Virtual transaction id */\n\t/* keep VXID format in sync with lockfuncs.c */\n\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\tappendStringInfo(&buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Transaction id */\n\tappendStringInfo(&buf, \"%u\", GetTopTransactionIdIfAny());\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Error severity */\n\tappendStringInfoString(&buf, _(error_severity(edata->elevel)));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* SQL state code */\n\tappendStringInfoString(&buf, unpack_sql_state(edata->sqlerrcode));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errmessage */\n\tappendCSVLiteral(&buf, edata->message);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errdetail or errdetail_log */\n\tif (edata->detail_log)\n\t\tappendCSVLiteral(&buf, edata->detail_log);\n\telse\n\t\tappendCSVLiteral(&buf, edata->detail);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errhint */\n\tappendCSVLiteral(&buf, edata->hint);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* internal query */\n\tappendCSVLiteral(&buf, edata->internalquery);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* if printed internal query, print internal pos too */\n\tif (edata->internalpos > 0 && edata->internalquery != NULL)\n\t\tappendStringInfo(&buf, \"%d\", edata->internalpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errcontext */\n\tif (!edata->hide_ctx)\n\t\tappendCSVLiteral(&buf, edata->context);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* user query --- only reported if not disabled by the caller */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t\tprint_stmt = true;\n\tif (print_stmt)\n\t\tappendCSVLiteral(&buf, debug_query_string);\n\tappendStringInfoChar(&buf, ',');\n\tif (print_stmt && edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, \"%d\", edata->cursorpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* file error location */\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t{\n\t\tStringInfoData msgbuf;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tif (edata->funcname && edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s, %s:%d\",\n\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t edata->lineno);\n\t\telse if (edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s:%d\",\n\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* application name */\n\tif (application_name)\n\t\tappendCSVLiteral(&buf, application_name);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\telse\n\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\n\tpfree(buf.data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_syslogger_file",
          "args": [
            "buf.data",
            "buf.len",
            "LOG_DESTINATION_STDERR"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_eventlog",
          "args": [
            "edata->elevel",
            "buf.data",
            "buf.len"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "write_eventlog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2065-2151",
          "snippet": "static void\nwrite_eventlog(int level, const char *line, int len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\tstatic HANDLE evtHandle = INVALID_HANDLE_VALUE;\n\n\tif (evtHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tevtHandle = RegisterEventSource(NULL,\n\t\t\t\t\t\t\t\t\t\tevent_source ? event_source : DEFAULT_EVENT_SOURCE);\n\t\tif (evtHandle == NULL)\n\t\t{\n\t\t\tevtHandle = INVALID_HANDLE_VALUE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (level)\n\t{\n\t\tcase DEBUG5:\n\t\tcase DEBUG4:\n\t\tcase DEBUG3:\n\t\tcase DEBUG2:\n\t\tcase DEBUG1:\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\tcase INFO:\n\t\tcase NOTICE:\n\t\t\teventlevel = EVENTLOG_INFORMATION_TYPE;\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\teventlevel = EVENTLOG_WARNING_TYPE;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\tcase FATAL:\n\t\tcase PANIC:\n\t\tdefault:\n\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If message character encoding matches the encoding expected by\n\t * ReportEventA(), call it to avoid the hazards of conversion.  Otherwise,\n\t * try to convert the message to UTF16 and write it with ReportEventW().\n\t * Fall back on ReportEventA() if conversion failed.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t *\n\t * Also verify that we are not on our way into error recursion trouble due\n\t * to error messages thrown deep inside pgwin32_message_to_UTF16().\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\tCurrentMemoryContext != NULL &&\n\t\tGetMessageEncoding() != GetACPEncoding())\n\t{\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, NULL);\n\t\tif (utf16)\n\t\t{\n\t\t\tReportEventW(evtHandle,\n\t\t\t\t\t\t eventlevel,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t 0,\t\t/* All events are Id 0 */\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 1,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t (LPCWSTR *) &utf16,\n\t\t\t\t\t\t NULL);\n\t\t\t/* XXX Try ReportEventA() when ReportEventW() fails? */\n\n\t\t\tpfree(utf16);\n\t\t\treturn;\n\t\t}\n\t}\n\tReportEventA(evtHandle,\n\t\t\t\t eventlevel,\n\t\t\t\t 0,\n\t\t\t\t 0,\t\t\t\t/* All events are Id 0 */\n\t\t\t\t NULL,\n\t\t\t\t 1,\n\t\t\t\t 0,\n\t\t\t\t &line,\n\t\t\t\t NULL);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_console(const char *line, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_eventlog(int level, const char *line, int len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\tstatic HANDLE evtHandle = INVALID_HANDLE_VALUE;\n\n\tif (evtHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tevtHandle = RegisterEventSource(NULL,\n\t\t\t\t\t\t\t\t\t\tevent_source ? event_source : DEFAULT_EVENT_SOURCE);\n\t\tif (evtHandle == NULL)\n\t\t{\n\t\t\tevtHandle = INVALID_HANDLE_VALUE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (level)\n\t{\n\t\tcase DEBUG5:\n\t\tcase DEBUG4:\n\t\tcase DEBUG3:\n\t\tcase DEBUG2:\n\t\tcase DEBUG1:\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\tcase INFO:\n\t\tcase NOTICE:\n\t\t\teventlevel = EVENTLOG_INFORMATION_TYPE;\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\teventlevel = EVENTLOG_WARNING_TYPE;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\tcase FATAL:\n\t\tcase PANIC:\n\t\tdefault:\n\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If message character encoding matches the encoding expected by\n\t * ReportEventA(), call it to avoid the hazards of conversion.  Otherwise,\n\t * try to convert the message to UTF16 and write it with ReportEventW().\n\t * Fall back on ReportEventA() if conversion failed.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t *\n\t * Also verify that we are not on our way into error recursion trouble due\n\t * to error messages thrown deep inside pgwin32_message_to_UTF16().\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\tCurrentMemoryContext != NULL &&\n\t\tGetMessageEncoding() != GetACPEncoding())\n\t{\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, NULL);\n\t\tif (utf16)\n\t\t{\n\t\t\tReportEventW(evtHandle,\n\t\t\t\t\t\t eventlevel,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t 0,\t\t/* All events are Id 0 */\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 1,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t (LPCWSTR *) &utf16,\n\t\t\t\t\t\t NULL);\n\t\t\t/* XXX Try ReportEventA() when ReportEventW() fails? */\n\n\t\t\tpfree(utf16);\n\t\t\treturn;\n\t\t}\n\t}\n\tReportEventA(evtHandle,\n\t\t\t\t eventlevel,\n\t\t\t\t 0,\n\t\t\t\t 0,\t\t\t\t/* All events are Id 0 */\n\t\t\t\t NULL,\n\t\t\t\t 1,\n\t\t\t\t 0,\n\t\t\t\t &line,\n\t\t\t\t NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_pipe_chunks",
          "args": [
            "buf.data",
            "buf.len",
            "LOG_DESTINATION_STDERR"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "write_pipe_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3088-3118",
          "snippet": "static void\nwrite_pipe_chunks(char *data, int len, int dest)\n{\n\tPipeProtoChunk p;\n\tint\t\t\tfd = fileno(stderr);\n\tint\t\t\trc;\n\n\tAssert(len > 0);\n\n\tp.proto.nuls[0] = p.proto.nuls[1] = '\\0';\n\tp.proto.pid = MyProcPid;\n\n\t/* write all but the last chunk */\n\twhile (len > PIPE_MAX_PAYLOAD)\n\t{\n\t\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'F' : 'f');\n\t\tp.proto.len = PIPE_MAX_PAYLOAD;\n\t\tmemcpy(p.proto.data, data, PIPE_MAX_PAYLOAD);\n\t\trc = write(fd, &p, PIPE_HEADER_SIZE + PIPE_MAX_PAYLOAD);\n\t\t(void) rc;\n\t\tdata += PIPE_MAX_PAYLOAD;\n\t\tlen -= PIPE_MAX_PAYLOAD;\n\t}\n\n\t/* write the last chunk */\n\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'T' : 't');\n\tp.proto.len = len;\n\tmemcpy(p.proto.data, data, len);\n\trc = write(fd, &p, PIPE_HEADER_SIZE + len);\n\t(void) rc;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_console(const char *line, int len);",
            "static void write_pipe_chunks(char *data, int len, int dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void write_console(const char *line, int len);\nstatic void write_pipe_chunks(char *data, int len, int dest);\n\nstatic void\nwrite_pipe_chunks(char *data, int len, int dest)\n{\n\tPipeProtoChunk p;\n\tint\t\t\tfd = fileno(stderr);\n\tint\t\t\trc;\n\n\tAssert(len > 0);\n\n\tp.proto.nuls[0] = p.proto.nuls[1] = '\\0';\n\tp.proto.pid = MyProcPid;\n\n\t/* write all but the last chunk */\n\twhile (len > PIPE_MAX_PAYLOAD)\n\t{\n\t\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'F' : 'f');\n\t\tp.proto.len = PIPE_MAX_PAYLOAD;\n\t\tmemcpy(p.proto.data, data, PIPE_MAX_PAYLOAD);\n\t\trc = write(fd, &p, PIPE_HEADER_SIZE + PIPE_MAX_PAYLOAD);\n\t\t(void) rc;\n\t\tdata += PIPE_MAX_PAYLOAD;\n\t\tlen -= PIPE_MAX_PAYLOAD;\n\t}\n\n\t/* write the last chunk */\n\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'T' : 't');\n\tp.proto.len = len;\n\tmemcpy(p.proto.data, data, len);\n\trc = write(fd, &p, PIPE_HEADER_SIZE + len);\n\t(void) rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_syslog",
          "args": [
            "syslog_level",
            "buf.data"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "write_syslog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1939-2042",
          "snippet": "static void\nwrite_syslog(int level, const char *line)\n{\n\tstatic unsigned long seq = 0;\n\n\tint\t\t\tlen;\n\tconst char *nlpos;\n\n\t/* Open syslog connection if not done yet */\n\tif (!openlog_done)\n\t{\n\t\topenlog(syslog_ident ? syslog_ident : \"postgres\",\n\t\t\t\tLOG_PID | LOG_NDELAY | LOG_NOWAIT,\n\t\t\t\tsyslog_facility);\n\t\topenlog_done = true;\n\t}\n\n\t/*\n\t * We add a sequence number to each log message to suppress \"same\"\n\t * messages.\n\t */\n\tseq++;\n\n\t/*\n\t * Our problem here is that many syslog implementations don't handle long\n\t * messages in an acceptable manner. While this function doesn't help that\n\t * fact, it does work around by splitting up messages into smaller pieces.\n\t *\n\t * We divide into multiple syslog() calls if message is too long or if the\n\t * message contains embedded newline(s).\n\t */\n\tlen = strlen(line);\n\tnlpos = strchr(line, '\\n');\n\tif (syslog_split_messages && (len > PG_SYSLOG_LIMIT || nlpos != NULL))\n\t{\n\t\tint\t\t\tchunk_nr = 0;\n\n\t\twhile (len > 0)\n\t\t{\n\t\t\tchar\t\tbuf[PG_SYSLOG_LIMIT + 1];\n\t\t\tint\t\t\tbuflen;\n\t\t\tint\t\t\ti;\n\n\t\t\t/* if we start at a newline, move ahead one char */\n\t\t\tif (line[0] == '\\n')\n\t\t\t{\n\t\t\t\tline++;\n\t\t\t\tlen--;\n\t\t\t\t/* we need to recompute the next newline's position, too */\n\t\t\t\tnlpos = strchr(line, '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* copy one line, or as much as will fit, to buf */\n\t\t\tif (nlpos != NULL)\n\t\t\t\tbuflen = nlpos - line;\n\t\t\telse\n\t\t\t\tbuflen = len;\n\t\t\tbuflen = Min(buflen, PG_SYSLOG_LIMIT);\n\t\t\tmemcpy(buf, line, buflen);\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* trim to multibyte letter boundary */\n\t\t\tbuflen = pg_mbcliplen(buf, buflen, buflen);\n\t\t\tif (buflen <= 0)\n\t\t\t\treturn;\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* already word boundary? */\n\t\t\tif (line[buflen] != '\\0' &&\n\t\t\t\t!isspace((unsigned char) line[buflen]))\n\t\t\t{\n\t\t\t\t/* try to divide at word boundary */\n\t\t\t\ti = buflen - 1;\n\t\t\t\twhile (i > 0 && !isspace((unsigned char) buf[i]))\n\t\t\t\t\ti--;\n\n\t\t\t\tif (i > 0)\t\t/* else couldn't divide word boundary */\n\t\t\t\t{\n\t\t\t\t\tbuflen = i;\n\t\t\t\t\tbuf[i] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunk_nr++;\n\n\t\t\tif (syslog_sequence_numbers)\n\t\t\t\tsyslog(level, \"[%lu-%d] %s\", seq, chunk_nr, buf);\n\t\t\telse\n\t\t\t\tsyslog(level, \"[%d] %s\", chunk_nr, buf);\n\n\t\t\tline += buflen;\n\t\t\tlen -= buflen;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* message short enough */\n\t\tif (syslog_sequence_numbers)\n\t\t\tsyslog(level, \"[%lu] %s\", seq, line);\n\t\telse\n\t\t\tsyslog(level, \"%s\", line);\n\t}\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PG_SYSLOG_LIMIT 900"
          ],
          "globals_used": [
            "bool\t\tsyslog_sequence_numbers = true;",
            "bool\t\tsyslog_split_messages = true;",
            "static void write_console(const char *line, int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define PG_SYSLOG_LIMIT 900\n\nbool\t\tsyslog_sequence_numbers = true;\nbool\t\tsyslog_split_messages = true;\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_syslog(int level, const char *line)\n{\n\tstatic unsigned long seq = 0;\n\n\tint\t\t\tlen;\n\tconst char *nlpos;\n\n\t/* Open syslog connection if not done yet */\n\tif (!openlog_done)\n\t{\n\t\topenlog(syslog_ident ? syslog_ident : \"postgres\",\n\t\t\t\tLOG_PID | LOG_NDELAY | LOG_NOWAIT,\n\t\t\t\tsyslog_facility);\n\t\topenlog_done = true;\n\t}\n\n\t/*\n\t * We add a sequence number to each log message to suppress \"same\"\n\t * messages.\n\t */\n\tseq++;\n\n\t/*\n\t * Our problem here is that many syslog implementations don't handle long\n\t * messages in an acceptable manner. While this function doesn't help that\n\t * fact, it does work around by splitting up messages into smaller pieces.\n\t *\n\t * We divide into multiple syslog() calls if message is too long or if the\n\t * message contains embedded newline(s).\n\t */\n\tlen = strlen(line);\n\tnlpos = strchr(line, '\\n');\n\tif (syslog_split_messages && (len > PG_SYSLOG_LIMIT || nlpos != NULL))\n\t{\n\t\tint\t\t\tchunk_nr = 0;\n\n\t\twhile (len > 0)\n\t\t{\n\t\t\tchar\t\tbuf[PG_SYSLOG_LIMIT + 1];\n\t\t\tint\t\t\tbuflen;\n\t\t\tint\t\t\ti;\n\n\t\t\t/* if we start at a newline, move ahead one char */\n\t\t\tif (line[0] == '\\n')\n\t\t\t{\n\t\t\t\tline++;\n\t\t\t\tlen--;\n\t\t\t\t/* we need to recompute the next newline's position, too */\n\t\t\t\tnlpos = strchr(line, '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* copy one line, or as much as will fit, to buf */\n\t\t\tif (nlpos != NULL)\n\t\t\t\tbuflen = nlpos - line;\n\t\t\telse\n\t\t\t\tbuflen = len;\n\t\t\tbuflen = Min(buflen, PG_SYSLOG_LIMIT);\n\t\t\tmemcpy(buf, line, buflen);\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* trim to multibyte letter boundary */\n\t\t\tbuflen = pg_mbcliplen(buf, buflen, buflen);\n\t\t\tif (buflen <= 0)\n\t\t\t\treturn;\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* already word boundary? */\n\t\t\tif (line[buflen] != '\\0' &&\n\t\t\t\t!isspace((unsigned char) line[buflen]))\n\t\t\t{\n\t\t\t\t/* try to divide at word boundary */\n\t\t\t\ti = buflen - 1;\n\t\t\t\twhile (i > 0 && !isspace((unsigned char) buf[i]))\n\t\t\t\t\ti--;\n\n\t\t\t\tif (i > 0)\t\t/* else couldn't divide word boundary */\n\t\t\t\t{\n\t\t\t\t\tbuflen = i;\n\t\t\t\t\tbuf[i] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunk_nr++;\n\n\t\t\tif (syslog_sequence_numbers)\n\t\t\t\tsyslog(level, \"[%lu-%d] %s\", seq, chunk_nr, buf);\n\t\t\telse\n\t\t\t\tsyslog(level, \"[%d] %s\", chunk_nr, buf);\n\n\t\t\tline += buflen;\n\t\t\tlen -= buflen;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* message short enough */\n\t\tif (syslog_sequence_numbers)\n\t\t\tsyslog(level, \"[%lu] %s\", seq, line);\n\t\telse\n\t\t\tsyslog(level, \"%s\", line);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "append_with_tabs",
          "args": [
            "&buf",
            "debug_query_string"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "append_with_tabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3649-3660",
          "snippet": "static void\nappend_with_tabs(StringInfo buf, const char *str)\n{\n\tchar\t\tch;\n\n\twhile ((ch = *str++) != '\\0')\n\t{\n\t\tappendStringInfoCharMacro(buf, ch);\n\t\tif (ch == '\\n')\n\t\t\tappendStringInfoCharMacro(buf, '\\t');\n\t}\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic void\nappend_with_tabs(StringInfo buf, const char *str)\n{\n\tchar\t\tch;\n\n\twhile ((ch = *str++) != '\\0')\n\t{\n\t\tappendStringInfoCharMacro(buf, ch);\n\t\tif (ch == '\\n')\n\t\t\tappendStringInfoCharMacro(buf, '\\t');\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(\"STATEMENT:  \")"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"STATEMENT:  \""
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "trace_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3750-3758",
          "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_line_prefix",
          "args": [
            "&buf",
            "edata"
          ],
          "line": 2954
        },
        "resolved": true,
        "details": {
          "function_name": "log_line_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2310-2613",
          "snippet": "static void\nlog_line_prefix(StringInfo buf, ErrorData *edata)\n{\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\tint\t\t\tpadding;\n\tconst char *p;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes. MyStartTime also changes when MyProcPid does, so\n\t * reset the formatted start timestamp too.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tif (Log_line_prefix == NULL)\n\t\treturn;\t\t\t\t\t/* in case guc hasn't run yet */\n\n\tfor (p = Log_line_prefix; *p != '\\0'; p++)\n\t{\n\t\tif (*p != '%')\n\t\t{\n\t\t\t/* literal char, just copy */\n\t\t\tappendStringInfoChar(buf, *p);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* must be a '%', so skip to the next char */\n\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\t\t\t\t/* format error - ignore it */\n\t\telse if (*p == '%')\n\t\t{\n\t\t\t/* string contains %% */\n\t\t\tappendStringInfoChar(buf, '%');\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t/*\n\t\t * Process any formatting which may exist after the '%'.  Note that\n\t\t * process_log_prefix_padding moves p past the padding number if it\n\t\t * exists.\n\t\t *\n\t\t * Note: Since only '-', '0' to '9' are valid formatting characters we\n\t\t * can do a quick check here to pre-check for formatting. If the char\n\t\t * is not formatting then we can skip a useless function call.\n\t\t *\n\t\t * Further note: At least on some platforms, passing %*s rather than\n\t\t * %s to appendStringInfo() is substantially slower, so many of the\n\t\t * cases below avoid doing that unless non-zero padding is in fact\n\t\t * specified.\n\t\t */\n\t\tif (*p > '9')\n\t\t\tpadding = 0;\n\t\telse if ((p = process_log_prefix_padding(p, &padding)) == NULL)\n\t\t\tbreak;\n\n\t\t/* process the option */\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase 'a':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *appname = application_name;\n\n\t\t\t\t\tif (appname == NULL || *appname == '\\0')\n\t\t\t\t\t\tappname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, appname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, appname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *username = MyProcPort->user_name;\n\n\t\t\t\t\tif (username == NULL || *username == '\\0')\n\t\t\t\t\t\tusername = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, username);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, username);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *dbname = MyProcPort->database_name;\n\n\t\t\t\t\tif (dbname == NULL || *dbname == '\\0')\n\t\t\t\t\t\tdbname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, dbname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, dbname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (padding != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%lx.%x\",\n\t\t\t\t\t\t\t (long) (MyStartTime), MyProcPid);\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%lx.%x\", (long) (MyStartTime), MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*d\", padding, MyProcPid);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%d\", MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*ld\", padding, log_line_number);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%ld\", log_line_number);\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tsetup_formatted_log_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_log_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_log_time);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tpg_time_t\tstamp_time = (pg_time_t) time(NULL);\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tpg_strftime(strfbuf, sizeof(strfbuf),\n\t\t\t\t\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\t\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tif (!saved_timeval_set)\n\t\t\t\t\t{\n\t\t\t\t\t\tgettimeofday(&saved_timeval, NULL);\n\t\t\t\t\t\tsaved_timeval_set = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf), \"%ld.%03d\",\n\t\t\t\t\t\t\t (long) saved_timeval.tv_sec,\n\t\t\t\t\t\t\t (int) (saved_timeval.tv_usec / 1000));\n\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (formatted_start_time[0] == '\\0')\n\t\t\t\t\tsetup_formatted_start_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_start_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_start_time);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *psdisp;\n\t\t\t\t\tint\t\t\tdisplen;\n\n\t\t\t\t\tpsdisp = get_ps_display(&displen);\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, psdisp);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendBinaryStringInfo(buf, psdisp, displen);\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * This option is slightly special as the port\n\t\t\t\t\t\t\t * number may be appended onto the end. Here we\n\t\t\t\t\t\t\t * need to build 1 string which contains the\n\t\t\t\t\t\t\t * remote_host and optionally the remote_port (if\n\t\t\t\t\t\t\t * set) so we can properly align the string.\n\t\t\t\t\t\t\t */\n\n\t\t\t\t\t\t\tchar\t   *hostport;\n\n\t\t\t\t\t\t\thostport = psprintf(\"%s(%s)\", MyProcPort->remote_host, MyProcPort->remote_port);\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, hostport);\n\t\t\t\t\t\t\tpfree(hostport);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* padding is 0, so we don't need a temp buffer */\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t\t\tif (MyProcPort->remote_port &&\n\t\t\t\t\t\t\tMyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t\tappendStringInfo(buf, \"(%s)\",\n\t\t\t\t\t\t\t\t\t\t\t MyProcPort->remote_port);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\t/* in postmaster and friends, stop if %q is seen */\n\t\t\t\t/* in a backend, just ignore */\n\t\t\t\tif (MyProcPort == NULL)\n\t\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\t/* keep VXID format in sync with lockfuncs.c */\n\t\t\t\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%d/%u\",\n\t\t\t\t\t\t\t\t MyProc->backendId, MyProc->lxid);\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'x':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*u\", padding, GetTopTransactionIdIfAny());\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%u\", GetTopTransactionIdIfAny());\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* format error - ignore it */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "char\t   *Log_line_prefix = NULL;",
            "static struct timeval saved_timeval;",
            "static bool saved_timeval_set = false;",
            "static char formatted_start_time[FORMATTED_TS_LEN];",
            "static char formatted_log_time[FORMATTED_TS_LEN];",
            "static void setup_formatted_log_time(void);",
            "static void setup_formatted_start_time(void);",
            "static const char *process_log_prefix_padding(const char *p, int *padding);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nchar\t   *Log_line_prefix = NULL;\nstatic struct timeval saved_timeval;\nstatic bool saved_timeval_set = false;\nstatic char formatted_start_time[FORMATTED_TS_LEN];\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_log_time(void);\nstatic void setup_formatted_start_time(void);\nstatic const char *process_log_prefix_padding(const char *p, int *padding);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nstatic void\nlog_line_prefix(StringInfo buf, ErrorData *edata)\n{\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\tint\t\t\tpadding;\n\tconst char *p;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes. MyStartTime also changes when MyProcPid does, so\n\t * reset the formatted start timestamp too.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tif (Log_line_prefix == NULL)\n\t\treturn;\t\t\t\t\t/* in case guc hasn't run yet */\n\n\tfor (p = Log_line_prefix; *p != '\\0'; p++)\n\t{\n\t\tif (*p != '%')\n\t\t{\n\t\t\t/* literal char, just copy */\n\t\t\tappendStringInfoChar(buf, *p);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* must be a '%', so skip to the next char */\n\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\t\t\t\t/* format error - ignore it */\n\t\telse if (*p == '%')\n\t\t{\n\t\t\t/* string contains %% */\n\t\t\tappendStringInfoChar(buf, '%');\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t/*\n\t\t * Process any formatting which may exist after the '%'.  Note that\n\t\t * process_log_prefix_padding moves p past the padding number if it\n\t\t * exists.\n\t\t *\n\t\t * Note: Since only '-', '0' to '9' are valid formatting characters we\n\t\t * can do a quick check here to pre-check for formatting. If the char\n\t\t * is not formatting then we can skip a useless function call.\n\t\t *\n\t\t * Further note: At least on some platforms, passing %*s rather than\n\t\t * %s to appendStringInfo() is substantially slower, so many of the\n\t\t * cases below avoid doing that unless non-zero padding is in fact\n\t\t * specified.\n\t\t */\n\t\tif (*p > '9')\n\t\t\tpadding = 0;\n\t\telse if ((p = process_log_prefix_padding(p, &padding)) == NULL)\n\t\t\tbreak;\n\n\t\t/* process the option */\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase 'a':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *appname = application_name;\n\n\t\t\t\t\tif (appname == NULL || *appname == '\\0')\n\t\t\t\t\t\tappname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, appname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, appname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *username = MyProcPort->user_name;\n\n\t\t\t\t\tif (username == NULL || *username == '\\0')\n\t\t\t\t\t\tusername = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, username);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, username);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *dbname = MyProcPort->database_name;\n\n\t\t\t\t\tif (dbname == NULL || *dbname == '\\0')\n\t\t\t\t\t\tdbname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, dbname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, dbname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (padding != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%lx.%x\",\n\t\t\t\t\t\t\t (long) (MyStartTime), MyProcPid);\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%lx.%x\", (long) (MyStartTime), MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*d\", padding, MyProcPid);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%d\", MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*ld\", padding, log_line_number);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%ld\", log_line_number);\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tsetup_formatted_log_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_log_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_log_time);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tpg_time_t\tstamp_time = (pg_time_t) time(NULL);\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tpg_strftime(strfbuf, sizeof(strfbuf),\n\t\t\t\t\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\t\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tif (!saved_timeval_set)\n\t\t\t\t\t{\n\t\t\t\t\t\tgettimeofday(&saved_timeval, NULL);\n\t\t\t\t\t\tsaved_timeval_set = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf), \"%ld.%03d\",\n\t\t\t\t\t\t\t (long) saved_timeval.tv_sec,\n\t\t\t\t\t\t\t (int) (saved_timeval.tv_usec / 1000));\n\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (formatted_start_time[0] == '\\0')\n\t\t\t\t\tsetup_formatted_start_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_start_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_start_time);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *psdisp;\n\t\t\t\t\tint\t\t\tdisplen;\n\n\t\t\t\t\tpsdisp = get_ps_display(&displen);\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, psdisp);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendBinaryStringInfo(buf, psdisp, displen);\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * This option is slightly special as the port\n\t\t\t\t\t\t\t * number may be appended onto the end. Here we\n\t\t\t\t\t\t\t * need to build 1 string which contains the\n\t\t\t\t\t\t\t * remote_host and optionally the remote_port (if\n\t\t\t\t\t\t\t * set) so we can properly align the string.\n\t\t\t\t\t\t\t */\n\n\t\t\t\t\t\t\tchar\t   *hostport;\n\n\t\t\t\t\t\t\thostport = psprintf(\"%s(%s)\", MyProcPort->remote_host, MyProcPort->remote_port);\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, hostport);\n\t\t\t\t\t\t\tpfree(hostport);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* padding is 0, so we don't need a temp buffer */\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t\t\tif (MyProcPort->remote_port &&\n\t\t\t\t\t\t\tMyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t\tappendStringInfo(buf, \"(%s)\",\n\t\t\t\t\t\t\t\t\t\t\t MyProcPort->remote_port);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\t/* in postmaster and friends, stop if %q is seen */\n\t\t\t\t/* in a backend, just ignore */\n\t\t\t\tif (MyProcPort == NULL)\n\t\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\t/* keep VXID format in sync with lockfuncs.c */\n\t\t\t\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%d/%u\",\n\t\t\t\t\t\t\t\t MyProc->backendId, MyProc->lxid);\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'x':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*u\", padding, GetTopTransactionIdIfAny());\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%u\", GetTopTransactionIdIfAny());\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* format error - ignore it */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_log_level_output",
          "args": [
            "edata->elevel",
            "log_min_error_statement"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "is_log_level_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3714-3733",
          "snippet": "static bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *error_severity(int elevel);",
            "static bool is_log_level_output(int elevel, int log_min_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\nstatic bool is_log_level_output(int elevel, int log_min_level);\n\nstatic bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "_(\"LOCATION:  %s:%d\\n\")",
            "edata->filename",
            "edata->lineno"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "_(\"LOCATION:  %s, %s:%d\\n\")",
            "edata->funcname",
            "edata->filename",
            "edata->lineno"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(\"CONTEXT:  \")"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(\"QUERY:  \")"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(\"HINT:  \")"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(\"DETAIL:  \")"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(\"DETAIL:  \")"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "_(\" at character %d\")",
            "edata->internalpos"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "_(\" at character %d\")",
            "edata->cursorpos"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s: \"",
            "unpack_sql_state(edata->sqlerrcode)"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_sql_state",
          "args": [
            "edata->sqlerrcode"
          ],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_sql_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2841-2855",
          "snippet": "char *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nchar *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%s:  \"",
            "_(error_severity(edata->elevel))"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_severity",
          "args": [
            "edata->elevel"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "error_severity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3598-3640",
          "snippet": "static const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\n\nstatic const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nextern bool redirection_done;\nint\t\t\tLog_error_verbosity = PGERROR_VERBOSE;\nint\t\t\tLog_destination = LOG_DESTINATION_STDERR;\nstatic bool saved_timeval_set = false;\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void write_console(const char *line, int len);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nstatic void\nsend_message_to_server_log(ErrorData *edata)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\tsaved_timeval_set = false;\n\tformatted_log_time[0] = '\\0';\n\n\tlog_line_prefix(&buf, edata);\n\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\tappendStringInfo(&buf, \"%s: \", unpack_sql_state(edata->sqlerrcode));\n\n\tif (edata->message)\n\t\tappend_with_tabs(&buf, edata->message);\n\telse\n\t\tappend_with_tabs(&buf, _(\"missing error text\"));\n\n\tif (edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->cursorpos);\n\telse if (edata->internalpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->internalpos);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\tif (Log_error_verbosity >= PGERROR_DEFAULT)\n\t{\n\t\tif (edata->detail_log)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail_log);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\telse if (edata->detail)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->hint)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"HINT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->hint);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"QUERY:  \"));\n\t\t\tappend_with_tabs(&buf, edata->internalquery);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->context && !edata->hide_ctx)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"CONTEXT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->context);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\t{\n\t\t\t/* assume no newlines in funcname or filename... */\n\t\t\tif (edata->funcname && edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s, %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t\t edata->lineno);\n\t\t\t}\n\t\t\telse if (edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the user wants the query that generated this error logged, do it.\n\t */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t{\n\t\tlog_line_prefix(&buf, edata);\n\t\tappendStringInfoString(&buf, _(\"STATEMENT:  \"));\n\t\tappend_with_tabs(&buf, debug_query_string);\n\t\tappendStringInfoChar(&buf, '\\n');\n\t}\n\n#ifdef HAVE_SYSLOG\n\t/* Write to syslog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_SYSLOG)\n\t{\n\t\tint\t\t\tsyslog_level;\n\n\t\tswitch (edata->elevel)\n\t\t{\n\t\t\tcase DEBUG5:\n\t\t\tcase DEBUG4:\n\t\t\tcase DEBUG3:\n\t\t\tcase DEBUG2:\n\t\t\tcase DEBUG1:\n\t\t\t\tsyslog_level = LOG_DEBUG;\n\t\t\t\tbreak;\n\t\t\tcase LOG:\n\t\t\tcase LOG_SERVER_ONLY:\n\t\t\tcase INFO:\n\t\t\t\tsyslog_level = LOG_INFO;\n\t\t\t\tbreak;\n\t\t\tcase NOTICE:\n\t\t\tcase WARNING:\n\t\t\t\tsyslog_level = LOG_NOTICE;\n\t\t\t\tbreak;\n\t\t\tcase ERROR:\n\t\t\t\tsyslog_level = LOG_WARNING;\n\t\t\t\tbreak;\n\t\t\tcase FATAL:\n\t\t\t\tsyslog_level = LOG_ERR;\n\t\t\t\tbreak;\n\t\t\tcase PANIC:\n\t\t\tdefault:\n\t\t\t\tsyslog_level = LOG_CRIT;\n\t\t\t\tbreak;\n\t\t}\n\n\t\twrite_syslog(syslog_level, buf.data);\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_SYSLOG */\n\n#ifdef WIN32\n\t/* Write to eventlog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_EVENTLOG)\n\t{\n\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t/* Write to stderr, if enabled */\n\tif ((Log_destination & LOG_DESTINATION_STDERR) || whereToSendOutput == DestDebug)\n\t{\n\t\t/*\n\t\t * Use the chunking protocol if we know the syslogger should be\n\t\t * catching stderr output, and we are not ourselves the syslogger.\n\t\t * Otherwise, just do a vanilla write to stderr.\n\t\t */\n\t\tif (redirection_done && !am_syslogger)\n\t\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_STDERR);\n#ifdef WIN32\n\n\t\t/*\n\t\t * In a win32 service environment, there is no usable stderr. Capture\n\t\t * anything going there and write it to the eventlog instead.\n\t\t *\n\t\t * If stderr redirection is active, it was OK to write to stderr above\n\t\t * because that's really a pipe to the syslogger process.\n\t\t */\n\t\telse if (pgwin32_is_service())\n\t\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n#endif\n\t\telse\n\t\t\twrite_console(buf.data, buf.len);\n\t}\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_STDERR);\n\n\t/* Write to CSV log if enabled */\n\tif (Log_destination & LOG_DESTINATION_CSVLOG)\n\t{\n\t\tif (redirection_done || am_syslogger)\n\t\t{\n\t\t\t/*\n\t\t\t * send CSV data if it's safe to do so (syslogger doesn't need the\n\t\t\t * pipe). First get back the space in the message buffer.\n\t\t\t */\n\t\t\tpfree(buf.data);\n\t\t\twrite_csvlog(edata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * syslogger not up (yet), so just dump the message to stderr,\n\t\t\t * unless we already did so above.\n\t\t\t */\n\t\t\tif (!(Log_destination & LOG_DESTINATION_STDERR) &&\n\t\t\t\twhereToSendOutput != DestDebug)\n\t\t\t\twrite_console(buf.data, buf.len);\n\t\t\tpfree(buf.data);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpfree(buf.data);\n\t}\n}"
  },
  {
    "function_name": "unpack_sql_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2841-2855",
    "snippet": "char *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PGUNSIXBIT",
          "args": [
            "sql_state"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nchar *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}"
  },
  {
    "function_name": "write_csvlog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2644-2835",
    "snippet": "static void\nwrite_csvlog(ErrorData *edata)\n{\n\tStringInfoData buf;\n\tbool\t\tprint_stmt = false;\n\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tinitStringInfo(&buf);\n\n\t/*\n\t * timestamp with milliseconds\n\t *\n\t * Check if the timestamp is already calculated for the syslog message,\n\t * and use it if so.  Otherwise, get the current timestamp.  This is done\n\t * to put same timestamp in both syslog and csvlog messages.\n\t */\n\tif (formatted_log_time[0] == '\\0')\n\t\tsetup_formatted_log_time();\n\n\tappendStringInfoString(&buf, formatted_log_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* username */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->user_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* database name */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->database_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Process id  */\n\tif (MyProcPid != 0)\n\t\tappendStringInfo(&buf, \"%d\", MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Remote host and port */\n\tif (MyProcPort && MyProcPort->remote_host)\n\t{\n\t\tappendStringInfoChar(&buf, '\"');\n\t\tappendStringInfoString(&buf, MyProcPort->remote_host);\n\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t{\n\t\t\tappendStringInfoChar(&buf, ':');\n\t\t\tappendStringInfoString(&buf, MyProcPort->remote_port);\n\t\t}\n\t\tappendStringInfoChar(&buf, '\"');\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session id */\n\tappendStringInfo(&buf, \"%lx.%x\", (long) MyStartTime, MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Line number */\n\tappendStringInfo(&buf, \"%ld\", log_line_number);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* PS display */\n\tif (MyProcPort)\n\t{\n\t\tStringInfoData msgbuf;\n\t\tconst char *psdisp;\n\t\tint\t\t\tdisplen;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tpsdisp = get_ps_display(&displen);\n\t\tappendBinaryStringInfo(&msgbuf, psdisp, displen);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session start timestamp */\n\tif (formatted_start_time[0] == '\\0')\n\t\tsetup_formatted_start_time();\n\tappendStringInfoString(&buf, formatted_start_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Virtual transaction id */\n\t/* keep VXID format in sync with lockfuncs.c */\n\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\tappendStringInfo(&buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Transaction id */\n\tappendStringInfo(&buf, \"%u\", GetTopTransactionIdIfAny());\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Error severity */\n\tappendStringInfoString(&buf, _(error_severity(edata->elevel)));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* SQL state code */\n\tappendStringInfoString(&buf, unpack_sql_state(edata->sqlerrcode));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errmessage */\n\tappendCSVLiteral(&buf, edata->message);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errdetail or errdetail_log */\n\tif (edata->detail_log)\n\t\tappendCSVLiteral(&buf, edata->detail_log);\n\telse\n\t\tappendCSVLiteral(&buf, edata->detail);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errhint */\n\tappendCSVLiteral(&buf, edata->hint);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* internal query */\n\tappendCSVLiteral(&buf, edata->internalquery);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* if printed internal query, print internal pos too */\n\tif (edata->internalpos > 0 && edata->internalquery != NULL)\n\t\tappendStringInfo(&buf, \"%d\", edata->internalpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errcontext */\n\tif (!edata->hide_ctx)\n\t\tappendCSVLiteral(&buf, edata->context);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* user query --- only reported if not disabled by the caller */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t\tprint_stmt = true;\n\tif (print_stmt)\n\t\tappendCSVLiteral(&buf, debug_query_string);\n\tappendStringInfoChar(&buf, ',');\n\tif (print_stmt && edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, \"%d\", edata->cursorpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* file error location */\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t{\n\t\tStringInfoData msgbuf;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tif (edata->funcname && edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s, %s:%d\",\n\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t edata->lineno);\n\t\telse if (edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s:%d\",\n\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* application name */\n\tif (application_name)\n\t\tappendCSVLiteral(&buf, application_name);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\telse\n\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\n\tpfree(buf.data);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tLog_error_verbosity = PGERROR_VERBOSE;",
      "static char formatted_start_time[FORMATTED_TS_LEN];",
      "static char formatted_log_time[FORMATTED_TS_LEN];",
      "static void write_console(const char *line, int len);",
      "static void setup_formatted_log_time(void);",
      "static void setup_formatted_start_time(void);",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "buf.data"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_pipe_chunks",
          "args": [
            "buf.data",
            "buf.len",
            "LOG_DESTINATION_CSVLOG"
          ],
          "line": 2832
        },
        "resolved": true,
        "details": {
          "function_name": "write_pipe_chunks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3088-3118",
          "snippet": "static void\nwrite_pipe_chunks(char *data, int len, int dest)\n{\n\tPipeProtoChunk p;\n\tint\t\t\tfd = fileno(stderr);\n\tint\t\t\trc;\n\n\tAssert(len > 0);\n\n\tp.proto.nuls[0] = p.proto.nuls[1] = '\\0';\n\tp.proto.pid = MyProcPid;\n\n\t/* write all but the last chunk */\n\twhile (len > PIPE_MAX_PAYLOAD)\n\t{\n\t\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'F' : 'f');\n\t\tp.proto.len = PIPE_MAX_PAYLOAD;\n\t\tmemcpy(p.proto.data, data, PIPE_MAX_PAYLOAD);\n\t\trc = write(fd, &p, PIPE_HEADER_SIZE + PIPE_MAX_PAYLOAD);\n\t\t(void) rc;\n\t\tdata += PIPE_MAX_PAYLOAD;\n\t\tlen -= PIPE_MAX_PAYLOAD;\n\t}\n\n\t/* write the last chunk */\n\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'T' : 't');\n\tp.proto.len = len;\n\tmemcpy(p.proto.data, data, len);\n\trc = write(fd, &p, PIPE_HEADER_SIZE + len);\n\t(void) rc;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void write_console(const char *line, int len);",
            "static void write_pipe_chunks(char *data, int len, int dest);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void write_console(const char *line, int len);\nstatic void write_pipe_chunks(char *data, int len, int dest);\n\nstatic void\nwrite_pipe_chunks(char *data, int len, int dest)\n{\n\tPipeProtoChunk p;\n\tint\t\t\tfd = fileno(stderr);\n\tint\t\t\trc;\n\n\tAssert(len > 0);\n\n\tp.proto.nuls[0] = p.proto.nuls[1] = '\\0';\n\tp.proto.pid = MyProcPid;\n\n\t/* write all but the last chunk */\n\twhile (len > PIPE_MAX_PAYLOAD)\n\t{\n\t\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'F' : 'f');\n\t\tp.proto.len = PIPE_MAX_PAYLOAD;\n\t\tmemcpy(p.proto.data, data, PIPE_MAX_PAYLOAD);\n\t\trc = write(fd, &p, PIPE_HEADER_SIZE + PIPE_MAX_PAYLOAD);\n\t\t(void) rc;\n\t\tdata += PIPE_MAX_PAYLOAD;\n\t\tlen -= PIPE_MAX_PAYLOAD;\n\t}\n\n\t/* write the last chunk */\n\tp.proto.is_last = (dest == LOG_DESTINATION_CSVLOG ? 'T' : 't');\n\tp.proto.len = len;\n\tmemcpy(p.proto.data, data, len);\n\trc = write(fd, &p, PIPE_HEADER_SIZE + len);\n\t(void) rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_syslogger_file",
          "args": [
            "buf.data",
            "buf.len",
            "LOG_DESTINATION_CSVLOG"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\\n'"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendCSVLiteral",
          "args": [
            "&buf",
            "application_name"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "appendCSVLiteral",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2620-2638",
          "snippet": "static inline void\nappendCSVLiteral(StringInfo buf, const char *data)\n{\n\tconst char *p = data;\n\tchar\t\tc;\n\n\t/* avoid confusing an empty string with NULL */\n\tif (p == NULL)\n\t\treturn;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\twhile ((c = *p++) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tappendStringInfoCharMacro(buf, '\"');\n\t\tappendStringInfoCharMacro(buf, c);\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic inline void\nappendCSVLiteral(StringInfo buf, const char *data)\n{\n\tconst char *p = data;\n\tchar\t\tc;\n\n\t/* avoid confusing an empty string with NULL */\n\tif (p == NULL)\n\t\treturn;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\twhile ((c = *p++) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tappendStringInfoCharMacro(buf, '\"');\n\t\tappendStringInfoCharMacro(buf, c);\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&msgbuf",
            "\"%s:%d\"",
            "edata->filename",
            "edata->lineno"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&msgbuf",
            "\"%s, %s:%d\"",
            "edata->funcname",
            "edata->filename",
            "edata->lineno"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "appendStringInfoRegexpSubstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/varlena.c",
          "lines": "3944-4037",
          "snippet": "static void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"levenshtein.c\"",
            "#include \"levenshtein.c\"",
            "#include \"utils/varlena.h\"",
            "#include \"utils/sortsupport.h\"",
            "#include \"utils/pg_locale.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/bytea.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"regex/regex.h\"",
            "#include \"port/pg_bswap.h\"",
            "#include \"parser/scansup.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"lib/hyperloglog.h\"",
            "#include \"common/int.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"access/tuptoaster.h\"",
            "#include \"access/hash.h\"",
            "#include <limits.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int32 text_length(Datum str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"levenshtein.c\"\n#include \"levenshtein.c\"\n#include \"utils/varlena.h\"\n#include \"utils/sortsupport.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"regex/regex.h\"\n#include \"port/pg_bswap.h\"\n#include \"parser/scansup.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include \"lib/hyperloglog.h\"\n#include \"common/int.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_collation.h\"\n#include \"access/tuptoaster.h\"\n#include \"access/hash.h\"\n#include <limits.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int32 text_length(Datum str);\n\nstatic void\nappendStringInfoRegexpSubstr(StringInfo str, text *replace_text,\n\t\t\t\t\t\t\t regmatch_t *pmatch,\n\t\t\t\t\t\t\t char *start_ptr, int data_pos)\n{\n\tconst char *p = VARDATA_ANY(replace_text);\n\tconst char *p_end = p + VARSIZE_ANY_EXHDR(replace_text);\n\tint\t\t\teml = pg_database_encoding_max_length();\n\n\tfor (;;)\n\t{\n\t\tconst char *chunk_start = p;\n\t\tint\t\t\tso;\n\t\tint\t\t\teo;\n\n\t\t/* Find next escape char. */\n\t\tif (eml == 1)\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p++)\n\t\t\t\t /* nothing */ ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (; p < p_end && *p != '\\\\'; p += pg_mblen(p))\n\t\t\t\t /* nothing */ ;\n\t\t}\n\n\t\t/* Copy the text we just scanned over, if any. */\n\t\tif (p > chunk_start)\n\t\t\tappendBinaryStringInfo(str, chunk_start, p - chunk_start);\n\n\t\t/* Done if at end of string, else advance over escape char. */\n\t\tif (p >= p_end)\n\t\t\tbreak;\n\t\tp++;\n\n\t\tif (p >= p_end)\n\t\t{\n\t\t\t/* Escape at very end of input.  Treat same as unexpected char */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*p >= '1' && *p <= '9')\n\t\t{\n\t\t\t/* Use the back reference of regexp. */\n\t\t\tint\t\t\tidx = *p - '0';\n\n\t\t\tso = pmatch[idx].rm_so;\n\t\t\teo = pmatch[idx].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '&')\n\t\t{\n\t\t\t/* Use the entire matched string. */\n\t\t\tso = pmatch[0].rm_so;\n\t\t\teo = pmatch[0].rm_eo;\n\t\t\tp++;\n\t\t}\n\t\telse if (*p == '\\\\')\n\t\t{\n\t\t\t/* \\\\ means transfer one \\ to output. */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * If escape char is not followed by any expected char, just treat\n\t\t\t * it as ordinary data to copy.  (XXX would it be better to throw\n\t\t\t * an error?)\n\t\t\t */\n\t\t\tappendStringInfoChar(str, '\\\\');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (so != -1 && eo != -1)\n\t\t{\n\t\t\t/*\n\t\t\t * Copy the text that is back reference of regexp.  Note so and eo\n\t\t\t * are counted in characters not bytes.\n\t\t\t */\n\t\t\tchar\t   *chunk_start;\n\t\t\tint\t\t\tchunk_len;\n\n\t\t\tAssert(so >= data_pos);\n\t\t\tchunk_start = start_ptr;\n\t\t\tchunk_start += charlen_to_bytelen(chunk_start, so - data_pos);\n\t\t\tchunk_len = charlen_to_bytelen(chunk_start, eo - so);\n\t\t\tappendBinaryStringInfo(str, chunk_start, chunk_len);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&msgbuf"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%d\"",
            "edata->cursorpos"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_log_level_output",
          "args": [
            "edata->elevel",
            "log_min_error_statement"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "is_log_level_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3714-3733",
          "snippet": "static bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *error_severity(int elevel);",
            "static bool is_log_level_output(int elevel, int log_min_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\nstatic bool is_log_level_output(int elevel, int log_min_level);\n\nstatic bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%d\"",
            "edata->internalpos"
          ],
          "line": 2783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "unpack_sql_state(edata->sqlerrcode)"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_sql_state",
          "args": [
            "edata->sqlerrcode"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_sql_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2841-2855",
          "snippet": "char *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nchar *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "_(error_severity(edata->elevel))"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "error_severity(edata->elevel)"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "trace_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3750-3758",
          "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error_severity",
          "args": [
            "edata->elevel"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "error_severity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3598-3640",
          "snippet": "static const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\n\nstatic const char *\nerror_severity(int elevel)\n{\n\tconst char *prefix;\n\n\tswitch (elevel)\n\t{\n\t\tcase DEBUG1:\n\t\tcase DEBUG2:\n\t\tcase DEBUG3:\n\t\tcase DEBUG4:\n\t\tcase DEBUG5:\n\t\t\tprefix = gettext_noop(\"DEBUG\");\n\t\t\tbreak;\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\t\tprefix = gettext_noop(\"LOG\");\n\t\t\tbreak;\n\t\tcase INFO:\n\t\t\tprefix = gettext_noop(\"INFO\");\n\t\t\tbreak;\n\t\tcase NOTICE:\n\t\t\tprefix = gettext_noop(\"NOTICE\");\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\tprefix = gettext_noop(\"WARNING\");\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\t\tprefix = gettext_noop(\"ERROR\");\n\t\t\tbreak;\n\t\tcase FATAL:\n\t\t\tprefix = gettext_noop(\"FATAL\");\n\t\t\tbreak;\n\t\tcase PANIC:\n\t\t\tprefix = gettext_noop(\"PANIC\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprefix = \"???\";\n\t\t\tbreak;\n\t}\n\n\treturn prefix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%u\"",
            "GetTopTransactionIdIfAny()"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTopTransactionIdIfAny",
          "args": [],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%d/%u\"",
            "MyProc->backendId",
            "MyProc->lxid"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "formatted_start_time"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_formatted_start_time",
          "args": [],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "setup_formatted_start_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2257-2270",
          "snippet": "static void\nsetup_formatted_start_time(void)\n{\n\tpg_time_t\tstamp_time = (pg_time_t) MyStartTime;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_start_time, FORMATTED_TS_LEN,\n\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FORMATTED_TS_LEN 128"
          ],
          "globals_used": [
            "char\t   *Log_line_prefix = NULL;",
            "static char formatted_start_time[FORMATTED_TS_LEN];",
            "static void setup_formatted_start_time(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define FORMATTED_TS_LEN 128\n\nchar\t   *Log_line_prefix = NULL;\nstatic char formatted_start_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_start_time(void);\n\nstatic void\nsetup_formatted_start_time(void)\n{\n\tpg_time_t\tstamp_time = (pg_time_t) MyStartTime;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_start_time, FORMATTED_TS_LEN,\n\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "&msgbuf",
            "psdisp",
            "displen"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ps_display",
          "args": [
            "&displen"
          ],
          "line": 2730
        },
        "resolved": true,
        "details": {
          "function_name": "get_ps_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
          "lines": "404-419",
          "snippet": "const char *\nget_ps_display(int *displen)\n{\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t{\n\t\t*displen = 0;\n\t\treturn \"\";\n\t}\n#endif\n\n\t*displen = (int) (ps_buffer_cur_len - ps_buffer_fixed_size);\n\n\treturn ps_buffer + ps_buffer_fixed_size;\n}",
          "includes": [
            "#include \"utils/guc.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/libpq.h\"",
            "#include <crt_externs.h>",
            "#include <sys/exec.h>",
            "#include <machine/vmparam.h>\t/* for old BSD */",
            "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PS_USE_CLOBBER_ARGV"
          ],
          "globals_used": [
            "static size_t ps_buffer_cur_len;",
            "static size_t ps_buffer_fixed_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PS_USE_CLOBBER_ARGV\n\nstatic size_t ps_buffer_cur_len;\nstatic size_t ps_buffer_fixed_size;\n\nconst char *\nget_ps_display(int *displen)\n{\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t{\n\t\t*displen = 0;\n\t\treturn \"\";\n\t}\n#endif\n\n\t*displen = (int) (ps_buffer_cur_len - ps_buffer_fixed_size);\n\n\treturn ps_buffer + ps_buffer_fixed_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&msgbuf"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%ld\"",
            "log_line_number"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%lx.%x\"",
            "(long) MyStartTime",
            "MyProcPid"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\"'"
          ],
          "line": 2709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "MyProcPort->remote_port"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "':'"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "MyProcPort->remote_host"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "'\"'"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "&buf",
            "\"%d\"",
            "MyProcPid"
          ],
          "line": 2696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "&buf",
            "formatted_log_time"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_formatted_log_time",
          "args": [],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "setup_formatted_log_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2225-2252",
          "snippet": "static void\nsetup_formatted_log_time(void)\n{\n\tpg_time_t\tstamp_time;\n\tchar\t\tmsbuf[13];\n\n\tif (!saved_timeval_set)\n\t{\n\t\tgettimeofday(&saved_timeval, NULL);\n\t\tsaved_timeval_set = true;\n\t}\n\n\tstamp_time = (pg_time_t) saved_timeval.tv_sec;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,\n\t/* leave room for milliseconds... */\n\t\t\t\t\"%Y-%m-%d %H:%M:%S     %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\n\t/* 'paste' milliseconds into place... */\n\tsprintf(msbuf, \".%03d\", (int) (saved_timeval.tv_usec / 1000));\n\tmemcpy(formatted_log_time + 19, msbuf, 4);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FORMATTED_TS_LEN 128"
          ],
          "globals_used": [
            "char\t   *Log_line_prefix = NULL;",
            "static struct timeval saved_timeval;",
            "static bool saved_timeval_set = false;",
            "static char formatted_log_time[FORMATTED_TS_LEN];",
            "static void setup_formatted_log_time(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define FORMATTED_TS_LEN 128\n\nchar\t   *Log_line_prefix = NULL;\nstatic struct timeval saved_timeval;\nstatic bool saved_timeval_set = false;\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_log_time(void);\n\nstatic void\nsetup_formatted_log_time(void)\n{\n\tpg_time_t\tstamp_time;\n\tchar\t\tmsbuf[13];\n\n\tif (!saved_timeval_set)\n\t{\n\t\tgettimeofday(&saved_timeval, NULL);\n\t\tsaved_timeval_set = true;\n\t}\n\n\tstamp_time = (pg_time_t) saved_timeval.tv_sec;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,\n\t/* leave room for milliseconds... */\n\t\t\t\t\"%Y-%m-%d %H:%M:%S     %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\n\t/* 'paste' milliseconds into place... */\n\tsprintf(msbuf, \".%03d\", (int) (saved_timeval.tv_usec / 1000));\n\tmemcpy(formatted_log_time + 19, msbuf, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initStringInfo",
          "args": [
            "&buf"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\t\t\tLog_error_verbosity = PGERROR_VERBOSE;\nstatic char formatted_start_time[FORMATTED_TS_LEN];\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void write_console(const char *line, int len);\nstatic void setup_formatted_log_time(void);\nstatic void setup_formatted_start_time(void);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nstatic void\nwrite_csvlog(ErrorData *edata)\n{\n\tStringInfoData buf;\n\tbool\t\tprint_stmt = false;\n\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tinitStringInfo(&buf);\n\n\t/*\n\t * timestamp with milliseconds\n\t *\n\t * Check if the timestamp is already calculated for the syslog message,\n\t * and use it if so.  Otherwise, get the current timestamp.  This is done\n\t * to put same timestamp in both syslog and csvlog messages.\n\t */\n\tif (formatted_log_time[0] == '\\0')\n\t\tsetup_formatted_log_time();\n\n\tappendStringInfoString(&buf, formatted_log_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* username */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->user_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* database name */\n\tif (MyProcPort)\n\t\tappendCSVLiteral(&buf, MyProcPort->database_name);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Process id  */\n\tif (MyProcPid != 0)\n\t\tappendStringInfo(&buf, \"%d\", MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Remote host and port */\n\tif (MyProcPort && MyProcPort->remote_host)\n\t{\n\t\tappendStringInfoChar(&buf, '\"');\n\t\tappendStringInfoString(&buf, MyProcPort->remote_host);\n\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t{\n\t\t\tappendStringInfoChar(&buf, ':');\n\t\t\tappendStringInfoString(&buf, MyProcPort->remote_port);\n\t\t}\n\t\tappendStringInfoChar(&buf, '\"');\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session id */\n\tappendStringInfo(&buf, \"%lx.%x\", (long) MyStartTime, MyProcPid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Line number */\n\tappendStringInfo(&buf, \"%ld\", log_line_number);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* PS display */\n\tif (MyProcPort)\n\t{\n\t\tStringInfoData msgbuf;\n\t\tconst char *psdisp;\n\t\tint\t\t\tdisplen;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tpsdisp = get_ps_display(&displen);\n\t\tappendBinaryStringInfo(&msgbuf, psdisp, displen);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* session start timestamp */\n\tif (formatted_start_time[0] == '\\0')\n\t\tsetup_formatted_start_time();\n\tappendStringInfoString(&buf, formatted_start_time);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Virtual transaction id */\n\t/* keep VXID format in sync with lockfuncs.c */\n\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\tappendStringInfo(&buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Transaction id */\n\tappendStringInfo(&buf, \"%u\", GetTopTransactionIdIfAny());\n\tappendStringInfoChar(&buf, ',');\n\n\t/* Error severity */\n\tappendStringInfoString(&buf, _(error_severity(edata->elevel)));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* SQL state code */\n\tappendStringInfoString(&buf, unpack_sql_state(edata->sqlerrcode));\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errmessage */\n\tappendCSVLiteral(&buf, edata->message);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errdetail or errdetail_log */\n\tif (edata->detail_log)\n\t\tappendCSVLiteral(&buf, edata->detail_log);\n\telse\n\t\tappendCSVLiteral(&buf, edata->detail);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errhint */\n\tappendCSVLiteral(&buf, edata->hint);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* internal query */\n\tappendCSVLiteral(&buf, edata->internalquery);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* if printed internal query, print internal pos too */\n\tif (edata->internalpos > 0 && edata->internalquery != NULL)\n\t\tappendStringInfo(&buf, \"%d\", edata->internalpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* errcontext */\n\tif (!edata->hide_ctx)\n\t\tappendCSVLiteral(&buf, edata->context);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* user query --- only reported if not disabled by the caller */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t\tprint_stmt = true;\n\tif (print_stmt)\n\t\tappendCSVLiteral(&buf, debug_query_string);\n\tappendStringInfoChar(&buf, ',');\n\tif (print_stmt && edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, \"%d\", edata->cursorpos);\n\tappendStringInfoChar(&buf, ',');\n\n\t/* file error location */\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t{\n\t\tStringInfoData msgbuf;\n\n\t\tinitStringInfo(&msgbuf);\n\n\t\tif (edata->funcname && edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s, %s:%d\",\n\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t edata->lineno);\n\t\telse if (edata->filename)\n\t\t\tappendStringInfo(&msgbuf, \"%s:%d\",\n\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\tappendCSVLiteral(&buf, msgbuf.data);\n\t\tpfree(msgbuf.data);\n\t}\n\tappendStringInfoChar(&buf, ',');\n\n\t/* application name */\n\tif (application_name)\n\t\tappendCSVLiteral(&buf, application_name);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\telse\n\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_CSVLOG);\n\n\tpfree(buf.data);\n}"
  },
  {
    "function_name": "appendCSVLiteral",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2620-2638",
    "snippet": "static inline void\nappendCSVLiteral(StringInfo buf, const char *data)\n{\n\tconst char *p = data;\n\tchar\t\tc;\n\n\t/* avoid confusing an empty string with NULL */\n\tif (p == NULL)\n\t\treturn;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\twhile ((c = *p++) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tappendStringInfoCharMacro(buf, '\"');\n\t\tappendStringInfoCharMacro(buf, c);\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "'\"'"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "c"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "'\"'"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoCharMacro",
          "args": [
            "buf",
            "'\"'"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic inline void\nappendCSVLiteral(StringInfo buf, const char *data)\n{\n\tconst char *p = data;\n\tchar\t\tc;\n\n\t/* avoid confusing an empty string with NULL */\n\tif (p == NULL)\n\t\treturn;\n\n\tappendStringInfoCharMacro(buf, '\"');\n\twhile ((c = *p++) != '\\0')\n\t{\n\t\tif (c == '\"')\n\t\t\tappendStringInfoCharMacro(buf, '\"');\n\t\tappendStringInfoCharMacro(buf, c);\n\t}\n\tappendStringInfoCharMacro(buf, '\"');\n}"
  },
  {
    "function_name": "log_line_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2310-2613",
    "snippet": "static void\nlog_line_prefix(StringInfo buf, ErrorData *edata)\n{\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\tint\t\t\tpadding;\n\tconst char *p;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes. MyStartTime also changes when MyProcPid does, so\n\t * reset the formatted start timestamp too.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tif (Log_line_prefix == NULL)\n\t\treturn;\t\t\t\t\t/* in case guc hasn't run yet */\n\n\tfor (p = Log_line_prefix; *p != '\\0'; p++)\n\t{\n\t\tif (*p != '%')\n\t\t{\n\t\t\t/* literal char, just copy */\n\t\t\tappendStringInfoChar(buf, *p);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* must be a '%', so skip to the next char */\n\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\t\t\t\t/* format error - ignore it */\n\t\telse if (*p == '%')\n\t\t{\n\t\t\t/* string contains %% */\n\t\t\tappendStringInfoChar(buf, '%');\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t/*\n\t\t * Process any formatting which may exist after the '%'.  Note that\n\t\t * process_log_prefix_padding moves p past the padding number if it\n\t\t * exists.\n\t\t *\n\t\t * Note: Since only '-', '0' to '9' are valid formatting characters we\n\t\t * can do a quick check here to pre-check for formatting. If the char\n\t\t * is not formatting then we can skip a useless function call.\n\t\t *\n\t\t * Further note: At least on some platforms, passing %*s rather than\n\t\t * %s to appendStringInfo() is substantially slower, so many of the\n\t\t * cases below avoid doing that unless non-zero padding is in fact\n\t\t * specified.\n\t\t */\n\t\tif (*p > '9')\n\t\t\tpadding = 0;\n\t\telse if ((p = process_log_prefix_padding(p, &padding)) == NULL)\n\t\t\tbreak;\n\n\t\t/* process the option */\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase 'a':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *appname = application_name;\n\n\t\t\t\t\tif (appname == NULL || *appname == '\\0')\n\t\t\t\t\t\tappname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, appname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, appname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *username = MyProcPort->user_name;\n\n\t\t\t\t\tif (username == NULL || *username == '\\0')\n\t\t\t\t\t\tusername = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, username);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, username);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *dbname = MyProcPort->database_name;\n\n\t\t\t\t\tif (dbname == NULL || *dbname == '\\0')\n\t\t\t\t\t\tdbname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, dbname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, dbname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (padding != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%lx.%x\",\n\t\t\t\t\t\t\t (long) (MyStartTime), MyProcPid);\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%lx.%x\", (long) (MyStartTime), MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*d\", padding, MyProcPid);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%d\", MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*ld\", padding, log_line_number);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%ld\", log_line_number);\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tsetup_formatted_log_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_log_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_log_time);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tpg_time_t\tstamp_time = (pg_time_t) time(NULL);\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tpg_strftime(strfbuf, sizeof(strfbuf),\n\t\t\t\t\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\t\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tif (!saved_timeval_set)\n\t\t\t\t\t{\n\t\t\t\t\t\tgettimeofday(&saved_timeval, NULL);\n\t\t\t\t\t\tsaved_timeval_set = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf), \"%ld.%03d\",\n\t\t\t\t\t\t\t (long) saved_timeval.tv_sec,\n\t\t\t\t\t\t\t (int) (saved_timeval.tv_usec / 1000));\n\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (formatted_start_time[0] == '\\0')\n\t\t\t\t\tsetup_formatted_start_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_start_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_start_time);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *psdisp;\n\t\t\t\t\tint\t\t\tdisplen;\n\n\t\t\t\t\tpsdisp = get_ps_display(&displen);\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, psdisp);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendBinaryStringInfo(buf, psdisp, displen);\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * This option is slightly special as the port\n\t\t\t\t\t\t\t * number may be appended onto the end. Here we\n\t\t\t\t\t\t\t * need to build 1 string which contains the\n\t\t\t\t\t\t\t * remote_host and optionally the remote_port (if\n\t\t\t\t\t\t\t * set) so we can properly align the string.\n\t\t\t\t\t\t\t */\n\n\t\t\t\t\t\t\tchar\t   *hostport;\n\n\t\t\t\t\t\t\thostport = psprintf(\"%s(%s)\", MyProcPort->remote_host, MyProcPort->remote_port);\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, hostport);\n\t\t\t\t\t\t\tpfree(hostport);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* padding is 0, so we don't need a temp buffer */\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t\t\tif (MyProcPort->remote_port &&\n\t\t\t\t\t\t\tMyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t\tappendStringInfo(buf, \"(%s)\",\n\t\t\t\t\t\t\t\t\t\t\t MyProcPort->remote_port);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\t/* in postmaster and friends, stop if %q is seen */\n\t\t\t\t/* in a backend, just ignore */\n\t\t\t\tif (MyProcPort == NULL)\n\t\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\t/* keep VXID format in sync with lockfuncs.c */\n\t\t\t\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%d/%u\",\n\t\t\t\t\t\t\t\t MyProc->backendId, MyProc->lxid);\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'x':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*u\", padding, GetTopTransactionIdIfAny());\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%u\", GetTopTransactionIdIfAny());\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* format error - ignore it */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "char\t   *Log_line_prefix = NULL;",
      "static struct timeval saved_timeval;",
      "static bool saved_timeval_set = false;",
      "static char formatted_start_time[FORMATTED_TS_LEN];",
      "static char formatted_log_time[FORMATTED_TS_LEN];",
      "static void setup_formatted_log_time(void);",
      "static void setup_formatted_start_time(void);",
      "static const char *process_log_prefix_padding(const char *p, int *padding);",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "unpack_sql_state(edata->sqlerrcode)"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_sql_state",
          "args": [
            "edata->sqlerrcode"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_sql_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2841-2855",
          "snippet": "char *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nchar *\nunpack_sql_state(int sql_state)\n{\n\tstatic char buf[12];\n\tint\t\t\ti;\n\n\tfor (i = 0; i < 5; i++)\n\t{\n\t\tbuf[i] = PGUNSIXBIT(sql_state);\n\t\tsql_state >>= 6;\n\t}\n\n\tbuf[i] = '\\0';\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "unpack_sql_state(edata->sqlerrcode)"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%u\"",
            "GetTopTransactionIdIfAny()"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTopTransactionIdIfAny",
          "args": [],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*u\"",
            "padding",
            "GetTopTransactionIdIfAny()"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTopTransactionIdIfAny",
          "args": [],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "padding > 0 ? padding : -padding"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%d/%u\"",
            "MyProc->backendId",
            "MyProc->lxid"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "strfbuf"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strfbuf",
            "sizeof(strfbuf) - 1",
            "\"%d/%u\"",
            "MyProc->backendId",
            "MyProc->lxid"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "padding > 0 ? padding : -padding"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "MyProcPort->remote_host"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "MyProcPort->remote_host"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "padding > 0 ? padding : -padding"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"(%s)\"",
            "MyProcPort->remote_port"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "MyProcPort->remote_host"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "MyProcPort->remote_host"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "hostport"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "hostport"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psprintf",
          "args": [
            "\"%s(%s)\"",
            "MyProcPort->remote_host",
            "MyProcPort->remote_port"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "padding > 0 ? padding : -padding"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendBinaryStringInfo",
          "args": [
            "buf",
            "psdisp",
            "displen"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "psdisp"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ps_display",
          "args": [
            "&displen"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "get_ps_display",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/misc/ps_status.c",
          "lines": "404-419",
          "snippet": "const char *\nget_ps_display(int *displen)\n{\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t{\n\t\t*displen = 0;\n\t\treturn \"\";\n\t}\n#endif\n\n\t*displen = (int) (ps_buffer_cur_len - ps_buffer_fixed_size);\n\n\treturn ps_buffer + ps_buffer_fixed_size;\n}",
          "includes": [
            "#include \"utils/guc.h\"",
            "#include \"utils/ps_status.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/libpq.h\"",
            "#include <crt_externs.h>",
            "#include <sys/exec.h>",
            "#include <machine/vmparam.h>\t/* for old BSD */",
            "#include <sys/pstat.h>\t\t\t/* for HP-UX */",
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define PS_USE_CLOBBER_ARGV"
          ],
          "globals_used": [
            "static size_t ps_buffer_cur_len;",
            "static size_t ps_buffer_fixed_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/guc.h\"\n#include \"utils/ps_status.h\"\n#include \"miscadmin.h\"\n#include \"libpq/libpq.h\"\n#include <crt_externs.h>\n#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t\t/* for HP-UX */\n#include <unistd.h>\n#include \"postgres.h\"\n\n#define PS_USE_CLOBBER_ARGV\n\nstatic size_t ps_buffer_cur_len;\nstatic size_t ps_buffer_fixed_size;\n\nconst char *\nget_ps_display(int *displen)\n{\n#ifdef PS_USE_CLOBBER_ARGV\n\t/* If ps_buffer is a pointer, it might still be null */\n\tif (!ps_buffer)\n\t{\n\t\t*displen = 0;\n\t\treturn \"\";\n\t}\n#endif\n\n\t*displen = (int) (ps_buffer_cur_len - ps_buffer_fixed_size);\n\n\treturn ps_buffer + ps_buffer_fixed_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "formatted_start_time"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "formatted_start_time"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_formatted_start_time",
          "args": [],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "setup_formatted_start_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2257-2270",
          "snippet": "static void\nsetup_formatted_start_time(void)\n{\n\tpg_time_t\tstamp_time = (pg_time_t) MyStartTime;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_start_time, FORMATTED_TS_LEN,\n\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FORMATTED_TS_LEN 128"
          ],
          "globals_used": [
            "char\t   *Log_line_prefix = NULL;",
            "static char formatted_start_time[FORMATTED_TS_LEN];",
            "static void setup_formatted_start_time(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define FORMATTED_TS_LEN 128\n\nchar\t   *Log_line_prefix = NULL;\nstatic char formatted_start_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_start_time(void);\n\nstatic void\nsetup_formatted_start_time(void)\n{\n\tpg_time_t\tstamp_time = (pg_time_t) MyStartTime;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_start_time, FORMATTED_TS_LEN,\n\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "strfbuf"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "strfbuf"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strfbuf",
            "sizeof(strfbuf)",
            "\"%ld.%03d\"",
            "(long) saved_timeval.tv_sec",
            "(int) (saved_timeval.tv_usec / 1000)"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&saved_timeval",
            "NULL"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "strfbuf"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "strfbuf"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strftime",
          "args": [
            "strfbuf",
            "sizeof(strfbuf)",
            "\"%Y-%m-%d %H:%M:%S %Z\"",
            "pg_localtime(&stamp_time, log_timezone)"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&stamp_time",
            "log_timezone"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "pg_timezone_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/datetime.c",
          "lines": "4766-4876",
          "snippet": "Datum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}",
          "includes": [
            "#include \"utils/tzparser.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/datetime.h\"",
            "#include \"utils/date.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"nodes/nodeFuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"funcapi.h\"",
            "#include \"common/string.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/htup_details.h\"",
            "#include <math.h>",
            "#include <limits.h>",
            "#include <float.h>",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);",
            "static int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/tzparser.h\"\n#include \"utils/memutils.h\"\n#include \"utils/datetime.h\"\n#include \"utils/date.h\"\n#include \"utils/builtins.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"miscadmin.h\"\n#include \"funcapi.h\"\n#include \"common/string.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/xact.h\"\n#include \"access/htup_details.h\"\n#include <math.h>\n#include <limits.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic int DecodeTime(char *str, int fmask, int range,\n\t\t   int *tmask, struct pg_tm *tm, fsec_t *fsec);\nstatic int DecodeDate(char *str, int fmask, int *tmask, bool *is2digits,\n\t\t   struct pg_tm *tm);\n\nDatum\npg_timezone_names(PG_FUNCTION_ARGS)\n{\n\tMemoryContext oldcontext;\n\tFuncCallContext *funcctx;\n\tpg_tzenum  *tzenum;\n\tpg_tz\t   *tz;\n\tDatum\t\tresult;\n\tHeapTuple\ttuple;\n\tDatum\t\tvalues[4];\n\tbool\t\tnulls[4];\n\tint\t\t\ttzoff;\n\tstruct pg_tm tm;\n\tfsec_t\t\tfsec;\n\tconst char *tzn;\n\tInterval   *resInterval;\n\tstruct pg_tm itm;\n\n\t/* stuff done only on the first call of the function */\n\tif (SRF_IS_FIRSTCALL())\n\t{\n\t\tTupleDesc\ttupdesc;\n\n\t\t/* create a function context for cross-call persistence */\n\t\tfuncctx = SRF_FIRSTCALL_INIT();\n\n\t\t/*\n\t\t * switch to memory context appropriate for multiple function calls\n\t\t */\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\n\t\t/* initialize timezone scanning code */\n\t\ttzenum = pg_tzenumerate_start();\n\t\tfuncctx->user_fctx = (void *) tzenum;\n\n\t\t/*\n\t\t * build tupdesc for result tuples. This must match this function's\n\t\t * pg_proc entry!\n\t\t */\n\t\ttupdesc = CreateTemplateTupleDesc(4, false);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 1, \"name\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 2, \"abbrev\",\n\t\t\t\t\t\t   TEXTOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 3, \"utc_offset\",\n\t\t\t\t\t\t   INTERVALOID, -1, 0);\n\t\tTupleDescInitEntry(tupdesc, (AttrNumber) 4, \"is_dst\",\n\t\t\t\t\t\t   BOOLOID, -1, 0);\n\n\t\tfuncctx->tuple_desc = BlessTupleDesc(tupdesc);\n\t\tMemoryContextSwitchTo(oldcontext);\n\t}\n\n\t/* stuff done on every call of the function */\n\tfuncctx = SRF_PERCALL_SETUP();\n\ttzenum = (pg_tzenum *) funcctx->user_fctx;\n\n\t/* search for another zone to display */\n\tfor (;;)\n\t{\n\t\toldcontext = MemoryContextSwitchTo(funcctx->multi_call_memory_ctx);\n\t\ttz = pg_tzenumerate_next(tzenum);\n\t\tMemoryContextSwitchTo(oldcontext);\n\n\t\tif (!tz)\n\t\t{\n\t\t\tpg_tzenumerate_end(tzenum);\n\t\t\tfuncctx->user_fctx = NULL;\n\t\t\tSRF_RETURN_DONE(funcctx);\n\t\t}\n\n\t\t/* Convert now() to local time in this zone */\n\t\tif (timestamp2tm(GetCurrentTransactionStartTimestamp(),\n\t\t\t\t\t\t &tzoff, &tm, &fsec, &tzn, tz) != 0)\n\t\t\tcontinue;\t\t\t/* ignore if conversion fails */\n\n\t\t/*\n\t\t * Ignore zic's rather silly \"Factory\" time zone.  The long string\n\t\t * about \"see zic manual page\" is used in tzdata versions before\n\t\t * 2016g; we can drop it someday when we're pretty sure no such data\n\t\t * exists in the wild on platforms using --with-system-tzdata.  In\n\t\t * 2016g and later, the time zone abbreviation \"-00\" is used for\n\t\t * \"Factory\" as well as some invalid cases, all of which we can\n\t\t * reasonably omit from the pg_timezone_names view.\n\t\t */\n\t\tif (tzn && (strcmp(tzn, \"-00\") == 0 ||\n\t\t\t\t\tstrcmp(tzn, \"Local time zone must be set--see zic manual page\") == 0))\n\t\t\tcontinue;\n\n\t\t/* Found a displayable zone */\n\t\tbreak;\n\t}\n\n\tMemSet(nulls, 0, sizeof(nulls));\n\n\tvalues[0] = CStringGetTextDatum(pg_get_timezone_name(tz));\n\tvalues[1] = CStringGetTextDatum(tzn ? tzn : \"\");\n\n\tMemSet(&itm, 0, sizeof(struct pg_tm));\n\titm.tm_sec = -tzoff;\n\tresInterval = (Interval *) palloc(sizeof(Interval));\n\ttm2interval(&itm, 0, resInterval);\n\tvalues[2] = IntervalPGetDatum(resInterval);\n\n\tvalues[3] = BoolGetDatum(tm.tm_isdst > 0);\n\n\ttuple = heap_form_tuple(funcctx->tuple_desc, values, nulls);\n\tresult = HeapTupleGetDatum(tuple);\n\n\tSRF_RETURN_NEXT(funcctx, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "formatted_log_time"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "formatted_log_time"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_formatted_log_time",
          "args": [],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "setup_formatted_log_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2225-2252",
          "snippet": "static void\nsetup_formatted_log_time(void)\n{\n\tpg_time_t\tstamp_time;\n\tchar\t\tmsbuf[13];\n\n\tif (!saved_timeval_set)\n\t{\n\t\tgettimeofday(&saved_timeval, NULL);\n\t\tsaved_timeval_set = true;\n\t}\n\n\tstamp_time = (pg_time_t) saved_timeval.tv_sec;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,\n\t/* leave room for milliseconds... */\n\t\t\t\t\"%Y-%m-%d %H:%M:%S     %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\n\t/* 'paste' milliseconds into place... */\n\tsprintf(msbuf, \".%03d\", (int) (saved_timeval.tv_usec / 1000));\n\tmemcpy(formatted_log_time + 19, msbuf, 4);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define FORMATTED_TS_LEN 128"
          ],
          "globals_used": [
            "char\t   *Log_line_prefix = NULL;",
            "static struct timeval saved_timeval;",
            "static bool saved_timeval_set = false;",
            "static char formatted_log_time[FORMATTED_TS_LEN];",
            "static void setup_formatted_log_time(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define FORMATTED_TS_LEN 128\n\nchar\t   *Log_line_prefix = NULL;\nstatic struct timeval saved_timeval;\nstatic bool saved_timeval_set = false;\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_log_time(void);\n\nstatic void\nsetup_formatted_log_time(void)\n{\n\tpg_time_t\tstamp_time;\n\tchar\t\tmsbuf[13];\n\n\tif (!saved_timeval_set)\n\t{\n\t\tgettimeofday(&saved_timeval, NULL);\n\t\tsaved_timeval_set = true;\n\t}\n\n\tstamp_time = (pg_time_t) saved_timeval.tv_sec;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,\n\t/* leave room for milliseconds... */\n\t\t\t\t\"%Y-%m-%d %H:%M:%S     %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\n\t/* 'paste' milliseconds into place... */\n\tsprintf(msbuf, \".%03d\", (int) (saved_timeval.tv_usec / 1000));\n\tmemcpy(formatted_log_time + 19, msbuf, 4);\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%ld\"",
            "log_line_number"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*ld\"",
            "padding",
            "log_line_number"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%d\"",
            "MyProcPid"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*d\"",
            "padding",
            "MyProcPid"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%lx.%x\"",
            "(long) (MyStartTime)",
            "MyProcPid"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "strfbuf"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strfbuf",
            "sizeof(strfbuf) - 1",
            "\"%lx.%x\"",
            "(long) (MyStartTime)",
            "MyProcPid"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "padding > 0 ? padding : -padding"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "dbname"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "dbname"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"[unknown]\""
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "trace_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3750-3758",
          "snippet": "int\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\ntrace_recovery(int trace_level)\n{\n\tif (trace_level < LOG &&\n\t\ttrace_level >= trace_recovery_messages)\n\t\treturn LOG;\n\n\treturn trace_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "padding > 0 ? padding : -padding"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "username"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "username"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoSpaces",
          "args": [
            "buf",
            "padding > 0 ? padding : -padding"
          ],
          "line": 2394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoString",
          "args": [
            "buf",
            "appname"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfo",
          "args": [
            "buf",
            "\"%*s\"",
            "padding",
            "appname"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_log_prefix_padding",
          "args": [
            "p",
            "&padding"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "process_log_prefix_padding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2279-2305",
          "snippet": "static const char *\nprocess_log_prefix_padding(const char *p, int *ppadding)\n{\n\tint\t\t\tpaddingsign = 1;\n\tint\t\t\tpadding = 0;\n\n\tif (*p == '-')\n\t{\n\t\tp++;\n\n\t\tif (*p == '\\0')\t\t\t/* Did the buf end in %- ? */\n\t\t\treturn NULL;\n\t\tpaddingsign = -1;\n\t}\n\n\t/* generate an int version of the numerical string */\n\twhile (*p >= '0' && *p <= '9')\n\t\tpadding = padding * 10 + (*p++ - '0');\n\n\t/* format is invalid if it ends with the padding number */\n\tif (*p == '\\0')\n\t\treturn NULL;\n\n\tpadding *= paddingsign;\n\t*ppadding = padding;\n\treturn p;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *process_log_prefix_padding(const char *p, int *padding);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *process_log_prefix_padding(const char *p, int *padding);\n\nstatic const char *\nprocess_log_prefix_padding(const char *p, int *ppadding)\n{\n\tint\t\t\tpaddingsign = 1;\n\tint\t\t\tpadding = 0;\n\n\tif (*p == '-')\n\t{\n\t\tp++;\n\n\t\tif (*p == '\\0')\t\t\t/* Did the buf end in %- ? */\n\t\t\treturn NULL;\n\t\tpaddingsign = -1;\n\t}\n\n\t/* generate an int version of the numerical string */\n\twhile (*p >= '0' && *p <= '9')\n\t\tpadding = padding * 10 + (*p++ - '0');\n\n\t/* format is invalid if it ends with the padding number */\n\tif (*p == '\\0')\n\t\treturn NULL;\n\n\tpadding *= paddingsign;\n\t*ppadding = padding;\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "buf",
            "'%'"
          ],
          "line": 2354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "appendStringInfoChar",
          "args": [
            "buf",
            "*p"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nchar\t   *Log_line_prefix = NULL;\nstatic struct timeval saved_timeval;\nstatic bool saved_timeval_set = false;\nstatic char formatted_start_time[FORMATTED_TS_LEN];\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_log_time(void);\nstatic void setup_formatted_start_time(void);\nstatic const char *process_log_prefix_padding(const char *p, int *padding);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nstatic void\nlog_line_prefix(StringInfo buf, ErrorData *edata)\n{\n\t/* static counter for line numbers */\n\tstatic long log_line_number = 0;\n\n\t/* has counter been reset in current process? */\n\tstatic int\tlog_my_pid = 0;\n\tint\t\t\tpadding;\n\tconst char *p;\n\n\t/*\n\t * This is one of the few places where we'd rather not inherit a static\n\t * variable's value from the postmaster.  But since we will, reset it when\n\t * MyProcPid changes. MyStartTime also changes when MyProcPid does, so\n\t * reset the formatted start timestamp too.\n\t */\n\tif (log_my_pid != MyProcPid)\n\t{\n\t\tlog_line_number = 0;\n\t\tlog_my_pid = MyProcPid;\n\t\tformatted_start_time[0] = '\\0';\n\t}\n\tlog_line_number++;\n\n\tif (Log_line_prefix == NULL)\n\t\treturn;\t\t\t\t\t/* in case guc hasn't run yet */\n\n\tfor (p = Log_line_prefix; *p != '\\0'; p++)\n\t{\n\t\tif (*p != '%')\n\t\t{\n\t\t\t/* literal char, just copy */\n\t\t\tappendStringInfoChar(buf, *p);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* must be a '%', so skip to the next char */\n\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tbreak;\t\t\t\t/* format error - ignore it */\n\t\telse if (*p == '%')\n\t\t{\n\t\t\t/* string contains %% */\n\t\t\tappendStringInfoChar(buf, '%');\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t/*\n\t\t * Process any formatting which may exist after the '%'.  Note that\n\t\t * process_log_prefix_padding moves p past the padding number if it\n\t\t * exists.\n\t\t *\n\t\t * Note: Since only '-', '0' to '9' are valid formatting characters we\n\t\t * can do a quick check here to pre-check for formatting. If the char\n\t\t * is not formatting then we can skip a useless function call.\n\t\t *\n\t\t * Further note: At least on some platforms, passing %*s rather than\n\t\t * %s to appendStringInfo() is substantially slower, so many of the\n\t\t * cases below avoid doing that unless non-zero padding is in fact\n\t\t * specified.\n\t\t */\n\t\tif (*p > '9')\n\t\t\tpadding = 0;\n\t\telse if ((p = process_log_prefix_padding(p, &padding)) == NULL)\n\t\t\tbreak;\n\n\t\t/* process the option */\n\t\tswitch (*p)\n\t\t{\n\t\t\tcase 'a':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *appname = application_name;\n\n\t\t\t\t\tif (appname == NULL || *appname == '\\0')\n\t\t\t\t\t\tappname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, appname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, appname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *username = MyProcPort->user_name;\n\n\t\t\t\t\tif (username == NULL || *username == '\\0')\n\t\t\t\t\t\tusername = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, username);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, username);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *dbname = MyProcPort->database_name;\n\n\t\t\t\t\tif (dbname == NULL || *dbname == '\\0')\n\t\t\t\t\t\tdbname = _(\"[unknown]\");\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, dbname);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, dbname);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tif (padding != 0)\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%lx.%x\",\n\t\t\t\t\t\t\t (long) (MyStartTime), MyProcPid);\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%lx.%x\", (long) (MyStartTime), MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*d\", padding, MyProcPid);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%d\", MyProcPid);\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*ld\", padding, log_line_number);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%ld\", log_line_number);\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tsetup_formatted_log_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_log_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_log_time);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\t{\n\t\t\t\t\tpg_time_t\tstamp_time = (pg_time_t) time(NULL);\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tpg_strftime(strfbuf, sizeof(strfbuf),\n\t\t\t\t\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\t\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\t{\n\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\tif (!saved_timeval_set)\n\t\t\t\t\t{\n\t\t\t\t\t\tgettimeofday(&saved_timeval, NULL);\n\t\t\t\t\t\tsaved_timeval_set = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf), \"%ld.%03d\",\n\t\t\t\t\t\t\t (long) saved_timeval.tv_sec,\n\t\t\t\t\t\t\t (int) (saved_timeval.tv_usec / 1000));\n\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, strfbuf);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (formatted_start_time[0] == '\\0')\n\t\t\t\t\tsetup_formatted_start_time();\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, formatted_start_time);\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, formatted_start_time);\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tif (MyProcPort)\n\t\t\t\t{\n\t\t\t\t\tconst char *psdisp;\n\t\t\t\t\tint\t\t\tdisplen;\n\n\t\t\t\t\tpsdisp = get_ps_display(&displen);\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, psdisp);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendBinaryStringInfo(buf, psdisp, displen);\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (MyProcPort->remote_port && MyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * This option is slightly special as the port\n\t\t\t\t\t\t\t * number may be appended onto the end. Here we\n\t\t\t\t\t\t\t * need to build 1 string which contains the\n\t\t\t\t\t\t\t * remote_host and optionally the remote_port (if\n\t\t\t\t\t\t\t * set) so we can properly align the string.\n\t\t\t\t\t\t\t */\n\n\t\t\t\t\t\t\tchar\t   *hostport;\n\n\t\t\t\t\t\t\thostport = psprintf(\"%s(%s)\", MyProcPort->remote_host, MyProcPort->remote_port);\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, hostport);\n\t\t\t\t\t\t\tpfree(hostport);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* padding is 0, so we don't need a temp buffer */\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t\t\tif (MyProcPort->remote_port &&\n\t\t\t\t\t\t\tMyProcPort->remote_port[0] != '\\0')\n\t\t\t\t\t\t\tappendStringInfo(buf, \"(%s)\",\n\t\t\t\t\t\t\t\t\t\t\t MyProcPort->remote_port);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tif (MyProcPort && MyProcPort->remote_host)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, MyProcPort->remote_host);\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfoString(buf, MyProcPort->remote_host);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\t/* in postmaster and friends, stop if %q is seen */\n\t\t\t\t/* in a backend, just ignore */\n\t\t\t\tif (MyProcPort == NULL)\n\t\t\t\t\treturn;\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\t/* keep VXID format in sync with lockfuncs.c */\n\t\t\t\tif (MyProc != NULL && MyProc->backendId != InvalidBackendId)\n\t\t\t\t{\n\t\t\t\t\tif (padding != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar\t\tstrfbuf[128];\n\n\t\t\t\t\t\tsnprintf(strfbuf, sizeof(strfbuf) - 1, \"%d/%u\",\n\t\t\t\t\t\t\t\t MyProc->backendId, MyProc->lxid);\n\t\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, strfbuf);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tappendStringInfo(buf, \"%d/%u\", MyProc->backendId, MyProc->lxid);\n\t\t\t\t}\n\t\t\t\telse if (padding != 0)\n\t\t\t\t\tappendStringInfoSpaces(buf,\n\t\t\t\t\t\t\t\t\t\t   padding > 0 ? padding : -padding);\n\t\t\t\tbreak;\n\t\t\tcase 'x':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*u\", padding, GetTopTransactionIdIfAny());\n\t\t\t\telse\n\t\t\t\t\tappendStringInfo(buf, \"%u\", GetTopTransactionIdIfAny());\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tif (padding != 0)\n\t\t\t\t\tappendStringInfo(buf, \"%*s\", padding, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\telse\n\t\t\t\t\tappendStringInfoString(buf, unpack_sql_state(edata->sqlerrcode));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* format error - ignore it */\n\t\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "process_log_prefix_padding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2279-2305",
    "snippet": "static const char *\nprocess_log_prefix_padding(const char *p, int *ppadding)\n{\n\tint\t\t\tpaddingsign = 1;\n\tint\t\t\tpadding = 0;\n\n\tif (*p == '-')\n\t{\n\t\tp++;\n\n\t\tif (*p == '\\0')\t\t\t/* Did the buf end in %- ? */\n\t\t\treturn NULL;\n\t\tpaddingsign = -1;\n\t}\n\n\t/* generate an int version of the numerical string */\n\twhile (*p >= '0' && *p <= '9')\n\t\tpadding = padding * 10 + (*p++ - '0');\n\n\t/* format is invalid if it ends with the padding number */\n\tif (*p == '\\0')\n\t\treturn NULL;\n\n\tpadding *= paddingsign;\n\t*ppadding = padding;\n\treturn p;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *process_log_prefix_padding(const char *p, int *padding);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *process_log_prefix_padding(const char *p, int *padding);\n\nstatic const char *\nprocess_log_prefix_padding(const char *p, int *ppadding)\n{\n\tint\t\t\tpaddingsign = 1;\n\tint\t\t\tpadding = 0;\n\n\tif (*p == '-')\n\t{\n\t\tp++;\n\n\t\tif (*p == '\\0')\t\t\t/* Did the buf end in %- ? */\n\t\t\treturn NULL;\n\t\tpaddingsign = -1;\n\t}\n\n\t/* generate an int version of the numerical string */\n\twhile (*p >= '0' && *p <= '9')\n\t\tpadding = padding * 10 + (*p++ - '0');\n\n\t/* format is invalid if it ends with the padding number */\n\tif (*p == '\\0')\n\t\treturn NULL;\n\n\tpadding *= paddingsign;\n\t*ppadding = padding;\n\treturn p;\n}"
  },
  {
    "function_name": "setup_formatted_start_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2257-2270",
    "snippet": "static void\nsetup_formatted_start_time(void)\n{\n\tpg_time_t\tstamp_time = (pg_time_t) MyStartTime;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_start_time, FORMATTED_TS_LEN,\n\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FORMATTED_TS_LEN 128"
    ],
    "globals_used": [
      "char\t   *Log_line_prefix = NULL;",
      "static char formatted_start_time[FORMATTED_TS_LEN];",
      "static void setup_formatted_start_time(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_strftime",
          "args": [
            "formatted_start_time",
            "FORMATTED_TS_LEN",
            "\"%Y-%m-%d %H:%M:%S %Z\"",
            "pg_localtime(&stamp_time, log_timezone)"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&stamp_time",
            "log_timezone"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define FORMATTED_TS_LEN 128\n\nchar\t   *Log_line_prefix = NULL;\nstatic char formatted_start_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_start_time(void);\n\nstatic void\nsetup_formatted_start_time(void)\n{\n\tpg_time_t\tstamp_time = (pg_time_t) MyStartTime;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_start_time, FORMATTED_TS_LEN,\n\t\t\t\t\"%Y-%m-%d %H:%M:%S %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n}"
  },
  {
    "function_name": "setup_formatted_log_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2225-2252",
    "snippet": "static void\nsetup_formatted_log_time(void)\n{\n\tpg_time_t\tstamp_time;\n\tchar\t\tmsbuf[13];\n\n\tif (!saved_timeval_set)\n\t{\n\t\tgettimeofday(&saved_timeval, NULL);\n\t\tsaved_timeval_set = true;\n\t}\n\n\tstamp_time = (pg_time_t) saved_timeval.tv_sec;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,\n\t/* leave room for milliseconds... */\n\t\t\t\t\"%Y-%m-%d %H:%M:%S     %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\n\t/* 'paste' milliseconds into place... */\n\tsprintf(msbuf, \".%03d\", (int) (saved_timeval.tv_usec / 1000));\n\tmemcpy(formatted_log_time + 19, msbuf, 4);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define FORMATTED_TS_LEN 128"
    ],
    "globals_used": [
      "char\t   *Log_line_prefix = NULL;",
      "static struct timeval saved_timeval;",
      "static bool saved_timeval_set = false;",
      "static char formatted_log_time[FORMATTED_TS_LEN];",
      "static void setup_formatted_log_time(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "formatted_log_time + 19",
            "msbuf",
            "4"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "msbuf",
            "\".%03d\"",
            "(int) (saved_timeval.tv_usec / 1000)"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_strftime",
          "args": [
            "formatted_log_time",
            "FORMATTED_TS_LEN",
            "/* leave room for milliseconds... */\"%Y-%m-%d %H:%M:%S     %Z\"",
            "pg_localtime(&stamp_time, log_timezone)"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pg_localtime",
          "args": [
            "&stamp_time",
            "log_timezone"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&saved_timeval",
            "NULL"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define FORMATTED_TS_LEN 128\n\nchar\t   *Log_line_prefix = NULL;\nstatic struct timeval saved_timeval;\nstatic bool saved_timeval_set = false;\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void setup_formatted_log_time(void);\n\nstatic void\nsetup_formatted_log_time(void)\n{\n\tpg_time_t\tstamp_time;\n\tchar\t\tmsbuf[13];\n\n\tif (!saved_timeval_set)\n\t{\n\t\tgettimeofday(&saved_timeval, NULL);\n\t\tsaved_timeval_set = true;\n\t}\n\n\tstamp_time = (pg_time_t) saved_timeval.tv_sec;\n\n\t/*\n\t * Note: we expect that guc.c will ensure that log_timezone is set up (at\n\t * least with a minimal GMT value) before Log_line_prefix can become\n\t * nonempty or CSV mode can be selected.\n\t */\n\tpg_strftime(formatted_log_time, FORMATTED_TS_LEN,\n\t/* leave room for milliseconds... */\n\t\t\t\t\"%Y-%m-%d %H:%M:%S     %Z\",\n\t\t\t\tpg_localtime(&stamp_time, log_timezone));\n\n\t/* 'paste' milliseconds into place... */\n\tsprintf(msbuf, \".%03d\", (int) (saved_timeval.tv_usec / 1000));\n\tmemcpy(formatted_log_time + 19, msbuf, 4);\n}"
  },
  {
    "function_name": "write_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2154-2220",
    "snippet": "static void\nwrite_console(const char *line, int len)\n{\n\tint\t\t\trc;\n\n#ifdef WIN32\n\n\t/*\n\t * Try to convert the message to UTF16 and write it with WriteConsoleW().\n\t * Fall back on write() if anything fails.\n\t *\n\t * In contrast to write_eventlog(), don't skip straight to write() based\n\t * on the applicable encodings.  Unlike WriteConsoleW(), write() depends\n\t * on the suitability of the console output code page.  Since we put\n\t * stderr into binary mode in SubPostmasterMain(), write() skips the\n\t * necessary translation anyway.\n\t *\n\t * WriteConsoleW() will fail if stderr is redirected, so just fall through\n\t * to writing unconverted to the logfile in this case.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\t!redirection_done &&\n\t\tCurrentMemoryContext != NULL)\n\t{\n\t\tWCHAR\t   *utf16;\n\t\tint\t\t\tutf16len;\n\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, &utf16len);\n\t\tif (utf16 != NULL)\n\t\t{\n\t\t\tHANDLE\t\tstdHandle;\n\t\t\tDWORD\t\twritten;\n\n\t\t\tstdHandle = GetStdHandle(STD_ERROR_HANDLE);\n\t\t\tif (WriteConsoleW(stdHandle, utf16, utf16len, &written, NULL))\n\t\t\t{\n\t\t\t\tpfree(utf16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In case WriteConsoleW() failed, fall back to writing the\n\t\t\t * message unconverted.\n\t\t\t */\n\t\t\tpfree(utf16);\n\t\t}\n\t}\n#else\n\n\t/*\n\t * Conversion on non-win32 platforms is not implemented yet. It requires\n\t * non-throw version of pg_do_encoding_conversion(), that converts\n\t * unconvertable characters to '?' without errors.\n\t */\n#endif\n\n\t/*\n\t * We ignore any error from write() here.  We have no useful way to report\n\t * it ... certainly whining on stderr isn't likely to be productive.\n\t */\n\trc = write(fileno(stderr), line, len);\n\t(void) rc;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool redirection_done;",
      "static void write_console(const char *line, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fileno(stderr)",
            "line",
            "len"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stderr"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "pg_filenode_relation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/dbsize.c",
          "lines": "919-932",
          "snippet": "Datum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/relmapper.h\"",
            "#include \"utils/relfilenodemap.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/numeric.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/acl.h\"",
            "#include \"storage/fd.h\"",
            "#include \"miscadmin.h\"",
            "#include \"commands/tablespace.h\"",
            "#include \"commands/dbcommands.h\"",
            "#include \"catalog/pg_tablespace.h\"",
            "#include \"catalog/pg_authid.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"catalog/catalog.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/heapam.h\"",
            "#include <sys/stat.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/relmapper.h\"\n#include \"utils/relfilenodemap.h\"\n#include \"utils/rel.h\"\n#include \"utils/numeric.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"storage/fd.h\"\n#include \"miscadmin.h\"\n#include \"commands/tablespace.h\"\n#include \"commands/dbcommands.h\"\n#include \"catalog/pg_tablespace.h\"\n#include \"catalog/pg_authid.h\"\n#include \"catalog/namespace.h\"\n#include \"catalog/catalog.h\"\n#include \"access/htup_details.h\"\n#include \"access/heapam.h\"\n#include <sys/stat.h>\n#include \"postgres.h\"\n\nDatum\npg_filenode_relation(PG_FUNCTION_ARGS)\n{\n\tOid\t\t\treltablespace = PG_GETARG_OID(0);\n\tOid\t\t\trelfilenode = PG_GETARG_OID(1);\n\tOid\t\t\theaprel = InvalidOid;\n\n\theaprel = RelidByRelfilenode(reltablespace, relfilenode);\n\n\tif (!OidIsValid(heaprel))\n\t\tPG_RETURN_NULL();\n\telse\n\t\tPG_RETURN_OID(heaprel);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "utf16"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteConsoleW",
          "args": [
            "stdHandle",
            "utf16",
            "utf16len",
            "&written",
            "NULL"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetStdHandle",
          "args": [
            "STD_ERROR_HANDLE"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgwin32_message_to_UTF16",
          "args": [
            "line",
            "len",
            "&utf16len"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "pgwin32_message_to_UTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1046-1103",
          "snippet": "WCHAR *\npgwin32_message_to_UTF16(const char *str, int len, int *utf16len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\tdstlen;\n\tUINT\t\tcodepage;\n\n\tcodepage = pg_enc2name_tbl[GetMessageEncoding()].codepage;\n\n\t/*\n\t * Use MultiByteToWideChar directly if there is a corresponding codepage,\n\t * or double conversion through UTF8 if not.  Double conversion is needed,\n\t * for example, in an ENCODING=LATIN8, LC_CTYPE=C database.\n\t */\n\tif (codepage != 0)\n\t{\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(codepage, 0, str, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\t}\n\telse\n\t{\n\t\tchar\t   *utf8;\n\n\t\t/*\n\t\t * XXX pg_do_encoding_conversion() requires a transaction.  In the\n\t\t * absence of one, hope for the input to be valid UTF8.\n\t\t */\n\t\tif (IsTransactionState())\n\t\t{\n\t\t\tutf8 = (char *) pg_do_encoding_conversion((unsigned char *) str,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  GetMessageEncoding(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PG_UTF8);\n\t\t\tif (utf8 != str)\n\t\t\t\tlen = strlen(utf8);\n\t\t}\n\t\telse\n\t\t\tutf8 = (char *) str;\n\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(CP_UTF8, 0, utf8, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\n\t\tif (utf8 != str)\n\t\t\tpfree(utf8);\n\t}\n\n\tif (dstlen == 0 && len > 0)\n\t{\n\t\tpfree(utf16);\n\t\treturn NULL;\t\t\t/* error */\n\t}\n\n\tif (utf16len)\n\t\t*utf16len = dstlen;\n\treturn utf16;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nWCHAR *\npgwin32_message_to_UTF16(const char *str, int len, int *utf16len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\tdstlen;\n\tUINT\t\tcodepage;\n\n\tcodepage = pg_enc2name_tbl[GetMessageEncoding()].codepage;\n\n\t/*\n\t * Use MultiByteToWideChar directly if there is a corresponding codepage,\n\t * or double conversion through UTF8 if not.  Double conversion is needed,\n\t * for example, in an ENCODING=LATIN8, LC_CTYPE=C database.\n\t */\n\tif (codepage != 0)\n\t{\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(codepage, 0, str, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\t}\n\telse\n\t{\n\t\tchar\t   *utf8;\n\n\t\t/*\n\t\t * XXX pg_do_encoding_conversion() requires a transaction.  In the\n\t\t * absence of one, hope for the input to be valid UTF8.\n\t\t */\n\t\tif (IsTransactionState())\n\t\t{\n\t\t\tutf8 = (char *) pg_do_encoding_conversion((unsigned char *) str,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  GetMessageEncoding(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PG_UTF8);\n\t\t\tif (utf8 != str)\n\t\t\t\tlen = strlen(utf8);\n\t\t}\n\t\telse\n\t\t\tutf8 = (char *) str;\n\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(CP_UTF8, 0, utf8, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\n\t\tif (utf8 != str)\n\t\t\tpfree(utf8);\n\t}\n\n\tif (dstlen == 0 && len > 0)\n\t{\n\t\tpfree(utf16);\n\t\treturn NULL;\t\t\t/* error */\n\t}\n\n\tif (utf16len)\n\t\t*utf16len = dstlen;\n\treturn utf16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_error_recursion_trouble",
          "args": [],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "in_error_recursion_trouble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "195-200",
          "snippet": "bool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trecursion_depth = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\trecursion_depth = 0;\n\nbool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nextern bool redirection_done;\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_console(const char *line, int len)\n{\n\tint\t\t\trc;\n\n#ifdef WIN32\n\n\t/*\n\t * Try to convert the message to UTF16 and write it with WriteConsoleW().\n\t * Fall back on write() if anything fails.\n\t *\n\t * In contrast to write_eventlog(), don't skip straight to write() based\n\t * on the applicable encodings.  Unlike WriteConsoleW(), write() depends\n\t * on the suitability of the console output code page.  Since we put\n\t * stderr into binary mode in SubPostmasterMain(), write() skips the\n\t * necessary translation anyway.\n\t *\n\t * WriteConsoleW() will fail if stderr is redirected, so just fall through\n\t * to writing unconverted to the logfile in this case.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\t!redirection_done &&\n\t\tCurrentMemoryContext != NULL)\n\t{\n\t\tWCHAR\t   *utf16;\n\t\tint\t\t\tutf16len;\n\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, &utf16len);\n\t\tif (utf16 != NULL)\n\t\t{\n\t\t\tHANDLE\t\tstdHandle;\n\t\t\tDWORD\t\twritten;\n\n\t\t\tstdHandle = GetStdHandle(STD_ERROR_HANDLE);\n\t\t\tif (WriteConsoleW(stdHandle, utf16, utf16len, &written, NULL))\n\t\t\t{\n\t\t\t\tpfree(utf16);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * In case WriteConsoleW() failed, fall back to writing the\n\t\t\t * message unconverted.\n\t\t\t */\n\t\t\tpfree(utf16);\n\t\t}\n\t}\n#else\n\n\t/*\n\t * Conversion on non-win32 platforms is not implemented yet. It requires\n\t * non-throw version of pg_do_encoding_conversion(), that converts\n\t * unconvertable characters to '?' without errors.\n\t */\n#endif\n\n\t/*\n\t * We ignore any error from write() here.  We have no useful way to report\n\t * it ... certainly whining on stderr isn't likely to be productive.\n\t */\n\trc = write(fileno(stderr), line, len);\n\t(void) rc;\n}"
  },
  {
    "function_name": "write_eventlog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2065-2151",
    "snippet": "static void\nwrite_eventlog(int level, const char *line, int len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\tstatic HANDLE evtHandle = INVALID_HANDLE_VALUE;\n\n\tif (evtHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tevtHandle = RegisterEventSource(NULL,\n\t\t\t\t\t\t\t\t\t\tevent_source ? event_source : DEFAULT_EVENT_SOURCE);\n\t\tif (evtHandle == NULL)\n\t\t{\n\t\t\tevtHandle = INVALID_HANDLE_VALUE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (level)\n\t{\n\t\tcase DEBUG5:\n\t\tcase DEBUG4:\n\t\tcase DEBUG3:\n\t\tcase DEBUG2:\n\t\tcase DEBUG1:\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\tcase INFO:\n\t\tcase NOTICE:\n\t\t\teventlevel = EVENTLOG_INFORMATION_TYPE;\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\teventlevel = EVENTLOG_WARNING_TYPE;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\tcase FATAL:\n\t\tcase PANIC:\n\t\tdefault:\n\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If message character encoding matches the encoding expected by\n\t * ReportEventA(), call it to avoid the hazards of conversion.  Otherwise,\n\t * try to convert the message to UTF16 and write it with ReportEventW().\n\t * Fall back on ReportEventA() if conversion failed.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t *\n\t * Also verify that we are not on our way into error recursion trouble due\n\t * to error messages thrown deep inside pgwin32_message_to_UTF16().\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\tCurrentMemoryContext != NULL &&\n\t\tGetMessageEncoding() != GetACPEncoding())\n\t{\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, NULL);\n\t\tif (utf16)\n\t\t{\n\t\t\tReportEventW(evtHandle,\n\t\t\t\t\t\t eventlevel,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t 0,\t\t/* All events are Id 0 */\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 1,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t (LPCWSTR *) &utf16,\n\t\t\t\t\t\t NULL);\n\t\t\t/* XXX Try ReportEventA() when ReportEventW() fails? */\n\n\t\t\tpfree(utf16);\n\t\t\treturn;\n\t\t}\n\t}\n\tReportEventA(evtHandle,\n\t\t\t\t eventlevel,\n\t\t\t\t 0,\n\t\t\t\t 0,\t\t\t\t/* All events are Id 0 */\n\t\t\t\t NULL,\n\t\t\t\t 1,\n\t\t\t\t 0,\n\t\t\t\t &line,\n\t\t\t\t NULL);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void write_console(const char *line, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReportEventA",
          "args": [
            "evtHandle",
            "eventlevel",
            "0",
            "0",
            "/* All events are Id 0 */NULL",
            "1",
            "0",
            "&line",
            "NULL"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "utf16"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReportEventW",
          "args": [
            "evtHandle",
            "eventlevel",
            "0",
            "0",
            "/* All events are Id 0 */NULL",
            "1",
            "0",
            "(LPCWSTR *) &utf16",
            "NULL"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgwin32_message_to_UTF16",
          "args": [
            "line",
            "len",
            "NULL"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "pgwin32_message_to_UTF16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1046-1103",
          "snippet": "WCHAR *\npgwin32_message_to_UTF16(const char *str, int len, int *utf16len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\tdstlen;\n\tUINT\t\tcodepage;\n\n\tcodepage = pg_enc2name_tbl[GetMessageEncoding()].codepage;\n\n\t/*\n\t * Use MultiByteToWideChar directly if there is a corresponding codepage,\n\t * or double conversion through UTF8 if not.  Double conversion is needed,\n\t * for example, in an ENCODING=LATIN8, LC_CTYPE=C database.\n\t */\n\tif (codepage != 0)\n\t{\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(codepage, 0, str, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\t}\n\telse\n\t{\n\t\tchar\t   *utf8;\n\n\t\t/*\n\t\t * XXX pg_do_encoding_conversion() requires a transaction.  In the\n\t\t * absence of one, hope for the input to be valid UTF8.\n\t\t */\n\t\tif (IsTransactionState())\n\t\t{\n\t\t\tutf8 = (char *) pg_do_encoding_conversion((unsigned char *) str,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  GetMessageEncoding(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PG_UTF8);\n\t\t\tif (utf8 != str)\n\t\t\t\tlen = strlen(utf8);\n\t\t}\n\t\telse\n\t\t\tutf8 = (char *) str;\n\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(CP_UTF8, 0, utf8, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\n\t\tif (utf8 != str)\n\t\t\tpfree(utf8);\n\t}\n\n\tif (dstlen == 0 && len > 0)\n\t{\n\t\tpfree(utf16);\n\t\treturn NULL;\t\t\t/* error */\n\t}\n\n\tif (utf16len)\n\t\t*utf16len = dstlen;\n\treturn utf16;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nWCHAR *\npgwin32_message_to_UTF16(const char *str, int len, int *utf16len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\tdstlen;\n\tUINT\t\tcodepage;\n\n\tcodepage = pg_enc2name_tbl[GetMessageEncoding()].codepage;\n\n\t/*\n\t * Use MultiByteToWideChar directly if there is a corresponding codepage,\n\t * or double conversion through UTF8 if not.  Double conversion is needed,\n\t * for example, in an ENCODING=LATIN8, LC_CTYPE=C database.\n\t */\n\tif (codepage != 0)\n\t{\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(codepage, 0, str, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\t}\n\telse\n\t{\n\t\tchar\t   *utf8;\n\n\t\t/*\n\t\t * XXX pg_do_encoding_conversion() requires a transaction.  In the\n\t\t * absence of one, hope for the input to be valid UTF8.\n\t\t */\n\t\tif (IsTransactionState())\n\t\t{\n\t\t\tutf8 = (char *) pg_do_encoding_conversion((unsigned char *) str,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  GetMessageEncoding(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  PG_UTF8);\n\t\t\tif (utf8 != str)\n\t\t\t\tlen = strlen(utf8);\n\t\t}\n\t\telse\n\t\t\tutf8 = (char *) str;\n\n\t\tutf16 = (WCHAR *) palloc(sizeof(WCHAR) * (len + 1));\n\t\tdstlen = MultiByteToWideChar(CP_UTF8, 0, utf8, len, utf16, len);\n\t\tutf16[dstlen] = (WCHAR) 0;\n\n\t\tif (utf8 != str)\n\t\t\tpfree(utf8);\n\t}\n\n\tif (dstlen == 0 && len > 0)\n\t{\n\t\tpfree(utf16);\n\t\treturn NULL;\t\t\t/* error */\n\t}\n\n\tif (utf16len)\n\t\t*utf16len = dstlen;\n\treturn utf16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetACPEncoding",
          "args": [],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "GetACPEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2051-2060",
          "snippet": "static int\nGetACPEncoding(void)\n{\n\tstatic int\tencoding = -2;\n\n\tif (encoding == -2)\n\t\tencoding = pg_codepage_to_encoding(GetACP());\n\n\treturn encoding;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\nGetACPEncoding(void)\n{\n\tstatic int\tencoding = -2;\n\n\tif (encoding == -2)\n\t\tencoding = pg_codepage_to_encoding(GetACP());\n\n\treturn encoding;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetMessageEncoding",
          "args": [],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "GetMessageEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "1033-1037",
          "snippet": "int\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *MessageEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\n\nint\nGetMessageEncoding(void)\n{\n\treturn MessageEncoding->encoding;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_error_recursion_trouble",
          "args": [],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "in_error_recursion_trouble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "195-200",
          "snippet": "bool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trecursion_depth = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\trecursion_depth = 0;\n\nbool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RegisterEventSource",
          "args": [
            "NULL",
            "event_source ? event_source : DEFAULT_EVENT_SOURCE"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_eventlog(int level, const char *line, int len)\n{\n\tWCHAR\t   *utf16;\n\tint\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\tstatic HANDLE evtHandle = INVALID_HANDLE_VALUE;\n\n\tif (evtHandle == INVALID_HANDLE_VALUE)\n\t{\n\t\tevtHandle = RegisterEventSource(NULL,\n\t\t\t\t\t\t\t\t\t\tevent_source ? event_source : DEFAULT_EVENT_SOURCE);\n\t\tif (evtHandle == NULL)\n\t\t{\n\t\t\tevtHandle = INVALID_HANDLE_VALUE;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tswitch (level)\n\t{\n\t\tcase DEBUG5:\n\t\tcase DEBUG4:\n\t\tcase DEBUG3:\n\t\tcase DEBUG2:\n\t\tcase DEBUG1:\n\t\tcase LOG:\n\t\tcase LOG_SERVER_ONLY:\n\t\tcase INFO:\n\t\tcase NOTICE:\n\t\t\teventlevel = EVENTLOG_INFORMATION_TYPE;\n\t\t\tbreak;\n\t\tcase WARNING:\n\t\t\teventlevel = EVENTLOG_WARNING_TYPE;\n\t\t\tbreak;\n\t\tcase ERROR:\n\t\tcase FATAL:\n\t\tcase PANIC:\n\t\tdefault:\n\t\t\teventlevel = EVENTLOG_ERROR_TYPE;\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If message character encoding matches the encoding expected by\n\t * ReportEventA(), call it to avoid the hazards of conversion.  Otherwise,\n\t * try to convert the message to UTF16 and write it with ReportEventW().\n\t * Fall back on ReportEventA() if conversion failed.\n\t *\n\t * Since we palloc the structure required for conversion, also fall\n\t * through to writing unconverted if we have not yet set up\n\t * CurrentMemoryContext.\n\t *\n\t * Also verify that we are not on our way into error recursion trouble due\n\t * to error messages thrown deep inside pgwin32_message_to_UTF16().\n\t */\n\tif (!in_error_recursion_trouble() &&\n\t\tCurrentMemoryContext != NULL &&\n\t\tGetMessageEncoding() != GetACPEncoding())\n\t{\n\t\tutf16 = pgwin32_message_to_UTF16(line, len, NULL);\n\t\tif (utf16)\n\t\t{\n\t\t\tReportEventW(evtHandle,\n\t\t\t\t\t\t eventlevel,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t 0,\t\t/* All events are Id 0 */\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t 1,\n\t\t\t\t\t\t 0,\n\t\t\t\t\t\t (LPCWSTR *) &utf16,\n\t\t\t\t\t\t NULL);\n\t\t\t/* XXX Try ReportEventA() when ReportEventW() fails? */\n\n\t\t\tpfree(utf16);\n\t\t\treturn;\n\t\t}\n\t}\n\tReportEventA(evtHandle,\n\t\t\t\t eventlevel,\n\t\t\t\t 0,\n\t\t\t\t 0,\t\t\t\t/* All events are Id 0 */\n\t\t\t\t NULL,\n\t\t\t\t 1,\n\t\t\t\t 0,\n\t\t\t\t &line,\n\t\t\t\t NULL);\n}"
  },
  {
    "function_name": "GetACPEncoding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "2051-2060",
    "snippet": "static int\nGetACPEncoding(void)\n{\n\tstatic int\tencoding = -2;\n\n\tif (encoding == -2)\n\t\tencoding = pg_codepage_to_encoding(GetACP());\n\n\treturn encoding;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pg_codepage_to_encoding",
          "args": [
            "GetACP()"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetACP",
          "args": [],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "GetACPEncoding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2051-2060",
          "snippet": "static int\nGetACPEncoding(void)\n{\n\tstatic int\tencoding = -2;\n\n\tif (encoding == -2)\n\t\tencoding = pg_codepage_to_encoding(GetACP());\n\n\treturn encoding;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\nGetACPEncoding(void)\n{\n\tstatic int\tencoding = -2;\n\n\tif (encoding == -2)\n\t\tencoding = pg_codepage_to_encoding(GetACP());\n\n\treturn encoding;\n}"
  },
  {
    "function_name": "write_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1939-2042",
    "snippet": "static void\nwrite_syslog(int level, const char *line)\n{\n\tstatic unsigned long seq = 0;\n\n\tint\t\t\tlen;\n\tconst char *nlpos;\n\n\t/* Open syslog connection if not done yet */\n\tif (!openlog_done)\n\t{\n\t\topenlog(syslog_ident ? syslog_ident : \"postgres\",\n\t\t\t\tLOG_PID | LOG_NDELAY | LOG_NOWAIT,\n\t\t\t\tsyslog_facility);\n\t\topenlog_done = true;\n\t}\n\n\t/*\n\t * We add a sequence number to each log message to suppress \"same\"\n\t * messages.\n\t */\n\tseq++;\n\n\t/*\n\t * Our problem here is that many syslog implementations don't handle long\n\t * messages in an acceptable manner. While this function doesn't help that\n\t * fact, it does work around by splitting up messages into smaller pieces.\n\t *\n\t * We divide into multiple syslog() calls if message is too long or if the\n\t * message contains embedded newline(s).\n\t */\n\tlen = strlen(line);\n\tnlpos = strchr(line, '\\n');\n\tif (syslog_split_messages && (len > PG_SYSLOG_LIMIT || nlpos != NULL))\n\t{\n\t\tint\t\t\tchunk_nr = 0;\n\n\t\twhile (len > 0)\n\t\t{\n\t\t\tchar\t\tbuf[PG_SYSLOG_LIMIT + 1];\n\t\t\tint\t\t\tbuflen;\n\t\t\tint\t\t\ti;\n\n\t\t\t/* if we start at a newline, move ahead one char */\n\t\t\tif (line[0] == '\\n')\n\t\t\t{\n\t\t\t\tline++;\n\t\t\t\tlen--;\n\t\t\t\t/* we need to recompute the next newline's position, too */\n\t\t\t\tnlpos = strchr(line, '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* copy one line, or as much as will fit, to buf */\n\t\t\tif (nlpos != NULL)\n\t\t\t\tbuflen = nlpos - line;\n\t\t\telse\n\t\t\t\tbuflen = len;\n\t\t\tbuflen = Min(buflen, PG_SYSLOG_LIMIT);\n\t\t\tmemcpy(buf, line, buflen);\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* trim to multibyte letter boundary */\n\t\t\tbuflen = pg_mbcliplen(buf, buflen, buflen);\n\t\t\tif (buflen <= 0)\n\t\t\t\treturn;\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* already word boundary? */\n\t\t\tif (line[buflen] != '\\0' &&\n\t\t\t\t!isspace((unsigned char) line[buflen]))\n\t\t\t{\n\t\t\t\t/* try to divide at word boundary */\n\t\t\t\ti = buflen - 1;\n\t\t\t\twhile (i > 0 && !isspace((unsigned char) buf[i]))\n\t\t\t\t\ti--;\n\n\t\t\t\tif (i > 0)\t\t/* else couldn't divide word boundary */\n\t\t\t\t{\n\t\t\t\t\tbuflen = i;\n\t\t\t\t\tbuf[i] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunk_nr++;\n\n\t\t\tif (syslog_sequence_numbers)\n\t\t\t\tsyslog(level, \"[%lu-%d] %s\", seq, chunk_nr, buf);\n\t\t\telse\n\t\t\t\tsyslog(level, \"[%d] %s\", chunk_nr, buf);\n\n\t\t\tline += buflen;\n\t\t\tlen -= buflen;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* message short enough */\n\t\tif (syslog_sequence_numbers)\n\t\t\tsyslog(level, \"[%lu] %s\", seq, line);\n\t\telse\n\t\t\tsyslog(level, \"%s\", line);\n\t}\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define PG_SYSLOG_LIMIT 900"
    ],
    "globals_used": [
      "bool\t\tsyslog_sequence_numbers = true;",
      "bool\t\tsyslog_split_messages = true;",
      "static void write_console(const char *line, int len);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "level",
            "\"%s\"",
            "line"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "level",
            "\"[%lu] %s\"",
            "seq",
            "line"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "level",
            "\"[%d] %s\"",
            "chunk_nr",
            "buf"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syslog",
          "args": [
            "level",
            "\"[%lu-%d] %s\"",
            "seq",
            "chunk_nr",
            "buf"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "(unsigned char) buf[i]"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "array_isspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/arrayfuncs.c",
          "lines": "431-442",
          "snippet": "static bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/arrayaccess.h\"",
            "#include \"utils/array.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"funcapi.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include <math.h>",
            "#include <float.h>\t\t\t\t/* for _isnan */",
            "#include <ctype.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool array_isspace(char ch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/datum.h\"\n#include \"utils/builtins.h\"\n#include \"utils/arrayaccess.h\"\n#include \"utils/array.h\"\n#include \"libpq/pqformat.h\"\n#include \"funcapi.h\"\n#include \"catalog/pg_type.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include <math.h>\n#include <float.h>\t\t\t\t/* for _isnan */\n#include <ctype.h>\n#include \"postgres.h\"\n\nstatic bool array_isspace(char ch);\n\nstatic bool\narray_isspace(char ch)\n{\n\tif (ch == ' ' ||\n\t\tch == '\\t' ||\n\t\tch == '\\n' ||\n\t\tch == '\\r' ||\n\t\tch == '\\v' ||\n\t\tch == '\\f')\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pg_mbcliplen",
          "args": [
            "buf",
            "buflen",
            "buflen"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "pg_mbcliplen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mb/mbutils.c",
          "lines": "819-824",
          "snippet": "int\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}",
          "includes": [
            "#include \"utils/syscache.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"access/xact.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];",
            "static int\tcliplen(const char *str, int len, int limit);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/syscache.h\"\n#include \"utils/memutils.h\"\n#include \"utils/builtins.h\"\n#include \"mb/pg_wchar.h\"\n#include \"catalog/namespace.h\"\n#include \"access/xact.h\"\n#include \"postgres.h\"\n\nstatic const pg_enc2name *DatabaseEncoding = &pg_enc2name_tbl[PG_SQL_ASCII];\nstatic int\tcliplen(const char *str, int len, int limit);\n\nint\npg_mbcliplen(const char *mbstr, int len, int limit)\n{\n\treturn pg_encoding_mbcliplen(DatabaseEncoding->encoding, mbstr,\n\t\t\t\t\t\t\t\t len, limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "line",
            "buflen"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Min",
          "args": [
            "buflen",
            "PG_SYSLOG_LIMIT"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "'\\n'"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "line"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "calcstrlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/tsquery_cleanup.c",
          "lines": "361-380",
          "snippet": "static int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}",
          "includes": [
            "#include \"miscadmin.h\"",
            "#include \"tsearch/ts_utils.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"miscadmin.h\"\n#include \"tsearch/ts_utils.h\"\n#include \"postgres.h\"\n\nstatic int32\ncalcstrlen(NODE *node)\n{\n\tint32\t\tsize = 0;\n\n\tif (node->valnode->type == QI_VAL)\n\t{\n\t\tsize = node->valnode->qoperand.length + 1;\n\t}\n\telse\n\t{\n\t\tAssert(node->valnode->type == QI_OPR);\n\n\t\tsize = calcstrlen(node->right);\n\t\tif (node->valnode->qoperator.oper != OP_NOT)\n\t\t\tsize += calcstrlen(node->left);\n\t}\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "syslog_ident ? syslog_ident : \"postgres\"",
            "LOG_PID | LOG_NDELAY | LOG_NOWAIT",
            "syslog_facility"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define PG_SYSLOG_LIMIT 900\n\nbool\t\tsyslog_sequence_numbers = true;\nbool\t\tsyslog_split_messages = true;\nstatic void write_console(const char *line, int len);\n\nstatic void\nwrite_syslog(int level, const char *line)\n{\n\tstatic unsigned long seq = 0;\n\n\tint\t\t\tlen;\n\tconst char *nlpos;\n\n\t/* Open syslog connection if not done yet */\n\tif (!openlog_done)\n\t{\n\t\topenlog(syslog_ident ? syslog_ident : \"postgres\",\n\t\t\t\tLOG_PID | LOG_NDELAY | LOG_NOWAIT,\n\t\t\t\tsyslog_facility);\n\t\topenlog_done = true;\n\t}\n\n\t/*\n\t * We add a sequence number to each log message to suppress \"same\"\n\t * messages.\n\t */\n\tseq++;\n\n\t/*\n\t * Our problem here is that many syslog implementations don't handle long\n\t * messages in an acceptable manner. While this function doesn't help that\n\t * fact, it does work around by splitting up messages into smaller pieces.\n\t *\n\t * We divide into multiple syslog() calls if message is too long or if the\n\t * message contains embedded newline(s).\n\t */\n\tlen = strlen(line);\n\tnlpos = strchr(line, '\\n');\n\tif (syslog_split_messages && (len > PG_SYSLOG_LIMIT || nlpos != NULL))\n\t{\n\t\tint\t\t\tchunk_nr = 0;\n\n\t\twhile (len > 0)\n\t\t{\n\t\t\tchar\t\tbuf[PG_SYSLOG_LIMIT + 1];\n\t\t\tint\t\t\tbuflen;\n\t\t\tint\t\t\ti;\n\n\t\t\t/* if we start at a newline, move ahead one char */\n\t\t\tif (line[0] == '\\n')\n\t\t\t{\n\t\t\t\tline++;\n\t\t\t\tlen--;\n\t\t\t\t/* we need to recompute the next newline's position, too */\n\t\t\t\tnlpos = strchr(line, '\\n');\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* copy one line, or as much as will fit, to buf */\n\t\t\tif (nlpos != NULL)\n\t\t\t\tbuflen = nlpos - line;\n\t\t\telse\n\t\t\t\tbuflen = len;\n\t\t\tbuflen = Min(buflen, PG_SYSLOG_LIMIT);\n\t\t\tmemcpy(buf, line, buflen);\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* trim to multibyte letter boundary */\n\t\t\tbuflen = pg_mbcliplen(buf, buflen, buflen);\n\t\t\tif (buflen <= 0)\n\t\t\t\treturn;\n\t\t\tbuf[buflen] = '\\0';\n\n\t\t\t/* already word boundary? */\n\t\t\tif (line[buflen] != '\\0' &&\n\t\t\t\t!isspace((unsigned char) line[buflen]))\n\t\t\t{\n\t\t\t\t/* try to divide at word boundary */\n\t\t\t\ti = buflen - 1;\n\t\t\t\twhile (i > 0 && !isspace((unsigned char) buf[i]))\n\t\t\t\t\ti--;\n\n\t\t\t\tif (i > 0)\t\t/* else couldn't divide word boundary */\n\t\t\t\t{\n\t\t\t\t\tbuflen = i;\n\t\t\t\t\tbuf[i] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchunk_nr++;\n\n\t\t\tif (syslog_sequence_numbers)\n\t\t\t\tsyslog(level, \"[%lu-%d] %s\", seq, chunk_nr, buf);\n\t\t\telse\n\t\t\t\tsyslog(level, \"[%d] %s\", chunk_nr, buf);\n\n\t\t\tline += buflen;\n\t\t\tlen -= buflen;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* message short enough */\n\t\tif (syslog_sequence_numbers)\n\t\t\tsyslog(level, \"[%lu] %s\", seq, line);\n\t\telse\n\t\t\tsyslog(level, \"%s\", line);\n\t}\n}"
  },
  {
    "function_name": "set_syslog_parameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1906-1933",
    "snippet": "void\nset_syslog_parameters(const char *ident, int facility)\n{\n\t/*\n\t * guc.c is likely to call us repeatedly with same parameters, so don't\n\t * thrash the syslog connection unnecessarily.  Also, we do not re-open\n\t * the connection until needed, since this routine will get called whether\n\t * or not Log_destination actually mentions syslog.\n\t *\n\t * Note that we make our own copy of the ident string rather than relying\n\t * on guc.c's.  This may be overly paranoid, but it ensures that we cannot\n\t * accidentally free a string that syslog is still using.\n\t */\n\tif (syslog_ident == NULL || strcmp(syslog_ident, ident) != 0 ||\n\t\tsyslog_facility != facility)\n\t{\n\t\tif (openlog_done)\n\t\t{\n\t\t\tcloselog();\n\t\t\topenlog_done = false;\n\t\t}\n\t\tif (syslog_ident)\n\t\t\tfree(syslog_ident);\n\t\tsyslog_ident = strdup(ident);\n\t\t/* if the strdup fails, we will cope in write_syslog() */\n\t\tsyslog_facility = facility;\n\t}\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int\t\t\tLog_destination = LOG_DESTINATION_STDERR;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "ident"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "syslog_ident"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "free_attstatsslot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/cache/lsyscache.c",
          "lines": "3052-3064",
          "snippet": "void\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}",
          "includes": [
            "#include \"utils/typcache.h\"",
            "#include \"utils/syscache.h\"",
            "#include \"utils/rel.h\"",
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/fmgroids.h\"",
            "#include \"utils/datum.h\"",
            "#include \"utils/catcache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"nodes/makefuncs.h\"",
            "#include \"miscadmin.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/pg_transform.h\"",
            "#include \"catalog/pg_statistic.h\"",
            "#include \"catalog/pg_range.h\"",
            "#include \"catalog/pg_proc.h\"",
            "#include \"catalog/pg_operator.h\"",
            "#include \"catalog/pg_opclass.h\"",
            "#include \"catalog/pg_namespace.h\"",
            "#include \"catalog/pg_language.h\"",
            "#include \"catalog/pg_constraint.h\"",
            "#include \"catalog/pg_collation.h\"",
            "#include \"catalog/pg_amproc.h\"",
            "#include \"catalog/pg_amop.h\"",
            "#include \"catalog/pg_am.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"bootstrap/bootstrap.h\"",
            "#include \"access/nbtree.h\"",
            "#include \"access/htup_details.h\"",
            "#include \"access/hash.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/typcache.h\"\n#include \"utils/syscache.h\"\n#include \"utils/rel.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/catcache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_transform.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_range.h\"\n#include \"catalog/pg_proc.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_opclass.h\"\n#include \"catalog/pg_namespace.h\"\n#include \"catalog/pg_language.h\"\n#include \"catalog/pg_constraint.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_amproc.h\"\n#include \"catalog/pg_amop.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/namespace.h\"\n#include \"bootstrap/bootstrap.h\"\n#include \"access/nbtree.h\"\n#include \"access/htup_details.h\"\n#include \"access/hash.h\"\n#include \"postgres.h\"\n\nvoid\nfree_attstatsslot(AttStatsSlot *sslot)\n{\n\t/* The values[] array was separately palloc'd by deconstruct_array */\n\tif (sslot->values)\n\t\tpfree(sslot->values);\n\t/* The numbers[] array points into numbers_arr, do not pfree it */\n\t/* Free the detoasted array objects, if any */\n\tif (sslot->values_arr)\n\t\tpfree(sslot->values_arr);\n\tif (sslot->numbers_arr)\n\t\tpfree(sslot->numbers_arr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "closelog",
          "args": [],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "syslog_ident",
            "ident"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "namestrcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/name.c",
          "lines": "246-256",
          "snippet": "int\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}",
          "includes": [
            "#include \"utils/lsyscache.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"utils/array.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"catalog/pg_type.h\"",
            "#include \"catalog/namespace.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/lsyscache.h\"\n#include \"utils/builtins.h\"\n#include \"utils/array.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/namespace.h\"\n#include \"postgres.h\"\n\nint\nnamestrcmp(Name name, const char *str)\n{\n\tif (!name && !str)\n\t\treturn 0;\n\tif (!name)\n\t\treturn -1;\t\t\t\t/* NULL < anything */\n\tif (!str)\n\t\treturn 1;\t\t\t\t/* NULL < anything */\n\treturn strncmp(NameStr(*name), str, NAMEDATALEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nint\t\t\tLog_destination = LOG_DESTINATION_STDERR;\n\nvoid\nset_syslog_parameters(const char *ident, int facility)\n{\n\t/*\n\t * guc.c is likely to call us repeatedly with same parameters, so don't\n\t * thrash the syslog connection unnecessarily.  Also, we do not re-open\n\t * the connection until needed, since this routine will get called whether\n\t * or not Log_destination actually mentions syslog.\n\t *\n\t * Note that we make our own copy of the ident string rather than relying\n\t * on guc.c's.  This may be overly paranoid, but it ensures that we cannot\n\t * accidentally free a string that syslog is still using.\n\t */\n\tif (syslog_ident == NULL || strcmp(syslog_ident, ident) != 0 ||\n\t\tsyslog_facility != facility)\n\t{\n\t\tif (openlog_done)\n\t\t{\n\t\t\tcloselog();\n\t\t\topenlog_done = false;\n\t\t}\n\t\tif (syslog_ident)\n\t\t\tfree(syslog_ident);\n\t\tsyslog_ident = strdup(ident);\n\t\t/* if the strdup fails, we will cope in write_syslog() */\n\t\tsyslog_facility = facility;\n\t}\n}"
  },
  {
    "function_name": "DebugFileOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1855-1898",
    "snippet": "void\nDebugFileOpen(void)\n{\n\tint\t\t\tfd,\n\t\t\t\tistty;\n\n\tif (OutputFileName[0])\n\t{\n\t\t/*\n\t\t * A debug-output file name was given.\n\t\t *\n\t\t * Make sure we can write the file, and find out if it's a tty.\n\t\t */\n\t\tif ((fd = open(OutputFileName, O_CREAT | O_APPEND | O_WRONLY,\n\t\t\t\t\t   0666)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", OutputFileName)));\n\t\tistty = isatty(fd);\n\t\tclose(fd);\n\n\t\t/*\n\t\t * Redirect our stderr to the debug output file.\n\t\t */\n\t\tif (!freopen(OutputFileName, \"a\", stderr))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stderr: %m\",\n\t\t\t\t\t\t\tOutputFileName)));\n\n\t\t/*\n\t\t * If the file is a tty and we're running under the postmaster, try to\n\t\t * send stdout there as well (if it isn't a tty then stderr will block\n\t\t * out stdout, so we may as well let stdout go wherever it was going\n\t\t * before).\n\t\t */\n\t\tif (istty && IsUnderPostmaster)\n\t\t\tif (!freopen(OutputFileName, \"a\", stdout))\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stdout: %m\",\n\t\t\t\t\t\t\t\tOutputFileName)));\n\t}\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stdout: %m\",\n\t\t\t\t\t\t\t\tOutputFileName))"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg",
          "args": [
            "\"could not reopen file \\\"%s\\\" as stdout: %m\"",
            "OutputFileName"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "errcode_for_file_access",
          "args": [],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "errcode_for_file_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "595-655",
          "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "freopen",
          "args": [
            "OutputFileName",
            "\"a\"",
            "stdout"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stderr: %m\",\n\t\t\t\t\t\t\tOutputFileName))"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freopen",
          "args": [
            "OutputFileName",
            "\"a\"",
            "stderr"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "close_lb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/geo_ops.c",
          "lines": "3105-3119",
          "snippet": "Datum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}",
          "includes": [
            "#include \"utils/geo_decls.h\"",
            "#include \"utils/builtins.h\"",
            "#include \"miscadmin.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include <ctype.h>",
            "#include <float.h>",
            "#include <limits.h>",
            "#include <math.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static double box_ht(BOX *box);",
            "static double box_wd(BOX *box);",
            "static double box_ar(BOX *box);",
            "static void box_cn(Point *center, BOX *box);",
            "static Point *interpt_sl(LSEG *lseg, LINE *line);",
            "static bool has_interpt_sl(LSEG *lseg, LINE *line);",
            "static double dist_pl_internal(Point *pt, LINE *line);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/geo_decls.h\"\n#include \"utils/builtins.h\"\n#include \"miscadmin.h\"\n#include \"libpq/pqformat.h\"\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include \"postgres.h\"\n\nstatic double box_ht(BOX *box);\nstatic double box_wd(BOX *box);\nstatic double box_ar(BOX *box);\nstatic void box_cn(Point *center, BOX *box);\nstatic Point *interpt_sl(LSEG *lseg, LINE *line);\nstatic bool has_interpt_sl(LSEG *lseg, LINE *line);\nstatic double dist_pl_internal(Point *pt, LINE *line);\n\nDatum\nclose_lb(PG_FUNCTION_ARGS)\n{\n#ifdef NOT_USED\n\tLINE\t   *line = PG_GETARG_LINE_P(0);\n\tBOX\t\t   *box = PG_GETARG_BOX_P(1);\n#endif\n\n\t/* think about this one for a while */\n\tereport(ERROR,\n\t\t\t(errcode(ERRCODE_FEATURE_NOT_SUPPORTED),\n\t\t\t errmsg(\"function \\\"close_lb\\\" not implemented\")));\n\n\tPG_RETURN_NULL();\n}"
        }
      },
      {
        "call_info": {
          "callee": "isatty",
          "args": [
            "fd"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "FATAL",
            "(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", OutputFileName))"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "OutputFileName",
            "O_CREAT | O_APPEND | O_WRONLY",
            "0666"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nDebugFileOpen(void)\n{\n\tint\t\t\tfd,\n\t\t\t\tistty;\n\n\tif (OutputFileName[0])\n\t{\n\t\t/*\n\t\t * A debug-output file name was given.\n\t\t *\n\t\t * Make sure we can write the file, and find out if it's a tty.\n\t\t */\n\t\tif ((fd = open(OutputFileName, O_CREAT | O_APPEND | O_WRONLY,\n\t\t\t\t\t   0666)) < 0)\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not open file \\\"%s\\\": %m\", OutputFileName)));\n\t\tistty = isatty(fd);\n\t\tclose(fd);\n\n\t\t/*\n\t\t * Redirect our stderr to the debug output file.\n\t\t */\n\t\tif (!freopen(OutputFileName, \"a\", stderr))\n\t\t\tereport(FATAL,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stderr: %m\",\n\t\t\t\t\t\t\tOutputFileName)));\n\n\t\t/*\n\t\t * If the file is a tty and we're running under the postmaster, try to\n\t\t * send stdout there as well (if it isn't a tty then stderr will block\n\t\t * out stdout, so we may as well let stdout go wherever it was going\n\t\t * before).\n\t\t */\n\t\tif (istty && IsUnderPostmaster)\n\t\t\tif (!freopen(OutputFileName, \"a\", stdout))\n\t\t\t\tereport(FATAL,\n\t\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t\t errmsg(\"could not reopen file \\\"%s\\\" as stdout: %m\",\n\t\t\t\t\t\t\t\tOutputFileName)));\n\t}\n}"
  },
  {
    "function_name": "GetErrorContextStack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1788-1849",
    "snippet": "char *\nGetErrorContextStack(void)\n{\n\tErrorData  *edata;\n\tErrorContextCallback *econtext;\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\trecursion_depth++;\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/*\n\t * Things look good so far, so initialize our error frame\n\t */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\n\t/*\n\t * Set up assoc_context to be the caller's context, so any allocations\n\t * done (which will include edata->context) will use their context.\n\t */\n\tedata->assoc_context = CurrentMemoryContext;\n\n\t/*\n\t * Call any context callback functions to collect the context information\n\t * into edata->context.\n\t *\n\t * Errors occurring in callback functions should go through the regular\n\t * error handling code which should handle any recursive errors, though we\n\t * double-check above, just in case.\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * Clean ourselves off the stack, any allocations done should have been\n\t * using edata->assoc_context, which we set up earlier to be the caller's\n\t * context, so we're free to just remove our entry off the stack and\n\t * decrement recursion depth and exit.\n\t */\n\terrordata_stack_depth--;\n\trecursion_depth--;\n\n\t/*\n\t * Return a pointer to the string the caller asked for, which should have\n\t * been allocated in their context.\n\t */\n\treturn edata->context;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRORDATA_STACK_SIZE  5"
    ],
    "globals_used": [
      "ErrorContextCallback *error_context_stack = NULL;",
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "econtext->callback",
          "args": [
            "econtext->arg"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "edata",
            "0",
            "sizeof(ErrorData)"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "PANIC",
            "(errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\"))"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"ERRORDATA_STACK_SIZE exceeded\""
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define ERRORDATA_STACK_SIZE  5\n\nErrorContextCallback *error_context_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nchar *\nGetErrorContextStack(void)\n{\n\tErrorData  *edata;\n\tErrorContextCallback *econtext;\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\trecursion_depth++;\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/*\n\t * Things look good so far, so initialize our error frame\n\t */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\n\t/*\n\t * Set up assoc_context to be the caller's context, so any allocations\n\t * done (which will include edata->context) will use their context.\n\t */\n\tedata->assoc_context = CurrentMemoryContext;\n\n\t/*\n\t * Call any context callback functions to collect the context information\n\t * into edata->context.\n\t *\n\t * Errors occurring in callback functions should go through the regular\n\t * error handling code which should handle any recursive errors, though we\n\t * double-check above, just in case.\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * Clean ourselves off the stack, any allocations done should have been\n\t * using edata->assoc_context, which we set up earlier to be the caller's\n\t * context, so we're free to just remove our entry off the stack and\n\t * decrement recursion depth and exit.\n\t */\n\terrordata_stack_depth--;\n\trecursion_depth--;\n\n\t/*\n\t * Return a pointer to the string the caller asked for, which should have\n\t * been allocated in their context.\n\t */\n\treturn edata->context;\n}"
  },
  {
    "function_name": "pg_re_throw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1726-1774",
    "snippet": "void\npg_re_throw(void)\n{\n\t/* If possible, throw the error to the next outer setjmp handler */\n\tif (PG_exception_stack != NULL)\n\t\tsiglongjmp(*PG_exception_stack, 1);\n\telse\n\t{\n\t\t/*\n\t\t * If we get here, elog(ERROR) was thrown inside a PG_TRY block, which\n\t\t * we have now exited only to discover that there is no outer setjmp\n\t\t * handler to pass the error to.  Had the error been thrown outside\n\t\t * the block to begin with, we'd have promoted the error to FATAL, so\n\t\t * the correct behavior is to make it FATAL now; that is, emit it and\n\t\t * then call proc_exit.\n\t\t */\n\t\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t\tAssert(errordata_stack_depth >= 0);\n\t\tAssert(edata->elevel == ERROR);\n\t\tedata->elevel = FATAL;\n\n\t\t/*\n\t\t * At least in principle, the increase in severity could have changed\n\t\t * where-to-output decisions, so recalculate.  This should stay in\n\t\t * sync with errstart(), which see for comments.\n\t\t */\n\t\tif (IsPostmasterEnvironment)\n\t\t\tedata->output_to_server = is_log_level_output(FATAL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  log_min_messages);\n\t\telse\n\t\t\tedata->output_to_server = (FATAL >= log_min_messages);\n\t\tif (whereToSendOutput == DestRemote)\n\t\t\tedata->output_to_client = true;\n\n\t\t/*\n\t\t * We can use errfinish() for the rest, but we don't want it to call\n\t\t * any error context routines a second time.  Since we know we are\n\t\t * about to exit, it should be OK to just clear the context stack.\n\t\t */\n\t\terror_context_stack = NULL;\n\n\t\terrfinish(0);\n\t}\n\n\t/* Doesn't return ... */\n\tExceptionalCondition(\"pg_re_throw tried to return\", \"FailedAssertion\",\n\t\t\t\t\t\t __FILE__, __LINE__);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ErrorContextCallback *error_context_stack = NULL;",
      "sigjmp_buf *PG_exception_stack = NULL;",
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExceptionalCondition",
          "args": [
            "\"pg_re_throw tried to return\"",
            "\"FailedAssertion\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 1772
        },
        "resolved": true,
        "details": {
          "function_name": "ExceptionalCondition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/assert.c",
          "lines": "25-55",
          "snippet": "void\nExceptionalCondition(const char *conditionName,\n\t\t\t\t\t const char *errorType,\n\t\t\t\t\t const char *fileName,\n\t\t\t\t\t int lineNumber)\n{\n\tif (!PointerIsValid(conditionName)\n\t\t|| !PointerIsValid(fileName)\n\t\t|| !PointerIsValid(errorType))\n\t\twrite_stderr(\"TRAP: ExceptionalCondition: bad arguments\\n\");\n\telse\n\t{\n\t\twrite_stderr(\"TRAP: %s(\\\"%s\\\", File: \\\"%s\\\", Line: %d)\\n\",\n\t\t\t\t\t errorType, conditionName,\n\t\t\t\t\t fileName, lineNumber);\n\t}\n\n\t/* Usually this shouldn't be needed, but make sure the msg went out */\n\tfflush(stderr);\n\n#ifdef SLEEP_ON_ASSERT\n\n\t/*\n\t * It would be nice to use pg_usleep() here, but only does 2000 sec or 33\n\t * minutes, which seems too short.\n\t */\n\tsleep(1000000);\n#endif\n\n\tabort();\n}",
          "includes": [
            "#include <unistd.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include \"postgres.h\"\n\nvoid\nExceptionalCondition(const char *conditionName,\n\t\t\t\t\t const char *errorType,\n\t\t\t\t\t const char *fileName,\n\t\t\t\t\t int lineNumber)\n{\n\tif (!PointerIsValid(conditionName)\n\t\t|| !PointerIsValid(fileName)\n\t\t|| !PointerIsValid(errorType))\n\t\twrite_stderr(\"TRAP: ExceptionalCondition: bad arguments\\n\");\n\telse\n\t{\n\t\twrite_stderr(\"TRAP: %s(\\\"%s\\\", File: \\\"%s\\\", Line: %d)\\n\",\n\t\t\t\t\t errorType, conditionName,\n\t\t\t\t\t fileName, lineNumber);\n\t}\n\n\t/* Usually this shouldn't be needed, but make sure the msg went out */\n\tfflush(stderr);\n\n#ifdef SLEEP_ON_ASSERT\n\n\t/*\n\t * It would be nice to use pg_usleep() here, but only does 2000 sec or 33\n\t * minutes, which seems too short.\n\t */\n\tsleep(1000000);\n#endif\n\n\tabort();\n}"
        }
      },
      {
        "call_info": {
          "callee": "errfinish",
          "args": [
            "0"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "errfinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "412-564",
          "snippet": "void\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ErrorContextCallback *error_context_stack = NULL;",
            "sigjmp_buf *PG_exception_stack = NULL;",
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_log_level_output",
          "args": [
            "FATAL",
            "log_min_messages"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "is_log_level_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3714-3733",
          "snippet": "static bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *error_severity(int elevel);",
            "static bool is_log_level_output(int elevel, int log_min_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\nstatic bool is_log_level_output(int elevel, int log_min_level);\n\nstatic bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "edata->elevel == ERROR"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "errordata_stack_depth >= 0"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siglongjmp",
          "args": [
            "*PG_exception_stack",
            "1"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\npg_re_throw(void)\n{\n\t/* If possible, throw the error to the next outer setjmp handler */\n\tif (PG_exception_stack != NULL)\n\t\tsiglongjmp(*PG_exception_stack, 1);\n\telse\n\t{\n\t\t/*\n\t\t * If we get here, elog(ERROR) was thrown inside a PG_TRY block, which\n\t\t * we have now exited only to discover that there is no outer setjmp\n\t\t * handler to pass the error to.  Had the error been thrown outside\n\t\t * the block to begin with, we'd have promoted the error to FATAL, so\n\t\t * the correct behavior is to make it FATAL now; that is, emit it and\n\t\t * then call proc_exit.\n\t\t */\n\t\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t\tAssert(errordata_stack_depth >= 0);\n\t\tAssert(edata->elevel == ERROR);\n\t\tedata->elevel = FATAL;\n\n\t\t/*\n\t\t * At least in principle, the increase in severity could have changed\n\t\t * where-to-output decisions, so recalculate.  This should stay in\n\t\t * sync with errstart(), which see for comments.\n\t\t */\n\t\tif (IsPostmasterEnvironment)\n\t\t\tedata->output_to_server = is_log_level_output(FATAL,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  log_min_messages);\n\t\telse\n\t\t\tedata->output_to_server = (FATAL >= log_min_messages);\n\t\tif (whereToSendOutput == DestRemote)\n\t\t\tedata->output_to_client = true;\n\n\t\t/*\n\t\t * We can use errfinish() for the rest, but we don't want it to call\n\t\t * any error context routines a second time.  Since we know we are\n\t\t * about to exit, it should be OK to just clear the context stack.\n\t\t */\n\t\terror_context_stack = NULL;\n\n\t\terrfinish(0);\n\t}\n\n\t/* Doesn't return ... */\n\tExceptionalCondition(\"pg_re_throw tried to return\", \"FailedAssertion\",\n\t\t\t\t\t\t __FILE__, __LINE__);\n}"
  },
  {
    "function_name": "ReThrowError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1667-1721",
    "snippet": "void\nReThrowError(ErrorData *edata)\n{\n\tErrorData  *newedata;\n\n\tAssert(edata->elevel == ERROR);\n\n\t/* Push the data back into the error context */\n\trecursion_depth++;\n\tMemoryContextSwitchTo(ErrorContext);\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\tnewedata = &errordata[errordata_stack_depth];\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Reset the assoc_context to be ErrorContext */\n\tnewedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\tPG_RE_THROW();\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRORDATA_STACK_SIZE  5"
    ],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "newedata->internalquery"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newedata",
            "edata",
            "sizeof(ErrorData)"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "PANIC",
            "(errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\"))"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"ERRORDATA_STACK_SIZE exceeded\""
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ErrorContext"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "edata->elevel == ERROR"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define ERRORDATA_STACK_SIZE  5\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\nReThrowError(ErrorData *edata)\n{\n\tErrorData  *newedata;\n\n\tAssert(edata->elevel == ERROR);\n\n\t/* Push the data back into the error context */\n\trecursion_depth++;\n\tMemoryContextSwitchTo(ErrorContext);\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\tnewedata = &errordata[errordata_stack_depth];\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Reset the assoc_context to be ErrorContext */\n\tnewedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\tPG_RE_THROW();\n}"
  },
  {
    "function_name": "ThrowErrorData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1609-1657",
    "snippet": "void\nThrowErrorData(ErrorData *edata)\n{\n\tErrorData  *newedata;\n\tMemoryContext oldcontext;\n\n\tif (!errstart(edata->elevel, edata->filename, edata->lineno,\n\t\t\t\t  edata->funcname, NULL))\n\t\treturn;\t\t\t\t\t/* error is not to be reported at all */\n\n\tnewedata = &errordata[errordata_stack_depth];\n\trecursion_depth++;\n\toldcontext = MemoryContextSwitchTo(newedata->assoc_context);\n\n\t/* Copy the supplied fields to the error stack entry. */\n\tif (edata->sqlerrcode != 0)\n\t\tnewedata->sqlerrcode = edata->sqlerrcode;\n\tif (edata->message)\n\t\tnewedata->message = pstrdup(edata->message);\n\tif (edata->detail)\n\t\tnewedata->detail = pstrdup(edata->detail);\n\tif (edata->detail_log)\n\t\tnewedata->detail_log = pstrdup(edata->detail_log);\n\tif (edata->hint)\n\t\tnewedata->hint = pstrdup(edata->hint);\n\tif (edata->context)\n\t\tnewedata->context = pstrdup(edata->context);\n\t/* assume message_id is not available */\n\tif (edata->schema_name)\n\t\tnewedata->schema_name = pstrdup(edata->schema_name);\n\tif (edata->table_name)\n\t\tnewedata->table_name = pstrdup(edata->table_name);\n\tif (edata->column_name)\n\t\tnewedata->column_name = pstrdup(edata->column_name);\n\tif (edata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(edata->constraint_name);\n\tnewedata->cursorpos = edata->cursorpos;\n\tnewedata->internalpos = edata->internalpos;\n\tif (edata->internalquery)\n\t\tnewedata->internalquery = pstrdup(edata->internalquery);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/* Process the error. */\n\terrfinish(0);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errfinish",
          "args": [
            "0"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "errfinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "412-564",
          "snippet": "void\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ErrorContextCallback *error_context_stack = NULL;",
            "sigjmp_buf *PG_exception_stack = NULL;",
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "edata->internalquery"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "newedata->assoc_context"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errstart",
          "args": [
            "edata->elevel",
            "edata->filename",
            "edata->lineno",
            "edata->funcname",
            "NULL"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "errstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "232-402",
          "snippet": "bool\nerrstart(int elevel, const char *filename, int lineno,\n\t\t const char *funcname, const char *domain)\n{\n\tErrorData  *edata;\n\tbool\t\toutput_to_server;\n\tbool\t\toutput_to_client = false;\n\tint\t\t\ti;\n\n\t/*\n\t * Check some cases in which we want to promote an error into a more\n\t * severe error.  None of this logic applies for non-error messages.\n\t */\n\tif (elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * If we are inside a critical section, all errors become PANIC\n\t\t * errors.  See miscadmin.h.\n\t\t */\n\t\tif (CritSectionCount > 0)\n\t\t\televel = PANIC;\n\n\t\t/*\n\t\t * Check reasons for treating ERROR as FATAL:\n\t\t *\n\t\t * 1. we have no handler to pass the error to (implies we are in the\n\t\t * postmaster or in backend startup).\n\t\t *\n\t\t * 2. ExitOnAnyError mode switch is set (initdb uses this).\n\t\t *\n\t\t * 3. the error occurred after proc_exit has begun to run.  (It's\n\t\t * proc_exit's responsibility to see that this doesn't turn into\n\t\t * infinite recursion!)\n\t\t */\n\t\tif (elevel == ERROR)\n\t\t{\n\t\t\tif (PG_exception_stack == NULL ||\n\t\t\t\tExitOnAnyError ||\n\t\t\t\tproc_exit_inprogress)\n\t\t\t\televel = FATAL;\n\t\t}\n\n\t\t/*\n\t\t * If the error level is ERROR or more, errfinish is not going to\n\t\t * return to caller; therefore, if there is any stacked error already\n\t\t * in progress it will be lost.  This is more or less okay, except we\n\t\t * do not want to have a FATAL or PANIC error downgraded because the\n\t\t * reporting process was interrupted by a lower-grade error.  So check\n\t\t * the stack and make sure we panic if panic is warranted.\n\t\t */\n\t\tfor (i = 0; i <= errordata_stack_depth; i++)\n\t\t\televel = Max(elevel, errordata[i].elevel);\n\t}\n\n\t/*\n\t * Now decide whether we need to process this report at all; if it's\n\t * warning or less and not enabled for logging, just return false without\n\t * starting up any error logging machinery.\n\t */\n\n\t/* Determine whether message is enabled for server log output */\n\toutput_to_server = is_log_level_output(elevel, log_min_messages);\n\n\t/* Determine whether message is enabled for client output */\n\tif (whereToSendOutput == DestRemote && elevel != LOG_SERVER_ONLY)\n\t{\n\t\t/*\n\t\t * client_min_messages is honored only after we complete the\n\t\t * authentication handshake.  This is required both for security\n\t\t * reasons and because many clients can't handle NOTICE messages\n\t\t * during authentication.\n\t\t */\n\t\tif (ClientAuthInProgress)\n\t\t\toutput_to_client = (elevel >= ERROR);\n\t\telse\n\t\t\toutput_to_client = (elevel >= client_min_messages ||\n\t\t\t\t\t\t\t\televel == INFO);\n\t}\n\n\t/* Skip processing effort if non-error message will not be output */\n\tif (elevel < ERROR && !output_to_server && !output_to_client)\n\t\treturn false;\n\n\t/*\n\t * We need to do some actual work.  Make sure that memory context\n\t * initialization has finished, else we can't do anything useful.\n\t */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\n\tif (recursion_depth++ > 0 && elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * Oops, error during error processing.  Clear ErrorContext as\n\t\t * discussed at top of file.  We will not return to the original\n\t\t * error's reporter or handler, so we don't need it.\n\t\t */\n\t\tMemoryContextReset(ErrorContext);\n\n\t\t/*\n\t\t * Infinite error recursion might be due to something broken in a\n\t\t * context traceback routine.  Abandon them too.  We also abandon\n\t\t * attempting to print the error statement (which, if long, could\n\t\t * itself be the source of the recursive failure).\n\t\t */\n\t\tif (in_error_recursion_trouble())\n\t\t{\n\t\t\terror_context_stack = NULL;\n\t\t\tdebug_query_string = NULL;\n\t\t}\n\t}\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/* Initialize data for this error frame */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\tedata->elevel = elevel;\n\tedata->output_to_server = output_to_server;\n\tedata->output_to_client = output_to_client;\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* the default text domain is the backend's */\n\tedata->domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* initialize context_domain the same way (see set_errcontext_domain()) */\n\tedata->context_domain = edata->domain;\n\t/* Select default errcode based on elevel */\n\tif (elevel >= ERROR)\n\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\telse if (elevel == WARNING)\n\t\tedata->sqlerrcode = ERRCODE_WARNING;\n\telse\n\t\tedata->sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;\n\t/* errno is saved here so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/*\n\t * Any allocations for this error state level should go into ErrorContext\n\t */\n\tedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\treturn true;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRORDATA_STACK_SIZE  5"
          ],
          "globals_used": [
            "ErrorContextCallback *error_context_stack = NULL;",
            "sigjmp_buf *PG_exception_stack = NULL;",
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define ERRORDATA_STACK_SIZE  5\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nbool\nerrstart(int elevel, const char *filename, int lineno,\n\t\t const char *funcname, const char *domain)\n{\n\tErrorData  *edata;\n\tbool\t\toutput_to_server;\n\tbool\t\toutput_to_client = false;\n\tint\t\t\ti;\n\n\t/*\n\t * Check some cases in which we want to promote an error into a more\n\t * severe error.  None of this logic applies for non-error messages.\n\t */\n\tif (elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * If we are inside a critical section, all errors become PANIC\n\t\t * errors.  See miscadmin.h.\n\t\t */\n\t\tif (CritSectionCount > 0)\n\t\t\televel = PANIC;\n\n\t\t/*\n\t\t * Check reasons for treating ERROR as FATAL:\n\t\t *\n\t\t * 1. we have no handler to pass the error to (implies we are in the\n\t\t * postmaster or in backend startup).\n\t\t *\n\t\t * 2. ExitOnAnyError mode switch is set (initdb uses this).\n\t\t *\n\t\t * 3. the error occurred after proc_exit has begun to run.  (It's\n\t\t * proc_exit's responsibility to see that this doesn't turn into\n\t\t * infinite recursion!)\n\t\t */\n\t\tif (elevel == ERROR)\n\t\t{\n\t\t\tif (PG_exception_stack == NULL ||\n\t\t\t\tExitOnAnyError ||\n\t\t\t\tproc_exit_inprogress)\n\t\t\t\televel = FATAL;\n\t\t}\n\n\t\t/*\n\t\t * If the error level is ERROR or more, errfinish is not going to\n\t\t * return to caller; therefore, if there is any stacked error already\n\t\t * in progress it will be lost.  This is more or less okay, except we\n\t\t * do not want to have a FATAL or PANIC error downgraded because the\n\t\t * reporting process was interrupted by a lower-grade error.  So check\n\t\t * the stack and make sure we panic if panic is warranted.\n\t\t */\n\t\tfor (i = 0; i <= errordata_stack_depth; i++)\n\t\t\televel = Max(elevel, errordata[i].elevel);\n\t}\n\n\t/*\n\t * Now decide whether we need to process this report at all; if it's\n\t * warning or less and not enabled for logging, just return false without\n\t * starting up any error logging machinery.\n\t */\n\n\t/* Determine whether message is enabled for server log output */\n\toutput_to_server = is_log_level_output(elevel, log_min_messages);\n\n\t/* Determine whether message is enabled for client output */\n\tif (whereToSendOutput == DestRemote && elevel != LOG_SERVER_ONLY)\n\t{\n\t\t/*\n\t\t * client_min_messages is honored only after we complete the\n\t\t * authentication handshake.  This is required both for security\n\t\t * reasons and because many clients can't handle NOTICE messages\n\t\t * during authentication.\n\t\t */\n\t\tif (ClientAuthInProgress)\n\t\t\toutput_to_client = (elevel >= ERROR);\n\t\telse\n\t\t\toutput_to_client = (elevel >= client_min_messages ||\n\t\t\t\t\t\t\t\televel == INFO);\n\t}\n\n\t/* Skip processing effort if non-error message will not be output */\n\tif (elevel < ERROR && !output_to_server && !output_to_client)\n\t\treturn false;\n\n\t/*\n\t * We need to do some actual work.  Make sure that memory context\n\t * initialization has finished, else we can't do anything useful.\n\t */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\n\tif (recursion_depth++ > 0 && elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * Oops, error during error processing.  Clear ErrorContext as\n\t\t * discussed at top of file.  We will not return to the original\n\t\t * error's reporter or handler, so we don't need it.\n\t\t */\n\t\tMemoryContextReset(ErrorContext);\n\n\t\t/*\n\t\t * Infinite error recursion might be due to something broken in a\n\t\t * context traceback routine.  Abandon them too.  We also abandon\n\t\t * attempting to print the error statement (which, if long, could\n\t\t * itself be the source of the recursive failure).\n\t\t */\n\t\tif (in_error_recursion_trouble())\n\t\t{\n\t\t\terror_context_stack = NULL;\n\t\t\tdebug_query_string = NULL;\n\t\t}\n\t}\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/* Initialize data for this error frame */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\tedata->elevel = elevel;\n\tedata->output_to_server = output_to_server;\n\tedata->output_to_client = output_to_client;\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* the default text domain is the backend's */\n\tedata->domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* initialize context_domain the same way (see set_errcontext_domain()) */\n\tedata->context_domain = edata->domain;\n\t/* Select default errcode based on elevel */\n\tif (elevel >= ERROR)\n\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\telse if (elevel == WARNING)\n\t\tedata->sqlerrcode = ERRCODE_WARNING;\n\telse\n\t\tedata->sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;\n\t/* errno is saved here so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/*\n\t * Any allocations for this error state level should go into ErrorContext\n\t */\n\tedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\nThrowErrorData(ErrorData *edata)\n{\n\tErrorData  *newedata;\n\tMemoryContext oldcontext;\n\n\tif (!errstart(edata->elevel, edata->filename, edata->lineno,\n\t\t\t\t  edata->funcname, NULL))\n\t\treturn;\t\t\t\t\t/* error is not to be reported at all */\n\n\tnewedata = &errordata[errordata_stack_depth];\n\trecursion_depth++;\n\toldcontext = MemoryContextSwitchTo(newedata->assoc_context);\n\n\t/* Copy the supplied fields to the error stack entry. */\n\tif (edata->sqlerrcode != 0)\n\t\tnewedata->sqlerrcode = edata->sqlerrcode;\n\tif (edata->message)\n\t\tnewedata->message = pstrdup(edata->message);\n\tif (edata->detail)\n\t\tnewedata->detail = pstrdup(edata->detail);\n\tif (edata->detail_log)\n\t\tnewedata->detail_log = pstrdup(edata->detail_log);\n\tif (edata->hint)\n\t\tnewedata->hint = pstrdup(edata->hint);\n\tif (edata->context)\n\t\tnewedata->context = pstrdup(edata->context);\n\t/* assume message_id is not available */\n\tif (edata->schema_name)\n\t\tnewedata->schema_name = pstrdup(edata->schema_name);\n\tif (edata->table_name)\n\t\tnewedata->table_name = pstrdup(edata->table_name);\n\tif (edata->column_name)\n\t\tnewedata->column_name = pstrdup(edata->column_name);\n\tif (edata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(edata->constraint_name);\n\tnewedata->cursorpos = edata->cursorpos;\n\tnewedata->internalpos = edata->internalpos;\n\tif (edata->internalquery)\n\t\tnewedata->internalquery = pstrdup(edata->internalquery);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/* Process the error. */\n\terrfinish(0);\n}"
  },
  {
    "function_name": "FlushErrorState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1584-1597",
    "snippet": "void\nFlushErrorState(void)\n{\n\t/*\n\t * Reset stack to empty.  The only case where it would be more than one\n\t * deep is if we serviced an error that interrupted construction of\n\t * another message.  We assume control escaped out of that message\n\t * construction and won't ever go back.\n\t */\n\terrordata_stack_depth = -1;\n\trecursion_depth = 0;\n\t/* Delete all data in ErrorContext */\n\tMemoryContextResetAndDeleteChildren(ErrorContext);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextResetAndDeleteChildren",
          "args": [
            "ErrorContext"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\n\nvoid\nFlushErrorState(void)\n{\n\t/*\n\t * Reset stack to empty.  The only case where it would be more than one\n\t * deep is if we serviced an error that interrupted construction of\n\t * another message.  We assume control escaped out of that message\n\t * construction and won't ever go back.\n\t */\n\terrordata_stack_depth = -1;\n\trecursion_depth = 0;\n\t/* Delete all data in ErrorContext */\n\tMemoryContextResetAndDeleteChildren(ErrorContext);\n}"
  },
  {
    "function_name": "FreeErrorData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1548-1574",
    "snippet": "void\nFreeErrorData(ErrorData *edata)\n{\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\tpfree(edata);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "edata"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nvoid\nFreeErrorData(ErrorData *edata)\n{\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\tpfree(edata);\n}"
  },
  {
    "function_name": "CopyErrorData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1494-1540",
    "snippet": "ErrorData *\nCopyErrorData(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tErrorData  *newedata;\n\n\t/*\n\t * we don't increment recursion_depth because out-of-memory here does not\n\t * indicate a problem within the error subsystem.\n\t */\n\tCHECK_STACK_DEPTH();\n\n\tAssert(CurrentMemoryContext != ErrorContext);\n\n\t/* Copy the struct itself */\n\tnewedata = (ErrorData *) palloc(sizeof(ErrorData));\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Use the calling context for string allocation */\n\tnewedata->assoc_context = CurrentMemoryContext;\n\n\treturn newedata;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pstrdup",
          "args": [
            "newedata->internalquery"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "pstrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1160-1164",
          "snippet": "char *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\n\nchar *\npstrdup(const char *in)\n{\n\treturn MemoryContextStrdup(CurrentMemoryContext, in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newedata",
            "edata",
            "sizeof(ErrorData)"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "palloc",
          "args": [
            "sizeof(ErrorData)"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "palloc0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "954-985",
          "snippet": "void *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "MemoryContext CurrentMemoryContext = NULL;",
            "MemoryContext TopMemoryContext = NULL;",
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nMemoryContext CurrentMemoryContext = NULL;\nMemoryContext TopMemoryContext = NULL;\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid *\npalloc0(Size size)\n{\n\t/* duplicates MemoryContextAllocZero to avoid increased overhead */\n\tvoid\t   *ret;\n\tMemoryContext context = CurrentMemoryContext;\n\n\tAssertArg(MemoryContextIsValid(context));\n\tAssertNotInCriticalSection(context);\n\n\tif (!AllocSizeIsValid(size))\n\t\telog(ERROR, \"invalid memory alloc request size %zu\", size);\n\n\tcontext->isReset = false;\n\n\tret = context->methods->alloc(context, size);\n\tif (unlikely(ret == NULL))\n\t{\n\t\tMemoryContextStats(TopMemoryContext);\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t errmsg(\"out of memory\"),\n\t\t\t\t errdetail(\"Failed on request of size %zu in memory context \\\"%s\\\".\",\n\t\t\t\t\t\t   size, context->name)));\n\t}\n\n\tVALGRIND_MEMPOOL_ALLOC(context, ret, size);\n\n\tMemSetAligned(ret, 0, size);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "CurrentMemoryContext != ErrorContext"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nErrorData *\nCopyErrorData(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tErrorData  *newedata;\n\n\t/*\n\t * we don't increment recursion_depth because out-of-memory here does not\n\t * indicate a problem within the error subsystem.\n\t */\n\tCHECK_STACK_DEPTH();\n\n\tAssert(CurrentMemoryContext != ErrorContext);\n\n\t/* Copy the struct itself */\n\tnewedata = (ErrorData *) palloc(sizeof(ErrorData));\n\tmemcpy(newedata, edata, sizeof(ErrorData));\n\n\t/* Make copies of separately-allocated fields */\n\tif (newedata->message)\n\t\tnewedata->message = pstrdup(newedata->message);\n\tif (newedata->detail)\n\t\tnewedata->detail = pstrdup(newedata->detail);\n\tif (newedata->detail_log)\n\t\tnewedata->detail_log = pstrdup(newedata->detail_log);\n\tif (newedata->hint)\n\t\tnewedata->hint = pstrdup(newedata->hint);\n\tif (newedata->context)\n\t\tnewedata->context = pstrdup(newedata->context);\n\tif (newedata->schema_name)\n\t\tnewedata->schema_name = pstrdup(newedata->schema_name);\n\tif (newedata->table_name)\n\t\tnewedata->table_name = pstrdup(newedata->table_name);\n\tif (newedata->column_name)\n\t\tnewedata->column_name = pstrdup(newedata->column_name);\n\tif (newedata->datatype_name)\n\t\tnewedata->datatype_name = pstrdup(newedata->datatype_name);\n\tif (newedata->constraint_name)\n\t\tnewedata->constraint_name = pstrdup(newedata->constraint_name);\n\tif (newedata->internalquery)\n\t\tnewedata->internalquery = pstrdup(newedata->internalquery);\n\n\t/* Use the calling context for string allocation */\n\tnewedata->assoc_context = CurrentMemoryContext;\n\n\treturn newedata;\n}"
  },
  {
    "function_name": "EmitErrorReport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1443-1485",
    "snippet": "void\nEmitErrorReport(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\t/*\n\t * Call hook before sending message to log.  The hook function is allowed\n\t * to turn off edata->output_to_server, so we must recheck that afterward.\n\t * Making any other change in the content of edata is not considered\n\t * supported.\n\t *\n\t * Note: the reason why the hook can only turn off output_to_server, and\n\t * not turn it on, is that it'd be unreliable: we will never get here at\n\t * all if errstart() deems the message uninteresting.  A hook that could\n\t * make decisions in that direction would have to hook into errstart(),\n\t * where it would have much less information available.  emit_log_hook is\n\t * intended for custom log filtering and custom log message transmission\n\t * mechanisms.\n\t *\n\t * The log hook has access to both the translated and original English\n\t * error message text, which is passed through to allow it to be used as a\n\t * message identifier. Note that the original text is not available for\n\t * detail, detail_log, hint and context text elements.\n\t */\n\tif (edata->output_to_server && emit_log_hook)\n\t\t(*emit_log_hook) (edata);\n\n\t/* Send to server log, if enabled */\n\tif (edata->output_to_server)\n\t\tsend_message_to_server_log(edata);\n\n\t/* Send to client, if enabled */\n\tif (edata->output_to_client)\n\t\tsend_message_to_frontend(edata);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "emit_log_hook_type emit_log_hook = NULL;",
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_message_to_frontend",
          "args": [
            "edata"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "send_message_to_frontend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3144-3318",
          "snippet": "static void\nsend_message_to_frontend(ErrorData *edata)\n{\n\tStringInfoData msgbuf;\n\n\t/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */\n\tpq_beginmessage(&msgbuf, (edata->elevel < ERROR) ? 'N' : 'E');\n\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)\n\t{\n\t\t/* New style with separate fields */\n\t\tconst char *sev;\n\t\tchar\t\ttbuf[12];\n\t\tint\t\t\tssval;\n\t\tint\t\t\ti;\n\n\t\tsev = error_severity(edata->elevel);\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY);\n\t\terr_sendstring(&msgbuf, _(sev));\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY_NONLOCALIZED);\n\t\terr_sendstring(&msgbuf, sev);\n\n\t\t/* unpack MAKE_SQLSTATE code */\n\t\tssval = edata->sqlerrcode;\n\t\tfor (i = 0; i < 5; i++)\n\t\t{\n\t\t\ttbuf[i] = PGUNSIXBIT(ssval);\n\t\t\tssval >>= 6;\n\t\t}\n\t\ttbuf[i] = '\\0';\n\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SQLSTATE);\n\t\terr_sendstring(&msgbuf, tbuf);\n\n\t\t/* M field is required per protocol, so always send something */\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_PRIMARY);\n\t\tif (edata->message)\n\t\t\terr_sendstring(&msgbuf, edata->message);\n\t\telse\n\t\t\terr_sendstring(&msgbuf, _(\"missing error text\"));\n\n\t\tif (edata->detail)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_DETAIL);\n\t\t\terr_sendstring(&msgbuf, edata->detail);\n\t\t}\n\n\t\t/* detail_log is intentionally not used here */\n\n\t\tif (edata->hint)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_HINT);\n\t\t\terr_sendstring(&msgbuf, edata->hint);\n\t\t}\n\n\t\tif (edata->context)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONTEXT);\n\t\t\terr_sendstring(&msgbuf, edata->context);\n\t\t}\n\n\t\tif (edata->schema_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SCHEMA_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->schema_name);\n\t\t}\n\n\t\tif (edata->table_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_TABLE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->table_name);\n\t\t}\n\n\t\tif (edata->column_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_COLUMN_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->column_name);\n\t\t}\n\n\t\tif (edata->datatype_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_DATATYPE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->datatype_name);\n\t\t}\n\n\t\tif (edata->constraint_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONSTRAINT_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->constraint_name);\n\t\t}\n\n\t\tif (edata->cursorpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->cursorpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_STATEMENT_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->internalpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_QUERY);\n\t\t\terr_sendstring(&msgbuf, edata->internalquery);\n\t\t}\n\n\t\tif (edata->filename)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FILE);\n\t\t\terr_sendstring(&msgbuf, edata->filename);\n\t\t}\n\n\t\tif (edata->lineno > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->lineno);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_LINE);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->funcname)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FUNCTION);\n\t\t\terr_sendstring(&msgbuf, edata->funcname);\n\t\t}\n\n\t\tpq_sendbyte(&msgbuf, '\\0'); /* terminator */\n\t}\n\telse\n\t{\n\t\t/* Old style --- gin up a backwards-compatible message */\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\t\tif (edata->show_funcname && edata->funcname)\n\t\t\tappendStringInfo(&buf, \"%s: \", edata->funcname);\n\n\t\tif (edata->message)\n\t\t\tappendStringInfoString(&buf, edata->message);\n\t\telse\n\t\t\tappendStringInfoString(&buf, _(\"missing error text\"));\n\n\t\tif (edata->cursorpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->cursorpos);\n\t\telse if (edata->internalpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->internalpos);\n\n\t\tappendStringInfoChar(&buf, '\\n');\n\n\t\terr_sendstring(&msgbuf, buf.data);\n\n\t\tpfree(buf.data);\n\t}\n\n\tpq_endmessage(&msgbuf);\n\n\t/*\n\t * This flush is normally not necessary, since postgres.c will flush out\n\t * waiting data when control returns to the main loop. But it seems best\n\t * to leave it here, so that the client has some clue what happened if the\n\t * backend dies before getting back to the main loop ... error/notice\n\t * messages should not be a performance-critical path anyway, so an extra\n\t * flush won't hurt much ...\n\t */\n\tpq_flush();\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nstatic void\nsend_message_to_frontend(ErrorData *edata)\n{\n\tStringInfoData msgbuf;\n\n\t/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */\n\tpq_beginmessage(&msgbuf, (edata->elevel < ERROR) ? 'N' : 'E');\n\n\tif (PG_PROTOCOL_MAJOR(FrontendProtocol) >= 3)\n\t{\n\t\t/* New style with separate fields */\n\t\tconst char *sev;\n\t\tchar\t\ttbuf[12];\n\t\tint\t\t\tssval;\n\t\tint\t\t\ti;\n\n\t\tsev = error_severity(edata->elevel);\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY);\n\t\terr_sendstring(&msgbuf, _(sev));\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SEVERITY_NONLOCALIZED);\n\t\terr_sendstring(&msgbuf, sev);\n\n\t\t/* unpack MAKE_SQLSTATE code */\n\t\tssval = edata->sqlerrcode;\n\t\tfor (i = 0; i < 5; i++)\n\t\t{\n\t\t\ttbuf[i] = PGUNSIXBIT(ssval);\n\t\t\tssval >>= 6;\n\t\t}\n\t\ttbuf[i] = '\\0';\n\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_SQLSTATE);\n\t\terr_sendstring(&msgbuf, tbuf);\n\n\t\t/* M field is required per protocol, so always send something */\n\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_PRIMARY);\n\t\tif (edata->message)\n\t\t\terr_sendstring(&msgbuf, edata->message);\n\t\telse\n\t\t\terr_sendstring(&msgbuf, _(\"missing error text\"));\n\n\t\tif (edata->detail)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_DETAIL);\n\t\t\terr_sendstring(&msgbuf, edata->detail);\n\t\t}\n\n\t\t/* detail_log is intentionally not used here */\n\n\t\tif (edata->hint)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_MESSAGE_HINT);\n\t\t\terr_sendstring(&msgbuf, edata->hint);\n\t\t}\n\n\t\tif (edata->context)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONTEXT);\n\t\t\terr_sendstring(&msgbuf, edata->context);\n\t\t}\n\n\t\tif (edata->schema_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SCHEMA_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->schema_name);\n\t\t}\n\n\t\tif (edata->table_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_TABLE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->table_name);\n\t\t}\n\n\t\tif (edata->column_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_COLUMN_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->column_name);\n\t\t}\n\n\t\tif (edata->datatype_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_DATATYPE_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->datatype_name);\n\t\t}\n\n\t\tif (edata->constraint_name)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_CONSTRAINT_NAME);\n\t\t\terr_sendstring(&msgbuf, edata->constraint_name);\n\t\t}\n\n\t\tif (edata->cursorpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->cursorpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_STATEMENT_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalpos > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->internalpos);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_POSITION);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_INTERNAL_QUERY);\n\t\t\terr_sendstring(&msgbuf, edata->internalquery);\n\t\t}\n\n\t\tif (edata->filename)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FILE);\n\t\t\terr_sendstring(&msgbuf, edata->filename);\n\t\t}\n\n\t\tif (edata->lineno > 0)\n\t\t{\n\t\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", edata->lineno);\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_LINE);\n\t\t\terr_sendstring(&msgbuf, tbuf);\n\t\t}\n\n\t\tif (edata->funcname)\n\t\t{\n\t\t\tpq_sendbyte(&msgbuf, PG_DIAG_SOURCE_FUNCTION);\n\t\t\terr_sendstring(&msgbuf, edata->funcname);\n\t\t}\n\n\t\tpq_sendbyte(&msgbuf, '\\0'); /* terminator */\n\t}\n\telse\n\t{\n\t\t/* Old style --- gin up a backwards-compatible message */\n\t\tStringInfoData buf;\n\n\t\tinitStringInfo(&buf);\n\n\t\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\t\tif (edata->show_funcname && edata->funcname)\n\t\t\tappendStringInfo(&buf, \"%s: \", edata->funcname);\n\n\t\tif (edata->message)\n\t\t\tappendStringInfoString(&buf, edata->message);\n\t\telse\n\t\t\tappendStringInfoString(&buf, _(\"missing error text\"));\n\n\t\tif (edata->cursorpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->cursorpos);\n\t\telse if (edata->internalpos > 0)\n\t\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t\t edata->internalpos);\n\n\t\tappendStringInfoChar(&buf, '\\n');\n\n\t\terr_sendstring(&msgbuf, buf.data);\n\n\t\tpfree(buf.data);\n\t}\n\n\tpq_endmessage(&msgbuf);\n\n\t/*\n\t * This flush is normally not necessary, since postgres.c will flush out\n\t * waiting data when control returns to the main loop. But it seems best\n\t * to leave it here, so that the client has some clue what happened if the\n\t * backend dies before getting back to the main loop ... error/notice\n\t * messages should not be a performance-critical path anyway, so an extra\n\t * flush won't hurt much ...\n\t */\n\tpq_flush();\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_message_to_server_log",
          "args": [
            "edata"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "send_message_to_server_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "2861-3066",
          "snippet": "static void\nsend_message_to_server_log(ErrorData *edata)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\tsaved_timeval_set = false;\n\tformatted_log_time[0] = '\\0';\n\n\tlog_line_prefix(&buf, edata);\n\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\tappendStringInfo(&buf, \"%s: \", unpack_sql_state(edata->sqlerrcode));\n\n\tif (edata->message)\n\t\tappend_with_tabs(&buf, edata->message);\n\telse\n\t\tappend_with_tabs(&buf, _(\"missing error text\"));\n\n\tif (edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->cursorpos);\n\telse if (edata->internalpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->internalpos);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\tif (Log_error_verbosity >= PGERROR_DEFAULT)\n\t{\n\t\tif (edata->detail_log)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail_log);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\telse if (edata->detail)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->hint)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"HINT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->hint);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"QUERY:  \"));\n\t\t\tappend_with_tabs(&buf, edata->internalquery);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->context && !edata->hide_ctx)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"CONTEXT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->context);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\t{\n\t\t\t/* assume no newlines in funcname or filename... */\n\t\t\tif (edata->funcname && edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s, %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t\t edata->lineno);\n\t\t\t}\n\t\t\telse if (edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the user wants the query that generated this error logged, do it.\n\t */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t{\n\t\tlog_line_prefix(&buf, edata);\n\t\tappendStringInfoString(&buf, _(\"STATEMENT:  \"));\n\t\tappend_with_tabs(&buf, debug_query_string);\n\t\tappendStringInfoChar(&buf, '\\n');\n\t}\n\n#ifdef HAVE_SYSLOG\n\t/* Write to syslog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_SYSLOG)\n\t{\n\t\tint\t\t\tsyslog_level;\n\n\t\tswitch (edata->elevel)\n\t\t{\n\t\t\tcase DEBUG5:\n\t\t\tcase DEBUG4:\n\t\t\tcase DEBUG3:\n\t\t\tcase DEBUG2:\n\t\t\tcase DEBUG1:\n\t\t\t\tsyslog_level = LOG_DEBUG;\n\t\t\t\tbreak;\n\t\t\tcase LOG:\n\t\t\tcase LOG_SERVER_ONLY:\n\t\t\tcase INFO:\n\t\t\t\tsyslog_level = LOG_INFO;\n\t\t\t\tbreak;\n\t\t\tcase NOTICE:\n\t\t\tcase WARNING:\n\t\t\t\tsyslog_level = LOG_NOTICE;\n\t\t\t\tbreak;\n\t\t\tcase ERROR:\n\t\t\t\tsyslog_level = LOG_WARNING;\n\t\t\t\tbreak;\n\t\t\tcase FATAL:\n\t\t\t\tsyslog_level = LOG_ERR;\n\t\t\t\tbreak;\n\t\t\tcase PANIC:\n\t\t\tdefault:\n\t\t\t\tsyslog_level = LOG_CRIT;\n\t\t\t\tbreak;\n\t\t}\n\n\t\twrite_syslog(syslog_level, buf.data);\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_SYSLOG */\n\n#ifdef WIN32\n\t/* Write to eventlog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_EVENTLOG)\n\t{\n\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t/* Write to stderr, if enabled */\n\tif ((Log_destination & LOG_DESTINATION_STDERR) || whereToSendOutput == DestDebug)\n\t{\n\t\t/*\n\t\t * Use the chunking protocol if we know the syslogger should be\n\t\t * catching stderr output, and we are not ourselves the syslogger.\n\t\t * Otherwise, just do a vanilla write to stderr.\n\t\t */\n\t\tif (redirection_done && !am_syslogger)\n\t\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_STDERR);\n#ifdef WIN32\n\n\t\t/*\n\t\t * In a win32 service environment, there is no usable stderr. Capture\n\t\t * anything going there and write it to the eventlog instead.\n\t\t *\n\t\t * If stderr redirection is active, it was OK to write to stderr above\n\t\t * because that's really a pipe to the syslogger process.\n\t\t */\n\t\telse if (pgwin32_is_service())\n\t\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n#endif\n\t\telse\n\t\t\twrite_console(buf.data, buf.len);\n\t}\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_STDERR);\n\n\t/* Write to CSV log if enabled */\n\tif (Log_destination & LOG_DESTINATION_CSVLOG)\n\t{\n\t\tif (redirection_done || am_syslogger)\n\t\t{\n\t\t\t/*\n\t\t\t * send CSV data if it's safe to do so (syslogger doesn't need the\n\t\t\t * pipe). First get back the space in the message buffer.\n\t\t\t */\n\t\t\tpfree(buf.data);\n\t\t\twrite_csvlog(edata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * syslogger not up (yet), so just dump the message to stderr,\n\t\t\t * unless we already did so above.\n\t\t\t */\n\t\t\tif (!(Log_destination & LOG_DESTINATION_STDERR) &&\n\t\t\t\twhereToSendOutput != DestDebug)\n\t\t\t\twrite_console(buf.data, buf.len);\n\t\t\tpfree(buf.data);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpfree(buf.data);\n\t}\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool redirection_done;",
            "int\t\t\tLog_error_verbosity = PGERROR_VERBOSE;",
            "int\t\t\tLog_destination = LOG_DESTINATION_STDERR;",
            "static bool saved_timeval_set = false;",
            "static char formatted_log_time[FORMATTED_TS_LEN];",
            "static void write_console(const char *line, int len);",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nextern bool redirection_done;\nint\t\t\tLog_error_verbosity = PGERROR_VERBOSE;\nint\t\t\tLog_destination = LOG_DESTINATION_STDERR;\nstatic bool saved_timeval_set = false;\nstatic char formatted_log_time[FORMATTED_TS_LEN];\nstatic void write_console(const char *line, int len);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nstatic void\nsend_message_to_server_log(ErrorData *edata)\n{\n\tStringInfoData buf;\n\n\tinitStringInfo(&buf);\n\n\tsaved_timeval_set = false;\n\tformatted_log_time[0] = '\\0';\n\n\tlog_line_prefix(&buf, edata);\n\tappendStringInfo(&buf, \"%s:  \", _(error_severity(edata->elevel)));\n\n\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\tappendStringInfo(&buf, \"%s: \", unpack_sql_state(edata->sqlerrcode));\n\n\tif (edata->message)\n\t\tappend_with_tabs(&buf, edata->message);\n\telse\n\t\tappend_with_tabs(&buf, _(\"missing error text\"));\n\n\tif (edata->cursorpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->cursorpos);\n\telse if (edata->internalpos > 0)\n\t\tappendStringInfo(&buf, _(\" at character %d\"),\n\t\t\t\t\t\t edata->internalpos);\n\n\tappendStringInfoChar(&buf, '\\n');\n\n\tif (Log_error_verbosity >= PGERROR_DEFAULT)\n\t{\n\t\tif (edata->detail_log)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail_log);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\telse if (edata->detail)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"DETAIL:  \"));\n\t\t\tappend_with_tabs(&buf, edata->detail);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->hint)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"HINT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->hint);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->internalquery)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"QUERY:  \"));\n\t\t\tappend_with_tabs(&buf, edata->internalquery);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (edata->context && !edata->hide_ctx)\n\t\t{\n\t\t\tlog_line_prefix(&buf, edata);\n\t\t\tappendStringInfoString(&buf, _(\"CONTEXT:  \"));\n\t\t\tappend_with_tabs(&buf, edata->context);\n\t\t\tappendStringInfoChar(&buf, '\\n');\n\t\t}\n\t\tif (Log_error_verbosity >= PGERROR_VERBOSE)\n\t\t{\n\t\t\t/* assume no newlines in funcname or filename... */\n\t\t\tif (edata->funcname && edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s, %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->funcname, edata->filename,\n\t\t\t\t\t\t\t\t edata->lineno);\n\t\t\t}\n\t\t\telse if (edata->filename)\n\t\t\t{\n\t\t\t\tlog_line_prefix(&buf, edata);\n\t\t\t\tappendStringInfo(&buf, _(\"LOCATION:  %s:%d\\n\"),\n\t\t\t\t\t\t\t\t edata->filename, edata->lineno);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * If the user wants the query that generated this error logged, do it.\n\t */\n\tif (is_log_level_output(edata->elevel, log_min_error_statement) &&\n\t\tdebug_query_string != NULL &&\n\t\t!edata->hide_stmt)\n\t{\n\t\tlog_line_prefix(&buf, edata);\n\t\tappendStringInfoString(&buf, _(\"STATEMENT:  \"));\n\t\tappend_with_tabs(&buf, debug_query_string);\n\t\tappendStringInfoChar(&buf, '\\n');\n\t}\n\n#ifdef HAVE_SYSLOG\n\t/* Write to syslog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_SYSLOG)\n\t{\n\t\tint\t\t\tsyslog_level;\n\n\t\tswitch (edata->elevel)\n\t\t{\n\t\t\tcase DEBUG5:\n\t\t\tcase DEBUG4:\n\t\t\tcase DEBUG3:\n\t\t\tcase DEBUG2:\n\t\t\tcase DEBUG1:\n\t\t\t\tsyslog_level = LOG_DEBUG;\n\t\t\t\tbreak;\n\t\t\tcase LOG:\n\t\t\tcase LOG_SERVER_ONLY:\n\t\t\tcase INFO:\n\t\t\t\tsyslog_level = LOG_INFO;\n\t\t\t\tbreak;\n\t\t\tcase NOTICE:\n\t\t\tcase WARNING:\n\t\t\t\tsyslog_level = LOG_NOTICE;\n\t\t\t\tbreak;\n\t\t\tcase ERROR:\n\t\t\t\tsyslog_level = LOG_WARNING;\n\t\t\t\tbreak;\n\t\t\tcase FATAL:\n\t\t\t\tsyslog_level = LOG_ERR;\n\t\t\t\tbreak;\n\t\t\tcase PANIC:\n\t\t\tdefault:\n\t\t\t\tsyslog_level = LOG_CRIT;\n\t\t\t\tbreak;\n\t\t}\n\n\t\twrite_syslog(syslog_level, buf.data);\n\t}\n#endif\t\t\t\t\t\t\t/* HAVE_SYSLOG */\n\n#ifdef WIN32\n\t/* Write to eventlog, if enabled */\n\tif (Log_destination & LOG_DESTINATION_EVENTLOG)\n\t{\n\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n\t}\n#endif\t\t\t\t\t\t\t/* WIN32 */\n\n\t/* Write to stderr, if enabled */\n\tif ((Log_destination & LOG_DESTINATION_STDERR) || whereToSendOutput == DestDebug)\n\t{\n\t\t/*\n\t\t * Use the chunking protocol if we know the syslogger should be\n\t\t * catching stderr output, and we are not ourselves the syslogger.\n\t\t * Otherwise, just do a vanilla write to stderr.\n\t\t */\n\t\tif (redirection_done && !am_syslogger)\n\t\t\twrite_pipe_chunks(buf.data, buf.len, LOG_DESTINATION_STDERR);\n#ifdef WIN32\n\n\t\t/*\n\t\t * In a win32 service environment, there is no usable stderr. Capture\n\t\t * anything going there and write it to the eventlog instead.\n\t\t *\n\t\t * If stderr redirection is active, it was OK to write to stderr above\n\t\t * because that's really a pipe to the syslogger process.\n\t\t */\n\t\telse if (pgwin32_is_service())\n\t\t\twrite_eventlog(edata->elevel, buf.data, buf.len);\n#endif\n\t\telse\n\t\t\twrite_console(buf.data, buf.len);\n\t}\n\n\t/* If in the syslogger process, try to write messages direct to file */\n\tif (am_syslogger)\n\t\twrite_syslogger_file(buf.data, buf.len, LOG_DESTINATION_STDERR);\n\n\t/* Write to CSV log if enabled */\n\tif (Log_destination & LOG_DESTINATION_CSVLOG)\n\t{\n\t\tif (redirection_done || am_syslogger)\n\t\t{\n\t\t\t/*\n\t\t\t * send CSV data if it's safe to do so (syslogger doesn't need the\n\t\t\t * pipe). First get back the space in the message buffer.\n\t\t\t */\n\t\t\tpfree(buf.data);\n\t\t\twrite_csvlog(edata);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/*\n\t\t\t * syslogger not up (yet), so just dump the message to stderr,\n\t\t\t * unless we already did so above.\n\t\t\t */\n\t\t\tif (!(Log_destination & LOG_DESTINATION_STDERR) &&\n\t\t\t\twhereToSendOutput != DestDebug)\n\t\t\t\twrite_console(buf.data, buf.len);\n\t\t\tpfree(buf.data);\n\t\t}\n\t}\n\telse\n\t{\n\t\tpfree(buf.data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "edata"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nemit_log_hook_type emit_log_hook = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nvoid\nEmitErrorReport(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\t/*\n\t * Call hook before sending message to log.  The hook function is allowed\n\t * to turn off edata->output_to_server, so we must recheck that afterward.\n\t * Making any other change in the content of edata is not considered\n\t * supported.\n\t *\n\t * Note: the reason why the hook can only turn off output_to_server, and\n\t * not turn it on, is that it'd be unreliable: we will never get here at\n\t * all if errstart() deems the message uninteresting.  A hook that could\n\t * make decisions in that direction would have to hook into errstart(),\n\t * where it would have much less information available.  emit_log_hook is\n\t * intended for custom log filtering and custom log message transmission\n\t * mechanisms.\n\t *\n\t * The log hook has access to both the translated and original English\n\t * error message text, which is passed through to allow it to be used as a\n\t * message identifier. Note that the original text is not available for\n\t * detail, detail_log, hint and context text elements.\n\t */\n\tif (edata->output_to_server && emit_log_hook)\n\t\t(*emit_log_hook) (edata);\n\n\t/* Send to server log, if enabled */\n\tif (edata->output_to_server)\n\t\tsend_message_to_server_log(edata);\n\n\t/* Send to client, if enabled */\n\tif (edata->output_to_client)\n\t\tsend_message_to_frontend(edata);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n}"
  },
  {
    "function_name": "format_elog_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1410-1433",
    "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static int\tsave_format_errnumber;",
      "static const char *save_format_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "message",
            "false",
            "true"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ErrorContext"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_TEXTDOMAIN",
          "args": [
            "\"postgres\""
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "edata",
            "0",
            "sizeof(ErrorData)"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
  },
  {
    "function_name": "pre_format_elog_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1401-1408",
    "snippet": "void\npre_format_elog_string(int errnumber, const char *domain)\n{\n\t/* Save errno before evaluation of argument functions can change it */\n\tsave_format_errnumber = errnumber;\n\t/* Save caller's text domain */\n\tsave_format_domain = domain;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tsave_format_errnumber;",
      "static const char *save_format_domain;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nvoid\npre_format_elog_string(int errnumber, const char *domain)\n{\n\t/* Save errno before evaluation of argument functions can change it */\n\tsave_format_errnumber = errnumber;\n\t/* Save caller's text domain */\n\tsave_format_domain = domain;\n}"
  },
  {
    "function_name": "elog_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1345-1377",
    "snippet": "void\nelog_finish(int elevel, const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\tCHECK_STACK_DEPTH();\n\n\t/*\n\t * Do errstart() to see if we actually want to report the message.\n\t */\n\terrordata_stack_depth--;\n\terrno = edata->saved_errno;\n\tif (!errstart(elevel, edata->filename, edata->lineno, edata->funcname, NULL))\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/*\n\t * Format error message just like errmsg_internal().\n\t */\n\trecursion_depth++;\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * And let errfinish() finish up.\n\t */\n\terrfinish(0);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "errfinish",
          "args": [
            "0"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "errfinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "412-564",
          "snippet": "void\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ErrorContextCallback *error_context_stack = NULL;",
            "sigjmp_buf *PG_exception_stack = NULL;",
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "message",
            "false",
            "false"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errstart",
          "args": [
            "elevel",
            "edata->filename",
            "edata->lineno",
            "edata->funcname",
            "NULL"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "errstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "232-402",
          "snippet": "bool\nerrstart(int elevel, const char *filename, int lineno,\n\t\t const char *funcname, const char *domain)\n{\n\tErrorData  *edata;\n\tbool\t\toutput_to_server;\n\tbool\t\toutput_to_client = false;\n\tint\t\t\ti;\n\n\t/*\n\t * Check some cases in which we want to promote an error into a more\n\t * severe error.  None of this logic applies for non-error messages.\n\t */\n\tif (elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * If we are inside a critical section, all errors become PANIC\n\t\t * errors.  See miscadmin.h.\n\t\t */\n\t\tif (CritSectionCount > 0)\n\t\t\televel = PANIC;\n\n\t\t/*\n\t\t * Check reasons for treating ERROR as FATAL:\n\t\t *\n\t\t * 1. we have no handler to pass the error to (implies we are in the\n\t\t * postmaster or in backend startup).\n\t\t *\n\t\t * 2. ExitOnAnyError mode switch is set (initdb uses this).\n\t\t *\n\t\t * 3. the error occurred after proc_exit has begun to run.  (It's\n\t\t * proc_exit's responsibility to see that this doesn't turn into\n\t\t * infinite recursion!)\n\t\t */\n\t\tif (elevel == ERROR)\n\t\t{\n\t\t\tif (PG_exception_stack == NULL ||\n\t\t\t\tExitOnAnyError ||\n\t\t\t\tproc_exit_inprogress)\n\t\t\t\televel = FATAL;\n\t\t}\n\n\t\t/*\n\t\t * If the error level is ERROR or more, errfinish is not going to\n\t\t * return to caller; therefore, if there is any stacked error already\n\t\t * in progress it will be lost.  This is more or less okay, except we\n\t\t * do not want to have a FATAL or PANIC error downgraded because the\n\t\t * reporting process was interrupted by a lower-grade error.  So check\n\t\t * the stack and make sure we panic if panic is warranted.\n\t\t */\n\t\tfor (i = 0; i <= errordata_stack_depth; i++)\n\t\t\televel = Max(elevel, errordata[i].elevel);\n\t}\n\n\t/*\n\t * Now decide whether we need to process this report at all; if it's\n\t * warning or less and not enabled for logging, just return false without\n\t * starting up any error logging machinery.\n\t */\n\n\t/* Determine whether message is enabled for server log output */\n\toutput_to_server = is_log_level_output(elevel, log_min_messages);\n\n\t/* Determine whether message is enabled for client output */\n\tif (whereToSendOutput == DestRemote && elevel != LOG_SERVER_ONLY)\n\t{\n\t\t/*\n\t\t * client_min_messages is honored only after we complete the\n\t\t * authentication handshake.  This is required both for security\n\t\t * reasons and because many clients can't handle NOTICE messages\n\t\t * during authentication.\n\t\t */\n\t\tif (ClientAuthInProgress)\n\t\t\toutput_to_client = (elevel >= ERROR);\n\t\telse\n\t\t\toutput_to_client = (elevel >= client_min_messages ||\n\t\t\t\t\t\t\t\televel == INFO);\n\t}\n\n\t/* Skip processing effort if non-error message will not be output */\n\tif (elevel < ERROR && !output_to_server && !output_to_client)\n\t\treturn false;\n\n\t/*\n\t * We need to do some actual work.  Make sure that memory context\n\t * initialization has finished, else we can't do anything useful.\n\t */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\n\tif (recursion_depth++ > 0 && elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * Oops, error during error processing.  Clear ErrorContext as\n\t\t * discussed at top of file.  We will not return to the original\n\t\t * error's reporter or handler, so we don't need it.\n\t\t */\n\t\tMemoryContextReset(ErrorContext);\n\n\t\t/*\n\t\t * Infinite error recursion might be due to something broken in a\n\t\t * context traceback routine.  Abandon them too.  We also abandon\n\t\t * attempting to print the error statement (which, if long, could\n\t\t * itself be the source of the recursive failure).\n\t\t */\n\t\tif (in_error_recursion_trouble())\n\t\t{\n\t\t\terror_context_stack = NULL;\n\t\t\tdebug_query_string = NULL;\n\t\t}\n\t}\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/* Initialize data for this error frame */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\tedata->elevel = elevel;\n\tedata->output_to_server = output_to_server;\n\tedata->output_to_client = output_to_client;\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* the default text domain is the backend's */\n\tedata->domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* initialize context_domain the same way (see set_errcontext_domain()) */\n\tedata->context_domain = edata->domain;\n\t/* Select default errcode based on elevel */\n\tif (elevel >= ERROR)\n\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\telse if (elevel == WARNING)\n\t\tedata->sqlerrcode = ERRCODE_WARNING;\n\telse\n\t\tedata->sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;\n\t/* errno is saved here so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/*\n\t * Any allocations for this error state level should go into ErrorContext\n\t */\n\tedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\treturn true;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [
            "#define ERRORDATA_STACK_SIZE  5"
          ],
          "globals_used": [
            "ErrorContextCallback *error_context_stack = NULL;",
            "sigjmp_buf *PG_exception_stack = NULL;",
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static const char *error_severity(int elevel);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define ERRORDATA_STACK_SIZE  5\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nbool\nerrstart(int elevel, const char *filename, int lineno,\n\t\t const char *funcname, const char *domain)\n{\n\tErrorData  *edata;\n\tbool\t\toutput_to_server;\n\tbool\t\toutput_to_client = false;\n\tint\t\t\ti;\n\n\t/*\n\t * Check some cases in which we want to promote an error into a more\n\t * severe error.  None of this logic applies for non-error messages.\n\t */\n\tif (elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * If we are inside a critical section, all errors become PANIC\n\t\t * errors.  See miscadmin.h.\n\t\t */\n\t\tif (CritSectionCount > 0)\n\t\t\televel = PANIC;\n\n\t\t/*\n\t\t * Check reasons for treating ERROR as FATAL:\n\t\t *\n\t\t * 1. we have no handler to pass the error to (implies we are in the\n\t\t * postmaster or in backend startup).\n\t\t *\n\t\t * 2. ExitOnAnyError mode switch is set (initdb uses this).\n\t\t *\n\t\t * 3. the error occurred after proc_exit has begun to run.  (It's\n\t\t * proc_exit's responsibility to see that this doesn't turn into\n\t\t * infinite recursion!)\n\t\t */\n\t\tif (elevel == ERROR)\n\t\t{\n\t\t\tif (PG_exception_stack == NULL ||\n\t\t\t\tExitOnAnyError ||\n\t\t\t\tproc_exit_inprogress)\n\t\t\t\televel = FATAL;\n\t\t}\n\n\t\t/*\n\t\t * If the error level is ERROR or more, errfinish is not going to\n\t\t * return to caller; therefore, if there is any stacked error already\n\t\t * in progress it will be lost.  This is more or less okay, except we\n\t\t * do not want to have a FATAL or PANIC error downgraded because the\n\t\t * reporting process was interrupted by a lower-grade error.  So check\n\t\t * the stack and make sure we panic if panic is warranted.\n\t\t */\n\t\tfor (i = 0; i <= errordata_stack_depth; i++)\n\t\t\televel = Max(elevel, errordata[i].elevel);\n\t}\n\n\t/*\n\t * Now decide whether we need to process this report at all; if it's\n\t * warning or less and not enabled for logging, just return false without\n\t * starting up any error logging machinery.\n\t */\n\n\t/* Determine whether message is enabled for server log output */\n\toutput_to_server = is_log_level_output(elevel, log_min_messages);\n\n\t/* Determine whether message is enabled for client output */\n\tif (whereToSendOutput == DestRemote && elevel != LOG_SERVER_ONLY)\n\t{\n\t\t/*\n\t\t * client_min_messages is honored only after we complete the\n\t\t * authentication handshake.  This is required both for security\n\t\t * reasons and because many clients can't handle NOTICE messages\n\t\t * during authentication.\n\t\t */\n\t\tif (ClientAuthInProgress)\n\t\t\toutput_to_client = (elevel >= ERROR);\n\t\telse\n\t\t\toutput_to_client = (elevel >= client_min_messages ||\n\t\t\t\t\t\t\t\televel == INFO);\n\t}\n\n\t/* Skip processing effort if non-error message will not be output */\n\tif (elevel < ERROR && !output_to_server && !output_to_client)\n\t\treturn false;\n\n\t/*\n\t * We need to do some actual work.  Make sure that memory context\n\t * initialization has finished, else we can't do anything useful.\n\t */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\n\tif (recursion_depth++ > 0 && elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * Oops, error during error processing.  Clear ErrorContext as\n\t\t * discussed at top of file.  We will not return to the original\n\t\t * error's reporter or handler, so we don't need it.\n\t\t */\n\t\tMemoryContextReset(ErrorContext);\n\n\t\t/*\n\t\t * Infinite error recursion might be due to something broken in a\n\t\t * context traceback routine.  Abandon them too.  We also abandon\n\t\t * attempting to print the error statement (which, if long, could\n\t\t * itself be the source of the recursive failure).\n\t\t */\n\t\tif (in_error_recursion_trouble())\n\t\t{\n\t\t\terror_context_stack = NULL;\n\t\t\tdebug_query_string = NULL;\n\t\t}\n\t}\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/* Initialize data for this error frame */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\tedata->elevel = elevel;\n\tedata->output_to_server = output_to_server;\n\tedata->output_to_client = output_to_client;\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* the default text domain is the backend's */\n\tedata->domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* initialize context_domain the same way (see set_errcontext_domain()) */\n\tedata->context_domain = edata->domain;\n\t/* Select default errcode based on elevel */\n\tif (elevel >= ERROR)\n\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\telse if (elevel == WARNING)\n\t\tedata->sqlerrcode = ERRCODE_WARNING;\n\telse\n\t\tedata->sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;\n\t/* errno is saved here so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/*\n\t * Any allocations for this error state level should go into ErrorContext\n\t */\n\tedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\nelog_finish(int elevel, const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\tCHECK_STACK_DEPTH();\n\n\t/*\n\t * Do errstart() to see if we actually want to report the message.\n\t */\n\terrordata_stack_depth--;\n\terrno = edata->saved_errno;\n\tif (!errstart(elevel, edata->filename, edata->lineno, edata->funcname, NULL))\n\t\treturn;\t\t\t\t\t/* nothing to do */\n\n\t/*\n\t * Format error message just like errmsg_internal().\n\t */\n\trecursion_depth++;\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * And let errfinish() finish up.\n\t */\n\terrfinish(0);\n}"
  },
  {
    "function_name": "elog_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1295-1340",
    "snippet": "void\nelog_start(const char *filename, int lineno, const char *funcname)\n{\n\tErrorData  *edata;\n\n\t/* Make sure that memory context initialization has finished */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.  Note that the message is intentionally not localized,\n\t\t * else failure to convert it to client encoding could cause further\n\t\t * recursion.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\tedata = &errordata[errordata_stack_depth];\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* errno is saved now so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/* Use ErrorContext for any allocations done at this level. */\n\tedata->assoc_context = ErrorContext;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRORDATA_STACK_SIZE  5"
    ],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "filename",
            "'/'"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "PANIC",
            "(errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\"))"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"ERRORDATA_STACK_SIZE exceeded\""
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_stderr",
          "args": [
            "\"error occurred at %s:%d before error message processing is available\\n\"",
            "filename ? filename : \"(unknown file)\"",
            "lineno"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define ERRORDATA_STACK_SIZE  5\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nvoid\nelog_start(const char *filename, int lineno, const char *funcname)\n{\n\tErrorData  *edata;\n\n\t/* Make sure that memory context initialization has finished */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.  Note that the message is intentionally not localized,\n\t\t * else failure to convert it to client encoding could cause further\n\t\t * recursion.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\tedata = &errordata[errordata_stack_depth];\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* errno is saved now so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/* Use ErrorContext for any allocations done at this level. */\n\tedata->assoc_context = ErrorContext;\n}"
  },
  {
    "function_name": "getinternalerrposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1271-1280",
    "snippet": "int\ngetinternalerrposition(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\treturn edata->internalpos;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\ngetinternalerrposition(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\treturn edata->internalpos;\n}"
  },
  {
    "function_name": "geterrposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1254-1263",
    "snippet": "int\ngeterrposition(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\treturn edata->cursorpos;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\ngeterrposition(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\treturn edata->cursorpos;\n}"
  },
  {
    "function_name": "geterrcode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1237-1246",
    "snippet": "int\ngeterrcode(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\treturn edata->sqlerrcode;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\ngeterrcode(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\treturn edata->sqlerrcode;\n}"
  },
  {
    "function_name": "set_errdata_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1224-1229",
    "snippet": "static void\nset_errdata_field(MemoryContextData *cxt, char **ptr, const char *str)\n{\n\tAssert(*ptr == NULL);\n\t*ptr = MemoryContextStrdup(cxt, str);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
      "static void append_with_tabs(StringInfo buf, const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "cxt",
            "str"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Assert",
          "args": [
            "*ptr == NULL"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic void\nset_errdata_field(MemoryContextData *cxt, char **ptr, const char *str)\n{\n\tAssert(*ptr == NULL);\n\t*ptr = MemoryContextStrdup(cxt, str);\n}"
  },
  {
    "function_name": "err_generic_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1188-1219",
    "snippet": "int\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static void append_with_tabs(StringInfo buf, const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "elog",
          "args": [
            "ERROR",
            "\"unsupported ErrorData field id: %d\"",
            "field"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "format_elog_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1410-1433",
          "snippet": "char *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
            "static int\tsave_format_errnumber;",
            "static const char *save_format_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic int\tsave_format_errnumber;\nstatic const char *save_format_domain;\n\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_errdata_field",
          "args": [
            "edata->assoc_context",
            "&edata->constraint_name",
            "str"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "set_errdata_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1224-1229",
          "snippet": "static void\nset_errdata_field(MemoryContextData *cxt, char **ptr, const char *str)\n{\n\tAssert(*ptr == NULL);\n\t*ptr = MemoryContextStrdup(cxt, str);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
            "static void append_with_tabs(StringInfo buf, const char *str);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic void\nset_errdata_field(MemoryContextData *cxt, char **ptr, const char *str)\n{\n\tAssert(*ptr == NULL);\n\t*ptr = MemoryContextStrdup(cxt, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nint\nerr_generic_string(int field, const char *str)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (field)\n\t{\n\t\tcase PG_DIAG_SCHEMA_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->schema_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_TABLE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->table_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_COLUMN_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->column_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_DATATYPE_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->datatype_name, str);\n\t\t\tbreak;\n\t\tcase PG_DIAG_CONSTRAINT_NAME:\n\t\t\tset_errdata_field(edata->assoc_context, &edata->constraint_name, str);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telog(ERROR, \"unsupported ErrorData field id: %d\", field);\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "internalerrquery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1158-1176",
    "snippet": "int\ninternalerrquery(const char *query)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tif (edata->internalquery)\n\t{\n\t\tpfree(edata->internalquery);\n\t\tedata->internalquery = NULL;\n\t}\n\n\tif (query)\n\t\tedata->internalquery = MemoryContextStrdup(edata->assoc_context, query);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextStrdup",
          "args": [
            "edata->assoc_context",
            "query"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextStrdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1147-1158",
          "snippet": "char *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nchar *\nMemoryContextStrdup(MemoryContext context, const char *string)\n{\n\tchar\t   *nstr;\n\tSize\t\tlen = strlen(string) + 1;\n\n\tnstr = (char *) MemoryContextAlloc(context, len);\n\n\tmemcpy(nstr, string, len);\n\n\treturn nstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "edata->internalquery"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\ninternalerrquery(const char *query)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tif (edata->internalquery)\n\t{\n\t\tpfree(edata->internalquery);\n\t\tedata->internalquery = NULL;\n\t}\n\n\tif (query)\n\t\tedata->internalquery = MemoryContextStrdup(edata->assoc_context, query);\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "internalerrposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1138-1149",
    "snippet": "int\ninternalerrposition(int cursorpos)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->internalpos = cursorpos;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\ninternalerrposition(int cursorpos)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->internalpos = cursorpos;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errposition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1122-1133",
    "snippet": "int\nerrposition(int cursorpos)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->cursorpos = cursorpos;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrposition(int cursorpos)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->cursorpos = cursorpos;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errfunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1105-1117",
    "snippet": "int\nerrfunction(const char *funcname)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->funcname = funcname;\n\tedata->show_funcname = true;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrfunction(const char *funcname)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->funcname = funcname;\n\tedata->show_funcname = true;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errhidecontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1084-1095",
    "snippet": "int\nerrhidecontext(bool hide_ctx)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->hide_ctx = hide_ctx;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhidecontext(bool hide_ctx)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->hide_ctx = hide_ctx;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errhidestmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1065-1076",
    "snippet": "int\nerrhidestmt(bool hide_stmt)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->hide_stmt = hide_stmt;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhidestmt(bool hide_stmt)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->hide_stmt = hide_stmt;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "set_errcontext_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1045-1057",
    "snippet": "int\nset_errcontext_domain(const char *domain)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\t/* the default text domain is the backend's */\n\tedata->context_domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_TEXTDOMAIN",
          "args": [
            "\"postgres\""
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nset_errcontext_domain(const char *domain)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\t/* the default text domain is the backend's */\n\tedata->context_domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errcontext_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "1009-1024",
    "snippet": "int\nerrcontext_msg(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->context_domain, context, true, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->context_domain",
            "context",
            "true",
            "true"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcontext_msg(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->context_domain, context, true, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errhint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "984-999",
    "snippet": "int\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "hint",
            "false",
            "true"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrhint(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, hint, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errdetail_plural",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "962-978",
    "snippet": "int\nerrdetail_plural(const char *fmt_singular, const char *fmt_plural,\n\t\t\t\t unsigned long n,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE_PLURAL(edata->domain, detail, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE_PLURAL",
          "args": [
            "edata->domain",
            "detail",
            "false"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_plural(const char *fmt_singular, const char *fmt_plural,\n\t\t\t\t unsigned long n,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE_PLURAL(edata->domain, detail, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errdetail_log_plural",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "939-955",
    "snippet": "int\nerrdetail_log_plural(const char *fmt_singular, const char *fmt_plural,\n\t\t\t\t\t unsigned long n,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE_PLURAL(edata->domain, detail_log, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE_PLURAL",
          "args": [
            "edata->domain",
            "detail_log",
            "false"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log_plural(const char *fmt_singular, const char *fmt_plural,\n\t\t\t\t\t unsigned long n,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE_PLURAL(edata->domain, detail_log, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errdetail_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "918-933",
    "snippet": "int\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "detail_log",
            "false",
            "true"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_log(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail_log, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errdetail_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "897-912",
    "snippet": "int\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "detail",
            "false",
            "false"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errdetail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "870-885",
    "snippet": "int\nerrdetail(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "detail",
            "false",
            "true"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrdetail(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tEVALUATE_MESSAGE(edata->domain, detail, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errmsg_plural",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "847-864",
    "snippet": "int\nerrmsg_plural(const char *fmt_singular, const char *fmt_plural,\n\t\t\t  unsigned long n,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt_singular;\n\tEVALUATE_MESSAGE_PLURAL(edata->domain, message, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE_PLURAL",
          "args": [
            "edata->domain",
            "message",
            "false"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_plural(const char *fmt_singular, const char *fmt_plural,\n\t\t\t  unsigned long n,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt_singular;\n\tEVALUATE_MESSAGE_PLURAL(edata->domain, message, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errmsg_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "824-840",
    "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "message",
            "false",
            "false"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "794-810",
    "snippet": "int\nerrmsg(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVALUATE_MESSAGE",
          "args": [
            "edata->domain",
            "message",
            "false",
            "true"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "edata->assoc_context"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errcode_for_socket_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "666-691",
    "snippet": "int\nerrcode_for_socket_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Loss of connection */\n\t\tcase EPIPE:\n#ifdef ECONNRESET\n\t\tcase ECONNRESET:\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_CONNECTION_FAILURE;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_socket_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Loss of connection */\n\t\tcase EPIPE:\n#ifdef ECONNRESET\n\t\tcase ECONNRESET:\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_CONNECTION_FAILURE;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errcode_for_file_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "595-655",
    "snippet": "int\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode_for_file_access(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tswitch (edata->saved_errno)\n\t{\n\t\t\t/* Permission-denied failures */\n\t\tcase EPERM:\t\t\t\t/* Not super-user */\n\t\tcase EACCES:\t\t\t/* Permission denied */\n#ifdef EROFS\n\t\tcase EROFS:\t\t\t\t/* Read only file system */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_PRIVILEGE;\n\t\t\tbreak;\n\n\t\t\t/* File not found */\n\t\tcase ENOENT:\t\t\t/* No such file or directory */\n\t\t\tedata->sqlerrcode = ERRCODE_UNDEFINED_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Duplicate file */\n\t\tcase EEXIST:\t\t\t/* File exists */\n\t\t\tedata->sqlerrcode = ERRCODE_DUPLICATE_FILE;\n\t\t\tbreak;\n\n\t\t\t/* Wrong object type or state */\n\t\tcase ENOTDIR:\t\t\t/* Not a directory */\n\t\tcase EISDIR:\t\t\t/* Is a directory */\n#if defined(ENOTEMPTY) && (ENOTEMPTY != EEXIST) /* same code on AIX */\n\t\tcase ENOTEMPTY:\t\t\t/* Directory not empty */\n#endif\n\t\t\tedata->sqlerrcode = ERRCODE_WRONG_OBJECT_TYPE;\n\t\t\tbreak;\n\n\t\t\t/* Insufficient resources */\n\t\tcase ENOSPC:\t\t\t/* No space left on device */\n\t\t\tedata->sqlerrcode = ERRCODE_DISK_FULL;\n\t\t\tbreak;\n\n\t\tcase ENFILE:\t\t\t/* File table overflow */\n\t\tcase EMFILE:\t\t\t/* Too many open files */\n\t\t\tedata->sqlerrcode = ERRCODE_INSUFFICIENT_RESOURCES;\n\t\t\tbreak;\n\n\t\t\t/* Hardware failure */\n\t\tcase EIO:\t\t\t\t/* I/O error */\n\t\t\tedata->sqlerrcode = ERRCODE_IO_ERROR;\n\t\t\tbreak;\n\n\t\t\t/* All else is classified as internal errors */\n\t\tdefault:\n\t\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\t\t\tbreak;\n\t}\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errcode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "572-583",
    "snippet": "int\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrcode(int sqlerrcode)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\n\t/* we don't bother incrementing recursion_depth */\n\tCHECK_STACK_DEPTH();\n\n\tedata->sqlerrcode = sqlerrcode;\n\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
  },
  {
    "function_name": "errfinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "412-564",
    "snippet": "void\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ErrorContextCallback *error_context_stack = NULL;",
      "sigjmp_buf *PG_exception_stack = NULL;",
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_FOR_INTERRUPTS",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_exit",
          "args": [
            "1"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "oldcontext"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfree",
          "args": [
            "edata->internalquery"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "pfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "1030-1037",
          "snippet": "void\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\npfree(void *pointer)\n{\n\tMemoryContext context = GetMemoryChunkContext(pointer);\n\n\tcontext->methods->free_p(context, pointer);\n\tVALGRIND_MEMPOOL_FREE(context, pointer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EmitErrorReport",
          "args": [],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "EmitErrorReport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "1443-1485",
          "snippet": "void\nEmitErrorReport(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\t/*\n\t * Call hook before sending message to log.  The hook function is allowed\n\t * to turn off edata->output_to_server, so we must recheck that afterward.\n\t * Making any other change in the content of edata is not considered\n\t * supported.\n\t *\n\t * Note: the reason why the hook can only turn off output_to_server, and\n\t * not turn it on, is that it'd be unreliable: we will never get here at\n\t * all if errstart() deems the message uninteresting.  A hook that could\n\t * make decisions in that direction would have to hook into errstart(),\n\t * where it would have much less information available.  emit_log_hook is\n\t * intended for custom log filtering and custom log message transmission\n\t * mechanisms.\n\t *\n\t * The log hook has access to both the translated and original English\n\t * error message text, which is passed through to allow it to be used as a\n\t * message identifier. Note that the original text is not available for\n\t * detail, detail_log, hint and context text elements.\n\t */\n\tif (edata->output_to_server && emit_log_hook)\n\t\t(*emit_log_hook) (edata);\n\n\t/* Send to server log, if enabled */\n\tif (edata->output_to_server)\n\t\tsend_message_to_server_log(edata);\n\n\t/* Send to client, if enabled */\n\tif (edata->output_to_client)\n\t\tsend_message_to_frontend(edata);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "emit_log_hook_type emit_log_hook = NULL;",
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nemit_log_hook_type emit_log_hook = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nvoid\nEmitErrorReport(void)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\t/*\n\t * Call hook before sending message to log.  The hook function is allowed\n\t * to turn off edata->output_to_server, so we must recheck that afterward.\n\t * Making any other change in the content of edata is not considered\n\t * supported.\n\t *\n\t * Note: the reason why the hook can only turn off output_to_server, and\n\t * not turn it on, is that it'd be unreliable: we will never get here at\n\t * all if errstart() deems the message uninteresting.  A hook that could\n\t * make decisions in that direction would have to hook into errstart(),\n\t * where it would have much less information available.  emit_log_hook is\n\t * intended for custom log filtering and custom log message transmission\n\t * mechanisms.\n\t *\n\t * The log hook has access to both the translated and original English\n\t * error message text, which is passed through to allow it to be used as a\n\t * message identifier. Note that the original text is not available for\n\t * detail, detail_log, hint and context text elements.\n\t */\n\tif (edata->output_to_server && emit_log_hook)\n\t\t(*emit_log_hook) (edata);\n\n\t/* Send to server log, if enabled */\n\tif (edata->output_to_server)\n\t\tsend_message_to_server_log(edata);\n\n\t/* Send to client, if enabled */\n\tif (edata->output_to_client)\n\t\tsend_message_to_frontend(edata);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pq_endcopyout",
          "args": [
            "true"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PG_RE_THROW",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "econtext->callback",
          "args": [
            "econtext->arg"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemoryContextSwitchTo",
          "args": [
            "ErrorContext"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_STACK_DEPTH",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nvoid\nerrfinish(int dummy,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tint\t\t\televel;\n\tMemoryContext oldcontext;\n\tErrorContextCallback *econtext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\televel = edata->elevel;\n\n\t/*\n\t * Do processing in ErrorContext, which we hope has enough reserved space\n\t * to report an error.\n\t */\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\t/*\n\t * Call any context callback functions.  Errors occurring in callback\n\t * functions will be treated as recursive errors --- this ensures we will\n\t * avoid infinite recursion (see errstart).\n\t */\n\tfor (econtext = error_context_stack;\n\t\t econtext != NULL;\n\t\t econtext = econtext->previous)\n\t\tecontext->callback(econtext->arg);\n\n\t/*\n\t * If ERROR (not more nor less) we pass it off to the current handler.\n\t * Printing it and popping the stack is the responsibility of the handler.\n\t */\n\tif (elevel == ERROR)\n\t{\n\t\t/*\n\t\t * We do some minimal cleanup before longjmp'ing so that handlers can\n\t\t * execute in a reasonably sane state.\n\t\t *\n\t\t * Reset InterruptHoldoffCount in case we ereport'd from inside an\n\t\t * interrupt holdoff section.  (We assume here that no handler will\n\t\t * itself be inside a holdoff section.  If necessary, such a handler\n\t\t * could save and restore InterruptHoldoffCount for itself, but this\n\t\t * should make life easier for most.)\n\t\t */\n\t\tInterruptHoldoffCount = 0;\n\t\tQueryCancelHoldoffCount = 0;\n\n\t\tCritSectionCount = 0;\t/* should be unnecessary, but... */\n\n\t\t/*\n\t\t * Note that we leave CurrentMemoryContext set to ErrorContext. The\n\t\t * handler should reset it to something else soon.\n\t\t */\n\n\t\trecursion_depth--;\n\t\tPG_RE_THROW();\n\t}\n\n\t/*\n\t * If we are doing FATAL or PANIC, abort any old-style COPY OUT in\n\t * progress, so that we can report the message before dying.  (Without\n\t * this, pq_putmessage will refuse to send the message at all, which is\n\t * what we want for NOTICE messages, but not for fatal exits.) This hack\n\t * is necessary because of poor design of old-style copy protocol.\n\t */\n\tif (elevel >= FATAL && whereToSendOutput == DestRemote)\n\t\tpq_endcopyout(true);\n\n\t/* Emit the message to the right places */\n\tEmitErrorReport();\n\n\t/* Now free up subsidiary data attached to stack entry, and release it */\n\tif (edata->message)\n\t\tpfree(edata->message);\n\tif (edata->detail)\n\t\tpfree(edata->detail);\n\tif (edata->detail_log)\n\t\tpfree(edata->detail_log);\n\tif (edata->hint)\n\t\tpfree(edata->hint);\n\tif (edata->context)\n\t\tpfree(edata->context);\n\tif (edata->schema_name)\n\t\tpfree(edata->schema_name);\n\tif (edata->table_name)\n\t\tpfree(edata->table_name);\n\tif (edata->column_name)\n\t\tpfree(edata->column_name);\n\tif (edata->datatype_name)\n\t\tpfree(edata->datatype_name);\n\tif (edata->constraint_name)\n\t\tpfree(edata->constraint_name);\n\tif (edata->internalquery)\n\t\tpfree(edata->internalquery);\n\n\terrordata_stack_depth--;\n\n\t/* Exit error-handling context */\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\n\t/*\n\t * Perform error recovery action as specified by elevel.\n\t */\n\tif (elevel == FATAL)\n\t{\n\t\t/*\n\t\t * For a FATAL error, we let proc_exit clean up and exit.\n\t\t *\n\t\t * If we just reported a startup failure, the client will disconnect\n\t\t * on receiving it, so don't send any more to the client.\n\t\t */\n\t\tif (PG_exception_stack == NULL && whereToSendOutput == DestRemote)\n\t\t\twhereToSendOutput = DestNone;\n\n\t\t/*\n\t\t * fflush here is just to improve the odds that we get to see the\n\t\t * error message, in case things are so hosed that proc_exit crashes.\n\t\t * Any other code you might be tempted to add here should probably be\n\t\t * in an on_proc_exit or on_shmem_exit callback instead.\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\n\t\t/*\n\t\t * Do normal process-exit cleanup, then return exit code 1 to indicate\n\t\t * FATAL termination.  The postmaster may or may not consider this\n\t\t * worthy of panic, depending on which subprocess returns it.\n\t\t */\n\t\tproc_exit(1);\n\t}\n\n\tif (elevel >= PANIC)\n\t{\n\t\t/*\n\t\t * Serious crash time. Postmaster will observe SIGABRT process exit\n\t\t * status and kill the other backends too.\n\t\t *\n\t\t * XXX: what if we are *in* the postmaster?  abort() won't kill our\n\t\t * children...\n\t\t */\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t\tabort();\n\t}\n\n\t/*\n\t * Check for cancel/die interrupt first --- this is so that the user can\n\t * stop a query emitting tons of notice or warning messages, even if it's\n\t * in a loop that otherwise fails to check for interrupts.\n\t */\n\tCHECK_FOR_INTERRUPTS();\n}"
  },
  {
    "function_name": "errstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "232-402",
    "snippet": "bool\nerrstart(int elevel, const char *filename, int lineno,\n\t\t const char *funcname, const char *domain)\n{\n\tErrorData  *edata;\n\tbool\t\toutput_to_server;\n\tbool\t\toutput_to_client = false;\n\tint\t\t\ti;\n\n\t/*\n\t * Check some cases in which we want to promote an error into a more\n\t * severe error.  None of this logic applies for non-error messages.\n\t */\n\tif (elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * If we are inside a critical section, all errors become PANIC\n\t\t * errors.  See miscadmin.h.\n\t\t */\n\t\tif (CritSectionCount > 0)\n\t\t\televel = PANIC;\n\n\t\t/*\n\t\t * Check reasons for treating ERROR as FATAL:\n\t\t *\n\t\t * 1. we have no handler to pass the error to (implies we are in the\n\t\t * postmaster or in backend startup).\n\t\t *\n\t\t * 2. ExitOnAnyError mode switch is set (initdb uses this).\n\t\t *\n\t\t * 3. the error occurred after proc_exit has begun to run.  (It's\n\t\t * proc_exit's responsibility to see that this doesn't turn into\n\t\t * infinite recursion!)\n\t\t */\n\t\tif (elevel == ERROR)\n\t\t{\n\t\t\tif (PG_exception_stack == NULL ||\n\t\t\t\tExitOnAnyError ||\n\t\t\t\tproc_exit_inprogress)\n\t\t\t\televel = FATAL;\n\t\t}\n\n\t\t/*\n\t\t * If the error level is ERROR or more, errfinish is not going to\n\t\t * return to caller; therefore, if there is any stacked error already\n\t\t * in progress it will be lost.  This is more or less okay, except we\n\t\t * do not want to have a FATAL or PANIC error downgraded because the\n\t\t * reporting process was interrupted by a lower-grade error.  So check\n\t\t * the stack and make sure we panic if panic is warranted.\n\t\t */\n\t\tfor (i = 0; i <= errordata_stack_depth; i++)\n\t\t\televel = Max(elevel, errordata[i].elevel);\n\t}\n\n\t/*\n\t * Now decide whether we need to process this report at all; if it's\n\t * warning or less and not enabled for logging, just return false without\n\t * starting up any error logging machinery.\n\t */\n\n\t/* Determine whether message is enabled for server log output */\n\toutput_to_server = is_log_level_output(elevel, log_min_messages);\n\n\t/* Determine whether message is enabled for client output */\n\tif (whereToSendOutput == DestRemote && elevel != LOG_SERVER_ONLY)\n\t{\n\t\t/*\n\t\t * client_min_messages is honored only after we complete the\n\t\t * authentication handshake.  This is required both for security\n\t\t * reasons and because many clients can't handle NOTICE messages\n\t\t * during authentication.\n\t\t */\n\t\tif (ClientAuthInProgress)\n\t\t\toutput_to_client = (elevel >= ERROR);\n\t\telse\n\t\t\toutput_to_client = (elevel >= client_min_messages ||\n\t\t\t\t\t\t\t\televel == INFO);\n\t}\n\n\t/* Skip processing effort if non-error message will not be output */\n\tif (elevel < ERROR && !output_to_server && !output_to_client)\n\t\treturn false;\n\n\t/*\n\t * We need to do some actual work.  Make sure that memory context\n\t * initialization has finished, else we can't do anything useful.\n\t */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\n\tif (recursion_depth++ > 0 && elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * Oops, error during error processing.  Clear ErrorContext as\n\t\t * discussed at top of file.  We will not return to the original\n\t\t * error's reporter or handler, so we don't need it.\n\t\t */\n\t\tMemoryContextReset(ErrorContext);\n\n\t\t/*\n\t\t * Infinite error recursion might be due to something broken in a\n\t\t * context traceback routine.  Abandon them too.  We also abandon\n\t\t * attempting to print the error statement (which, if long, could\n\t\t * itself be the source of the recursive failure).\n\t\t */\n\t\tif (in_error_recursion_trouble())\n\t\t{\n\t\t\terror_context_stack = NULL;\n\t\t\tdebug_query_string = NULL;\n\t\t}\n\t}\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/* Initialize data for this error frame */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\tedata->elevel = elevel;\n\tedata->output_to_server = output_to_server;\n\tedata->output_to_client = output_to_client;\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* the default text domain is the backend's */\n\tedata->domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* initialize context_domain the same way (see set_errcontext_domain()) */\n\tedata->context_domain = edata->domain;\n\t/* Select default errcode based on elevel */\n\tif (elevel >= ERROR)\n\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\telse if (elevel == WARNING)\n\t\tedata->sqlerrcode = ERRCODE_WARNING;\n\telse\n\t\tedata->sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;\n\t/* errno is saved here so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/*\n\t * Any allocations for this error state level should go into ErrorContext\n\t */\n\tedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\treturn true;\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [
      "#define ERRORDATA_STACK_SIZE  5"
    ],
    "globals_used": [
      "ErrorContextCallback *error_context_stack = NULL;",
      "sigjmp_buf *PG_exception_stack = NULL;",
      "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
      "static int\terrordata_stack_depth = -1;",
      "static int\trecursion_depth = 0;",
      "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
      "static void write_csvlog(ErrorData *edata);",
      "static void send_message_to_server_log(ErrorData *edata);",
      "static void send_message_to_frontend(ErrorData *edata);",
      "static char *expand_fmt_string(const char *fmt, ErrorData *edata);",
      "static const char *error_severity(int elevel);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PG_TEXTDOMAIN",
          "args": [
            "\"postgres\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "filename",
            "'/'"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MemSet",
          "args": [
            "edata",
            "0",
            "sizeof(ErrorData)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ereport",
          "args": [
            "PANIC",
            "(errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\"))"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "errmsg_internal",
          "args": [
            "\"ERRORDATA_STACK_SIZE exceeded\""
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "errmsg_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "824-840",
          "snippet": "int\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static ErrorData errordata[ERRORDATA_STACK_SIZE];",
            "static int\terrordata_stack_depth = -1;",
            "static int\trecursion_depth = 0;",
            "static void log_line_prefix(StringInfo buf, ErrorData *edata);",
            "static void write_csvlog(ErrorData *edata);",
            "static void send_message_to_server_log(ErrorData *edata);",
            "static void send_message_to_frontend(ErrorData *edata);",
            "static char *expand_fmt_string(const char *fmt, ErrorData *edata);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\n\nint\nerrmsg_internal(const char *fmt,...)\n{\n\tErrorData  *edata = &errordata[errordata_stack_depth];\n\tMemoryContext oldcontext;\n\n\trecursion_depth++;\n\tCHECK_STACK_DEPTH();\n\toldcontext = MemoryContextSwitchTo(edata->assoc_context);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, false);\n\n\tMemoryContextSwitchTo(oldcontext);\n\trecursion_depth--;\n\treturn 0;\t\t\t\t\t/* return value does not matter */\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_error_recursion_trouble",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "in_error_recursion_trouble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "195-200",
          "snippet": "bool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trecursion_depth = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\trecursion_depth = 0;\n\nbool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MemoryContextReset",
          "args": [
            "ErrorContext"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryContextResetChildren",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/mmgr/mcxt.c",
          "lines": "187-199",
          "snippet": "void\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}",
          "includes": [
            "#include \"utils/memutils.h\"",
            "#include \"utils/memdebug.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void MemoryContextCallResetCallbacks(MemoryContext context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/memutils.h\"\n#include \"utils/memdebug.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"postgres.h\"\n\nstatic void MemoryContextCallResetCallbacks(MemoryContext context);\n\nvoid\nMemoryContextResetChildren(MemoryContext context)\n{\n\tMemoryContext child;\n\n\tAssertArg(MemoryContextIsValid(context));\n\n\tfor (child = context->firstchild; child != NULL; child = child->nextchild)\n\t{\n\t\tMemoryContextResetChildren(child);\n\t\tMemoryContextResetOnly(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_stderr",
          "args": [
            "\"error occurred at %s:%d before error message processing is available\\n\"",
            "filename ? filename : \"(unknown file)\"",
            "lineno"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "write_stderr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3668-3703",
          "snippet": "void\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nvoid\nwrite_stderr(const char *fmt,...)\n{\n\tva_list\t\tap;\n\n#ifdef WIN32\n\tchar\t\terrbuf[2048];\t/* Arbitrary size? */\n#endif\n\n\tfmt = _(fmt);\n\n\tva_start(ap, fmt);\n#ifndef WIN32\n\t/* On Unix, we just fprintf to stderr */\n\tvfprintf(stderr, fmt, ap);\n\tfflush(stderr);\n#else\n\tvsnprintf(errbuf, sizeof(errbuf), fmt, ap);\n\n\t/*\n\t * On Win32, we print to stderr if running on a console, or write to\n\t * eventlog if running as a service\n\t */\n\tif (pgwin32_is_service())\t/* Running as a service */\n\t{\n\t\twrite_eventlog(ERROR, errbuf, strlen(errbuf));\n\t}\n\telse\n\t{\n\t\t/* Not running as service, write to stderr */\n\t\twrite_console(errbuf, strlen(errbuf));\n\t\tfflush(stderr);\n\t}\n#endif\n\tva_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_log_level_output",
          "args": [
            "elevel",
            "log_min_messages"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "is_log_level_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "3714-3733",
          "snippet": "static bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *error_severity(int elevel);",
            "static bool is_log_level_output(int elevel, int log_min_level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic const char *error_severity(int elevel);\nstatic bool is_log_level_output(int elevel, int log_min_level);\n\nstatic bool\nis_log_level_output(int elevel, int log_min_level)\n{\n\tif (elevel == LOG || elevel == LOG_SERVER_ONLY)\n\t{\n\t\tif (log_min_level == LOG || log_min_level <= ERROR)\n\t\t\treturn true;\n\t}\n\telse if (log_min_level == LOG)\n\t{\n\t\t/* elevel != LOG */\n\t\tif (elevel >= FATAL)\n\t\t\treturn true;\n\t}\n\t/* Neither is LOG */\n\telse if (elevel >= log_min_level)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Max",
          "args": [
            "elevel",
            "errordata[i].elevel"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\n#define ERRORDATA_STACK_SIZE  5\n\nErrorContextCallback *error_context_stack = NULL;\nsigjmp_buf *PG_exception_stack = NULL;\nstatic ErrorData errordata[ERRORDATA_STACK_SIZE];\nstatic int\terrordata_stack_depth = -1;\nstatic int\trecursion_depth = 0;\nstatic void log_line_prefix(StringInfo buf, ErrorData *edata);\nstatic void write_csvlog(ErrorData *edata);\nstatic void send_message_to_server_log(ErrorData *edata);\nstatic void send_message_to_frontend(ErrorData *edata);\nstatic char *expand_fmt_string(const char *fmt, ErrorData *edata);\nstatic const char *error_severity(int elevel);\n\nbool\nerrstart(int elevel, const char *filename, int lineno,\n\t\t const char *funcname, const char *domain)\n{\n\tErrorData  *edata;\n\tbool\t\toutput_to_server;\n\tbool\t\toutput_to_client = false;\n\tint\t\t\ti;\n\n\t/*\n\t * Check some cases in which we want to promote an error into a more\n\t * severe error.  None of this logic applies for non-error messages.\n\t */\n\tif (elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * If we are inside a critical section, all errors become PANIC\n\t\t * errors.  See miscadmin.h.\n\t\t */\n\t\tif (CritSectionCount > 0)\n\t\t\televel = PANIC;\n\n\t\t/*\n\t\t * Check reasons for treating ERROR as FATAL:\n\t\t *\n\t\t * 1. we have no handler to pass the error to (implies we are in the\n\t\t * postmaster or in backend startup).\n\t\t *\n\t\t * 2. ExitOnAnyError mode switch is set (initdb uses this).\n\t\t *\n\t\t * 3. the error occurred after proc_exit has begun to run.  (It's\n\t\t * proc_exit's responsibility to see that this doesn't turn into\n\t\t * infinite recursion!)\n\t\t */\n\t\tif (elevel == ERROR)\n\t\t{\n\t\t\tif (PG_exception_stack == NULL ||\n\t\t\t\tExitOnAnyError ||\n\t\t\t\tproc_exit_inprogress)\n\t\t\t\televel = FATAL;\n\t\t}\n\n\t\t/*\n\t\t * If the error level is ERROR or more, errfinish is not going to\n\t\t * return to caller; therefore, if there is any stacked error already\n\t\t * in progress it will be lost.  This is more or less okay, except we\n\t\t * do not want to have a FATAL or PANIC error downgraded because the\n\t\t * reporting process was interrupted by a lower-grade error.  So check\n\t\t * the stack and make sure we panic if panic is warranted.\n\t\t */\n\t\tfor (i = 0; i <= errordata_stack_depth; i++)\n\t\t\televel = Max(elevel, errordata[i].elevel);\n\t}\n\n\t/*\n\t * Now decide whether we need to process this report at all; if it's\n\t * warning or less and not enabled for logging, just return false without\n\t * starting up any error logging machinery.\n\t */\n\n\t/* Determine whether message is enabled for server log output */\n\toutput_to_server = is_log_level_output(elevel, log_min_messages);\n\n\t/* Determine whether message is enabled for client output */\n\tif (whereToSendOutput == DestRemote && elevel != LOG_SERVER_ONLY)\n\t{\n\t\t/*\n\t\t * client_min_messages is honored only after we complete the\n\t\t * authentication handshake.  This is required both for security\n\t\t * reasons and because many clients can't handle NOTICE messages\n\t\t * during authentication.\n\t\t */\n\t\tif (ClientAuthInProgress)\n\t\t\toutput_to_client = (elevel >= ERROR);\n\t\telse\n\t\t\toutput_to_client = (elevel >= client_min_messages ||\n\t\t\t\t\t\t\t\televel == INFO);\n\t}\n\n\t/* Skip processing effort if non-error message will not be output */\n\tif (elevel < ERROR && !output_to_server && !output_to_client)\n\t\treturn false;\n\n\t/*\n\t * We need to do some actual work.  Make sure that memory context\n\t * initialization has finished, else we can't do anything useful.\n\t */\n\tif (ErrorContext == NULL)\n\t{\n\t\t/* Oops, hard crash time; very little we can do safely here */\n\t\twrite_stderr(\"error occurred at %s:%d before error message processing is available\\n\",\n\t\t\t\t\t filename ? filename : \"(unknown file)\", lineno);\n\t\texit(2);\n\t}\n\n\t/*\n\t * Okay, crank up a stack entry to store the info in.\n\t */\n\n\tif (recursion_depth++ > 0 && elevel >= ERROR)\n\t{\n\t\t/*\n\t\t * Oops, error during error processing.  Clear ErrorContext as\n\t\t * discussed at top of file.  We will not return to the original\n\t\t * error's reporter or handler, so we don't need it.\n\t\t */\n\t\tMemoryContextReset(ErrorContext);\n\n\t\t/*\n\t\t * Infinite error recursion might be due to something broken in a\n\t\t * context traceback routine.  Abandon them too.  We also abandon\n\t\t * attempting to print the error statement (which, if long, could\n\t\t * itself be the source of the recursive failure).\n\t\t */\n\t\tif (in_error_recursion_trouble())\n\t\t{\n\t\t\terror_context_stack = NULL;\n\t\t\tdebug_query_string = NULL;\n\t\t}\n\t}\n\tif (++errordata_stack_depth >= ERRORDATA_STACK_SIZE)\n\t{\n\t\t/*\n\t\t * Wups, stack not big enough.  We treat this as a PANIC condition\n\t\t * because it suggests an infinite loop of errors during error\n\t\t * recovery.\n\t\t */\n\t\terrordata_stack_depth = -1; /* make room on stack */\n\t\tereport(PANIC, (errmsg_internal(\"ERRORDATA_STACK_SIZE exceeded\")));\n\t}\n\n\t/* Initialize data for this error frame */\n\tedata = &errordata[errordata_stack_depth];\n\tMemSet(edata, 0, sizeof(ErrorData));\n\tedata->elevel = elevel;\n\tedata->output_to_server = output_to_server;\n\tedata->output_to_client = output_to_client;\n\tif (filename)\n\t{\n\t\tconst char *slash;\n\n\t\t/* keep only base name, useful especially for vpath builds */\n\t\tslash = strrchr(filename, '/');\n\t\tif (slash)\n\t\t\tfilename = slash + 1;\n\t}\n\tedata->filename = filename;\n\tedata->lineno = lineno;\n\tedata->funcname = funcname;\n\t/* the default text domain is the backend's */\n\tedata->domain = domain ? domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* initialize context_domain the same way (see set_errcontext_domain()) */\n\tedata->context_domain = edata->domain;\n\t/* Select default errcode based on elevel */\n\tif (elevel >= ERROR)\n\t\tedata->sqlerrcode = ERRCODE_INTERNAL_ERROR;\n\telse if (elevel == WARNING)\n\t\tedata->sqlerrcode = ERRCODE_WARNING;\n\telse\n\t\tedata->sqlerrcode = ERRCODE_SUCCESSFUL_COMPLETION;\n\t/* errno is saved here so that error parameter eval can't change it */\n\tedata->saved_errno = errno;\n\n\t/*\n\t * Any allocations for this error state level should go into ErrorContext\n\t */\n\tedata->assoc_context = ErrorContext;\n\n\trecursion_depth--;\n\treturn true;\n}"
  },
  {
    "function_name": "err_gettext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "207-218",
    "snippet": "static inline const char *\nerr_gettext(const char *str)\n{\n#ifdef ENABLE_NLS\n\tif (in_error_recursion_trouble())\n\t\treturn str;\n\telse\n\t\treturn gettext(str);\n#else\n\treturn str;\n#endif\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);",
      "static void append_with_tabs(StringInfo buf, const char *str);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gettext",
          "args": [
            "str"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "err_gettext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "207-218",
          "snippet": "static inline const char *\nerr_gettext(const char *str)\n{\n#ifdef ENABLE_NLS\n\tif (in_error_recursion_trouble())\n\t\treturn str;\n\telse\n\t\treturn gettext(str);\n#else\n\treturn str;\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "in_error_recursion_trouble",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "in_error_recursion_trouble",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
          "lines": "195-200",
          "snippet": "bool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}",
          "includes": [
            "#include \"utils/ps_status.h\"",
            "#include \"utils/memutils.h\"",
            "#include \"utils/guc.h\"",
            "#include \"tcop/tcopprot.h\"",
            "#include \"storage/proc.h\"",
            "#include \"storage/ipc.h\"",
            "#include \"postmaster/syslogger.h\"",
            "#include \"postmaster/postmaster.h\"",
            "#include \"miscadmin.h\"",
            "#include \"mb/pg_wchar.h\"",
            "#include \"libpq/pqformat.h\"",
            "#include \"libpq/libpq.h\"",
            "#include \"access/xact.h\"",
            "#include \"access/transam.h\"",
            "#include <syslog.h>",
            "#include <ctype.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include \"postgres.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\trecursion_depth = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\trecursion_depth = 0;\n\nbool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic void set_errdata_field(MemoryContextData *cxt, char **ptr, const char *str);\nstatic void append_with_tabs(StringInfo buf, const char *str);\n\nstatic inline const char *\nerr_gettext(const char *str)\n{\n#ifdef ENABLE_NLS\n\tif (in_error_recursion_trouble())\n\t\treturn str;\n\telse\n\t\treturn gettext(str);\n#else\n\treturn str;\n#endif\n}"
  },
  {
    "function_name": "in_error_recursion_trouble",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/error/elog.c",
    "lines": "195-200",
    "snippet": "bool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}",
    "includes": [
      "#include \"utils/ps_status.h\"",
      "#include \"utils/memutils.h\"",
      "#include \"utils/guc.h\"",
      "#include \"tcop/tcopprot.h\"",
      "#include \"storage/proc.h\"",
      "#include \"storage/ipc.h\"",
      "#include \"postmaster/syslogger.h\"",
      "#include \"postmaster/postmaster.h\"",
      "#include \"miscadmin.h\"",
      "#include \"mb/pg_wchar.h\"",
      "#include \"libpq/pqformat.h\"",
      "#include \"libpq/libpq.h\"",
      "#include \"access/xact.h\"",
      "#include \"access/transam.h\"",
      "#include <syslog.h>",
      "#include <ctype.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <time.h>",
      "#include <fcntl.h>",
      "#include \"postgres.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int\trecursion_depth = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"utils/ps_status.h\"\n#include \"utils/memutils.h\"\n#include \"utils/guc.h\"\n#include \"tcop/tcopprot.h\"\n#include \"storage/proc.h\"\n#include \"storage/ipc.h\"\n#include \"postmaster/syslogger.h\"\n#include \"postmaster/postmaster.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"libpq/pqformat.h\"\n#include \"libpq/libpq.h\"\n#include \"access/xact.h\"\n#include \"access/transam.h\"\n#include <syslog.h>\n#include <ctype.h>\n#include <signal.h>\n#include <unistd.h>\n#include <time.h>\n#include <fcntl.h>\n#include \"postgres.h\"\n\nstatic int\trecursion_depth = 0;\n\nbool\nin_error_recursion_trouble(void)\n{\n\t/* Pull the plug if recurse more than once */\n\treturn (recursion_depth > 2);\n}"
  }
]