[
  {
    "function_name": "exit_nfsd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1300-1313",
    "snippet": "static void __exit exit_nfsd(void)\n{\n\tnfsd_reply_cache_shutdown();\n\tremove_proc_entry(\"fs/nfs/exports\", NULL);\n\tremove_proc_entry(\"fs/nfs\", NULL);\n\tnfsd_stat_shutdown();\n\tnfsd_lockd_shutdown();\n\tnfsd4_free_slabs();\n\tnfsd4_exit_pnfs();\n\tnfsd_fault_inject_cleanup();\n\tunregister_filesystem(&nfsd_fs_type);\n\tunregister_cld_notifier();\n\tunregister_pernet_subsys(&nfsd_net_ops);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type nfsd_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nfsd\",\n\t.mount\t\t= nfsd_mount,\n\t.kill_sb\t= nfsd_umount,\n};",
      "static struct pernet_operations nfsd_net_ops = {\n\t.init = nfsd_init_net,\n\t.exit = nfsd_exit_net,\n\t.id   = &nfsd_net_id,\n\t.size = sizeof(struct nfsd_net),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_pernet_subsys",
          "args": [
            "&nfsd_net_ops"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_cld_notifier",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_cld_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1558-1562",
          "snippet": "void\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nvoid\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&nfsd_fs_type"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_fault_inject_cleanup",
          "args": [],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_fault_inject_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "660-660",
          "snippet": "static inline void nfsd_fault_inject_cleanup(void) {}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void nfsd_fault_inject_cleanup(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_exit_pnfs",
          "args": [],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_exit_pnfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "762-776",
          "snippet": "void\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
          ],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;",
            "static struct kmem_cache *nfs4_layout_stateid_cache;",
            "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nvoid\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_free_slabs",
          "args": [],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "129-129",
          "snippet": "static inline void nfsd4_free_slabs(void) { }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline void nfsd4_free_slabs(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_lockd_shutdown",
          "args": [],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lockd_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/lockd.c",
          "lines": "73-77",
          "snippet": "void\nnfsd_lockd_shutdown(void)\n{\n\tnlmsvc_ops = NULL;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/lockd/bind.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/lockd/bind.h>\n#include <linux/file.h>\n\nvoid\nnfsd_lockd_shutdown(void)\n{\n\tnlmsvc_ops = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_stat_shutdown",
          "args": [],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_stat_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/stats.c",
          "lines": "100-104",
          "snippet": "void\nnfsd_stat_shutdown(void)\n{\n\tsvc_proc_unregister(&init_net, \"nfsd\");\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n\nvoid\nnfsd_stat_shutdown(void)\n{\n\tsvc_proc_unregister(&init_net, \"nfsd\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/nfs\"",
            "NULL"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/nfs/exports\"",
            "NULL"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_shutdown",
          "args": [],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "192-213",
          "snippet": "void nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static struct kmem_cache\t*drc_slab;",
            "static unsigned int\t\tdrc_hashsize;",
            "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tdrc_hashsize;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nvoid nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct file_system_type nfsd_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nfsd\",\n\t.mount\t\t= nfsd_mount,\n\t.kill_sb\t= nfsd_umount,\n};\nstatic struct pernet_operations nfsd_net_ops = {\n\t.init = nfsd_init_net,\n\t.exit = nfsd_exit_net,\n\t.id   = &nfsd_net_id,\n\t.size = sizeof(struct nfsd_net),\n};\n\nstatic void __exit exit_nfsd(void)\n{\n\tnfsd_reply_cache_shutdown();\n\tremove_proc_entry(\"fs/nfs/exports\", NULL);\n\tremove_proc_entry(\"fs/nfs\", NULL);\n\tnfsd_stat_shutdown();\n\tnfsd_lockd_shutdown();\n\tnfsd4_free_slabs();\n\tnfsd4_exit_pnfs();\n\tnfsd_fault_inject_cleanup();\n\tunregister_filesystem(&nfsd_fs_type);\n\tunregister_cld_notifier();\n\tunregister_pernet_subsys(&nfsd_net_ops);\n}"
  },
  {
    "function_name": "init_nfsd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1248-1298",
    "snippet": "static int __init init_nfsd(void)\n{\n\tint retval;\n\tprintk(KERN_INFO \"Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\\n\");\n\n\tretval = register_pernet_subsys(&nfsd_net_ops);\n\tif (retval < 0)\n\t\treturn retval;\n\tretval = register_cld_notifier();\n\tif (retval)\n\t\tgoto out_unregister_pernet;\n\tretval = nfsd4_init_slabs();\n\tif (retval)\n\t\tgoto out_unregister_notifier;\n\tretval = nfsd4_init_pnfs();\n\tif (retval)\n\t\tgoto out_free_slabs;\n\tretval = nfsd_fault_inject_init(); /* nfsd fault injection controls */\n\tif (retval)\n\t\tgoto out_exit_pnfs;\n\tnfsd_stat_init();\t/* Statistics */\n\tretval = nfsd_reply_cache_init();\n\tif (retval)\n\t\tgoto out_free_stat;\n\tnfsd_lockd_init();\t/* lockd->nfsd callbacks */\n\tretval = create_proc_exports_entry();\n\tif (retval)\n\t\tgoto out_free_lockd;\n\tretval = register_filesystem(&nfsd_fs_type);\n\tif (retval)\n\t\tgoto out_free_all;\n\treturn 0;\nout_free_all:\n\tremove_proc_entry(\"fs/nfs/exports\", NULL);\n\tremove_proc_entry(\"fs/nfs\", NULL);\nout_free_lockd:\n\tnfsd_lockd_shutdown();\n\tnfsd_reply_cache_shutdown();\nout_free_stat:\n\tnfsd_stat_shutdown();\n\tnfsd_fault_inject_cleanup();\nout_exit_pnfs:\n\tnfsd4_exit_pnfs();\nout_free_slabs:\n\tnfsd4_free_slabs();\nout_unregister_notifier:\n\tunregister_cld_notifier();\nout_unregister_pernet:\n\tunregister_pernet_subsys(&nfsd_net_ops);\n\treturn retval;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type nfsd_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nfsd\",\n\t.mount\t\t= nfsd_mount,\n\t.kill_sb\t= nfsd_umount,\n};",
      "static struct pernet_operations nfsd_net_ops = {\n\t.init = nfsd_init_net,\n\t.exit = nfsd_exit_net,\n\t.id   = &nfsd_net_id,\n\t.size = sizeof(struct nfsd_net),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_pernet_subsys",
          "args": [
            "&nfsd_net_ops"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_cld_notifier",
          "args": [],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_cld_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1558-1562",
          "snippet": "void\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nvoid\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_free_slabs",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "129-129",
          "snippet": "static inline void nfsd4_free_slabs(void) { }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline void nfsd4_free_slabs(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_exit_pnfs",
          "args": [],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_exit_pnfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "762-776",
          "snippet": "void\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
          ],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;",
            "static struct kmem_cache *nfs4_layout_stateid_cache;",
            "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nvoid\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_fault_inject_cleanup",
          "args": [],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_fault_inject_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "660-660",
          "snippet": "static inline void nfsd_fault_inject_cleanup(void) {}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void nfsd_fault_inject_cleanup(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_stat_shutdown",
          "args": [],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_stat_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/stats.c",
          "lines": "100-104",
          "snippet": "void\nnfsd_stat_shutdown(void)\n{\n\tsvc_proc_unregister(&init_net, \"nfsd\");\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n\nvoid\nnfsd_stat_shutdown(void)\n{\n\tsvc_proc_unregister(&init_net, \"nfsd\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_shutdown",
          "args": [],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "192-213",
          "snippet": "void nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static struct kmem_cache\t*drc_slab;",
            "static unsigned int\t\tdrc_hashsize;",
            "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tdrc_hashsize;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nvoid nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_lockd_shutdown",
          "args": [],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lockd_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/lockd.c",
          "lines": "73-77",
          "snippet": "void\nnfsd_lockd_shutdown(void)\n{\n\tnlmsvc_ops = NULL;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/lockd/bind.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/lockd/bind.h>\n#include <linux/file.h>\n\nvoid\nnfsd_lockd_shutdown(void)\n{\n\tnlmsvc_ops = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/nfs\"",
            "NULL"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/nfs/exports\"",
            "NULL"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&nfsd_fs_type"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_proc_exports_entry",
          "args": [],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "create_proc_exports_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "1206-1209",
          "snippet": "static int create_proc_exports_entry(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int create_proc_exports_entry(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_lockd_init",
          "args": [],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lockd_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/lockd.c",
          "lines": "66-71",
          "snippet": "void\nnfsd_lockd_init(void)\n{\n\tdprintk(\"nfsd: initializing lockd\\n\");\n\tnlmsvc_ops = &nfsd_nlm_ops;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/lockd/bind.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nlmsvc_binding nfsd_nlm_ops = {\n\t.fopen\t\t= nlm_fopen,\t\t/* open file for locking */\n\t.fclose\t\t= nlm_fclose,\t\t/* close file */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/lockd/bind.h>\n#include <linux/file.h>\n\nstatic const struct nlmsvc_binding nfsd_nlm_ops = {\n\t.fopen\t\t= nlm_fopen,\t\t/* open file for locking */\n\t.fclose\t\t= nlm_fclose,\t\t/* close file */\n};\n\nvoid\nnfsd_lockd_init(void)\n{\n\tdprintk(\"nfsd: initializing lockd\\n\");\n\tnlmsvc_ops = &nfsd_nlm_ops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_init",
          "args": [],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "156-190",
          "snippet": "int nfsd_reply_cache_init(void)\n{\n\tunsigned int hashsize;\n\tunsigned int i;\n\tint status = 0;\n\n\tmax_drc_entries = nfsd_cache_size_limit();\n\tatomic_set(&num_drc_entries, 0);\n\thashsize = nfsd_hashsize(max_drc_entries);\n\tmaskbits = ilog2(hashsize);\n\n\tstatus = register_shrinker(&nfsd_reply_cache_shrinker);\n\tif (status)\n\t\treturn status;\n\n\tdrc_slab = kmem_cache_create(\"nfsd_drc\", sizeof(struct svc_cacherep),\n\t\t\t\t\t0, 0, NULL);\n\tif (!drc_slab)\n\t\tgoto out_nomem;\n\n\tdrc_hashtbl = kcalloc(hashsize, sizeof(*drc_hashtbl), GFP_KERNEL);\n\tif (!drc_hashtbl)\n\t\tgoto out_nomem;\n\tfor (i = 0; i < hashsize; i++) {\n\t\tINIT_LIST_HEAD(&drc_hashtbl[i].lru_head);\n\t\tspin_lock_init(&drc_hashtbl[i].cache_lock);\n\t}\n\tdrc_hashsize = hashsize;\n\n\treturn 0;\nout_nomem:\n\tprintk(KERN_ERR \"nfsd: failed to allocate reply cache\\n\");\n\tnfsd_reply_cache_shutdown();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static struct kmem_cache\t*drc_slab;",
            "static unsigned int\t\tmax_drc_entries;",
            "static unsigned int\t\tmaskbits;",
            "static unsigned int\t\tdrc_hashsize;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tmax_drc_entries;\nstatic unsigned int\t\tmaskbits;\nstatic unsigned int\t\tdrc_hashsize;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nint nfsd_reply_cache_init(void)\n{\n\tunsigned int hashsize;\n\tunsigned int i;\n\tint status = 0;\n\n\tmax_drc_entries = nfsd_cache_size_limit();\n\tatomic_set(&num_drc_entries, 0);\n\thashsize = nfsd_hashsize(max_drc_entries);\n\tmaskbits = ilog2(hashsize);\n\n\tstatus = register_shrinker(&nfsd_reply_cache_shrinker);\n\tif (status)\n\t\treturn status;\n\n\tdrc_slab = kmem_cache_create(\"nfsd_drc\", sizeof(struct svc_cacherep),\n\t\t\t\t\t0, 0, NULL);\n\tif (!drc_slab)\n\t\tgoto out_nomem;\n\n\tdrc_hashtbl = kcalloc(hashsize, sizeof(*drc_hashtbl), GFP_KERNEL);\n\tif (!drc_hashtbl)\n\t\tgoto out_nomem;\n\tfor (i = 0; i < hashsize; i++) {\n\t\tINIT_LIST_HEAD(&drc_hashtbl[i].lru_head);\n\t\tspin_lock_init(&drc_hashtbl[i].cache_lock);\n\t}\n\tdrc_hashsize = hashsize;\n\n\treturn 0;\nout_nomem:\n\tprintk(KERN_ERR \"nfsd: failed to allocate reply cache\\n\");\n\tnfsd_reply_cache_shutdown();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_stat_init",
          "args": [],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_stat_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/stats.c",
          "lines": "94-98",
          "snippet": "void\nnfsd_stat_init(void)\n{\n\tsvc_proc_register(&init_net, &nfsd_svcstats, &nfsd_proc_fops);\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/module.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct svc_stat\t\tnfsd_svcstats = {\n\t.program\t= &nfsd_program,\n};",
            "static const struct file_operations nfsd_proc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = nfsd_proc_open,\n\t.read  = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n\nstruct svc_stat\t\tnfsd_svcstats = {\n\t.program\t= &nfsd_program,\n};\nstatic const struct file_operations nfsd_proc_fops = {\n\t.owner = THIS_MODULE,\n\t.open = nfsd_proc_open,\n\t.read  = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nvoid\nnfsd_stat_init(void)\n{\n\tsvc_proc_register(&init_net, &nfsd_svcstats, &nfsd_proc_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_fault_inject_init",
          "args": [],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_fault_inject_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "659-659",
          "snippet": "static inline int nfsd_fault_inject_init(void) { return 0; }",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline int nfsd_fault_inject_init(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_pnfs",
          "args": [],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_pnfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "740-760",
          "snippet": "int\nnfsd4_init_pnfs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nfsd_devid_hash[i]);\n\n\tnfs4_layout_cache = kmem_cache_create(\"nfs4_layout\",\n\t\t\tsizeof(struct nfs4_layout), 0, 0, NULL);\n\tif (!nfs4_layout_cache)\n\t\treturn -ENOMEM;\n\n\tnfs4_layout_stateid_cache = kmem_cache_create(\"nfs4_layout_stateid\",\n\t\t\tsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\n\tif (!nfs4_layout_stateid_cache) {\n\t\tkmem_cache_destroy(nfs4_layout_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
          ],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;",
            "static struct kmem_cache *nfs4_layout_stateid_cache;",
            "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nint\nnfsd4_init_pnfs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nfsd_devid_hash[i]);\n\n\tnfs4_layout_cache = kmem_cache_create(\"nfs4_layout\",\n\t\t\tsizeof(struct nfs4_layout), 0, 0, NULL);\n\tif (!nfs4_layout_cache)\n\t\treturn -ENOMEM;\n\n\tnfs4_layout_stateid_cache = kmem_cache_create(\"nfs4_layout_stateid\",\n\t\t\tsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\n\tif (!nfs4_layout_stateid_cache) {\n\t\tkmem_cache_destroy(nfs4_layout_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_slabs",
          "args": [],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "128-128",
          "snippet": "static inline int nfsd4_init_slabs(void) { return 0; }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfsd4_init_slabs(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "register_pernet_subsys",
          "args": [
            "&nfsd_net_ops"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\\n\""
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct file_system_type nfsd_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"nfsd\",\n\t.mount\t\t= nfsd_mount,\n\t.kill_sb\t= nfsd_umount,\n};\nstatic struct pernet_operations nfsd_net_ops = {\n\t.init = nfsd_init_net,\n\t.exit = nfsd_exit_net,\n\t.id   = &nfsd_net_id,\n\t.size = sizeof(struct nfsd_net),\n};\n\nstatic int __init init_nfsd(void)\n{\n\tint retval;\n\tprintk(KERN_INFO \"Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\\n\");\n\n\tretval = register_pernet_subsys(&nfsd_net_ops);\n\tif (retval < 0)\n\t\treturn retval;\n\tretval = register_cld_notifier();\n\tif (retval)\n\t\tgoto out_unregister_pernet;\n\tretval = nfsd4_init_slabs();\n\tif (retval)\n\t\tgoto out_unregister_notifier;\n\tretval = nfsd4_init_pnfs();\n\tif (retval)\n\t\tgoto out_free_slabs;\n\tretval = nfsd_fault_inject_init(); /* nfsd fault injection controls */\n\tif (retval)\n\t\tgoto out_exit_pnfs;\n\tnfsd_stat_init();\t/* Statistics */\n\tretval = nfsd_reply_cache_init();\n\tif (retval)\n\t\tgoto out_free_stat;\n\tnfsd_lockd_init();\t/* lockd->nfsd callbacks */\n\tretval = create_proc_exports_entry();\n\tif (retval)\n\t\tgoto out_free_lockd;\n\tretval = register_filesystem(&nfsd_fs_type);\n\tif (retval)\n\t\tgoto out_free_all;\n\treturn 0;\nout_free_all:\n\tremove_proc_entry(\"fs/nfs/exports\", NULL);\n\tremove_proc_entry(\"fs/nfs\", NULL);\nout_free_lockd:\n\tnfsd_lockd_shutdown();\n\tnfsd_reply_cache_shutdown();\nout_free_stat:\n\tnfsd_stat_shutdown();\n\tnfsd_fault_inject_cleanup();\nout_exit_pnfs:\n\tnfsd4_exit_pnfs();\nout_free_slabs:\n\tnfsd4_free_slabs();\nout_unregister_notifier:\n\tunregister_cld_notifier();\nout_unregister_pernet:\n\tunregister_pernet_subsys(&nfsd_net_ops);\n\treturn retval;\n}"
  },
  {
    "function_name": "nfsd_exit_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1235-1239",
    "snippet": "static __net_exit void nfsd_exit_net(struct net *net)\n{\n\tnfsd_idmap_shutdown(net);\n\tnfsd_export_shutdown(net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_export_shutdown",
          "args": [
            "net"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_export_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1264-1278",
          "snippet": "void\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_idmap_shutdown",
          "args": [
            "net"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_idmap_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/idmap.h",
          "lines": "50-52",
          "snippet": "static inline void nfsd_idmap_shutdown(struct net *net)\n{\n}",
          "includes": [
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/in.h>\n\nstatic inline void nfsd_idmap_shutdown(struct net *net)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic __net_exit void nfsd_exit_net(struct net *net)\n{\n\tnfsd_idmap_shutdown(net);\n\tnfsd_export_shutdown(net);\n}"
  },
  {
    "function_name": "nfsd_init_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1214-1233",
    "snippet": "static __net_init int nfsd_init_net(struct net *net)\n{\n\tint retval;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tretval = nfsd_export_init(net);\n\tif (retval)\n\t\tgoto out_export_error;\n\tretval = nfsd_idmap_init(net);\n\tif (retval)\n\t\tgoto out_idmap_error;\n\tnn->nfsd4_lease = 90;\t/* default lease time */\n\tnn->nfsd4_grace = 90;\n\treturn 0;\n\nout_idmap_error:\n\tnfsd_export_shutdown(net);\nout_export_error:\n\treturn retval;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_export_shutdown",
          "args": [
            "net"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_export_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1264-1278",
          "snippet": "void\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_idmap_init",
          "args": [
            "net"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_idmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/idmap.h",
          "lines": "46-49",
          "snippet": "static inline int nfsd_idmap_init(struct net *net)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nfs_idmap.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/in.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_idmap.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/in.h>\n\nstatic inline int nfsd_idmap_init(struct net *net)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_export_init",
          "args": [
            "net"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_export_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1215-1247",
          "snippet": "int\nnfsd_export_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: initializing export module (net: %p).\\n\", net);\n\n\tnn->svc_export_cache = cache_create_net(&svc_export_cache_template, net);\n\tif (IS_ERR(nn->svc_export_cache))\n\t\treturn PTR_ERR(nn->svc_export_cache);\n\trv = cache_register_net(nn->svc_export_cache, net);\n\tif (rv)\n\t\tgoto destroy_export_cache;\n\n\tnn->svc_expkey_cache = cache_create_net(&svc_expkey_cache_template, net);\n\tif (IS_ERR(nn->svc_expkey_cache)) {\n\t\trv = PTR_ERR(nn->svc_expkey_cache);\n\t\tgoto unregister_export_cache;\n\t}\n\trv = cache_register_net(nn->svc_expkey_cache, net);\n\tif (rv)\n\t\tgoto destroy_expkey_cache;\n\treturn 0;\n\ndestroy_expkey_cache:\n\tcache_destroy_net(nn->svc_expkey_cache, net);\nunregister_export_cache:\n\tcache_unregister_net(nn->svc_export_cache, net);\ndestroy_export_cache:\n\tcache_destroy_net(nn->svc_export_cache, net);\n\treturn rv;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cache_detail svc_expkey_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPKEY_HASHMAX,\n\t.name\t\t= \"nfsd.fh\",\n\t.cache_put\t= expkey_put,\n\t.cache_request\t= expkey_request,\n\t.cache_parse\t= expkey_parse,\n\t.cache_show\t= expkey_show,\n\t.match\t\t= expkey_match,\n\t.init\t\t= expkey_init,\n\t.update       \t= expkey_update,\n\t.alloc\t\t= expkey_alloc,\n};",
            "static struct cache_detail svc_export_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPORT_HASHMAX,\n\t.name\t\t= \"nfsd.export\",\n\t.cache_put\t= svc_export_put,\n\t.cache_request\t= svc_export_request,\n\t.cache_parse\t= svc_export_parse,\n\t.cache_show\t= svc_export_show,\n\t.match\t\t= svc_export_match,\n\t.init\t\t= svc_export_init,\n\t.update\t\t= export_update,\n\t.alloc\t\t= svc_export_alloc,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct cache_detail svc_expkey_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPKEY_HASHMAX,\n\t.name\t\t= \"nfsd.fh\",\n\t.cache_put\t= expkey_put,\n\t.cache_request\t= expkey_request,\n\t.cache_parse\t= expkey_parse,\n\t.cache_show\t= expkey_show,\n\t.match\t\t= expkey_match,\n\t.init\t\t= expkey_init,\n\t.update       \t= expkey_update,\n\t.alloc\t\t= expkey_alloc,\n};\nstatic struct cache_detail svc_export_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPORT_HASHMAX,\n\t.name\t\t= \"nfsd.export\",\n\t.cache_put\t= svc_export_put,\n\t.cache_request\t= svc_export_request,\n\t.cache_parse\t= svc_export_parse,\n\t.cache_show\t= svc_export_show,\n\t.match\t\t= svc_export_match,\n\t.init\t\t= svc_export_init,\n\t.update\t\t= export_update,\n\t.alloc\t\t= svc_export_alloc,\n};\n\nint\nnfsd_export_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: initializing export module (net: %p).\\n\", net);\n\n\tnn->svc_export_cache = cache_create_net(&svc_export_cache_template, net);\n\tif (IS_ERR(nn->svc_export_cache))\n\t\treturn PTR_ERR(nn->svc_export_cache);\n\trv = cache_register_net(nn->svc_export_cache, net);\n\tif (rv)\n\t\tgoto destroy_export_cache;\n\n\tnn->svc_expkey_cache = cache_create_net(&svc_expkey_cache_template, net);\n\tif (IS_ERR(nn->svc_expkey_cache)) {\n\t\trv = PTR_ERR(nn->svc_expkey_cache);\n\t\tgoto unregister_export_cache;\n\t}\n\trv = cache_register_net(nn->svc_expkey_cache, net);\n\tif (rv)\n\t\tgoto destroy_expkey_cache;\n\treturn 0;\n\ndestroy_expkey_cache:\n\tcache_destroy_net(nn->svc_expkey_cache, net);\nunregister_export_cache:\n\tcache_unregister_net(nn->svc_export_cache, net);\ndestroy_export_cache:\n\tcache_destroy_net(nn->svc_export_cache, net);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic __net_init int nfsd_init_net(struct net *net)\n{\n\tint retval;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tretval = nfsd_export_init(net);\n\tif (retval)\n\t\tgoto out_export_error;\n\tretval = nfsd_idmap_init(net);\n\tif (retval)\n\t\tgoto out_idmap_error;\n\tnn->nfsd4_lease = 90;\t/* default lease time */\n\tnn->nfsd4_grace = 90;\n\treturn 0;\n\nout_idmap_error:\n\tnfsd_export_shutdown(net);\nout_export_error:\n\treturn retval;\n}"
  },
  {
    "function_name": "create_proc_exports_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1206-1209",
    "snippet": "static int create_proc_exports_entry(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int create_proc_exports_entry(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "create_proc_exports_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1190-1204",
    "snippet": "static int create_proc_exports_entry(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tentry = proc_mkdir(\"fs/nfs\", NULL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry = proc_create(\"exports\", 0, entry,\n\t\t\t\t &exports_proc_operations);\n\tif (!entry) {\n\t\tremove_proc_entry(\"fs/nfs\", NULL);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations exports_proc_operations = {\n\t.open\t\t= exports_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.owner\t\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"fs/nfs\"",
            "NULL"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"exports\"",
            "0",
            "entry",
            "&exports_proc_operations"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"fs/nfs\"",
            "NULL"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic const struct file_operations exports_proc_operations = {\n\t.open\t\t= exports_proc_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.owner\t\t= THIS_MODULE,\n};\n\nstatic int create_proc_exports_entry(void)\n{\n\tstruct proc_dir_entry *entry;\n\n\tentry = proc_mkdir(\"fs/nfs\", NULL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tentry = proc_create(\"exports\", 0, entry,\n\t\t\t\t &exports_proc_operations);\n\tif (!entry) {\n\t\tremove_proc_entry(\"fs/nfs\", NULL);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1173-1179",
    "snippet": "static void nfsd_umount(struct super_block *sb)\n{\n\tstruct net *net = sb->s_fs_info;\n\n\tkill_litter_super(sb);\n\tput_net(net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_litter_super",
          "args": [
            "sb"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd_umount(struct super_block *sb)\n{\n\tstruct net *net = sb->s_fs_info;\n\n\tkill_litter_super(sb);\n\tput_net(net);\n}"
  },
  {
    "function_name": "nfsd_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1167-1171",
    "snippet": "static struct dentry *nfsd_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_ns(fs_type, flags, current->nsproxy->net_ns, nfsd_fill_super);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_ns",
          "args": [
            "fs_type",
            "flags",
            "current->nsproxy->net_ns",
            "nfsd_fill_super"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct dentry *nfsd_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_ns(fs_type, flags, current->nsproxy->net_ns, nfsd_fill_super);\n}"
  },
  {
    "function_name": "nfsd_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1127-1165",
    "snippet": "static int nfsd_fill_super(struct super_block * sb, void * data, int silent)\n{\n\tstatic struct tree_descr nfsd_files[] = {\n\t\t[NFSD_List] = {\"exports\", &exports_nfsd_operations, S_IRUGO},\n\t\t[NFSD_Export_features] = {\"export_features\",\n\t\t\t\t\t&export_features_operations, S_IRUGO},\n\t\t[NFSD_FO_UnlockIP] = {\"unlock_ip\",\n\t\t\t\t\t&transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_FO_UnlockFS] = {\"unlock_filesystem\",\n\t\t\t\t\t&transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Fh] = {\"filehandle\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Threads] = {\"threads\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Pool_Threads] = {\"pool_threads\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Pool_Stats] = {\"pool_stats\", &pool_stats_operations, S_IRUGO},\n\t\t[NFSD_Reply_Cache_Stats] = {\"reply_cache_stats\", &reply_cache_stats_operations, S_IRUGO},\n\t\t[NFSD_Versions] = {\"versions\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Ports] = {\"portlist\", &transaction_ops, S_IWUSR|S_IRUGO},\n\t\t[NFSD_MaxBlkSize] = {\"max_block_size\", &transaction_ops, S_IWUSR|S_IRUGO},\n\t\t[NFSD_MaxConnections] = {\"max_connections\", &transaction_ops, S_IWUSR|S_IRUGO},\n#if defined(CONFIG_SUNRPC_GSS) || defined(CONFIG_SUNRPC_GSS_MODULE)\n\t\t[NFSD_SupportedEnctypes] = {\"supported_krb5_enctypes\", &supported_enctypes_ops, S_IRUGO},\n#endif /* CONFIG_SUNRPC_GSS or CONFIG_SUNRPC_GSS_MODULE */\n#ifdef CONFIG_NFSD_V4\n\t\t[NFSD_Leasetime] = {\"nfsv4leasetime\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Gracetime] = {\"nfsv4gracetime\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_RecoveryDir] = {\"nfsv4recoverydir\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_V4EndGrace] = {\"v4_end_grace\", &transaction_ops, S_IWUSR|S_IRUGO},\n#endif\n\t\t/* last one */ {\"\"}\n\t};\n\tstruct net *net = data;\n\tint ret;\n\n\tret = simple_fill_super(sb, 0x6e667364, nfsd_files);\n\tif (ret)\n\t\treturn ret;\n\tsb->s_fs_info = get_net(net);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations transaction_ops = {\n\t.write\t\t= nfsctl_transaction_write,\n\t.read\t\t= nfsctl_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations exports_nfsd_operations = {\n\t.open\t\t= exports_nfsd_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.owner\t\t= THIS_MODULE,\n};",
      "static const struct file_operations export_features_operations = {\n\t.open\t\t= export_features_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};",
      "static const struct file_operations pool_stats_operations = {\n\t.open\t\t= nfsd_pool_stats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= nfsd_pool_stats_release,\n\t.owner\t\t= THIS_MODULE,\n};",
      "static struct file_operations reply_cache_stats_operations = {\n\t.open\t\t= nfsd_reply_cache_stats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "net"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "0x6e667364",
            "nfsd_files"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "CONFIG_SUNRPC_GSS_MODULE"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic const struct file_operations transaction_ops = {\n\t.write\t\t= nfsctl_transaction_write,\n\t.read\t\t= nfsctl_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations exports_nfsd_operations = {\n\t.open\t\t= exports_nfsd_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n\t.owner\t\t= THIS_MODULE,\n};\nstatic const struct file_operations export_features_operations = {\n\t.open\t\t= export_features_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\nstatic const struct file_operations pool_stats_operations = {\n\t.open\t\t= nfsd_pool_stats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= nfsd_pool_stats_release,\n\t.owner\t\t= THIS_MODULE,\n};\nstatic struct file_operations reply_cache_stats_operations = {\n\t.open\t\t= nfsd_reply_cache_stats_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int nfsd_fill_super(struct super_block * sb, void * data, int silent)\n{\n\tstatic struct tree_descr nfsd_files[] = {\n\t\t[NFSD_List] = {\"exports\", &exports_nfsd_operations, S_IRUGO},\n\t\t[NFSD_Export_features] = {\"export_features\",\n\t\t\t\t\t&export_features_operations, S_IRUGO},\n\t\t[NFSD_FO_UnlockIP] = {\"unlock_ip\",\n\t\t\t\t\t&transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_FO_UnlockFS] = {\"unlock_filesystem\",\n\t\t\t\t\t&transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Fh] = {\"filehandle\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Threads] = {\"threads\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Pool_Threads] = {\"pool_threads\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Pool_Stats] = {\"pool_stats\", &pool_stats_operations, S_IRUGO},\n\t\t[NFSD_Reply_Cache_Stats] = {\"reply_cache_stats\", &reply_cache_stats_operations, S_IRUGO},\n\t\t[NFSD_Versions] = {\"versions\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Ports] = {\"portlist\", &transaction_ops, S_IWUSR|S_IRUGO},\n\t\t[NFSD_MaxBlkSize] = {\"max_block_size\", &transaction_ops, S_IWUSR|S_IRUGO},\n\t\t[NFSD_MaxConnections] = {\"max_connections\", &transaction_ops, S_IWUSR|S_IRUGO},\n#if defined(CONFIG_SUNRPC_GSS) || defined(CONFIG_SUNRPC_GSS_MODULE)\n\t\t[NFSD_SupportedEnctypes] = {\"supported_krb5_enctypes\", &supported_enctypes_ops, S_IRUGO},\n#endif /* CONFIG_SUNRPC_GSS or CONFIG_SUNRPC_GSS_MODULE */\n#ifdef CONFIG_NFSD_V4\n\t\t[NFSD_Leasetime] = {\"nfsv4leasetime\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_Gracetime] = {\"nfsv4gracetime\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_RecoveryDir] = {\"nfsv4recoverydir\", &transaction_ops, S_IWUSR|S_IRUSR},\n\t\t[NFSD_V4EndGrace] = {\"v4_end_grace\", &transaction_ops, S_IWUSR|S_IRUGO},\n#endif\n\t\t/* last one */ {\"\"}\n\t};\n\tstruct net *net = data;\n\tint ret;\n\n\tret = simple_fill_super(sb, 0x6e667364, nfsd_files);\n\tif (ret)\n\t\treturn ret;\n\tsb->s_fs_info = get_net(net);\n\treturn 0;\n}"
  },
  {
    "function_name": "write_v4_end_grace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1100-1118",
    "snippet": "static ssize_t write_v4_end_grace(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size > 0) {\n\t\tswitch(buf[0]) {\n\t\tcase 'Y':\n\t\tcase 'y':\n\t\tcase '1':\n\t\t\tnfsd4_end_grace(nn);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%c\\n\",\n\t\t\t nn->grace_ended ? 'Y' : 'N');\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "SIMPLE_TRANSACTION_LIMIT",
            "\"%c\\n\"",
            "nn->grace_ended ? 'Y' : 'N'"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_end_grace",
          "args": [
            "nn"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_end_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4467-4498",
          "snippet": "void\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "netns(file)",
            "nfsd_net_id"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_net_id;\n\nstatic ssize_t write_v4_end_grace(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size > 0) {\n\t\tswitch(buf[0]) {\n\t\tcase 'Y':\n\t\tcase 'y':\n\t\tcase '1':\n\t\t\tnfsd4_end_grace(nn);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%c\\n\",\n\t\t\t nn->grace_ended ? 'Y' : 'N');\n}"
  },
  {
    "function_name": "write_recoverydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1069-1078",
    "snippet": "static ssize_t write_recoverydir(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_recoverydir(file, buf, size, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__write_recoverydir",
          "args": [
            "file",
            "buf",
            "size",
            "nn"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "__write_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "1020-1046",
          "snippet": "static ssize_t __write_recoverydir(struct file *file, char *buf, size_t size,\n\t\t\t\t   struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tchar *recdir;\n\tint len, status;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\tif (size > PATH_MAX || buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\trecdir = mesg;\n\t\tlen = qword_get(&mesg, recdir, size);\n\t\tif (len <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tstatus = nfs4_reset_recoverydir(recdir);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%s\\n\",\n\t\t\t\t\t\t\tnfs4_recoverydir());\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
            "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
            "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t __write_recoverydir(struct file *file, char *buf, size_t size,\n\t\t\t\t   struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tchar *recdir;\n\tint len, status;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\tif (size > PATH_MAX || buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\trecdir = mesg;\n\t\tlen = qword_get(&mesg, recdir, size);\n\t\tif (len <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tstatus = nfs4_reset_recoverydir(recdir);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%s\\n\",\n\t\t\t\t\t\t\tnfs4_recoverydir());\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "netns(file)",
            "nfsd_net_id"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_net_id;\n\nstatic ssize_t write_recoverydir(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_recoverydir(file, buf, size, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
  },
  {
    "function_name": "__write_recoverydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1020-1046",
    "snippet": "static ssize_t __write_recoverydir(struct file *file, char *buf, size_t size,\n\t\t\t\t   struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tchar *recdir;\n\tint len, status;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\tif (size > PATH_MAX || buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\trecdir = mesg;\n\t\tlen = qword_get(&mesg, recdir, size);\n\t\tif (len <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tstatus = nfs4_reset_recoverydir(recdir);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%s\\n\",\n\t\t\t\t\t\t\tnfs4_recoverydir());\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "SIMPLE_TRANSACTION_LIMIT",
            "\"%s\\n\"",
            "nfs4_recoverydir()"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_recoverydir",
          "args": [],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "136-136",
          "snippet": "static inline char * nfs4_recoverydir(void) {return NULL; }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline char * nfs4_recoverydir(void) {return NULL; }"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_reset_recoverydir",
          "args": [
            "recdir"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "135-135",
          "snippet": "static inline int nfs4_reset_recoverydir(char *recdir) { return 0; }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfs4_reset_recoverydir(char *recdir) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "recdir",
            "size"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t __write_recoverydir(struct file *file, char *buf, size_t size,\n\t\t\t\t   struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tchar *recdir;\n\tint len, status;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\tif (size > PATH_MAX || buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\trecdir = mesg;\n\t\tlen = qword_get(&mesg, recdir, size);\n\t\tif (len <= 0)\n\t\t\treturn -EINVAL;\n\n\t\tstatus = nfs4_reset_recoverydir(recdir);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%s\\n\",\n\t\t\t\t\t\t\tnfs4_recoverydir());\n}"
  },
  {
    "function_name": "write_gracetime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "1014-1018",
    "snippet": "static ssize_t write_gracetime(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\treturn nfsd4_write_time(file, buf, size, &nn->nfsd4_grace, nn);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_write_time",
          "args": [
            "file",
            "buf",
            "size",
            "&nn->nfsd4_grace",
            "nn"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_write_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "966-975",
          "snippet": "static ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\ttime_t *time, struct nfsd_net *nn)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __nfsd4_write_time(file, buf, size, time, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
            "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
            "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\ttime_t *time, struct nfsd_net *nn)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __nfsd4_write_time(file, buf, size, time, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "netns(file)",
            "nfsd_net_id"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_net_id;\n\nstatic ssize_t write_gracetime(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\treturn nfsd4_write_time(file, buf, size, &nn->nfsd4_grace, nn);\n}"
  },
  {
    "function_name": "write_leasetime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "998-1002",
    "snippet": "static ssize_t write_leasetime(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\treturn nfsd4_write_time(file, buf, size, &nn->nfsd4_lease, nn);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_write_time",
          "args": [
            "file",
            "buf",
            "size",
            "&nn->nfsd4_lease",
            "nn"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_write_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "966-975",
          "snippet": "static ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\ttime_t *time, struct nfsd_net *nn)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __nfsd4_write_time(file, buf, size, time, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
            "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
            "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\ttime_t *time, struct nfsd_net *nn)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __nfsd4_write_time(file, buf, size, time, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "netns(file)",
            "nfsd_net_id"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_net_id;\n\nstatic ssize_t write_leasetime(struct file *file, char *buf, size_t size)\n{\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\treturn nfsd4_write_time(file, buf, size, &nn->nfsd4_lease, nn);\n}"
  },
  {
    "function_name": "nfsd4_write_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "966-975",
    "snippet": "static ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\ttime_t *time, struct nfsd_net *nn)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __nfsd4_write_time(file, buf, size, time, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfsd4_write_time",
          "args": [
            "file",
            "buf",
            "size",
            "time",
            "nn"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_write_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "934-964",
          "snippet": "static ssize_t __nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\t  time_t *time, struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tint rv, i;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\trv = get_int(&mesg, &i);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\t/*\n\t\t * Some sanity checking.  We don't have a reason for\n\t\t * these particular numbers, but problems with the\n\t\t * extremes are:\n\t\t *\t- Too short: the briefest network outage may\n\t\t *\t  cause clients to lose all their locks.  Also,\n\t\t *\t  the frequent polling may be wasteful.\n\t\t *\t- Too long: do you really want reboot recovery\n\t\t *\t  to take more than an hour?  Or to make other\n\t\t *\t  clients wait an hour before being able to\n\t\t *\t  revoke a dead client's locks?\n\t\t */\n\t\tif (i < 10 || i > 3600)\n\t\t\treturn -EINVAL;\n\t\t*time = i;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%ld\\n\", *time);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
            "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
            "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t __nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\t  time_t *time, struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tint rv, i;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\trv = get_int(&mesg, &i);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\t/*\n\t\t * Some sanity checking.  We don't have a reason for\n\t\t * these particular numbers, but problems with the\n\t\t * extremes are:\n\t\t *\t- Too short: the briefest network outage may\n\t\t *\t  cause clients to lose all their locks.  Also,\n\t\t *\t  the frequent polling may be wasteful.\n\t\t *\t- Too long: do you really want reboot recovery\n\t\t *\t  to take more than an hour?  Or to make other\n\t\t *\t  clients wait an hour before being able to\n\t\t *\t  revoke a dead client's locks?\n\t\t */\n\t\tif (i < 10 || i > 3600)\n\t\t\treturn -EINVAL;\n\t\t*time = i;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%ld\\n\", *time);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\ttime_t *time, struct nfsd_net *nn)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __nfsd4_write_time(file, buf, size, time, nn);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
  },
  {
    "function_name": "__nfsd4_write_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "934-964",
    "snippet": "static ssize_t __nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\t  time_t *time, struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tint rv, i;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\trv = get_int(&mesg, &i);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\t/*\n\t\t * Some sanity checking.  We don't have a reason for\n\t\t * these particular numbers, but problems with the\n\t\t * extremes are:\n\t\t *\t- Too short: the briefest network outage may\n\t\t *\t  cause clients to lose all their locks.  Also,\n\t\t *\t  the frequent polling may be wasteful.\n\t\t *\t- Too long: do you really want reboot recovery\n\t\t *\t  to take more than an hour?  Or to make other\n\t\t *\t  clients wait an hour before being able to\n\t\t *\t  revoke a dead client's locks?\n\t\t */\n\t\tif (i < 10 || i > 3600)\n\t\t\treturn -EINVAL;\n\t\t*time = i;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%ld\\n\", *time);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "SIMPLE_TRANSACTION_LIMIT",
            "\"%ld\\n\"",
            "*time"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&i"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t __nfsd4_write_time(struct file *file, char *buf, size_t size,\n\t\t\t\t  time_t *time, struct nfsd_net *nn)\n{\n\tchar *mesg = buf;\n\tint rv, i;\n\n\tif (size > 0) {\n\t\tif (nn->nfsd_serv)\n\t\t\treturn -EBUSY;\n\t\trv = get_int(&mesg, &i);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\t/*\n\t\t * Some sanity checking.  We don't have a reason for\n\t\t * these particular numbers, but problems with the\n\t\t * extremes are:\n\t\t *\t- Too short: the briefest network outage may\n\t\t *\t  cause clients to lose all their locks.  Also,\n\t\t *\t  the frequent polling may be wasteful.\n\t\t *\t- Too long: do you really want reboot recovery\n\t\t *\t  to take more than an hour?  Or to make other\n\t\t *\t  clients wait an hour before being able to\n\t\t *\t  revoke a dead client's locks?\n\t\t */\n\t\tif (i < 10 || i > 3600)\n\t\t\treturn -EINVAL;\n\t\t*time = i;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%ld\\n\", *time);\n}"
  },
  {
    "function_name": "write_maxconn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "916-931",
    "snippet": "static ssize_t write_maxconn(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\tunsigned int maxconn = nn->max_connections;\n\n\tif (size > 0) {\n\t\tint rv = get_uint(&mesg, &maxconn);\n\n\t\tif (rv)\n\t\t\treturn rv;\n\t\tnn->max_connections = maxconn;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%u\\n\", maxconn);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "SIMPLE_TRANSACTION_LIMIT",
            "\"%u\\n\"",
            "maxconn"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "&mesg",
            "&maxconn"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "netns(file)",
            "nfsd_net_id"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_net_id;\n\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\tunsigned int maxconn = nn->max_connections;\n\n\tif (size > 0) {\n\t\tint rv = get_uint(&mesg, &maxconn);\n\n\t\tif (rv)\n\t\t\treturn rv;\n\t\tnn->max_connections = maxconn;\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%u\\n\", maxconn);\n}"
  },
  {
    "function_name": "write_maxblksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "867-894",
    "snippet": "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size > 0) {\n\t\tint bsize;\n\t\tint rv = get_int(&mesg, &bsize);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\t/* force bsize into allowed range and\n\t\t * required alignment.\n\t\t */\n\t\tbsize = max_t(int, bsize, 1024);\n\t\tbsize = min_t(int, bsize, NFSSVC_MAXBLKSIZE);\n\t\tbsize &= ~(1024-1);\n\t\tmutex_lock(&nfsd_mutex);\n\t\tif (nn->nfsd_serv) {\n\t\t\tmutex_unlock(&nfsd_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tnfsd_max_blksize = bsize;\n\t\tmutex_unlock(&nfsd_mutex);\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%d\\n\",\n\t\t\t\t\t\t\tnfsd_max_blksize);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "int nfsd_max_blksize;",
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "SIMPLE_TRANSACTION_LIMIT",
            "\"%d\\n\"",
            "nfsd_max_blksize"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "bsize",
            "NFSSVC_MAXBLKSIZE"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "int",
            "bsize",
            "1024"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&bsize"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "netns(file)",
            "nfsd_net_id"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_max_blksize;\nint nfsd_net_id;\n\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size > 0) {\n\t\tint bsize;\n\t\tint rv = get_int(&mesg, &bsize);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\t/* force bsize into allowed range and\n\t\t * required alignment.\n\t\t */\n\t\tbsize = max_t(int, bsize, 1024);\n\t\tbsize = min_t(int, bsize, NFSSVC_MAXBLKSIZE);\n\t\tbsize &= ~(1024-1);\n\t\tmutex_lock(&nfsd_mutex);\n\t\tif (nn->nfsd_serv) {\n\t\t\tmutex_unlock(&nfsd_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tnfsd_max_blksize = bsize;\n\t\tmutex_unlock(&nfsd_mutex);\n\t}\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%d\\n\",\n\t\t\t\t\t\t\tnfsd_max_blksize);\n}"
  },
  {
    "function_name": "write_ports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "833-841",
    "snippet": "static ssize_t write_ports(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_ports(file, buf, size, netns(file));\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__write_ports",
          "args": [
            "file",
            "buf",
            "size",
            "netns(file)"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "__write_ports",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "775-788",
          "snippet": "static ssize_t __write_ports(struct file *file, char *buf, size_t size,\n\t\t\t     struct net *net)\n{\n\tif (size == 0)\n\t\treturn __write_ports_names(buf, net);\n\n\tif (isdigit(buf[0]))\n\t\treturn __write_ports_addfd(buf, net);\n\n\tif (isalpha(buf[0]))\n\t\treturn __write_ports_addxprt(buf, net);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
            "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
            "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t __write_ports(struct file *file, char *buf, size_t size,\n\t\t\t     struct net *net)\n{\n\tif (size == 0)\n\t\treturn __write_ports_names(buf, net);\n\n\tif (isdigit(buf[0]))\n\t\treturn __write_ports_addfd(buf, net);\n\n\tif (isalpha(buf[0]))\n\t\treturn __write_ports_addxprt(buf, net);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_ports(file, buf, size, netns(file));\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
  },
  {
    "function_name": "__write_ports",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "775-788",
    "snippet": "static ssize_t __write_ports(struct file *file, char *buf, size_t size,\n\t\t\t     struct net *net)\n{\n\tif (size == 0)\n\t\treturn __write_ports_names(buf, net);\n\n\tif (isdigit(buf[0]))\n\t\treturn __write_ports_addfd(buf, net);\n\n\tif (isalpha(buf[0]))\n\t\treturn __write_ports_addxprt(buf, net);\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__write_ports_addxprt",
          "args": [
            "buf",
            "net"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "__write_ports_addxprt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "734-773",
          "snippet": "static ssize_t __write_ports_addxprt(char *buf, struct net *net)\n{\n\tchar transport[16];\n\tstruct svc_xprt *xprt;\n\tint port, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (sscanf(buf, \"%15s %5u\", transport, &port) != 2)\n\t\treturn -EINVAL;\n\n\tif (port < 1 || port > USHRT_MAX)\n\t\treturn -EINVAL;\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET6, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0 && err != -EAFNOSUPPORT)\n\t\tgoto out_close;\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn 0;\nout_close:\n\txprt = svc_find_xprt(nn->nfsd_serv, transport, net, PF_INET, port);\n\tif (xprt != NULL) {\n\t\tsvc_close_xprt(xprt);\n\t\tsvc_xprt_put(xprt);\n\t}\nout_err:\n\tnfsd_destroy(net);\n\treturn err;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfsd_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic ssize_t __write_ports_addxprt(char *buf, struct net *net)\n{\n\tchar transport[16];\n\tstruct svc_xprt *xprt;\n\tint port, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (sscanf(buf, \"%15s %5u\", transport, &port) != 2)\n\t\treturn -EINVAL;\n\n\tif (port < 1 || port > USHRT_MAX)\n\t\treturn -EINVAL;\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET6, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0 && err != -EAFNOSUPPORT)\n\t\tgoto out_close;\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn 0;\nout_close:\n\txprt = svc_find_xprt(nn->nfsd_serv, transport, net, PF_INET, port);\n\tif (xprt != NULL) {\n\t\tsvc_close_xprt(xprt);\n\t\tsvc_xprt_put(xprt);\n\t}\nout_err:\n\tnfsd_destroy(net);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "buf[0]"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__write_ports_addfd",
          "args": [
            "buf",
            "net"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "__write_ports_addfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "700-728",
          "snippet": "static ssize_t __write_ports_addfd(char *buf, struct net *net)\n{\n\tchar *mesg = buf;\n\tint fd, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = get_int(&mesg, &fd);\n\tif (err != 0 || fd < 0)\n\t\treturn -EINVAL;\n\n\tif (svc_alien_sock(net, fd)) {\n\t\tprintk(KERN_ERR \"%s: socket net is different to NFSd's one\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_addsock(nn->nfsd_serv, fd, buf, SIMPLE_TRANSACTION_LIMIT);\n\tif (err < 0) {\n\t\tnfsd_destroy(net);\n\t\treturn err;\n\t}\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn err;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfsd_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic ssize_t __write_ports_addfd(char *buf, struct net *net)\n{\n\tchar *mesg = buf;\n\tint fd, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = get_int(&mesg, &fd);\n\tif (err != 0 || fd < 0)\n\t\treturn -EINVAL;\n\n\tif (svc_alien_sock(net, fd)) {\n\t\tprintk(KERN_ERR \"%s: socket net is different to NFSd's one\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_addsock(nn->nfsd_serv, fd, buf, SIMPLE_TRANSACTION_LIMIT);\n\tif (err < 0) {\n\t\tnfsd_destroy(net);\n\t\treturn err;\n\t}\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "buf[0]"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__write_ports_names",
          "args": [
            "buf",
            "net"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "__write_ports_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "686-693",
          "snippet": "static ssize_t __write_ports_names(char *buf, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\treturn svc_xprt_names(nn->nfsd_serv, buf, SIMPLE_TRANSACTION_LIMIT);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfsd_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic ssize_t __write_ports_names(char *buf, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\treturn svc_xprt_names(nn->nfsd_serv, buf, SIMPLE_TRANSACTION_LIMIT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t __write_ports(struct file *file, char *buf, size_t size,\n\t\t\t     struct net *net)\n{\n\tif (size == 0)\n\t\treturn __write_ports_names(buf, net);\n\n\tif (isdigit(buf[0]))\n\t\treturn __write_ports_addfd(buf, net);\n\n\tif (isalpha(buf[0]))\n\t\treturn __write_ports_addxprt(buf, net);\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__write_ports_addxprt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "734-773",
    "snippet": "static ssize_t __write_ports_addxprt(char *buf, struct net *net)\n{\n\tchar transport[16];\n\tstruct svc_xprt *xprt;\n\tint port, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (sscanf(buf, \"%15s %5u\", transport, &port) != 2)\n\t\treturn -EINVAL;\n\n\tif (port < 1 || port > USHRT_MAX)\n\t\treturn -EINVAL;\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET6, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0 && err != -EAFNOSUPPORT)\n\t\tgoto out_close;\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn 0;\nout_close:\n\txprt = svc_find_xprt(nn->nfsd_serv, transport, net, PF_INET, port);\n\tif (xprt != NULL) {\n\t\tsvc_close_xprt(xprt);\n\t\tsvc_xprt_put(xprt);\n\t}\nout_err:\n\tnfsd_destroy(net);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "522-532",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_xprt_put",
          "args": [
            "xprt"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_close_xprt",
          "args": [
            "xprt"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_find_xprt",
          "args": [
            "nn->nfsd_serv",
            "transport",
            "net",
            "PF_INET",
            "port"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "nn->nfsd_serv",
            "transport",
            "net",
            "PF_INET6",
            "port",
            "SVC_SOCK_ANONYMOUS"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "nn->nfsd_serv",
            "transport",
            "net",
            "PF_INET",
            "port",
            "SVC_SOCK_ANONYMOUS"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_create_serv",
          "args": [
            "net"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create_serv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "465-497",
          "snippet": "int nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct svc_program\tnfsd_program;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nextern struct svc_program\tnfsd_program;\n\nint nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%15s %5u\"",
            "transport",
            "&port"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic ssize_t __write_ports_addxprt(char *buf, struct net *net)\n{\n\tchar transport[16];\n\tstruct svc_xprt *xprt;\n\tint port, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (sscanf(buf, \"%15s %5u\", transport, &port) != 2)\n\t\treturn -EINVAL;\n\n\tif (port < 1 || port > USHRT_MAX)\n\t\treturn -EINVAL;\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0)\n\t\tgoto out_err;\n\n\terr = svc_create_xprt(nn->nfsd_serv, transport, net,\n\t\t\t\tPF_INET6, port, SVC_SOCK_ANONYMOUS);\n\tif (err < 0 && err != -EAFNOSUPPORT)\n\t\tgoto out_close;\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn 0;\nout_close:\n\txprt = svc_find_xprt(nn->nfsd_serv, transport, net, PF_INET, port);\n\tif (xprt != NULL) {\n\t\tsvc_close_xprt(xprt);\n\t\tsvc_xprt_put(xprt);\n\t}\nout_err:\n\tnfsd_destroy(net);\n\treturn err;\n}"
  },
  {
    "function_name": "__write_ports_addfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "700-728",
    "snippet": "static ssize_t __write_ports_addfd(char *buf, struct net *net)\n{\n\tchar *mesg = buf;\n\tint fd, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = get_int(&mesg, &fd);\n\tif (err != 0 || fd < 0)\n\t\treturn -EINVAL;\n\n\tif (svc_alien_sock(net, fd)) {\n\t\tprintk(KERN_ERR \"%s: socket net is different to NFSd's one\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_addsock(nn->nfsd_serv, fd, buf, SIMPLE_TRANSACTION_LIMIT);\n\tif (err < 0) {\n\t\tnfsd_destroy(net);\n\t\treturn err;\n\t}\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "522-532",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_addsock",
          "args": [
            "nn->nfsd_serv",
            "fd",
            "buf",
            "SIMPLE_TRANSACTION_LIMIT"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_create_serv",
          "args": [
            "net"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create_serv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "465-497",
          "snippet": "int nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct svc_program\tnfsd_program;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nextern struct svc_program\tnfsd_program;\n\nint nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: socket net is different to NFSd's one\\n\"",
            "__func__"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_alien_sock",
          "args": [
            "net",
            "fd"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&fd"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic ssize_t __write_ports_addfd(char *buf, struct net *net)\n{\n\tchar *mesg = buf;\n\tint fd, err;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = get_int(&mesg, &fd);\n\tif (err != 0 || fd < 0)\n\t\treturn -EINVAL;\n\n\tif (svc_alien_sock(net, fd)) {\n\t\tprintk(KERN_ERR \"%s: socket net is different to NFSd's one\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\terr = nfsd_create_serv(net);\n\tif (err != 0)\n\t\treturn err;\n\n\terr = svc_addsock(nn->nfsd_serv, fd, buf, SIMPLE_TRANSACTION_LIMIT);\n\tif (err < 0) {\n\t\tnfsd_destroy(net);\n\t\treturn err;\n\t}\n\n\t/* Decrease the count, but don't shut down the service */\n\tnn->nfsd_serv->sv_nrthreads--;\n\treturn err;\n}"
  },
  {
    "function_name": "__write_ports_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "686-693",
    "snippet": "static ssize_t __write_ports_names(char *buf, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\treturn svc_xprt_names(nn->nfsd_serv, buf, SIMPLE_TRANSACTION_LIMIT);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_xprt_names",
          "args": [
            "nn->nfsd_serv",
            "buf",
            "SIMPLE_TRANSACTION_LIMIT"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic ssize_t __write_ports_names(char *buf, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\treturn svc_xprt_names(nn->nfsd_serv, buf, SIMPLE_TRANSACTION_LIMIT);\n}"
  },
  {
    "function_name": "write_versions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "672-680",
    "snippet": "static ssize_t write_versions(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_versions(file, buf, size);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__write_versions",
          "args": [
            "file",
            "buf",
            "size"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "__write_versions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "542-638",
          "snippet": "static ssize_t __write_versions(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tchar *vers, *minorp, sign;\n\tint len, num, remaining;\n\tunsigned minor;\n\tssize_t tlen = 0;\n\tchar *sep;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size>0) {\n\t\tif (nn->nfsd_serv)\n\t\t\t/* Cannot change versions without updating\n\t\t\t * nn->nfsd_serv->sv_xdrsize, and reallocing\n\t\t\t * rq_argp and rq_resp\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t\tif (buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\tvers = mesg;\n\t\tlen = qword_get(&mesg, vers, size);\n\t\tif (len <= 0) return -EINVAL;\n\t\tdo {\n\t\t\tsign = *vers;\n\t\t\tif (sign == '+' || sign == '-')\n\t\t\t\tnum = simple_strtol((vers+1), &minorp, 0);\n\t\t\telse\n\t\t\t\tnum = simple_strtol(vers, &minorp, 0);\n\t\t\tif (*minorp == '.') {\n\t\t\t\tif (num != 4)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tminor = simple_strtoul(minorp+1, NULL, 0);\n\t\t\t\tif (minor == 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (nfsd_minorversion(minor, sign == '-' ?\n\t\t\t\t\t\t     NFSD_CLEAR : NFSD_SET) < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tswitch(num) {\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\tnfsd_vers(num, sign == '-' ? NFSD_CLEAR : NFSD_SET);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\tnext:\n\t\t\tvers += len + 1;\n\t\t} while ((len = qword_get(&mesg, vers, size)) > 0);\n\t\t/* If all get turned off, turn them back on, as\n\t\t * having no versions is BAD\n\t\t */\n\t\tnfsd_reset_versions();\n\t}\n\n\t/* Now write current state into reply buffer */\n\tlen = 0;\n\tsep = \"\";\n\tremaining = SIMPLE_TRANSACTION_LIMIT;\n\tfor (num=2 ; num <= 4 ; num++)\n\t\tif (nfsd_vers(num, NFSD_AVAIL)) {\n\t\t\tlen = snprintf(buf, remaining, \"%s%c%d\", sep,\n\t\t\t\t       nfsd_vers(num, NFSD_TEST)?'+':'-',\n\t\t\t\t       num);\n\t\t\tsep = \" \";\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\tif (nfsd_vers(4, NFSD_AVAIL))\n\t\tfor (minor = 1; minor <= NFSD_SUPPORTED_MINOR_VERSION;\n\t\t     minor++) {\n\t\t\tlen = snprintf(buf, remaining, \" %c4.%u\",\n\t\t\t\t\t(nfsd_vers(4, NFSD_TEST) &&\n\t\t\t\t\t nfsd_minorversion(minor, NFSD_TEST)) ?\n\t\t\t\t\t\t'+' : '-',\n\t\t\t\t\tminor);\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\n\tlen = snprintf(buf, remaining, \"\\n\");\n\tif (len >= remaining)\n\t\treturn -EINVAL;\n\treturn tlen + len;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
            "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
            "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
            "int nfsd_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_net_id;\n\nstatic ssize_t __write_versions(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tchar *vers, *minorp, sign;\n\tint len, num, remaining;\n\tunsigned minor;\n\tssize_t tlen = 0;\n\tchar *sep;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size>0) {\n\t\tif (nn->nfsd_serv)\n\t\t\t/* Cannot change versions without updating\n\t\t\t * nn->nfsd_serv->sv_xdrsize, and reallocing\n\t\t\t * rq_argp and rq_resp\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t\tif (buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\tvers = mesg;\n\t\tlen = qword_get(&mesg, vers, size);\n\t\tif (len <= 0) return -EINVAL;\n\t\tdo {\n\t\t\tsign = *vers;\n\t\t\tif (sign == '+' || sign == '-')\n\t\t\t\tnum = simple_strtol((vers+1), &minorp, 0);\n\t\t\telse\n\t\t\t\tnum = simple_strtol(vers, &minorp, 0);\n\t\t\tif (*minorp == '.') {\n\t\t\t\tif (num != 4)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tminor = simple_strtoul(minorp+1, NULL, 0);\n\t\t\t\tif (minor == 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (nfsd_minorversion(minor, sign == '-' ?\n\t\t\t\t\t\t     NFSD_CLEAR : NFSD_SET) < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tswitch(num) {\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\tnfsd_vers(num, sign == '-' ? NFSD_CLEAR : NFSD_SET);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\tnext:\n\t\t\tvers += len + 1;\n\t\t} while ((len = qword_get(&mesg, vers, size)) > 0);\n\t\t/* If all get turned off, turn them back on, as\n\t\t * having no versions is BAD\n\t\t */\n\t\tnfsd_reset_versions();\n\t}\n\n\t/* Now write current state into reply buffer */\n\tlen = 0;\n\tsep = \"\";\n\tremaining = SIMPLE_TRANSACTION_LIMIT;\n\tfor (num=2 ; num <= 4 ; num++)\n\t\tif (nfsd_vers(num, NFSD_AVAIL)) {\n\t\t\tlen = snprintf(buf, remaining, \"%s%c%d\", sep,\n\t\t\t\t       nfsd_vers(num, NFSD_TEST)?'+':'-',\n\t\t\t\t       num);\n\t\t\tsep = \" \";\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\tif (nfsd_vers(4, NFSD_AVAIL))\n\t\tfor (minor = 1; minor <= NFSD_SUPPORTED_MINOR_VERSION;\n\t\t     minor++) {\n\t\t\tlen = snprintf(buf, remaining, \" %c4.%u\",\n\t\t\t\t\t(nfsd_vers(4, NFSD_TEST) &&\n\t\t\t\t\t nfsd_minorversion(minor, NFSD_TEST)) ?\n\t\t\t\t\t\t'+' : '-',\n\t\t\t\t\tminor);\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\n\tlen = snprintf(buf, remaining, \"\\n\");\n\tif (len >= remaining)\n\t\treturn -EINVAL;\n\treturn tlen + len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size)\n{\n\tssize_t rv;\n\n\tmutex_lock(&nfsd_mutex);\n\trv = __write_versions(file, buf, size);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
  },
  {
    "function_name": "__write_versions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "542-638",
    "snippet": "static ssize_t __write_versions(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tchar *vers, *minorp, sign;\n\tint len, num, remaining;\n\tunsigned minor;\n\tssize_t tlen = 0;\n\tchar *sep;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size>0) {\n\t\tif (nn->nfsd_serv)\n\t\t\t/* Cannot change versions without updating\n\t\t\t * nn->nfsd_serv->sv_xdrsize, and reallocing\n\t\t\t * rq_argp and rq_resp\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t\tif (buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\tvers = mesg;\n\t\tlen = qword_get(&mesg, vers, size);\n\t\tif (len <= 0) return -EINVAL;\n\t\tdo {\n\t\t\tsign = *vers;\n\t\t\tif (sign == '+' || sign == '-')\n\t\t\t\tnum = simple_strtol((vers+1), &minorp, 0);\n\t\t\telse\n\t\t\t\tnum = simple_strtol(vers, &minorp, 0);\n\t\t\tif (*minorp == '.') {\n\t\t\t\tif (num != 4)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tminor = simple_strtoul(minorp+1, NULL, 0);\n\t\t\t\tif (minor == 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (nfsd_minorversion(minor, sign == '-' ?\n\t\t\t\t\t\t     NFSD_CLEAR : NFSD_SET) < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tswitch(num) {\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\tnfsd_vers(num, sign == '-' ? NFSD_CLEAR : NFSD_SET);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\tnext:\n\t\t\tvers += len + 1;\n\t\t} while ((len = qword_get(&mesg, vers, size)) > 0);\n\t\t/* If all get turned off, turn them back on, as\n\t\t * having no versions is BAD\n\t\t */\n\t\tnfsd_reset_versions();\n\t}\n\n\t/* Now write current state into reply buffer */\n\tlen = 0;\n\tsep = \"\";\n\tremaining = SIMPLE_TRANSACTION_LIMIT;\n\tfor (num=2 ; num <= 4 ; num++)\n\t\tif (nfsd_vers(num, NFSD_AVAIL)) {\n\t\t\tlen = snprintf(buf, remaining, \"%s%c%d\", sep,\n\t\t\t\t       nfsd_vers(num, NFSD_TEST)?'+':'-',\n\t\t\t\t       num);\n\t\t\tsep = \" \";\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\tif (nfsd_vers(4, NFSD_AVAIL))\n\t\tfor (minor = 1; minor <= NFSD_SUPPORTED_MINOR_VERSION;\n\t\t     minor++) {\n\t\t\tlen = snprintf(buf, remaining, \" %c4.%u\",\n\t\t\t\t\t(nfsd_vers(4, NFSD_TEST) &&\n\t\t\t\t\t nfsd_minorversion(minor, NFSD_TEST)) ?\n\t\t\t\t\t\t'+' : '-',\n\t\t\t\t\tminor);\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\n\tlen = snprintf(buf, remaining, \"\\n\");\n\tif (len >= remaining)\n\t\treturn -EINVAL;\n\treturn tlen + len;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "remaining",
            "\"\\n\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "remaining",
            "\" %c4.%u\"",
            "(nfsd_vers(4, NFSD_TEST) &&\n\t\t\t\t\t nfsd_minorversion(minor, NFSD_TEST)) ?\n\t\t\t\t\t\t'+' : '-'",
            "minor"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_minorversion",
          "args": [
            "minor",
            "NFSD_TEST"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_vers",
          "args": [
            "4",
            "NFSD_TEST"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_vers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "129-154",
          "snippet": "int nfsd_vers(int vers, enum vers_op change)\n{\n\tif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\n\t\treturn 0;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_versions[vers] = nfsd_version[vers];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = nfsd_acl_version[vers];\n#endif\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_versions[vers] = NULL;\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = NULL;\n#endif\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_versions[vers] != NULL;\n\tcase NFSD_AVAIL:\n\t\treturn nfsd_version[vers] != NULL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
            "#define NFSD_MINVERS    \t2",
            "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)"
          ],
          "globals_used": [
            "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};",
            "static struct svc_version *nfsd_versions[NFSD_NRVERS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\nstatic struct svc_version *nfsd_versions[NFSD_NRVERS];\n\nint nfsd_vers(int vers, enum vers_op change)\n{\n\tif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\n\t\treturn 0;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_versions[vers] = nfsd_version[vers];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = nfsd_acl_version[vers];\n#endif\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_versions[vers] = NULL;\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = NULL;\n#endif\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_versions[vers] != NULL;\n\tcase NFSD_AVAIL:\n\t\treturn nfsd_version[vers] != NULL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "remaining",
            "\"%s%c%d\"",
            "sep",
            "nfsd_vers(num, NFSD_TEST)?'+':'-'",
            "num"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reset_versions",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reset_versions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "393-412",
          "snippet": "void nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
            "#define NFSD_MINVERS    \t2",
            "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)",
            "#define NFSD_ACL_MINVERS            2"
          ],
          "globals_used": [
            "extern struct svc_program\tnfsd_program;",
            "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n#define NFSD_ACL_MINVERS            2\n\nextern struct svc_program\tnfsd_program;\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\n\nvoid nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "vers",
            "size"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "minorp+1",
            "NULL",
            "0"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "vers",
            "&minorp",
            "0"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "(vers+1)",
            "&minorp",
            "0"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "vers",
            "size"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "netns(file)",
            "nfsd_net_id"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nint nfsd_net_id;\n\nstatic ssize_t __write_versions(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tchar *vers, *minorp, sign;\n\tint len, num, remaining;\n\tunsigned minor;\n\tssize_t tlen = 0;\n\tchar *sep;\n\tstruct nfsd_net *nn = net_generic(netns(file), nfsd_net_id);\n\n\tif (size>0) {\n\t\tif (nn->nfsd_serv)\n\t\t\t/* Cannot change versions without updating\n\t\t\t * nn->nfsd_serv->sv_xdrsize, and reallocing\n\t\t\t * rq_argp and rq_resp\n\t\t\t */\n\t\t\treturn -EBUSY;\n\t\tif (buf[size-1] != '\\n')\n\t\t\treturn -EINVAL;\n\t\tbuf[size-1] = 0;\n\n\t\tvers = mesg;\n\t\tlen = qword_get(&mesg, vers, size);\n\t\tif (len <= 0) return -EINVAL;\n\t\tdo {\n\t\t\tsign = *vers;\n\t\t\tif (sign == '+' || sign == '-')\n\t\t\t\tnum = simple_strtol((vers+1), &minorp, 0);\n\t\t\telse\n\t\t\t\tnum = simple_strtol(vers, &minorp, 0);\n\t\t\tif (*minorp == '.') {\n\t\t\t\tif (num != 4)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tminor = simple_strtoul(minorp+1, NULL, 0);\n\t\t\t\tif (minor == 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tif (nfsd_minorversion(minor, sign == '-' ?\n\t\t\t\t\t\t     NFSD_CLEAR : NFSD_SET) < 0)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tswitch(num) {\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\t\tnfsd_vers(num, sign == '-' ? NFSD_CLEAR : NFSD_SET);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\tnext:\n\t\t\tvers += len + 1;\n\t\t} while ((len = qword_get(&mesg, vers, size)) > 0);\n\t\t/* If all get turned off, turn them back on, as\n\t\t * having no versions is BAD\n\t\t */\n\t\tnfsd_reset_versions();\n\t}\n\n\t/* Now write current state into reply buffer */\n\tlen = 0;\n\tsep = \"\";\n\tremaining = SIMPLE_TRANSACTION_LIMIT;\n\tfor (num=2 ; num <= 4 ; num++)\n\t\tif (nfsd_vers(num, NFSD_AVAIL)) {\n\t\t\tlen = snprintf(buf, remaining, \"%s%c%d\", sep,\n\t\t\t\t       nfsd_vers(num, NFSD_TEST)?'+':'-',\n\t\t\t\t       num);\n\t\t\tsep = \" \";\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\tif (nfsd_vers(4, NFSD_AVAIL))\n\t\tfor (minor = 1; minor <= NFSD_SUPPORTED_MINOR_VERSION;\n\t\t     minor++) {\n\t\t\tlen = snprintf(buf, remaining, \" %c4.%u\",\n\t\t\t\t\t(nfsd_vers(4, NFSD_TEST) &&\n\t\t\t\t\t nfsd_minorversion(minor, NFSD_TEST)) ?\n\t\t\t\t\t\t'+' : '-',\n\t\t\t\t\tminor);\n\n\t\t\tif (len >= remaining)\n\t\t\t\tbreak;\n\t\t\tremaining -= len;\n\t\t\tbuf += len;\n\t\t\ttlen += len;\n\t\t}\n\n\tlen = snprintf(buf, remaining, \"\\n\");\n\tif (len >= remaining)\n\t\treturn -EINVAL;\n\treturn tlen + len;\n}"
  },
  {
    "function_name": "write_pool_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "476-540",
    "snippet": "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size)\n{\n\t/* if size > 0, look for an array of number of threads per node\n\t * and apply them  then write out number of threads per node as reply\n\t */\n\tchar *mesg = buf;\n\tint i;\n\tint rv;\n\tint len;\n\tint npools;\n\tint *nthreads;\n\tstruct net *net = netns(file);\n\n\tmutex_lock(&nfsd_mutex);\n\tnpools = nfsd_nrpools(net);\n\tif (npools == 0) {\n\t\t/*\n\t\t * NFS is shut down.  The admin can start it by\n\t\t * writing to the threads file but NOT the pool_threads\n\t\t * file, sorry.  Report zero threads.\n\t\t */\n\t\tmutex_unlock(&nfsd_mutex);\n\t\tstrcpy(buf, \"0\\n\");\n\t\treturn strlen(buf);\n\t}\n\n\tnthreads = kcalloc(npools, sizeof(int), GFP_KERNEL);\n\trv = -ENOMEM;\n\tif (nthreads == NULL)\n\t\tgoto out_free;\n\n\tif (size > 0) {\n\t\tfor (i = 0; i < npools; i++) {\n\t\t\trv = get_int(&mesg, &nthreads[i]);\n\t\t\tif (rv == -ENOENT)\n\t\t\t\tbreak;\t\t/* fewer numbers than pools */\n\t\t\tif (rv)\n\t\t\t\tgoto out_free;\t/* syntax error */\n\t\t\trv = -EINVAL;\n\t\t\tif (nthreads[i] < 0)\n\t\t\t\tgoto out_free;\n\t\t}\n\t\trv = nfsd_set_nrthreads(i, nthreads, net);\n\t\tif (rv)\n\t\t\tgoto out_free;\n\t}\n\n\trv = nfsd_get_nrthreads(npools, nthreads, net);\n\tif (rv)\n\t\tgoto out_free;\n\n\tmesg = buf;\n\tsize = SIMPLE_TRANSACTION_LIMIT;\n\tfor (i = 0; i < npools && size > 0; i++) {\n\t\tsnprintf(mesg, size, \"%d%c\", nthreads[i], (i == npools-1 ? '\\n' : ' '));\n\t\tlen = strlen(mesg);\n\t\tsize -= len;\n\t\tmesg += len;\n\t}\n\trv = mesg - buf;\nout_free:\n\tkfree(nthreads);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nthreads"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mesg"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "mesg",
            "size",
            "\"%d%c\"",
            "nthreads[i]",
            "(i == npools-1 ? '\\n' : ' ')"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_get_nrthreads",
          "args": [
            "npools",
            "nthreads",
            "net"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_get_nrthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "509-520",
          "snippet": "int nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv != NULL) {\n\t\tfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\n\t\t\tnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv != NULL) {\n\t\tfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\n\t\t\tnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_set_nrthreads",
          "args": [
            "i",
            "nthreads",
            "net"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_set_nrthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "534-585",
          "snippet": "int nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tint tot = 0;\n\tint err = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\n\tif (nn->nfsd_serv == NULL || n <= 0)\n\t\treturn 0;\n\n\tif (n > nn->nfsd_serv->sv_nrpools)\n\t\tn = nn->nfsd_serv->sv_nrpools;\n\n\t/* enforce a global maximum number of threads */\n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tnthreads[i] = min(nthreads[i], NFSD_MAXSERVS);\n\t\ttot += nthreads[i];\n\t}\n\tif (tot > NFSD_MAXSERVS) {\n\t\t/* total too large: scale down requested numbers */\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t    \tint new = nthreads[i] * NFSD_MAXSERVS / tot;\n\t\t\ttot -= (nthreads[i] - new);\n\t\t\tnthreads[i] = new;\n\t\t}\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tnthreads[i]--;\n\t\t\ttot--;\n\t\t}\n\t}\n\n\t/*\n\t * There must always be a thread in pool 0; the admin\n\t * can't shut down NFS completely using pool_threads.\n\t */\n\tif (nthreads[0] == 0)\n\t\tnthreads[0] = 1;\n\n\t/* apply the new numbers */\n\tsvc_get(nn->nfsd_serv);\n\tfor (i = 0; i < n; i++) {\n\t\terr = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\t\t&nn->nfsd_serv->sv_pools[i], nthreads[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tnfsd_destroy(net);\n\treturn err;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define\tNFSD_MAXSERVS\t\t8192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define\tNFSD_MAXSERVS\t\t8192\n\nint nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tint tot = 0;\n\tint err = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\n\tif (nn->nfsd_serv == NULL || n <= 0)\n\t\treturn 0;\n\n\tif (n > nn->nfsd_serv->sv_nrpools)\n\t\tn = nn->nfsd_serv->sv_nrpools;\n\n\t/* enforce a global maximum number of threads */\n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tnthreads[i] = min(nthreads[i], NFSD_MAXSERVS);\n\t\ttot += nthreads[i];\n\t}\n\tif (tot > NFSD_MAXSERVS) {\n\t\t/* total too large: scale down requested numbers */\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t    \tint new = nthreads[i] * NFSD_MAXSERVS / tot;\n\t\t\ttot -= (nthreads[i] - new);\n\t\t\tnthreads[i] = new;\n\t\t}\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tnthreads[i]--;\n\t\t\ttot--;\n\t\t}\n\t}\n\n\t/*\n\t * There must always be a thread in pool 0; the admin\n\t * can't shut down NFS completely using pool_threads.\n\t */\n\tif (nthreads[0] == 0)\n\t\tnthreads[0] = 1;\n\n\t/* apply the new numbers */\n\tsvc_get(nn->nfsd_serv);\n\tfor (i = 0; i < n; i++) {\n\t\terr = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\t\t&nn->nfsd_serv->sv_pools[i], nthreads[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tnfsd_destroy(net);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&nthreads[i]"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "npools",
            "sizeof(int)",
            "GFP_KERNEL"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "\"0\\n\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_nrpools",
          "args": [
            "net"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_nrpools",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "499-507",
          "snippet": "int nfsd_nrpools(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\telse\n\t\treturn nn->nfsd_serv->sv_nrpools;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_nrpools(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\telse\n\t\treturn nn->nfsd_serv->sv_nrpools;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size)\n{\n\t/* if size > 0, look for an array of number of threads per node\n\t * and apply them  then write out number of threads per node as reply\n\t */\n\tchar *mesg = buf;\n\tint i;\n\tint rv;\n\tint len;\n\tint npools;\n\tint *nthreads;\n\tstruct net *net = netns(file);\n\n\tmutex_lock(&nfsd_mutex);\n\tnpools = nfsd_nrpools(net);\n\tif (npools == 0) {\n\t\t/*\n\t\t * NFS is shut down.  The admin can start it by\n\t\t * writing to the threads file but NOT the pool_threads\n\t\t * file, sorry.  Report zero threads.\n\t\t */\n\t\tmutex_unlock(&nfsd_mutex);\n\t\tstrcpy(buf, \"0\\n\");\n\t\treturn strlen(buf);\n\t}\n\n\tnthreads = kcalloc(npools, sizeof(int), GFP_KERNEL);\n\trv = -ENOMEM;\n\tif (nthreads == NULL)\n\t\tgoto out_free;\n\n\tif (size > 0) {\n\t\tfor (i = 0; i < npools; i++) {\n\t\t\trv = get_int(&mesg, &nthreads[i]);\n\t\t\tif (rv == -ENOENT)\n\t\t\t\tbreak;\t\t/* fewer numbers than pools */\n\t\t\tif (rv)\n\t\t\t\tgoto out_free;\t/* syntax error */\n\t\t\trv = -EINVAL;\n\t\t\tif (nthreads[i] < 0)\n\t\t\t\tgoto out_free;\n\t\t}\n\t\trv = nfsd_set_nrthreads(i, nthreads, net);\n\t\tif (rv)\n\t\t\tgoto out_free;\n\t}\n\n\trv = nfsd_get_nrthreads(npools, nthreads, net);\n\tif (rv)\n\t\tgoto out_free;\n\n\tmesg = buf;\n\tsize = SIMPLE_TRANSACTION_LIMIT;\n\tfor (i = 0; i < npools && size > 0; i++) {\n\t\tsnprintf(mesg, size, \"%d%c\", nthreads[i], (i == npools-1 ? '\\n' : ' '));\n\t\tlen = strlen(mesg);\n\t\tsize -= len;\n\t\tmesg += len;\n\t}\n\trv = mesg - buf;\nout_free:\n\tkfree(nthreads);\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
  },
  {
    "function_name": "write_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "432-452",
    "snippet": "static ssize_t write_threads(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tint rv;\n\tstruct net *net = netns(file);\n\n\tif (size > 0) {\n\t\tint newthreads;\n\t\trv = get_int(&mesg, &newthreads);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\tif (newthreads < 0)\n\t\t\treturn -EINVAL;\n\t\trv = nfsd_svc(newthreads, net);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t} else\n\t\trv = nfsd_nrthreads(net);\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%d\\n\", rv);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "buf",
            "SIMPLE_TRANSACTION_LIMIT",
            "\"%d\\n\"",
            "rv"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_nrthreads",
          "args": [
            "net"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_nrthreads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "180-190",
          "snippet": "int nfsd_nrthreads(struct net *net)\n{\n\tint rv = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv)\n\t\trv = nn->nfsd_serv->sv_nrthreads;\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_nrthreads(struct net *net)\n{\n\tint rv = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv)\n\t\trv = nn->nfsd_serv->sv_nrthreads;\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_svc",
          "args": [
            "newthreads",
            "net"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_svc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "592-635",
          "snippet": "int\nnfsd_svc(int nrservs, struct net *net)\n{\n\tint\terror;\n\tbool\tnfsd_up_before;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tdprintk(\"nfsd: creating service\\n\");\n\n\tnrservs = max(nrservs, 0);\n\tnrservs = min(nrservs, NFSD_MAXSERVS);\n\terror = 0;\n\n\tif (nrservs == 0 && nn->nfsd_serv == NULL)\n\t\tgoto out;\n\n\terror = nfsd_create_serv(net);\n\tif (error)\n\t\tgoto out;\n\n\tnfsd_up_before = nn->nfsd_net_up;\n\n\terror = nfsd_startup_net(nrservs, net);\n\tif (error)\n\t\tgoto out_destroy;\n\terror = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\tNULL, nrservs);\n\tif (error)\n\t\tgoto out_shutdown;\n\t/* We are holding a reference to nn->nfsd_serv which\n\t * we don't want to count in the return value,\n\t * so subtract 1\n\t */\n\terror = nn->nfsd_serv->sv_nrthreads - 1;\nout_shutdown:\n\tif (error < 0 && !nfsd_up_before)\n\t\tnfsd_shutdown_net(net);\nout_destroy:\n\tnfsd_destroy(net);\t\t/* Release server */\nout:\n\tmutex_unlock(&nfsd_mutex);\n\treturn error;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define\tNFSD_MAXSERVS\t\t8192"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define\tNFSD_MAXSERVS\t\t8192\n\nint\nnfsd_svc(int nrservs, struct net *net)\n{\n\tint\terror;\n\tbool\tnfsd_up_before;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tdprintk(\"nfsd: creating service\\n\");\n\n\tnrservs = max(nrservs, 0);\n\tnrservs = min(nrservs, NFSD_MAXSERVS);\n\terror = 0;\n\n\tif (nrservs == 0 && nn->nfsd_serv == NULL)\n\t\tgoto out;\n\n\terror = nfsd_create_serv(net);\n\tif (error)\n\t\tgoto out;\n\n\tnfsd_up_before = nn->nfsd_net_up;\n\n\terror = nfsd_startup_net(nrservs, net);\n\tif (error)\n\t\tgoto out_destroy;\n\terror = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\tNULL, nrservs);\n\tif (error)\n\t\tgoto out_shutdown;\n\t/* We are holding a reference to nn->nfsd_serv which\n\t * we don't want to count in the return value,\n\t * so subtract 1\n\t */\n\terror = nn->nfsd_serv->sv_nrthreads - 1;\nout_shutdown:\n\tif (error < 0 && !nfsd_up_before)\n\t\tnfsd_shutdown_net(net);\nout_destroy:\n\tnfsd_destroy(net);\t\t/* Release server */\nout:\n\tmutex_unlock(&nfsd_mutex);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&newthreads"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size)\n{\n\tchar *mesg = buf;\n\tint rv;\n\tstruct net *net = netns(file);\n\n\tif (size > 0) {\n\t\tint newthreads;\n\t\trv = get_int(&mesg, &newthreads);\n\t\tif (rv)\n\t\t\treturn rv;\n\t\tif (newthreads < 0)\n\t\t\treturn -EINVAL;\n\t\trv = nfsd_svc(newthreads, net);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t} else\n\t\trv = nfsd_nrthreads(net);\n\n\treturn scnprintf(buf, SIMPLE_TRANSACTION_LIMIT, \"%d\\n\", rv);\n}"
  },
  {
    "function_name": "write_filehandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "350-402",
    "snippet": "static ssize_t write_filehandle(struct file *file, char *buf, size_t size)\n{\n\tchar *dname, *path;\n\tint uninitialized_var(maxsize);\n\tchar *mesg = buf;\n\tint len;\n\tstruct auth_domain *dom;\n\tstruct knfsd_fh fh;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\tbuf[size-1] = 0;\n\n\tdname = mesg;\n\tlen = qword_get(&mesg, dname, size);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\t\n\tpath = dname+len+1;\n\tlen = qword_get(&mesg, path, size);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = get_int(&mesg, &maxsize);\n\tif (len)\n\t\treturn len;\n\n\tif (maxsize < NFS_FHSIZE)\n\t\treturn -EINVAL;\n\tmaxsize = min(maxsize, NFS3_FHSIZE);\n\n\tif (qword_get(&mesg, mesg, size)>0)\n\t\treturn -EINVAL;\n\n\t/* we have all the words, they are in buf.. */\n\tdom = unix_domain_find(dname);\n\tif (!dom)\n\t\treturn -ENOMEM;\n\n\tlen = exp_rootfh(netns(file), dom, path, &fh,  maxsize);\n\tauth_domain_put(dom);\n\tif (len)\n\t\treturn len;\n\t\n\tmesg = buf;\n\tlen = SIMPLE_TRANSACTION_LIMIT;\n\tqword_addhex(&mesg, &len, (char*)&fh.fh_base, fh.fh_size);\n\tmesg[-1] = '\\n';\n\treturn mesg - buf;\t\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qword_addhex",
          "args": [
            "&mesg",
            "&len",
            "(char*)&fh.fh_base",
            "fh.fh_size"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "dom"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_rootfh",
          "args": [
            "netns(file)",
            "dom",
            "path",
            "&fh",
            "maxsize"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "exp_rootfh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "875-918",
          "snippet": "int\nexp_rootfh(struct net *net, struct auth_domain *clp, char *name,\n\t   struct knfsd_fh *f, int maxsize)\n{\n\tstruct svc_export\t*exp;\n\tstruct path\t\tpath;\n\tstruct inode\t\t*inode;\n\tstruct svc_fh\t\tfh;\n\tint\t\t\terr;\n\tstruct nfsd_net\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct cache_detail\t*cd = nn->svc_export_cache;\n\n\terr = -EPERM;\n\t/* NB: we probably ought to check that it's NUL-terminated */\n\tif (kern_path(name, 0, &path)) {\n\t\tprintk(\"nfsd: exp_rootfh path not found %s\", name);\n\t\treturn err;\n\t}\n\tinode = d_inode(path.dentry);\n\n\tdprintk(\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\",\n\t\t name, path.dentry, clp->name,\n\t\t inode->i_sb->s_id, inode->i_ino);\n\texp = exp_parent(cd, clp, &path);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * fh must be initialized before calling fh_compose\n\t */\n\tfh_init(&fh, maxsize);\n\tif (fh_compose(&fh, exp, path.dentry, NULL))\n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\tmemcpy(f, &fh.fh_handle, sizeof(struct knfsd_fh));\n\tfh_put(&fh);\n\texp_put(exp);\nout:\n\tpath_put(&path);\n\treturn err;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
            "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nint\nexp_rootfh(struct net *net, struct auth_domain *clp, char *name,\n\t   struct knfsd_fh *f, int maxsize)\n{\n\tstruct svc_export\t*exp;\n\tstruct path\t\tpath;\n\tstruct inode\t\t*inode;\n\tstruct svc_fh\t\tfh;\n\tint\t\t\terr;\n\tstruct nfsd_net\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct cache_detail\t*cd = nn->svc_export_cache;\n\n\terr = -EPERM;\n\t/* NB: we probably ought to check that it's NUL-terminated */\n\tif (kern_path(name, 0, &path)) {\n\t\tprintk(\"nfsd: exp_rootfh path not found %s\", name);\n\t\treturn err;\n\t}\n\tinode = d_inode(path.dentry);\n\n\tdprintk(\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\",\n\t\t name, path.dentry, clp->name,\n\t\t inode->i_sb->s_id, inode->i_ino);\n\texp = exp_parent(cd, clp, &path);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * fh must be initialized before calling fh_compose\n\t */\n\tfh_init(&fh, maxsize);\n\tif (fh_compose(&fh, exp, path.dentry, NULL))\n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\tmemcpy(f, &fh.fh_handle, sizeof(struct knfsd_fh));\n\tfh_put(&fh);\n\texp_put(exp);\nout:\n\tpath_put(&path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unix_domain_find",
          "args": [
            "dname"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "mesg",
            "size"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "maxsize",
            "NFS3_FHSIZE"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&maxsize"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "path",
            "size"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "dname",
            "size"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size)\n{\n\tchar *dname, *path;\n\tint uninitialized_var(maxsize);\n\tchar *mesg = buf;\n\tint len;\n\tstruct auth_domain *dom;\n\tstruct knfsd_fh fh;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\tbuf[size-1] = 0;\n\n\tdname = mesg;\n\tlen = qword_get(&mesg, dname, size);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\t\n\tpath = dname+len+1;\n\tlen = qword_get(&mesg, path, size);\n\tif (len <= 0)\n\t\treturn -EINVAL;\n\n\tlen = get_int(&mesg, &maxsize);\n\tif (len)\n\t\treturn len;\n\n\tif (maxsize < NFS_FHSIZE)\n\t\treturn -EINVAL;\n\tmaxsize = min(maxsize, NFS3_FHSIZE);\n\n\tif (qword_get(&mesg, mesg, size)>0)\n\t\treturn -EINVAL;\n\n\t/* we have all the words, they are in buf.. */\n\tdom = unix_domain_find(dname);\n\tif (!dom)\n\t\treturn -ENOMEM;\n\n\tlen = exp_rootfh(netns(file), dom, path, &fh,  maxsize);\n\tauth_domain_put(dom);\n\tif (len)\n\t\treturn len;\n\t\n\tmesg = buf;\n\tlen = SIMPLE_TRANSACTION_LIMIT;\n\tqword_addhex(&mesg, &len, (char*)&fh.fh_base, fh.fh_size);\n\tmesg[-1] = '\\n';\n\treturn mesg - buf;\t\n}"
  },
  {
    "function_name": "write_unlock_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "293-327",
    "snippet": "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size)\n{\n\tstruct path path;\n\tchar *fo_path;\n\tint error;\n\n\t/* sanity check */\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\n\tfo_path = buf;\n\tif (qword_get(&buf, fo_path, size) < 0)\n\t\treturn -EINVAL;\n\n\terror = kern_path(fo_path, 0, &path);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX: Needs better sanity checking.  Otherwise we could end up\n\t * releasing locks on the wrong file system.\n\t *\n\t * For example:\n\t * 1.  Does the path refer to a directory?\n\t * 2.  Is that directory a mount point, or\n\t * 3.  Is that directory the root of an exported file system?\n\t */\n\terror = nlmsvc_unlock_all_by_sb(path.dentry->d_sb);\n\n\tpath_put(&path);\n\treturn error;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsvc_unlock_all_by_sb",
          "args": [
            "path.dentry->d_sb"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "fo_path",
            "0",
            "&path"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&buf",
            "fo_path",
            "size"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size)\n{\n\tstruct path path;\n\tchar *fo_path;\n\tint error;\n\n\t/* sanity check */\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\n\tfo_path = buf;\n\tif (qword_get(&buf, fo_path, size) < 0)\n\t\treturn -EINVAL;\n\n\terror = kern_path(fo_path, 0, &path);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * XXX: Needs better sanity checking.  Otherwise we could end up\n\t * releasing locks on the wrong file system.\n\t *\n\t * For example:\n\t * 1.  Does the path refer to a directory?\n\t * 2.  Is that directory a mount point, or\n\t * 3.  Is that directory the root of an exported file system?\n\t */\n\terror = nlmsvc_unlock_all_by_sb(path.dentry->d_sb);\n\n\tpath_put(&path);\n\treturn error;\n}"
  },
  {
    "function_name": "write_unlock_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "254-277",
    "snippet": "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size)\n{\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *sap = (struct sockaddr *)&address;\n\tsize_t salen = sizeof(address);\n\tchar *fo_path;\n\tstruct net *net = netns(file);\n\n\t/* sanity check */\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\n\tfo_path = buf;\n\tif (qword_get(&buf, fo_path, size) < 0)\n\t\treturn -EINVAL;\n\n\tif (rpc_pton(net, fo_path, size, sap, salen) == 0)\n\t\treturn -EINVAL;\n\n\treturn nlmsvc_unlock_all_by_ip(sap);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsvc_unlock_all_by_ip",
          "args": [
            "sap"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_pton",
          "args": [
            "net",
            "fo_path",
            "size",
            "sap",
            "salen"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&buf",
            "fo_path",
            "size"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netns",
          "args": [
            "file"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "netns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "235-238",
          "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size)\n{\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *sap = (struct sockaddr *)&address;\n\tsize_t salen = sizeof(address);\n\tchar *fo_path;\n\tstruct net *net = netns(file);\n\n\t/* sanity check */\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\tif (buf[size-1] != '\\n')\n\t\treturn -EINVAL;\n\n\tfo_path = buf;\n\tif (qword_get(&buf, fo_path, size) < 0)\n\t\treturn -EINVAL;\n\n\tif (rpc_pton(net, fo_path, size, sap, salen) == 0)\n\t\treturn -EINVAL;\n\n\treturn nlmsvc_unlock_all_by_ip(sap);\n}"
  },
  {
    "function_name": "netns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "235-238",
    "snippet": "static inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline struct net *netns(struct file *file)\n{\n\treturn file_inode(file)->i_sb->s_fs_info;\n}"
  },
  {
    "function_name": "supported_enctypes_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "202-205",
    "snippet": "static int supported_enctypes_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, supported_enctypes_show, NULL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "supported_enctypes_show",
            "NULL"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int supported_enctypes_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, supported_enctypes_show, NULL);\n}"
  },
  {
    "function_name": "supported_enctypes_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "196-200",
    "snippet": "static int supported_enctypes_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, KRB5_SUPPORTED_ENCTYPES);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "KRB5_SUPPORTED_ENCTYPES"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int supported_enctypes_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, KRB5_SUPPORTED_ENCTYPES);\n\treturn 0;\n}"
  },
  {
    "function_name": "export_features_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "183-186",
    "snippet": "static int export_features_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, export_features_show, NULL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "export_features_show",
            "NULL"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int export_features_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, export_features_show, NULL);\n}"
  },
  {
    "function_name": "export_features_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "177-181",
    "snippet": "static int export_features_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"0x%x 0x%x\\n\", NFSEXP_ALLFLAGS, NFSEXP_SECINFO_FLAGS);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%x 0x%x\\n\"",
            "NFSEXP_ALLFLAGS",
            "NFSEXP_SECINFO_FLAGS"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int export_features_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"0x%x 0x%x\\n\", NFSEXP_ALLFLAGS, NFSEXP_SECINFO_FLAGS);\n\treturn 0;\n}"
  },
  {
    "function_name": "exports_nfsd_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "164-167",
    "snippet": "static int exports_nfsd_open(struct inode *inode, struct file *file)\n{\n\treturn exports_net_open(inode->i_sb->s_fs_info, file);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exports_net_open",
          "args": [
            "inode->i_sb->s_fs_info",
            "file"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "exports_net_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "136-149",
          "snippet": "static int exports_net_open(struct net *net, struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = seq_open(file, &nfs_exports_op);\n\tif (err)\n\t\treturn err;\n\n\tseq = file->private_data;\n\tseq->private = nn->svc_export_cache;\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfsd_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic int exports_net_open(struct net *net, struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = seq_open(file, &nfs_exports_op);\n\tif (err)\n\t\treturn err;\n\n\tseq = file->private_data;\n\tseq->private = nn->svc_export_cache;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int exports_nfsd_open(struct inode *inode, struct file *file)\n{\n\treturn exports_net_open(inode->i_sb->s_fs_info, file);\n}"
  },
  {
    "function_name": "exports_proc_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "151-154",
    "snippet": "static int exports_proc_open(struct inode *inode, struct file *file)\n{\n\treturn exports_net_open(current->nsproxy->net_ns, file);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exports_net_open",
          "args": [
            "current->nsproxy->net_ns",
            "file"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "exports_net_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "136-149",
          "snippet": "static int exports_net_open(struct net *net, struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = seq_open(file, &nfs_exports_op);\n\tif (err)\n\t\treturn err;\n\n\tseq = file->private_data;\n\tseq->private = nn->svc_export_cache;\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nfsd_net_id;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic int exports_net_open(struct net *net, struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = seq_open(file, &nfs_exports_op);\n\tif (err)\n\t\treturn err;\n\n\tseq = file->private_data;\n\tseq->private = nn->svc_export_cache;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int exports_proc_open(struct inode *inode, struct file *file)\n{\n\treturn exports_net_open(current->nsproxy->net_ns, file);\n}"
  },
  {
    "function_name": "exports_net_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "136-149",
    "snippet": "static int exports_net_open(struct net *net, struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = seq_open(file, &nfs_exports_op);\n\tif (err)\n\t\treturn err;\n\n\tseq = file->private_data;\n\tseq->private = nn->svc_export_cache;\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int nfsd_net_id;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&nfs_exports_op"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nint nfsd_net_id;\n\nstatic int exports_net_open(struct net *net, struct file *file)\n{\n\tint err;\n\tstruct seq_file *seq;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\terr = seq_open(file, &nfs_exports_op);\n\tif (err)\n\t\treturn err;\n\n\tseq = file->private_data;\n\tseq->private = nn->svc_export_cache;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsctl_transaction_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "115-127",
    "snippet": "static ssize_t nfsctl_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\n{\n\tif (! file->private_data) {\n\t\t/* An attempt to read a transaction file without writing\n\t\t * causes a 0-byte write so that the file can return\n\t\t * state information\n\t\t */\n\t\tssize_t rv = nfsctl_transaction_write(file, buf, 0, pos);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t}\n\treturn simple_transaction_read(file, buf, size, pos);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_transaction_read",
          "args": [
            "file",
            "buf",
            "size",
            "pos"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsctl_transaction_write",
          "args": [
            "file",
            "buf",
            "0",
            "pos"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nfsctl_transaction_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
          "lines": "94-113",
          "snippet": "static ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino =  file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv =  write_op[ino](file, data, size);\n\tif (rv >= 0) {\n\t\tsimple_transaction_set(file, rv);\n\t\trv = size;\n\t}\n\treturn rv;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <linux/module.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <linux/sunrpc/gss_krb5_enctypes.h>",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/ctype.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
            "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
            "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
            "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
            "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
            "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
            "static ssize_t (*write_op[])(struct file *, char *, size_t) = {\n\t[NFSD_Fh] = write_filehandle,\n\t[NFSD_FO_UnlockIP] = write_unlock_ip,\n\t[NFSD_FO_UnlockFS] = write_unlock_fs,\n\t[NFSD_Threads] = write_threads,\n\t[NFSD_Pool_Threads] = write_pool_threads,\n\t[NFSD_Versions] = write_versions,\n\t[NFSD_Ports] = write_ports,\n\t[NFSD_MaxBlkSize] = write_maxblksize,\n\t[NFSD_MaxConnections] = write_maxconn,\n#ifdef CONFIG_NFSD_V4\n\t[NFSD_Leasetime] = write_leasetime,\n\t[NFSD_Gracetime] = write_gracetime,\n\t[NFSD_RecoveryDir] = write_recoverydir,\n\t[NFSD_V4EndGrace] = write_v4_end_grace,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nstatic ssize_t (*write_op[])(struct file *, char *, size_t) = {\n\t[NFSD_Fh] = write_filehandle,\n\t[NFSD_FO_UnlockIP] = write_unlock_ip,\n\t[NFSD_FO_UnlockFS] = write_unlock_fs,\n\t[NFSD_Threads] = write_threads,\n\t[NFSD_Pool_Threads] = write_pool_threads,\n\t[NFSD_Versions] = write_versions,\n\t[NFSD_Ports] = write_ports,\n\t[NFSD_MaxBlkSize] = write_maxblksize,\n\t[NFSD_MaxConnections] = write_maxconn,\n#ifdef CONFIG_NFSD_V4\n\t[NFSD_Leasetime] = write_leasetime,\n\t[NFSD_Gracetime] = write_gracetime,\n\t[NFSD_RecoveryDir] = write_recoverydir,\n\t[NFSD_V4EndGrace] = write_v4_end_grace,\n#endif\n};\n\nstatic ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino =  file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv =  write_op[ino](file, data, size);\n\tif (rv >= 0) {\n\t\tsimple_transaction_set(file, rv);\n\t\trv = size;\n\t}\n\treturn rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\n\nstatic ssize_t nfsctl_transaction_read(struct file *file, char __user *buf, size_t size, loff_t *pos)\n{\n\tif (! file->private_data) {\n\t\t/* An attempt to read a transaction file without writing\n\t\t * causes a 0-byte write so that the file can return\n\t\t * state information\n\t\t */\n\t\tssize_t rv = nfsctl_transaction_write(file, buf, 0, pos);\n\t\tif (rv < 0)\n\t\t\treturn rv;\n\t}\n\treturn simple_transaction_read(file, buf, size, pos);\n}"
  },
  {
    "function_name": "nfsctl_transaction_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsctl.c",
    "lines": "94-113",
    "snippet": "static ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino =  file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv =  write_op[ino](file, data, size);\n\tif (rv >= 0) {\n\t\tsimple_transaction_set(file, rv);\n\t\trv = size;\n\t}\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"state.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include \"idmap.h\"",
      "#include <linux/module.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <linux/sunrpc/gss_krb5_enctypes.h>",
      "#include <linux/sunrpc/gss_api.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/lockd/lockd.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/ctype.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ssize_t write_filehandle(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);",
      "static ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);",
      "static ssize_t write_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_pool_threads(struct file *file, char *buf, size_t size);",
      "static ssize_t write_versions(struct file *file, char *buf, size_t size);",
      "static ssize_t write_ports(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxblksize(struct file *file, char *buf, size_t size);",
      "static ssize_t write_maxconn(struct file *file, char *buf, size_t size);",
      "static ssize_t (*write_op[])(struct file *, char *, size_t) = {\n\t[NFSD_Fh] = write_filehandle,\n\t[NFSD_FO_UnlockIP] = write_unlock_ip,\n\t[NFSD_FO_UnlockFS] = write_unlock_fs,\n\t[NFSD_Threads] = write_threads,\n\t[NFSD_Pool_Threads] = write_pool_threads,\n\t[NFSD_Versions] = write_versions,\n\t[NFSD_Ports] = write_ports,\n\t[NFSD_MaxBlkSize] = write_maxblksize,\n\t[NFSD_MaxConnections] = write_maxconn,\n#ifdef CONFIG_NFSD_V4\n\t[NFSD_Leasetime] = write_leasetime,\n\t[NFSD_Gracetime] = write_gracetime,\n\t[NFSD_RecoveryDir] = write_recoverydir,\n\t[NFSD_V4EndGrace] = write_v4_end_grace,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_transaction_set",
          "args": [
            "file",
            "rv"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_op[ino]",
          "args": [
            "file",
            "data",
            "size"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_transaction_get",
          "args": [
            "file",
            "buf",
            "size"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "write_op"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <linux/module.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <linux/sunrpc/gss_krb5_enctypes.h>\n#include <linux/sunrpc/gss_api.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/lockd/lockd.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/ctype.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic ssize_t write_filehandle(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_ip(struct file *file, char *buf, size_t size);\nstatic ssize_t write_unlock_fs(struct file *file, char *buf, size_t size);\nstatic ssize_t write_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_pool_threads(struct file *file, char *buf, size_t size);\nstatic ssize_t write_versions(struct file *file, char *buf, size_t size);\nstatic ssize_t write_ports(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxblksize(struct file *file, char *buf, size_t size);\nstatic ssize_t write_maxconn(struct file *file, char *buf, size_t size);\nstatic ssize_t (*write_op[])(struct file *, char *, size_t) = {\n\t[NFSD_Fh] = write_filehandle,\n\t[NFSD_FO_UnlockIP] = write_unlock_ip,\n\t[NFSD_FO_UnlockFS] = write_unlock_fs,\n\t[NFSD_Threads] = write_threads,\n\t[NFSD_Pool_Threads] = write_pool_threads,\n\t[NFSD_Versions] = write_versions,\n\t[NFSD_Ports] = write_ports,\n\t[NFSD_MaxBlkSize] = write_maxblksize,\n\t[NFSD_MaxConnections] = write_maxconn,\n#ifdef CONFIG_NFSD_V4\n\t[NFSD_Leasetime] = write_leasetime,\n\t[NFSD_Gracetime] = write_gracetime,\n\t[NFSD_RecoveryDir] = write_recoverydir,\n\t[NFSD_V4EndGrace] = write_v4_end_grace,\n#endif\n};\n\nstatic ssize_t nfsctl_transaction_write(struct file *file, const char __user *buf, size_t size, loff_t *pos)\n{\n\tino_t ino =  file_inode(file)->i_ino;\n\tchar *data;\n\tssize_t rv;\n\n\tif (ino >= ARRAY_SIZE(write_op) || !write_op[ino])\n\t\treturn -EINVAL;\n\n\tdata = simple_transaction_get(file, buf, size);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trv =  write_op[ino](file, data, size);\n\tif (rv >= 0) {\n\t\tsimple_transaction_set(file, rv);\n\t\trv = size;\n\t}\n\treturn rv;\n}"
  }
]