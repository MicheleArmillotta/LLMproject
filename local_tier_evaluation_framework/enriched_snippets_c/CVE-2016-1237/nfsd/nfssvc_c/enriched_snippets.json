[
  {
    "function_name": "nfsd_pool_stats_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "818-828",
    "snippet": "int nfsd_pool_stats_release(struct inode *inode, struct file *file)\n{\n\tint ret = seq_release(inode, file);\n\tstruct net *net = inode->i_sb->s_fs_info;\n\n\tmutex_lock(&nfsd_mutex);\n\t/* this function really, really should have been called svc_put() */\n\tnfsd_destroy(net);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "522-532",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_pool_stats_release(struct inode *inode, struct file *file)\n{\n\tint ret = seq_release(inode, file);\n\tstruct net *net = inode->i_sb->s_fs_info;\n\n\tmutex_lock(&nfsd_mutex);\n\t/* this function really, really should have been called svc_put() */\n\tnfsd_destroy(net);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_pool_stats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "801-816",
    "snippet": "int nfsd_pool_stats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(inode->i_sb->s_fs_info, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv == NULL) {\n\t\tmutex_unlock(&nfsd_mutex);\n\t\treturn -ENODEV;\n\t}\n\t/* bump up the psudo refcount while traversing */\n\tsvc_get(nn->nfsd_serv);\n\tret = svc_pool_stats_open(nn->nfsd_serv, file);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_pool_stats_open",
          "args": [
            "nn->nfsd_serv",
            "file"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_get",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "inode->i_sb->s_fs_info",
            "nfsd_net_id"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_pool_stats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(inode->i_sb->s_fs_info, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv == NULL) {\n\t\tmutex_unlock(&nfsd_mutex);\n\t\treturn -ENODEV;\n\t}\n\t/* bump up the psudo refcount while traversing */\n\tsvc_get(nn->nfsd_serv);\n\tret = svc_pool_stats_open(nn->nfsd_serv, file);\n\tmutex_unlock(&nfsd_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_dispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "726-799",
    "snippet": "int\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n{\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n\t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n\tproc = rqstp->rq_procinfo;\n\n\t/*\n\t * Give the xdr decoder a chance to change this if it wants\n\t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_cache_update",
          "args": [
            "rqstp",
            "rqstp->rq_cachetype",
            "statp + 1"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "509-563",
          "snippet": "void\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_mem_usage;\n\nvoid\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: failed to encode result!\\n\""
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr",
          "args": [
            "rqstp",
            "nfserrp",
            "rqstp->rq_resp"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_dupstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "206-216",
          "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: Dropping request; may be revisited later\\n\""
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_DROPME",
            "&rqstp->rq_flags"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_new_errors",
          "args": [
            "rqstp->rq_vers",
            "nfserr"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "map_new_errors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "717-724",
          "snippet": "static __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc->pc_func",
          "args": [
            "rqstp",
            "rqstp->rq_argp",
            "rqstp->rq_resp"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_lookup",
          "args": [
            "rqstp"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "380-491",
          "snippet": "int\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nint\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: failed to decode arguments!\\n\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd_dispatch: vers %d proc %d\\n\"",
            "rqstp->rq_vers",
            "rqstp->rq_proc"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n{\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n\t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n\tproc = rqstp->rq_procinfo;\n\n\t/*\n\t * Give the xdr decoder a chance to change this if it wants\n\t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}"
  },
  {
    "function_name": "map_new_errors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "717-724",
    "snippet": "static __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic __be32 map_new_errors(u32 vers, __be32 nfserr)\n{\n\tif (nfserr == nfserr_jukebox && vers == 2)\n\t\treturn nfserr_dropit;\n\tif (nfserr == nfserr_wrongsec && vers < 4)\n\t\treturn nfserr_acces;\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "641-715",
    "snippet": "static int\nnfsd(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = (struct svc_rqst *) vrqstp;\n\tstruct svc_xprt *perm_sock = list_entry(rqstp->rq_server->sv_permsocks.next, typeof(struct svc_xprt), xpt_list);\n\tstruct net *net = perm_sock->xpt_net;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint err;\n\n\t/* Lock module and set up kernel thread */\n\tmutex_lock(&nfsd_mutex);\n\n\t/* At this point, the thread shares current->fs\n\t * with the init process. We need to create files with a\n\t * umask of 0 instead of init's umask. */\n\tif (unshare_fs_struct() < 0) {\n\t\tprintk(\"Unable to start nfsd thread: out of memory\\n\");\n\t\tgoto out;\n\t}\n\n\tcurrent->fs->umask = 0;\n\n\t/*\n\t * thread is spawned with all signals set to SIG_IGN, re-enable\n\t * the ones that will bring down the thread\n\t */\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGHUP);\n\tallow_signal(SIGINT);\n\tallow_signal(SIGQUIT);\n\n\tnfsdstats.th_cnt++;\n\tmutex_unlock(&nfsd_mutex);\n\n\tset_freezable();\n\n\t/*\n\t * The main request loop\n\t */\n\tfor (;;) {\n\t\t/* Update sv_maxconn if it has changed */\n\t\trqstp->rq_server->sv_maxconn = nn->max_connections;\n\n\t\t/*\n\t\t * Find a socket with data available and call its\n\t\t * recvfrom routine.\n\t\t */\n\t\twhile ((err = svc_recv(rqstp, 60*60*HZ)) == -EAGAIN)\n\t\t\t;\n\t\tif (err == -EINTR)\n\t\t\tbreak;\n\t\tvalidate_process_creds();\n\t\tsvc_process(rqstp);\n\t\tvalidate_process_creds();\n\t}\n\n\t/* Clear signals before calling svc_exit_thread() */\n\tflush_signals(current);\n\n\tmutex_lock(&nfsd_mutex);\n\tnfsdstats.th_cnt --;\n\nout:\n\trqstp->rq_server = NULL;\n\n\t/* Release the thread */\n\tsvc_exit_thread(rqstp);\n\n\tnfsd_destroy(net);\n\n\t/* Release module */\n\tmutex_unlock(&nfsd_mutex);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\tnfsd(void *vrqstp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put_and_exit",
          "args": [
            "0"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "522-532",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_exit_thread",
          "args": [
            "rqstp"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_signals",
          "args": [
            "current"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_process_creds",
          "args": [],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_process",
          "args": [
            "rqstp"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_process_creds",
          "args": [],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_recv",
          "args": [
            "rqstp",
            "60*60*HZ"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGQUIT"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGINT"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGHUP"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_signal",
          "args": [
            "SIGKILL"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Unable to start nfsd thread: out of memory\\n\""
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare_fs_struct",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rqstp->rq_server->sv_permsocks.next",
            "typeof(struct svc_xprt)",
            "xpt_list"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "structsvc_xprt"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int\t\t\tnfsd(void *vrqstp);\n\nstatic int\nnfsd(void *vrqstp)\n{\n\tstruct svc_rqst *rqstp = (struct svc_rqst *) vrqstp;\n\tstruct svc_xprt *perm_sock = list_entry(rqstp->rq_server->sv_permsocks.next, typeof(struct svc_xprt), xpt_list);\n\tstruct net *net = perm_sock->xpt_net;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint err;\n\n\t/* Lock module and set up kernel thread */\n\tmutex_lock(&nfsd_mutex);\n\n\t/* At this point, the thread shares current->fs\n\t * with the init process. We need to create files with a\n\t * umask of 0 instead of init's umask. */\n\tif (unshare_fs_struct() < 0) {\n\t\tprintk(\"Unable to start nfsd thread: out of memory\\n\");\n\t\tgoto out;\n\t}\n\n\tcurrent->fs->umask = 0;\n\n\t/*\n\t * thread is spawned with all signals set to SIG_IGN, re-enable\n\t * the ones that will bring down the thread\n\t */\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGHUP);\n\tallow_signal(SIGINT);\n\tallow_signal(SIGQUIT);\n\n\tnfsdstats.th_cnt++;\n\tmutex_unlock(&nfsd_mutex);\n\n\tset_freezable();\n\n\t/*\n\t * The main request loop\n\t */\n\tfor (;;) {\n\t\t/* Update sv_maxconn if it has changed */\n\t\trqstp->rq_server->sv_maxconn = nn->max_connections;\n\n\t\t/*\n\t\t * Find a socket with data available and call its\n\t\t * recvfrom routine.\n\t\t */\n\t\twhile ((err = svc_recv(rqstp, 60*60*HZ)) == -EAGAIN)\n\t\t\t;\n\t\tif (err == -EINTR)\n\t\t\tbreak;\n\t\tvalidate_process_creds();\n\t\tsvc_process(rqstp);\n\t\tvalidate_process_creds();\n\t}\n\n\t/* Clear signals before calling svc_exit_thread() */\n\tflush_signals(current);\n\n\tmutex_lock(&nfsd_mutex);\n\tnfsdstats.th_cnt --;\n\nout:\n\trqstp->rq_server = NULL;\n\n\t/* Release the thread */\n\tsvc_exit_thread(rqstp);\n\n\tnfsd_destroy(net);\n\n\t/* Release module */\n\tmutex_unlock(&nfsd_mutex);\n\tmodule_put_and_exit(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_svc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "592-635",
    "snippet": "int\nnfsd_svc(int nrservs, struct net *net)\n{\n\tint\terror;\n\tbool\tnfsd_up_before;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tdprintk(\"nfsd: creating service\\n\");\n\n\tnrservs = max(nrservs, 0);\n\tnrservs = min(nrservs, NFSD_MAXSERVS);\n\terror = 0;\n\n\tif (nrservs == 0 && nn->nfsd_serv == NULL)\n\t\tgoto out;\n\n\terror = nfsd_create_serv(net);\n\tif (error)\n\t\tgoto out;\n\n\tnfsd_up_before = nn->nfsd_net_up;\n\n\terror = nfsd_startup_net(nrservs, net);\n\tif (error)\n\t\tgoto out_destroy;\n\terror = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\tNULL, nrservs);\n\tif (error)\n\t\tgoto out_shutdown;\n\t/* We are holding a reference to nn->nfsd_serv which\n\t * we don't want to count in the return value,\n\t * so subtract 1\n\t */\n\terror = nn->nfsd_serv->sv_nrthreads - 1;\nout_shutdown:\n\tif (error < 0 && !nfsd_up_before)\n\t\tnfsd_shutdown_net(net);\nout_destroy:\n\tnfsd_destroy(net);\t\t/* Release server */\nout:\n\tmutex_unlock(&nfsd_mutex);\n\treturn error;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define\tNFSD_MAXSERVS\t\t8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "522-532",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_shutdown_net",
          "args": [
            "net"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "300-311",
          "snippet": "static void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nn->nfsd_serv->sv_ops->svo_setup",
          "args": [
            "nn->nfsd_serv",
            "NULL",
            "nrservs"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_startup_net",
          "args": [
            "nrservs",
            "net"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_startup_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "261-298",
          "snippet": "static int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_create_serv",
          "args": [
            "net"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create_serv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "465-497",
          "snippet": "int nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct svc_program\tnfsd_program;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nextern struct svc_program\tnfsd_program;\n\nint nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nrservs",
            "NFSD_MAXSERVS"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nrservs",
            "0"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_max_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4proc.c",
          "lines": "2338-2348",
          "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define op_encode_hdr_size\t\t(2)"
          ],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: creating service\\n\""
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define\tNFSD_MAXSERVS\t\t8192\n\nint\nnfsd_svc(int nrservs, struct net *net)\n{\n\tint\terror;\n\tbool\tnfsd_up_before;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tdprintk(\"nfsd: creating service\\n\");\n\n\tnrservs = max(nrservs, 0);\n\tnrservs = min(nrservs, NFSD_MAXSERVS);\n\terror = 0;\n\n\tif (nrservs == 0 && nn->nfsd_serv == NULL)\n\t\tgoto out;\n\n\terror = nfsd_create_serv(net);\n\tif (error)\n\t\tgoto out;\n\n\tnfsd_up_before = nn->nfsd_net_up;\n\n\terror = nfsd_startup_net(nrservs, net);\n\tif (error)\n\t\tgoto out_destroy;\n\terror = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\tNULL, nrservs);\n\tif (error)\n\t\tgoto out_shutdown;\n\t/* We are holding a reference to nn->nfsd_serv which\n\t * we don't want to count in the return value,\n\t * so subtract 1\n\t */\n\terror = nn->nfsd_serv->sv_nrthreads - 1;\nout_shutdown:\n\tif (error < 0 && !nfsd_up_before)\n\t\tnfsd_shutdown_net(net);\nout_destroy:\n\tnfsd_destroy(net);\t\t/* Release server */\nout:\n\tmutex_unlock(&nfsd_mutex);\n\treturn error;\n}"
  },
  {
    "function_name": "nfsd_set_nrthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "534-585",
    "snippet": "int nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tint tot = 0;\n\tint err = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\n\tif (nn->nfsd_serv == NULL || n <= 0)\n\t\treturn 0;\n\n\tif (n > nn->nfsd_serv->sv_nrpools)\n\t\tn = nn->nfsd_serv->sv_nrpools;\n\n\t/* enforce a global maximum number of threads */\n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tnthreads[i] = min(nthreads[i], NFSD_MAXSERVS);\n\t\ttot += nthreads[i];\n\t}\n\tif (tot > NFSD_MAXSERVS) {\n\t\t/* total too large: scale down requested numbers */\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t    \tint new = nthreads[i] * NFSD_MAXSERVS / tot;\n\t\t\ttot -= (nthreads[i] - new);\n\t\t\tnthreads[i] = new;\n\t\t}\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tnthreads[i]--;\n\t\t\ttot--;\n\t\t}\n\t}\n\n\t/*\n\t * There must always be a thread in pool 0; the admin\n\t * can't shut down NFS completely using pool_threads.\n\t */\n\tif (nthreads[0] == 0)\n\t\tnthreads[0] = 1;\n\n\t/* apply the new numbers */\n\tsvc_get(nn->nfsd_serv);\n\tfor (i = 0; i < n; i++) {\n\t\terr = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\t\t&nn->nfsd_serv->sv_pools[i], nthreads[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tnfsd_destroy(net);\n\treturn err;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define\tNFSD_MAXSERVS\t\t8192"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_destroy",
          "args": [
            "net"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "522-532",
          "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nn->nfsd_serv->sv_ops->svo_setup",
          "args": [
            "nn->nfsd_serv",
            "&nn->nfsd_serv->sv_pools[i]",
            "nthreads[i]"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_get",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nthreads[i]",
            "NFSD_MAXSERVS"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&nfsd_mutex)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define\tNFSD_MAXSERVS\t\t8192\n\nint nfsd_set_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tint tot = 0;\n\tint err = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\n\tif (nn->nfsd_serv == NULL || n <= 0)\n\t\treturn 0;\n\n\tif (n > nn->nfsd_serv->sv_nrpools)\n\t\tn = nn->nfsd_serv->sv_nrpools;\n\n\t/* enforce a global maximum number of threads */\n\ttot = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tnthreads[i] = min(nthreads[i], NFSD_MAXSERVS);\n\t\ttot += nthreads[i];\n\t}\n\tif (tot > NFSD_MAXSERVS) {\n\t\t/* total too large: scale down requested numbers */\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t    \tint new = nthreads[i] * NFSD_MAXSERVS / tot;\n\t\t\ttot -= (nthreads[i] - new);\n\t\t\tnthreads[i] = new;\n\t\t}\n\t\tfor (i = 0; i < n && tot > 0; i++) {\n\t\t\tnthreads[i]--;\n\t\t\ttot--;\n\t\t}\n\t}\n\n\t/*\n\t * There must always be a thread in pool 0; the admin\n\t * can't shut down NFS completely using pool_threads.\n\t */\n\tif (nthreads[0] == 0)\n\t\tnthreads[0] = 1;\n\n\t/* apply the new numbers */\n\tsvc_get(nn->nfsd_serv);\n\tfor (i = 0; i < n; i++) {\n\t\terr = nn->nfsd_serv->sv_ops->svo_setup(nn->nfsd_serv,\n\t\t\t\t&nn->nfsd_serv->sv_pools[i], nthreads[i]);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tnfsd_destroy(net);\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "522-532",
    "snippet": "void nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_destroy",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_shutdown_net",
          "args": [
            "nn->nfsd_serv",
            "net"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nvoid nfsd_destroy(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint destroy = (nn->nfsd_serv->sv_nrthreads == 1);\n\n\tif (destroy)\n\t\tsvc_shutdown_net(nn->nfsd_serv, net);\n\tsvc_destroy(nn->nfsd_serv);\n\tif (destroy)\n\t\tnn->nfsd_serv = NULL;\n}"
  },
  {
    "function_name": "nfsd_get_nrthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "509-520",
    "snippet": "int nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv != NULL) {\n\t\tfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\n\t\t\tnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_get_nrthreads(int n, int *nthreads, struct net *net)\n{\n\tint i = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv != NULL) {\n\t\tfor (i = 0; i < nn->nfsd_serv->sv_nrpools && i < n; i++)\n\t\t\tnthreads[i] = nn->nfsd_serv->sv_pools[i].sp_nrthreads;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_nrpools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "499-507",
    "snippet": "int nfsd_nrpools(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\telse\n\t\treturn nn->nfsd_serv->sv_nrpools;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_nrpools(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->nfsd_serv == NULL)\n\t\treturn 0;\n\telse\n\t\treturn nn->nfsd_serv->sv_nrpools;\n}"
  },
  {
    "function_name": "nfsd_create_serv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "465-497",
    "snippet": "int nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct svc_program\tnfsd_program;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_gettimeofday",
          "args": [
            "&nn->nfssvc_boot"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_inet6addr_notifier",
          "args": [
            "&nfsd_inet6addr_notifier"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_inetaddr_notifier",
          "args": [
            "&nfsd_inetaddr_notifier"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_max_drc",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "set_max_drc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "426-434",
          "snippet": "static void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define NFSD_DRC_SIZE_SHIFT\t10"
          ],
          "globals_used": [
            "spinlock_t\tnfsd_drc_lock;",
            "unsigned long\tnfsd_drc_max_mem;",
            "unsigned long\tnfsd_drc_mem_used;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_DRC_SIZE_SHIFT\t10\n\nspinlock_t\tnfsd_drc_lock;\nunsigned long\tnfsd_drc_max_mem;\nunsigned long\tnfsd_drc_mem_used;\n\nstatic void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_destroy",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_bind",
          "args": [
            "nn->nfsd_serv",
            "net"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_pooled",
          "args": [
            "&nfsd_program",
            "nfsd_max_blksize",
            "&nfsd_thread_sv_ops"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reset_versions",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reset_versions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "393-412",
          "snippet": "void nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
            "#define NFSD_MINVERS    \t2",
            "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)",
            "#define NFSD_ACL_MINVERS            2"
          ],
          "globals_used": [
            "extern struct svc_program\tnfsd_program;",
            "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n#define NFSD_ACL_MINVERS            2\n\nextern struct svc_program\tnfsd_program;\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\n\nvoid nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_get_default_max_blksize",
          "args": [],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_get_default_max_blksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "436-455",
          "snippet": "static int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_get",
          "args": [
            "nn->nfsd_serv"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!mutex_is_locked(&nfsd_mutex)"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nextern struct svc_program\tnfsd_program;\n\nint nfsd_create_serv(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tWARN_ON(!mutex_is_locked(&nfsd_mutex));\n\tif (nn->nfsd_serv) {\n\t\tsvc_get(nn->nfsd_serv);\n\t\treturn 0;\n\t}\n\tif (nfsd_max_blksize == 0)\n\t\tnfsd_max_blksize = nfsd_get_default_max_blksize();\n\tnfsd_reset_versions();\n\tnn->nfsd_serv = svc_create_pooled(&nfsd_program, nfsd_max_blksize,\n\t\t\t\t\t\t&nfsd_thread_sv_ops);\n\tif (nn->nfsd_serv == NULL)\n\t\treturn -ENOMEM;\n\n\tnn->nfsd_serv->sv_maxconn = nn->max_connections;\n\terror = svc_bind(nn->nfsd_serv, net);\n\tif (error < 0) {\n\t\tsvc_destroy(nn->nfsd_serv);\n\t\treturn error;\n\t}\n\n\tset_max_drc();\n\tregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\tdo_gettimeofday(&nn->nfssvc_boot);\t\t/* record boot time */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_get_default_max_blksize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "436-455",
    "snippet": "static int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "&i"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_get_default_max_blksize(void)\n{\n\tstruct sysinfo i;\n\tunsigned long long target;\n\tunsigned long ret;\n\n\tsi_meminfo(&i);\n\ttarget = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n\t/*\n\t * Aim for 1/4096 of memory per thread This gives 1MB on 4Gig\n\t * machines, but only uses 32K on 128M machines.  Bottom out at\n\t * 8K on 32M and smaller.  Of course, this is only a default.\n\t */\n\ttarget >>= 12;\n\n\tret = NFSSVC_MAXBLKSIZE;\n\twhile (ret > target && ret >= 8*1024*2)\n\t\tret /= 2;\n\treturn ret;\n}"
  },
  {
    "function_name": "set_max_drc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "426-434",
    "snippet": "static void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define NFSD_DRC_SIZE_SHIFT\t10"
    ],
    "globals_used": [
      "spinlock_t\tnfsd_drc_lock;",
      "unsigned long\tnfsd_drc_max_mem;",
      "unsigned long\tnfsd_drc_mem_used;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s nfsd_drc_max_mem %lu \\n\"",
            "__func__",
            "nfsd_drc_max_mem"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_DRC_SIZE_SHIFT\t10\n\nspinlock_t\tnfsd_drc_lock;\nunsigned long\tnfsd_drc_max_mem;\nunsigned long\tnfsd_drc_mem_used;\n\nstatic void set_max_drc(void)\n{\n\t#define NFSD_DRC_SIZE_SHIFT\t10\n\tnfsd_drc_max_mem = (nr_free_buffer_pages()\n\t\t\t\t\t>> NFSD_DRC_SIZE_SHIFT) * PAGE_SIZE;\n\tnfsd_drc_mem_used = 0;\n\tspin_lock_init(&nfsd_drc_lock);\n\tdprintk(\"%s nfsd_drc_max_mem %lu \\n\", __func__, nfsd_drc_max_mem);\n}"
  },
  {
    "function_name": "nfsd_reset_versions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "393-412",
    "snippet": "void nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
      "#define NFSD_MINVERS    \t2",
      "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)",
      "#define NFSD_ACL_MINVERS            2"
    ],
    "globals_used": [
      "extern struct svc_program\tnfsd_program;",
      "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n#define NFSD_ACL_MINVERS            2\n\nextern struct svc_program\tnfsd_program;\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\n\nvoid nfsd_reset_versions(void)\n{\n\tint found_one = 0;\n\tint i;\n\n\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++) {\n\t\tif (nfsd_program.pg_vers[i])\n\t\t\tfound_one = 1;\n\t}\n\n\tif (!found_one) {\n\t\tfor (i = NFSD_MINVERS; i < NFSD_NRVERS; i++)\n\t\t\tnfsd_program.pg_vers[i] = nfsd_version[i];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tfor (i = NFSD_ACL_MINVERS; i < NFSD_ACL_NRVERS; i++)\n\t\t\tnfsd_acl_program.pg_vers[i] =\n\t\t\t\tnfsd_acl_version[i];\n#endif\n\t}\n}"
  },
  {
    "function_name": "nfsd_last_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "369-391",
    "snippet": "static void nfsd_last_thread(struct svc_serv *serv, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tunregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\t/*\n\t * write_ports can create the server without actually starting\n\t * any threads--if we get shut down before any threads are\n\t * started, then nfsd_last_thread will be run before any of this\n\t * other initialization has been done except the rpcb information.\n\t */\n\tsvc_rpcb_cleanup(serv, net);\n\tif (!nn->nfsd_net_up)\n\t\treturn;\n\n\tnfsd_shutdown_net(net);\n\tprintk(KERN_WARNING \"nfsd: last server has exited, flushing export \"\n\t\t\t    \"cache\\n\");\n\tnfsd_export_flush(net);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_export_flush",
          "args": [
            "net"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_export_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1252-1259",
          "snippet": "void\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"nfsd: last server has exited, flushing export \"\n\t\t\t    \"cache\\n\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_shutdown_net",
          "args": [
            "net"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "300-311",
          "snippet": "static void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_rpcb_cleanup",
          "args": [
            "serv",
            "net"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_inet6addr_notifier",
          "args": [
            "&nfsd_inet6addr_notifier"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_inetaddr_notifier",
          "args": [
            "&nfsd_inetaddr_notifier"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_last_thread(struct svc_serv *serv, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tunregister_inetaddr_notifier(&nfsd_inetaddr_notifier);\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&nfsd_inet6addr_notifier);\n#endif\n\t/*\n\t * write_ports can create the server without actually starting\n\t * any threads--if we get shut down before any threads are\n\t * started, then nfsd_last_thread will be run before any of this\n\t * other initialization has been done except the rpcb information.\n\t */\n\tsvc_rpcb_cleanup(serv, net);\n\tif (!nn->nfsd_net_up)\n\t\treturn;\n\n\tnfsd_shutdown_net(net);\n\tprintk(KERN_WARNING \"nfsd: last server has exited, flushing export \"\n\t\t\t    \"cache\\n\");\n\tnfsd_export_flush(net);\n}"
  },
  {
    "function_name": "nfsd_inet6addr_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "341-362",
    "snippet": "static int nfsd_inet6addr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->idev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in6 sin6;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inet6addr_event: removed %pI6\\n\", &ifa->addr);\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = ifa->addr;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_age_temp_xprts_now",
          "args": [
            "nn->nfsd_serv",
            "(struct sockaddr *)&sin6"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd_inet6addr_event: removed %pI6\\n\"",
            "&ifa->addr"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_net",
          "args": [
            "dev"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_inet6addr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->idev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in6 sin6;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inet6addr_event: removed %pI6\\n\", &ifa->addr);\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = ifa->addr;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "nfsd_inetaddr_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "313-334",
    "snippet": "static int nfsd_inetaddr_event(struct notifier_block *this, unsigned long event,\n\tvoid *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in sin;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inetaddr_event: removed %pI4\\n\", &ifa->ifa_local);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = ifa->ifa_local;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_age_temp_xprts_now",
          "args": [
            "nn->nfsd_serv",
            "(struct sockaddr *)&sin"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd_inetaddr_event: removed %pI4\\n\"",
            "&ifa->ifa_local"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_net",
          "args": [
            "dev"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_inetaddr_event(struct notifier_block *this, unsigned long event,\n\tvoid *ptr)\n{\n\tstruct in_ifaddr *ifa = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->ifa_dev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in sin;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inetaddr_event: removed %pI4\\n\", &ifa->ifa_local);\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_addr.s_addr = ifa->ifa_local;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "nfsd_shutdown_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "300-311",
    "snippet": "static void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_shutdown_generic",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "243-250",
          "snippet": "static void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockd_down",
          "args": [
            "net"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_shutdown_net",
          "args": [
            "net"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_shutdown_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "133-133",
          "snippet": "static inline void nfs4_state_shutdown_net(struct net *net) { }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline void nfs4_state_shutdown_net(struct net *net) { }"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_state_shutdown_net(net);\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\n\tnn->nfsd_net_up = false;\n\tnfsd_shutdown_generic();\n}"
  },
  {
    "function_name": "nfsd_startup_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "261-298",
    "snippet": "static int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_shutdown_generic",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_shutdown_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "243-250",
          "snippet": "static void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockd_down",
          "args": [
            "net"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_start_net",
          "args": [
            "net"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "131-131",
          "snippet": "static inline int nfs4_state_start_net(struct net *net) { return 0; }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfs4_state_start_net(struct net *net) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "lockd_up",
          "args": [
            "net"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_needs_lockd",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_needs_lockd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "252-259",
          "snippet": "static bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_version *nfsd_versions[NFSD_NRVERS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic struct svc_version *nfsd_versions[NFSD_NRVERS];\n\nstatic bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_init_socks",
          "args": [
            "net"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_init_socks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "192-211",
          "snippet": "static int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_startup_generic",
          "args": [
            "nrservs"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_startup_generic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "215-241",
          "snippet": "static int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_net(int nrservs, struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tif (nn->nfsd_net_up)\n\t\treturn 0;\n\n\tret = nfsd_startup_generic(nrservs);\n\tif (ret)\n\t\treturn ret;\n\tret = nfsd_init_socks(net);\n\tif (ret)\n\t\tgoto out_socks;\n\n\tif (nfsd_needs_lockd() && !nn->lockd_up) {\n\t\tret = lockd_up(net);\n\t\tif (ret)\n\t\t\tgoto out_socks;\n\t\tnn->lockd_up = 1;\n\t}\n\n\tret = nfs4_state_start_net(net);\n\tif (ret)\n\t\tgoto out_lockd;\n\n\tnn->nfsd_net_up = true;\n\treturn 0;\n\nout_lockd:\n\tif (nn->lockd_up) {\n\t\tlockd_down(net);\n\t\tnn->lockd_up = 0;\n\t}\nout_socks:\n\tnfsd_shutdown_generic();\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_needs_lockd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "252-259",
    "snippet": "static bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_version *nfsd_versions[NFSD_NRVERS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic struct svc_version *nfsd_versions[NFSD_NRVERS];\n\nstatic bool nfsd_needs_lockd(void)\n{\n#if defined(CONFIG_NFSD_V3)\n\treturn (nfsd_versions[2] != NULL) || (nfsd_versions[3] != NULL);\n#else\n\treturn (nfsd_versions[2] != NULL);\n#endif\n}"
  },
  {
    "function_name": "nfsd_shutdown_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "243-250",
    "snippet": "static void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_racache_shutdown",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_racache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "2034-2051",
          "snippet": "void\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)"
          ],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nvoid\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_shutdown",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "132-132",
          "snippet": "static inline void nfs4_state_shutdown(void) { }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline void nfs4_state_shutdown(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic void nfsd_shutdown_generic(void)\n{\n\tif (--nfsd_users)\n\t\treturn;\n\n\tnfs4_state_shutdown();\n\tnfsd_racache_shutdown();\n}"
  },
  {
    "function_name": "nfsd_startup_generic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "215-241",
    "snippet": "static int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_racache_shutdown",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_racache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "2034-2051",
          "snippet": "void\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)"
          ],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nvoid\nnfsd_racache_shutdown(void)\n{\n\tstruct raparms *raparm, *last_raparm;\n\tunsigned int i;\n\n\tdprintk(\"nfsd: freeing readahead buffers.\\n\");\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\traparm = raparm_hash[i].pb_head;\n\t\twhile(raparm) {\n\t\t\tlast_raparm = raparm;\n\t\t\traparm = raparm->p_next;\n\t\t\tkfree(last_raparm);\n\t\t}\n\t\traparm_hash[i].pb_head = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_state_start",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "130-130",
          "snippet": "static inline int nfs4_state_start(void) { return 0; }",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfs4_state_start(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_racache_init",
          "args": [
            "2*nrservs"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_racache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "2055-2092",
          "snippet": "int\nnfsd_racache_init(int cache_size)\n{\n\tint\ti;\n\tint\tj = 0;\n\tint\tnperbucket;\n\tstruct raparms **raparm = NULL;\n\n\n\tif (raparm_hash[0].pb_head)\n\t\treturn 0;\n\tnperbucket = DIV_ROUND_UP(cache_size, RAPARM_HASH_SIZE);\n\tnperbucket = max(2, nperbucket);\n\tcache_size = nperbucket * RAPARM_HASH_SIZE;\n\n\tdprintk(\"nfsd: allocating %d readahead buffers.\\n\", cache_size);\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\tspin_lock_init(&raparm_hash[i].pb_lock);\n\n\t\traparm = &raparm_hash[i].pb_head;\n\t\tfor (j = 0; j < nperbucket; j++) {\n\t\t\t*raparm = kzalloc(sizeof(struct raparms), GFP_KERNEL);\n\t\t\tif (!*raparm)\n\t\t\t\tgoto out_nomem;\n\t\t\traparm = &(*raparm)->p_next;\n\t\t}\n\t\t*raparm = NULL;\n\t}\n\n\tnfsdstats.ra_size = cache_size;\n\treturn 0;\n\nout_nomem:\n\tdprintk(\"nfsd: kmalloc failed, freeing readahead buffers\\n\");\n\tnfsd_racache_shutdown();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)"
          ],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define RAPARM_HASH_SIZE\t(1<<RAPARM_HASH_BITS)\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nint\nnfsd_racache_init(int cache_size)\n{\n\tint\ti;\n\tint\tj = 0;\n\tint\tnperbucket;\n\tstruct raparms **raparm = NULL;\n\n\n\tif (raparm_hash[0].pb_head)\n\t\treturn 0;\n\tnperbucket = DIV_ROUND_UP(cache_size, RAPARM_HASH_SIZE);\n\tnperbucket = max(2, nperbucket);\n\tcache_size = nperbucket * RAPARM_HASH_SIZE;\n\n\tdprintk(\"nfsd: allocating %d readahead buffers.\\n\", cache_size);\n\n\tfor (i = 0; i < RAPARM_HASH_SIZE; i++) {\n\t\tspin_lock_init(&raparm_hash[i].pb_lock);\n\n\t\traparm = &raparm_hash[i].pb_head;\n\t\tfor (j = 0; j < nperbucket; j++) {\n\t\t\t*raparm = kzalloc(sizeof(struct raparms), GFP_KERNEL);\n\t\t\tif (!*raparm)\n\t\t\t\tgoto out_nomem;\n\t\t\traparm = &(*raparm)->p_next;\n\t\t}\n\t\t*raparm = NULL;\n\t}\n\n\tnfsdstats.ra_size = cache_size;\n\treturn 0;\n\nout_nomem:\n\tdprintk(\"nfsd: kmalloc failed, freeing readahead buffers\\n\");\n\tnfsd_racache_shutdown();\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_startup_generic(int nrservs)\n{\n\tint ret;\n\n\tif (nfsd_users++)\n\t\treturn 0;\n\n\t/*\n\t * Readahead param cache - will no-op if it already exists.\n\t * (Note therefore results will be suboptimal if number of\n\t * threads is modified after nfsd start.)\n\t */\n\tret = nfsd_racache_init(2*nrservs);\n\tif (ret)\n\t\tgoto dec_users;\n\n\tret = nfs4_state_start();\n\tif (ret)\n\t\tgoto out_racache;\n\treturn 0;\n\nout_racache:\n\tnfsd_racache_shutdown();\ndec_users:\n\tnfsd_users--;\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_init_socks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "192-211",
    "snippet": "static int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "nn->nfsd_serv",
            "\"tcp\"",
            "net",
            "PF_INET",
            "NFS_PORT",
            "SVC_SOCK_DEFAULTS"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_create_xprt",
          "args": [
            "nn->nfsd_serv",
            "\"udp\"",
            "net",
            "PF_INET",
            "NFS_PORT",
            "SVC_SOCK_DEFAULTS"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->nfsd_serv->sv_permsocks"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nstatic int nfsd_init_socks(struct net *net)\n{\n\tint error;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!list_empty(&nn->nfsd_serv->sv_permsocks))\n\t\treturn 0;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"udp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = svc_create_xprt(nn->nfsd_serv, \"tcp\", net, PF_INET, NFS_PORT,\n\t\t\t\t\tSVC_SOCK_DEFAULTS);\n\tif (error < 0)\n\t\treturn error;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_nrthreads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "180-190",
    "snippet": "int nfsd_nrthreads(struct net *net)\n{\n\tint rv = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv)\n\t\trv = nn->nfsd_serv->sv_nrthreads;\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nfsd_mutex"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_nrthreads(struct net *net)\n{\n\tint rv = 0;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tmutex_lock(&nfsd_mutex);\n\tif (nn->nfsd_serv)\n\t\trv = nn->nfsd_serv->sv_nrthreads;\n\tmutex_unlock(&nfsd_mutex);\n\treturn rv;\n}"
  },
  {
    "function_name": "nfsd_minorversion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "156-173",
    "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_vers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
    "lines": "129-154",
    "snippet": "int nfsd_vers(int vers, enum vers_op change)\n{\n\tif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\n\t\treturn 0;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_versions[vers] = nfsd_version[vers];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = nfsd_acl_version[vers];\n#endif\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_versions[vers] = NULL;\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = NULL;\n#endif\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_versions[vers] != NULL;\n\tcase NFSD_AVAIL:\n\t\treturn nfsd_version[vers] != NULL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/net_namespace.h>",
      "#include <net/ipv6.h>",
      "#include <net/addrconf.h>",
      "#include <linux/inetdevice.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/nfsacl.h>",
      "#include <linux/lockd/bind.h>",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/sunrpc/svcsock.h>",
      "#include <linux/sunrpc/stats.h>",
      "#include <linux/swap.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/module.h>",
      "#include <linux/freezer.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)",
      "#define NFSD_MINVERS    \t2",
      "#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)"
    ],
    "globals_used": [
      "static struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};",
      "static struct svc_version *nfsd_versions[NFSD_NRVERS];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\n#define NFSD_NRVERS\t\tARRAY_SIZE(nfsd_version)\n#define NFSD_MINVERS    \t2\n#define NFSD_ACL_NRVERS\t\tARRAY_SIZE(nfsd_acl_version)\n\nstatic struct svc_version *\tnfsd_version[] = {\n\t[2] = &nfsd_version2,\n#if defined(CONFIG_NFSD_V3)\n\t[3] = &nfsd_version3,\n#endif\n#if defined(CONFIG_NFSD_V4)\n\t[4] = &nfsd_version4,\n#endif\n};\nstatic struct svc_version *nfsd_versions[NFSD_NRVERS];\n\nint nfsd_vers(int vers, enum vers_op change)\n{\n\tif (vers < NFSD_MINVERS || vers >= NFSD_NRVERS)\n\t\treturn 0;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_versions[vers] = nfsd_version[vers];\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = nfsd_acl_version[vers];\n#endif\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_versions[vers] = NULL;\n#if defined(CONFIG_NFSD_V2_ACL) || defined(CONFIG_NFSD_V3_ACL)\n\t\tif (vers < NFSD_ACL_NRVERS)\n\t\t\tnfsd_acl_versions[vers] = NULL;\n#endif\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_versions[vers] != NULL;\n\tcase NFSD_AVAIL:\n\t\treturn nfsd_version[vers] != NULL;\n\t}\n\treturn 0;\n}"
  }
]