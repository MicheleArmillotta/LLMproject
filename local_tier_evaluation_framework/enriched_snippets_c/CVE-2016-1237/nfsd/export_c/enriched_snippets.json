[
  {
    "function_name": "nfsd_export_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1264-1278",
    "snippet": "void\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: export shutdown complete (net: %p).\\n\"",
            "net"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_unix_purge",
          "args": [
            "net"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_expkey_cache",
            "net"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_unregister_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_unregister_net",
          "args": [
            "nn->svc_expkey_cache",
            "net"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: shutting down export module (net: %p).\\n\"",
            "net"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: shutting down export module (net: %p).\\n\", net);\n\n\tcache_unregister_net(nn->svc_expkey_cache, net);\n\tcache_unregister_net(nn->svc_export_cache, net);\n\tcache_destroy_net(nn->svc_expkey_cache, net);\n\tcache_destroy_net(nn->svc_export_cache, net);\n\tsvcauth_unix_purge(net);\n\n\tdprintk(\"nfsd: export shutdown complete (net: %p).\\n\", net);\n}"
  },
  {
    "function_name": "nfsd_export_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1252-1259",
    "snippet": "void\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_purge",
          "args": [
            "nn->svc_export_cache"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_purge",
          "args": [
            "nn->svc_expkey_cache"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nvoid\nnfsd_export_flush(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcache_purge(nn->svc_expkey_cache);\n\tcache_purge(nn->svc_export_cache);\n}"
  },
  {
    "function_name": "nfsd_export_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1215-1247",
    "snippet": "int\nnfsd_export_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: initializing export module (net: %p).\\n\", net);\n\n\tnn->svc_export_cache = cache_create_net(&svc_export_cache_template, net);\n\tif (IS_ERR(nn->svc_export_cache))\n\t\treturn PTR_ERR(nn->svc_export_cache);\n\trv = cache_register_net(nn->svc_export_cache, net);\n\tif (rv)\n\t\tgoto destroy_export_cache;\n\n\tnn->svc_expkey_cache = cache_create_net(&svc_expkey_cache_template, net);\n\tif (IS_ERR(nn->svc_expkey_cache)) {\n\t\trv = PTR_ERR(nn->svc_expkey_cache);\n\t\tgoto unregister_export_cache;\n\t}\n\trv = cache_register_net(nn->svc_expkey_cache, net);\n\tif (rv)\n\t\tgoto destroy_expkey_cache;\n\treturn 0;\n\ndestroy_expkey_cache:\n\tcache_destroy_net(nn->svc_expkey_cache, net);\nunregister_export_cache:\n\tcache_unregister_net(nn->svc_export_cache, net);\ndestroy_export_cache:\n\tcache_destroy_net(nn->svc_export_cache, net);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cache_detail svc_expkey_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPKEY_HASHMAX,\n\t.name\t\t= \"nfsd.fh\",\n\t.cache_put\t= expkey_put,\n\t.cache_request\t= expkey_request,\n\t.cache_parse\t= expkey_parse,\n\t.cache_show\t= expkey_show,\n\t.match\t\t= expkey_match,\n\t.init\t\t= expkey_init,\n\t.update       \t= expkey_update,\n\t.alloc\t\t= expkey_alloc,\n};",
      "static struct cache_detail svc_export_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPORT_HASHMAX,\n\t.name\t\t= \"nfsd.export\",\n\t.cache_put\t= svc_export_put,\n\t.cache_request\t= svc_export_request,\n\t.cache_parse\t= svc_export_parse,\n\t.cache_show\t= svc_export_show,\n\t.match\t\t= svc_export_match,\n\t.init\t\t= svc_export_init,\n\t.update\t\t= export_update,\n\t.alloc\t\t= svc_export_alloc,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_unregister_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_destroy_net",
          "args": [
            "nn->svc_expkey_cache",
            "net"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_register_net",
          "args": [
            "nn->svc_expkey_cache",
            "net"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nn->svc_expkey_cache"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nn->svc_expkey_cache"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_create_net",
          "args": [
            "&svc_expkey_cache_template",
            "net"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_register_net",
          "args": [
            "nn->svc_export_cache",
            "net"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nn->svc_export_cache"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nn->svc_export_cache"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_create_net",
          "args": [
            "&svc_export_cache_template",
            "net"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: initializing export module (net: %p).\\n\"",
            "net"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct cache_detail svc_expkey_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPKEY_HASHMAX,\n\t.name\t\t= \"nfsd.fh\",\n\t.cache_put\t= expkey_put,\n\t.cache_request\t= expkey_request,\n\t.cache_parse\t= expkey_parse,\n\t.cache_show\t= expkey_show,\n\t.match\t\t= expkey_match,\n\t.init\t\t= expkey_init,\n\t.update       \t= expkey_update,\n\t.alloc\t\t= expkey_alloc,\n};\nstatic struct cache_detail svc_export_cache_template = {\n\t.owner\t\t= THIS_MODULE,\n\t.hash_size\t= EXPORT_HASHMAX,\n\t.name\t\t= \"nfsd.export\",\n\t.cache_put\t= svc_export_put,\n\t.cache_request\t= svc_export_request,\n\t.cache_parse\t= svc_export_parse,\n\t.cache_show\t= svc_export_show,\n\t.match\t\t= svc_export_match,\n\t.init\t\t= svc_export_init,\n\t.update\t\t= export_update,\n\t.alloc\t\t= svc_export_alloc,\n};\n\nint\nnfsd_export_init(struct net *net)\n{\n\tint rv;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"nfsd: initializing export module (net: %p).\\n\", net);\n\n\tnn->svc_export_cache = cache_create_net(&svc_export_cache_template, net);\n\tif (IS_ERR(nn->svc_export_cache))\n\t\treturn PTR_ERR(nn->svc_export_cache);\n\trv = cache_register_net(nn->svc_export_cache, net);\n\tif (rv)\n\t\tgoto destroy_export_cache;\n\n\tnn->svc_expkey_cache = cache_create_net(&svc_expkey_cache_template, net);\n\tif (IS_ERR(nn->svc_expkey_cache)) {\n\t\trv = PTR_ERR(nn->svc_expkey_cache);\n\t\tgoto unregister_export_cache;\n\t}\n\trv = cache_register_net(nn->svc_expkey_cache, net);\n\tif (rv)\n\t\tgoto destroy_expkey_cache;\n\treturn 0;\n\ndestroy_expkey_cache:\n\tcache_destroy_net(nn->svc_expkey_cache, net);\nunregister_export_cache:\n\tcache_unregister_net(nn->svc_export_cache, net);\ndestroy_export_cache:\n\tcache_destroy_net(nn->svc_export_cache, net);\n\treturn rv;\n}"
  },
  {
    "function_name": "e_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1186-1203",
    "snippet": "static int e_show(struct seq_file *m, void *p)\n{\n\tstruct cache_head *cp = p;\n\tstruct svc_export *exp = container_of(cp, struct svc_export, h);\n\tstruct cache_detail *cd = m->private;\n\n\tif (p == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"# Version 1.1\\n\");\n\t\tseq_puts(m, \"# Path Client(Flags) # IPs\\n\");\n\t\treturn 0;\n\t}\n\n\texp_get(exp);\n\tif (cache_check(cd, &exp->h, NULL))\n\t\treturn 0;\n\texp_put(exp);\n\treturn svc_export_show(m, cd, cp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_export_show",
          "args": [
            "m",
            "cd",
            "cp"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "656-688",
          "snippet": "static int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
            "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_check",
          "args": [
            "cd",
            "&exp->h",
            "NULL"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "exp"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "107-111",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# Path Client(Flags) # IPs\\n\""
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# Version 1.1\\n\""
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cp",
            "structsvc_export",
            "h"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int e_show(struct seq_file *m, void *p)\n{\n\tstruct cache_head *cp = p;\n\tstruct svc_export *exp = container_of(cp, struct svc_export, h);\n\tstruct cache_detail *cd = m->private;\n\n\tif (p == SEQ_START_TOKEN) {\n\t\tseq_puts(m, \"# Version 1.1\\n\");\n\t\tseq_puts(m, \"# Path Client(Flags) # IPs\\n\");\n\t\treturn 0;\n\t}\n\n\texp_get(exp);\n\tif (cache_check(cd, &exp->h, NULL))\n\t\treturn 0;\n\texp_put(exp);\n\treturn svc_export_show(m, cd, cp);\n}"
  },
  {
    "function_name": "exp_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1157-1184",
    "snippet": "static void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "fsloc->locations[i].hosts",
            "\",;@ \\t\\n\\\\\""
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'@'"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "fsloc->locations[i].path",
            "\",;@ \\t\\n\\\\\""
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "';'"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "fsloc->locations[0].hosts",
            "\",;@ \\t\\n\\\\\""
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'@'"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "fsloc->locations[0].path",
            "\",;@ \\t\\n\\\\\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",%s=\"",
            "loctype"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",anongid=%u\"",
            "from_kgid(&init_user_ns, anong)"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "anong"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "anong",
            "make_kgid(&init_user_ns, 0x10000-2)"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "0x10000-2"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "anong",
            "make_kgid(&init_user_ns, (gid_t)-2)"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "(gid_t)-2"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",anonuid=%u\"",
            "from_kuid(&init_user_ns, anonu)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "anonu"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "anonu",
            "make_kuid(&init_user_ns, 0x10000-2)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "0x10000-2"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "anonu",
            "make_kuid(&init_user_ns, (uid_t)-2)"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "(uid_t)-2"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",fsid=%d\"",
            "fsid"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_expflags",
          "args": [
            "m",
            "flag",
            "NFSEXP_ALLFLAGS"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "show_expflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1098-1110",
          "snippet": "static void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "show_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1139-1155",
    "snippet": "static void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_secinfo_flags",
          "args": [
            "m",
            "flags"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "show_secinfo_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1112-1116",
          "snippet": "static void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_secinfo_run",
          "args": [
            "m",
            "&f",
            "end"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "show_secinfo_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1125-1137",
          "snippet": "static int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secinfo_flags_equal",
          "args": [
            "flags",
            "exp->ex_flags"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "secinfo_flags_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1118-1123",
          "snippet": "static bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}"
  },
  {
    "function_name": "show_secinfo_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1125-1137",
    "snippet": "static int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\":%d\"",
            "(*fp)->pseudoflavor"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secinfo_flags_equal",
          "args": [
            "flags",
            "(*fp)->flags"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "secinfo_flags_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1118-1123",
          "snippet": "static bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",sec=%d\"",
            "(*fp)->pseudoflavor"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int show_secinfo_run(struct seq_file *m, struct exp_flavor_info **fp, struct exp_flavor_info *end)\n{\n\tint flags;\n\n\tflags = (*fp)->flags;\n\tseq_printf(m, \",sec=%d\", (*fp)->pseudoflavor);\n\t(*fp)++;\n\twhile (*fp != end && secinfo_flags_equal(flags, (*fp)->flags)) {\n\t\tseq_printf(m, \":%d\", (*fp)->pseudoflavor);\n\t\t(*fp)++;\n\t}\n\treturn flags;\n}"
  },
  {
    "function_name": "secinfo_flags_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1118-1123",
    "snippet": "static bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic bool secinfo_flags_equal(int f, int g)\n{\n\tf &= NFSEXP_SECINFO_FLAGS;\n\tg &= NFSEXP_SECINFO_FLAGS;\n\treturn f == g;\n}"
  },
  {
    "function_name": "show_secinfo_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1112-1116",
    "snippet": "static void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_expflags",
          "args": [
            "m",
            "flags",
            "NFSEXP_SECINFO_FLAGS"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "show_expflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1098-1110",
          "snippet": "static void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",\""
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void show_secinfo_flags(struct seq_file *m, int flags)\n{\n\tseq_printf(m, \",\");\n\tshow_expflags(m, flags, NFSEXP_SECINFO_FLAGS);\n}"
  },
  {
    "function_name": "show_expflags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1098-1110",
    "snippet": "static void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s%s\"",
            "first++?\",\":\"\"",
            "flg->name[state]"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void show_expflags(struct seq_file *m, int flags, int mask)\n{\n\tstruct flags *flg;\n\tint state, first = 0;\n\n\tfor (flg = expflags; flg->flag; flg++) {\n\t\tif (flg->flag & ~mask)\n\t\t\tcontinue;\n\t\tstate = (flg->flag & flags) ? 0 : 1;\n\t\tif (*flg->name[state])\n\t\t\tseq_printf(m, \"%s%s\", first++?\",\":\"\", flg->name[state]);\n\t}\n}"
  },
  {
    "function_name": "exp_pseudoroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1064-1076",
    "snippet": "__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "fhp",
            "exp",
            "exp->ex_path.dentry",
            "NULL"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(exp)"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_find_fsidzero_export",
          "args": [
            "rqstp"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_find_fsidzero_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1050-1057",
          "snippet": "struct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstruct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32\nexp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct svc_export *exp;\n\t__be32 rv;\n\n\texp = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\trv = fh_compose(fhp, exp, exp->ex_path.dentry, NULL);\n\texp_put(exp);\n\treturn rv;\n}"
  },
  {
    "function_name": "rqst_find_fsidzero_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1050-1057",
    "snippet": "struct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rqst_exp_find",
          "args": [
            "rqstp",
            "FSID_NUM",
            "fsidv"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_exp_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1000-1031",
          "snippet": "struct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_fsid",
          "args": [
            "FSID_NUM",
            "fsidv",
            "0",
            "0",
            "0",
            "NULL"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "mk_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "87-137",
          "snippet": "static inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstruct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}"
  },
  {
    "function_name": "rqst_exp_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1033-1048",
    "snippet": "struct svc_export *\nrqst_exp_parent(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = rqst_exp_get_by_name(rqstp, path);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = rqst_exp_get_by_name(rqstp, path);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "path->dentry"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_exp_get_by_name",
          "args": [
            "rqstp",
            "path"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "969-998",
          "snippet": "struct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "path->dentry"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "path->dentry"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "path->dentry"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "path->dentry"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_parent(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = rqst_exp_get_by_name(rqstp, path);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = rqst_exp_get_by_name(rqstp, path);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}"
  },
  {
    "function_name": "rqst_exp_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "1000-1031",
    "snippet": "struct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gssexp"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_find",
          "args": [
            "cd",
            "rqstp->rq_gssclient",
            "fsid_type",
            "fsidv",
            "&rqstp->rq_chandle"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "exp_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "920-936",
          "snippet": "static struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
  },
  {
    "function_name": "rqst_exp_get_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "969-998",
    "snippet": "struct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "gssexp"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_get_by_name",
          "args": [
            "cd",
            "rqstp->rq_gssclient",
            "path",
            "&rqstp->rq_chandle"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "825-846",
          "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_get_by_name(struct svc_rqst *rqstp, struct path *path)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_get_by_name(cd, rqstp->rq_client, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_get_by_name(cd, rqstp->rq_gssclient, path, &rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
  },
  {
    "function_name": "check_nfsd_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "938-958",
    "snippet": "__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}"
  },
  {
    "function_name": "exp_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "920-936",
    "snippet": "static struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "exp"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_put",
          "args": [
            "&ek->h",
            "nn->svc_expkey_cache"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_get_by_name",
          "args": [
            "cd",
            "clp",
            "&ek->ek_path",
            "reqp"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "825-846",
          "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "ek"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ek"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_find_key",
          "args": [
            "nn->svc_expkey_cache",
            "clp",
            "fsid_type",
            "fsidv",
            "reqp"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "exp_find_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "802-823",
          "snippet": "static struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "cd->net",
            "nfsd_net_id"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *exp_find(struct cache_detail *cd,\n\t\t\t\t   struct auth_domain *clp, int fsid_type,\n\t\t\t\t   u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_export *exp;\n\tstruct nfsd_net *nn = net_generic(cd->net, nfsd_net_id);\n\tstruct svc_expkey *ek = exp_find_key(nn->svc_expkey_cache, clp, fsid_type, fsidv, reqp);\n\tif (IS_ERR(ek))\n\t\treturn ERR_CAST(ek);\n\n\texp = exp_get_by_name(cd, clp, &ek->ek_path, reqp);\n\tcache_put(&ek->h, nn->svc_expkey_cache);\n\n\tif (IS_ERR(exp))\n\t\treturn ERR_CAST(exp);\n\treturn exp;\n}"
  },
  {
    "function_name": "exp_rootfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "875-918",
    "snippet": "int\nexp_rootfh(struct net *net, struct auth_domain *clp, char *name,\n\t   struct knfsd_fh *f, int maxsize)\n{\n\tstruct svc_export\t*exp;\n\tstruct path\t\tpath;\n\tstruct inode\t\t*inode;\n\tstruct svc_fh\t\tfh;\n\tint\t\t\terr;\n\tstruct nfsd_net\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct cache_detail\t*cd = nn->svc_export_cache;\n\n\terr = -EPERM;\n\t/* NB: we probably ought to check that it's NUL-terminated */\n\tif (kern_path(name, 0, &path)) {\n\t\tprintk(\"nfsd: exp_rootfh path not found %s\", name);\n\t\treturn err;\n\t}\n\tinode = d_inode(path.dentry);\n\n\tdprintk(\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\",\n\t\t name, path.dentry, clp->name,\n\t\t inode->i_sb->s_id, inode->i_ino);\n\texp = exp_parent(cd, clp, &path);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * fh must be initialized before calling fh_compose\n\t */\n\tfh_init(&fh, maxsize);\n\tif (fh_compose(&fh, exp, path.dentry, NULL))\n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\tmemcpy(f, &fh.fh_handle, sizeof(struct knfsd_fh));\n\tfh_put(&fh);\n\texp_put(exp);\nout:\n\tpath_put(&path);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&fh"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "f",
            "&fh.fh_handle",
            "sizeof(struct knfsd_fh)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "&fh",
            "exp",
            "path.dentry",
            "NULL"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&fh",
            "maxsize"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_parent",
          "args": [
            "cd",
            "clp",
            "&path"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "exp_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "851-866",
          "snippet": "static struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\"",
            "name",
            "path.dentry",
            "clp->name",
            "inode->i_sb->s_id",
            "inode->i_ino"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "path.dentry"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd: exp_rootfh path not found %s\"",
            "name"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "name",
            "0",
            "&path"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nint\nexp_rootfh(struct net *net, struct auth_domain *clp, char *name,\n\t   struct knfsd_fh *f, int maxsize)\n{\n\tstruct svc_export\t*exp;\n\tstruct path\t\tpath;\n\tstruct inode\t\t*inode;\n\tstruct svc_fh\t\tfh;\n\tint\t\t\terr;\n\tstruct nfsd_net\t\t*nn = net_generic(net, nfsd_net_id);\n\tstruct cache_detail\t*cd = nn->svc_export_cache;\n\n\terr = -EPERM;\n\t/* NB: we probably ought to check that it's NUL-terminated */\n\tif (kern_path(name, 0, &path)) {\n\t\tprintk(\"nfsd: exp_rootfh path not found %s\", name);\n\t\treturn err;\n\t}\n\tinode = d_inode(path.dentry);\n\n\tdprintk(\"nfsd: exp_rootfh(%s [%p] %s:%s/%ld)\\n\",\n\t\t name, path.dentry, clp->name,\n\t\t inode->i_sb->s_id, inode->i_ino);\n\texp = exp_parent(cd, clp, &path);\n\tif (IS_ERR(exp)) {\n\t\terr = PTR_ERR(exp);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * fh must be initialized before calling fh_compose\n\t */\n\tfh_init(&fh, maxsize);\n\tif (fh_compose(&fh, exp, path.dentry, NULL))\n\t\terr = -EINVAL;\n\telse\n\t\terr = 0;\n\tmemcpy(f, &fh.fh_handle, sizeof(struct knfsd_fh));\n\tfh_put(&fh);\n\texp_put(exp);\nout:\n\tpath_put(&path);\n\treturn err;\n}"
  },
  {
    "function_name": "exp_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "851-866",
    "snippet": "static struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "path->dentry"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_get_by_name",
          "args": [
            "cd",
            "clp",
            "path",
            "NULL"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "825-846",
          "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "path->dentry"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "path->dentry"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "path->dentry"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "path->dentry"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_parent(struct cache_detail *cd, struct auth_domain *clp, struct path *path)\n{\n\tstruct dentry *saved = dget(path->dentry);\n\tstruct svc_export *exp = exp_get_by_name(cd, clp, path, NULL);\n\n\twhile (PTR_ERR(exp) == -ENOENT && !IS_ROOT(path->dentry)) {\n\t\tstruct dentry *parent = dget_parent(path->dentry);\n\t\tdput(path->dentry);\n\t\tpath->dentry = parent;\n\t\texp = exp_get_by_name(cd, clp, path, NULL);\n\t}\n\tdput(path->dentry);\n\tpath->dentry = saved;\n\treturn exp;\n}"
  },
  {
    "function_name": "exp_get_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "825-846",
    "snippet": "static struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_check",
          "args": [
            "cd",
            "&exp->h",
            "reqp"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_lookup",
          "args": [
            "&key"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "775-786",
          "snippet": "static struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nexp_get_by_name(struct cache_detail *cd, struct auth_domain *clp,\n\t\tconst struct path *path, struct cache_req *reqp)\n{\n\tstruct svc_export *exp, key;\n\tint err;\n\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ex_client = clp;\n\tkey.ex_path = *path;\n\tkey.cd = cd;\n\n\texp = svc_export_lookup(&key);\n\tif (exp == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &exp->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn exp;\n}"
  },
  {
    "function_name": "exp_find_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "802-823",
    "snippet": "static struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_check",
          "args": [
            "cd",
            "&ek->h",
            "reqp"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_lookup",
          "args": [
            "cd",
            "&key"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "261-272",
          "snippet": "static struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key.ek_fsid",
            "fsidv",
            "key_len(fsid_type)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "fsid_type"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nexp_find_key(struct cache_detail *cd, struct auth_domain *clp, int fsid_type,\n\t     u32 *fsidv, struct cache_req *reqp)\n{\n\tstruct svc_expkey key, *ek;\n\tint err;\n\t\n\tif (!clp)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tkey.ek_client = clp;\n\tkey.ek_fsidtype = fsid_type;\n\tmemcpy(key.ek_fsid, fsidv, key_len(fsid_type));\n\n\tek = svc_expkey_lookup(cd, &key);\n\tif (ek == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = cache_check(cd, &ek->h, reqp);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn ek;\n}"
  },
  {
    "function_name": "svc_export_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "788-799",
    "snippet": "static struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
      "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);",
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_export",
            "h"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_update",
          "args": [
            "old->cd",
            "&new->h",
            "&old->h",
            "hash"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_hash",
          "args": [
            "old"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "764-773",
          "snippet": "static int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPORT_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHBITS\t\t8\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_export_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "775-786",
    "snippet": "static struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_export",
            "h"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_lookup",
          "args": [
            "exp->cd",
            "&exp->h",
            "hash"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_hash",
          "args": [
            "exp"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "764-773",
          "snippet": "static int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPORT_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHBITS\t\t8\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_export_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "764-773",
    "snippet": "static int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define\tEXPORT_HASHBITS\t\t8"
    ],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "exp->ex_path.mnt",
            "EXPORT_HASHBITS"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "exp->ex_path.dentry",
            "EXPORT_HASHBITS"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "exp->ex_client",
            "EXPORT_HASHBITS"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPORT_HASHBITS\t\t8\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int\nsvc_export_hash(struct svc_export *exp)\n{\n\tint hash;\n\n\thash = hash_ptr(exp->ex_client, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.dentry, EXPORT_HASHBITS);\n\thash ^= hash_ptr(exp->ex_path.mnt, EXPORT_HASHBITS);\n\treturn hash;\n}"
  },
  {
    "function_name": "svc_export_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "741-748",
    "snippet": "static struct cache_head *svc_export_alloc(void)\n{\n\tstruct svc_export *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*i)",
            "GFP_KERNEL"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic struct cache_head *svc_export_alloc(void)\n{\n\tstruct svc_export *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "export_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "714-739",
    "snippet": "static void export_update(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\tint i;\n\n\tnew->ex_flags = item->ex_flags;\n\tnew->ex_anon_uid = item->ex_anon_uid;\n\tnew->ex_anon_gid = item->ex_anon_gid;\n\tnew->ex_fsid = item->ex_fsid;\n\tnew->ex_devid_map = item->ex_devid_map;\n\titem->ex_devid_map = NULL;\n\tnew->ex_uuid = item->ex_uuid;\n\titem->ex_uuid = NULL;\n\tnew->ex_fslocs.locations = item->ex_fslocs.locations;\n\titem->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = item->ex_fslocs.locations_count;\n\titem->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = item->ex_fslocs.migrated;\n\titem->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = item->ex_layout_type;\n\tnew->ex_nflavors = item->ex_nflavors;\n\tfor (i = 0; i < MAX_SECINFO_LIST; i++) {\n\t\tnew->ex_flavors[i] = item->ex_flavors[i];\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_export",
            "h"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_export",
            "h"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic void export_update(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\tint i;\n\n\tnew->ex_flags = item->ex_flags;\n\tnew->ex_anon_uid = item->ex_anon_uid;\n\tnew->ex_anon_gid = item->ex_anon_gid;\n\tnew->ex_fsid = item->ex_fsid;\n\tnew->ex_devid_map = item->ex_devid_map;\n\titem->ex_devid_map = NULL;\n\tnew->ex_uuid = item->ex_uuid;\n\titem->ex_uuid = NULL;\n\tnew->ex_fslocs.locations = item->ex_fslocs.locations;\n\titem->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = item->ex_fslocs.locations_count;\n\titem->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = item->ex_fslocs.migrated;\n\titem->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = item->ex_layout_type;\n\tnew->ex_nflavors = item->ex_nflavors;\n\tfor (i = 0; i < MAX_SECINFO_LIST; i++) {\n\t\tnew->ex_flavors[i] = item->ex_flavors[i];\n\t}\n}"
  },
  {
    "function_name": "svc_export_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "697-712",
    "snippet": "static void svc_export_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\n\tkref_get(&item->ex_client->ref);\n\tnew->ex_client = item->ex_client;\n\tnew->ex_path = item->ex_path;\n\tpath_get(&item->ex_path);\n\tnew->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = 0;\n\tnew->ex_uuid = NULL;\n\tnew->cd = item->cd;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&item->ex_path"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&item->ex_client->ref"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_export",
            "h"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_export",
            "h"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic void svc_export_init(struct cache_head *cnew, struct cache_head *citem)\n{\n\tstruct svc_export *new = container_of(cnew, struct svc_export, h);\n\tstruct svc_export *item = container_of(citem, struct svc_export, h);\n\n\tkref_get(&item->ex_client->ref);\n\tnew->ex_client = item->ex_client;\n\tnew->ex_path = item->ex_path;\n\tpath_get(&item->ex_path);\n\tnew->ex_fslocs.locations = NULL;\n\tnew->ex_fslocs.locations_count = 0;\n\tnew->ex_fslocs.migrated = 0;\n\tnew->ex_layout_type = 0;\n\tnew->ex_uuid = NULL;\n\tnew->cd = item->cd;\n}"
  },
  {
    "function_name": "svc_export_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "689-695",
    "snippet": "static int svc_export_match(struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_export *orig = container_of(a, struct svc_export, h);\n\tstruct svc_export *new = container_of(b, struct svc_export, h);\n\treturn orig->ex_client == new->ex_client &&\n\t\tpath_equal(&orig->ex_path, &new->ex_path);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_equal",
          "args": [
            "&orig->ex_path",
            "&new->ex_path"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structsvc_export",
            "h"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structsvc_export",
            "h"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic int svc_export_match(struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_export *orig = container_of(a, struct svc_export, h);\n\tstruct svc_export *new = container_of(b, struct svc_export, h);\n\treturn orig->ex_client == new->ex_client &&\n\t\tpath_equal(&orig->ex_path, &new->ex_path);\n}"
  },
  {
    "function_name": "svc_export_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "656-688",
    "snippet": "static int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\")\\n\""
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_secinfo",
          "args": [
            "m",
            "exp"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "show_secinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1139-1155",
          "snippet": "static void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\tint flags;\n\n\tif (exp->ex_nflavors == 0)\n\t\treturn;\n\tf = exp->ex_flavors;\n\tflags = show_secinfo_run(m, &f, end);\n\tif (!secinfo_flags_equal(flags, exp->ex_flags))\n\t\tshow_secinfo_flags(m, flags);\n\twhile (f != end) {\n\t\tflags = show_secinfo_run(m, &f, end);\n\t\tshow_secinfo_flags(m, flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%02x\"",
            "exp->ex_uuid[i]"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "':'"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\",uuid=\""
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_flags",
          "args": [
            "m",
            "exp->ex_flags",
            "exp->ex_fsid",
            "exp->ex_anon_uid",
            "exp->ex_anon_gid",
            "&exp->ex_fslocs"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "exp_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1157-1184",
          "snippet": "static void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void exp_flags(struct seq_file *m, int flag, int fsid,\n\t\tkuid_t anonu, kgid_t anong, struct nfsd4_fs_locations *fsloc)\n{\n\tshow_expflags(m, flag, NFSEXP_ALLFLAGS);\n\tif (flag & NFSEXP_FSID)\n\t\tseq_printf(m, \",fsid=%d\", fsid);\n\tif (!uid_eq(anonu, make_kuid(&init_user_ns, (uid_t)-2)) &&\n\t    !uid_eq(anonu, make_kuid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anonuid=%u\", from_kuid(&init_user_ns, anonu));\n\tif (!gid_eq(anong, make_kgid(&init_user_ns, (gid_t)-2)) &&\n\t    !gid_eq(anong, make_kgid(&init_user_ns, 0x10000-2)))\n\t\tseq_printf(m, \",anongid=%u\", from_kgid(&init_user_ns, anong));\n\tif (fsloc && fsloc->locations_count > 0) {\n\t\tchar *loctype = (fsloc->migrated) ? \"refer\" : \"replicas\";\n\t\tint i;\n\n\t\tseq_printf(m, \",%s=\", loctype);\n\t\tseq_escape(m, fsloc->locations[0].path, \",;@ \\t\\n\\\\\");\n\t\tseq_putc(m, '@');\n\t\tseq_escape(m, fsloc->locations[0].hosts, \",;@ \\t\\n\\\\\");\n\t\tfor (i = 1; i < fsloc->locations_count; i++) {\n\t\t\tseq_putc(m, ';');\n\t\t\tseq_escape(m, fsloc->locations[i].path, \",;@ \\t\\n\\\\\");\n\t\t\tseq_putc(m, '@');\n\t\t\tseq_escape(m, fsloc->locations[i].hosts, \",;@ \\t\\n\\\\\");\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&h->flags"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_VALID",
            "&h->flags"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'('"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "exp->ex_client->name",
            "\" \\t\\n\\\\\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\t'"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&exp->ex_path",
            "\" \\t\\n\\\\\""
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_export",
            "h"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#path domain(flags)\\n\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic int svc_export_show(struct seq_file *m,\n\t\t\t   struct cache_detail *cd,\n\t\t\t   struct cache_head *h)\n{\n\tstruct svc_export *exp ;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#path domain(flags)\\n\");\n\t\treturn 0;\n\t}\n\texp = container_of(h, struct svc_export, h);\n\tseq_path(m, &exp->ex_path, \" \\t\\n\\\\\");\n\tseq_putc(m, '\\t');\n\tseq_escape(m, exp->ex_client->name, \" \\t\\n\\\\\");\n\tseq_putc(m, '(');\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\texp_flags(m, exp->ex_flags, exp->ex_fsid,\n\t\t\t  exp->ex_anon_uid, exp->ex_anon_gid, &exp->ex_fslocs);\n\t\tif (exp->ex_uuid) {\n\t\t\tint i;\n\t\t\tseq_puts(m, \",uuid=\");\n\t\t\tfor (i = 0; i < EX_UUID_LEN; i++) {\n\t\t\t\tif ((i&3) == 0 && i)\n\t\t\t\t\tseq_putc(m, ':');\n\t\t\t\tseq_printf(m, \"%02x\", exp->ex_uuid[i]);\n\t\t\t}\n\t\t}\n\t\tshow_secinfo(m, exp);\n\t}\n\tseq_puts(m, \")\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "svc_export_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "509-650",
    "snippet": "static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client path expiry [flags anonuid anongid fsid] */\n\tchar *buf;\n\tint len;\n\tint err;\n\tstruct auth_domain *dom = NULL;\n\tstruct svc_export exp = {}, *expp;\n\tint an_int;\n\n\tif (mesg[mlen-1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* client */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\n\t/* path */\n\terr = -EINVAL;\n\tif ((len = qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out1;\n\n\terr = kern_path(buf, 0, &exp.ex_path);\n\tif (err)\n\t\tgoto out1;\n\n\texp.ex_client = dom;\n\texp.cd = cd;\n\texp.ex_devid_map = NULL;\n\n\t/* expiry */\n\terr = -EINVAL;\n\texp.h.expiry_time = get_expiry(&mesg);\n\tif (exp.h.expiry_time == 0)\n\t\tgoto out3;\n\n\t/* flags */\n\terr = get_int(&mesg, &an_int);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tset_bit(CACHE_NEGATIVE, &exp.h.flags);\n\t} else {\n\t\tif (err || an_int < 0)\n\t\t\tgoto out3;\n\t\texp.ex_flags= an_int;\n\t\n\t\t/* anon uid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_uid= make_kuid(&init_user_ns, an_int);\n\n\t\t/* anon gid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_gid= make_kgid(&init_user_ns, an_int);\n\n\t\t/* fsid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_fsid = an_int;\n\n\t\twhile ((len = qword_get(&mesg, buf, PAGE_SIZE)) > 0) {\n\t\t\tif (strcmp(buf, \"fsloc\") == 0)\n\t\t\t\terr = fsloc_parse(&mesg, buf, &exp.ex_fslocs);\n\t\t\telse if (strcmp(buf, \"uuid\") == 0)\n\t\t\t\terr = uuid_parse(&mesg, buf, &exp.ex_uuid);\n\t\t\telse if (strcmp(buf, \"secinfo\") == 0)\n\t\t\t\terr = secinfo_parse(&mesg, buf, &exp);\n\t\t\telse\n\t\t\t\t/* quietly ignore unknown words and anything\n\t\t\t\t * following. Newer user-space can try to set\n\t\t\t\t * new values, then see what the result was.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tif (err)\n\t\t\t\tgoto out4;\n\t\t}\n\n\t\terr = check_export(d_inode(exp.ex_path.dentry), &exp.ex_flags,\n\t\t\t\t   exp.ex_uuid);\n\t\tif (err)\n\t\t\tgoto out4;\n\t\t/*\n\t\t * No point caching this if it would immediately expire.\n\t\t * Also, this protects exportfs's dummy export from the\n\t\t * anon_uid/anon_gid checks:\n\t\t */\n\t\tif (exp.h.expiry_time < seconds_since_boot())\n\t\t\tgoto out4;\n\t\t/*\n\t\t * For some reason exportfs has been passing down an\n\t\t * invalid (-1) uid & gid on the \"dummy\" export which it\n\t\t * uses to test export support.  To make sure exportfs\n\t\t * sees errors from check_export we therefore need to\n\t\t * delay these checks till after check_export:\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (!uid_valid(exp.ex_anon_uid))\n\t\t\tgoto out4;\n\t\tif (!gid_valid(exp.ex_anon_gid))\n\t\t\tgoto out4;\n\t\terr = 0;\n\n\t\tnfsd4_setup_layout_type(&exp);\n\t}\n\n\texpp = svc_export_lookup(&exp);\n\tif (expp)\n\t\texpp = svc_export_update(&exp, expp);\n\telse\n\t\terr = -ENOMEM;\n\tcache_flush();\n\tif (expp == NULL)\n\t\terr = -ENOMEM;\n\telse\n\t\texp_put(expp);\nout4:\n\tnfsd4_fslocs_free(&exp.ex_fslocs);\n\tkfree(exp.ex_uuid);\nout3:\n\tpath_put(&exp.ex_path);\nout1:\n\tauth_domain_put(dom);\nout:\n\tkfree(buf);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "dom"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&exp.ex_path"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exp.ex_uuid"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_fslocs_free",
          "args": [
            "&exp.ex_fslocs"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fslocs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "292-307",
          "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "expp"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_flush",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_export_update",
          "args": [
            "&exp",
            "expp"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "788-799",
          "snippet": "static struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
            "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);",
            "static struct svc_export *svc_export_lookup(struct svc_export *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstatic struct svc_export *\nsvc_export_update(struct svc_export *new, struct svc_export *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(old);\n\n\tch = sunrpc_cache_update(old->cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_export_lookup",
          "args": [
            "&exp"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "svc_export_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "775-786",
          "snippet": "static struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic struct svc_export *\nsvc_export_lookup(struct svc_export *exp)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_export_hash(exp);\n\n\tch = sunrpc_cache_lookup(exp->cd, &exp->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_export, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_setup_layout_type",
          "args": [
            "&exp"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_setup_layout_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "123-148",
          "snippet": "void nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (!(exp->ex_flags & NFSEXP_PNFS))\n\t\treturn;\n\n\t/*\n\t * Check if the file system supports exporting a block-like layout.\n\t * If the block device supports reservations prefer the SCSI layout,\n\t * otherwise advertise the block layout.\n\t */\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\t/* overwrite block layout selection if needed */\n\tif (sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks &&\n\t    sb->s_bdev && sb->s_bdev->bd_disk->fops->pr_ops)\n\t\texp->ex_layout_type = LAYOUT_SCSI;\n#endif\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nvoid nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (!(exp->ex_flags & NFSEXP_PNFS))\n\t\treturn;\n\n\t/*\n\t * Check if the file system supports exporting a block-like layout.\n\t * If the block device supports reservations prefer the SCSI layout,\n\t * otherwise advertise the block layout.\n\t */\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\t/* overwrite block layout selection if needed */\n\tif (sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks &&\n\t    sb->s_bdev && sb->s_bdev->bd_disk->fops->pr_ops)\n\t\texp->ex_layout_type = LAYOUT_SCSI;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "exp.ex_anon_gid"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "exp.ex_anon_uid"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_export",
          "args": [
            "d_inode(exp.ex_path.dentry)",
            "&exp.ex_flags",
            "exp.ex_uuid"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "check_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "342-383",
          "snippet": "static int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "exp.ex_path.dentry"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secinfo_parse",
          "args": [
            "&mesg",
            "buf",
            "&exp"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "secinfo_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "484-485",
          "snippet": "static inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"secinfo\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_parse",
          "args": [
            "&mesg",
            "buf",
            "&exp.ex_uuid"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "488-507",
          "snippet": "static inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"uuid\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsloc_parse",
          "args": [
            "&mesg",
            "buf",
            "&exp.ex_fslocs"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "fsloc_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "482-483",
          "snippet": "static inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"fsloc\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "an_int"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "an_int"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&exp.h.flags"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "&mesg",
            "&an_int"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_expiry",
          "args": [
            "&mesg"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "buf",
            "0",
            "&exp.ex_path"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_find",
          "args": [
            "buf"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client path expiry [flags anonuid anongid fsid] */\n\tchar *buf;\n\tint len;\n\tint err;\n\tstruct auth_domain *dom = NULL;\n\tstruct svc_export exp = {}, *expp;\n\tint an_int;\n\n\tif (mesg[mlen-1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t/* client */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\n\t/* path */\n\terr = -EINVAL;\n\tif ((len = qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out1;\n\n\terr = kern_path(buf, 0, &exp.ex_path);\n\tif (err)\n\t\tgoto out1;\n\n\texp.ex_client = dom;\n\texp.cd = cd;\n\texp.ex_devid_map = NULL;\n\n\t/* expiry */\n\terr = -EINVAL;\n\texp.h.expiry_time = get_expiry(&mesg);\n\tif (exp.h.expiry_time == 0)\n\t\tgoto out3;\n\n\t/* flags */\n\terr = get_int(&mesg, &an_int);\n\tif (err == -ENOENT) {\n\t\terr = 0;\n\t\tset_bit(CACHE_NEGATIVE, &exp.h.flags);\n\t} else {\n\t\tif (err || an_int < 0)\n\t\t\tgoto out3;\n\t\texp.ex_flags= an_int;\n\t\n\t\t/* anon uid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_uid= make_kuid(&init_user_ns, an_int);\n\n\t\t/* anon gid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_anon_gid= make_kgid(&init_user_ns, an_int);\n\n\t\t/* fsid */\n\t\terr = get_int(&mesg, &an_int);\n\t\tif (err)\n\t\t\tgoto out3;\n\t\texp.ex_fsid = an_int;\n\n\t\twhile ((len = qword_get(&mesg, buf, PAGE_SIZE)) > 0) {\n\t\t\tif (strcmp(buf, \"fsloc\") == 0)\n\t\t\t\terr = fsloc_parse(&mesg, buf, &exp.ex_fslocs);\n\t\t\telse if (strcmp(buf, \"uuid\") == 0)\n\t\t\t\terr = uuid_parse(&mesg, buf, &exp.ex_uuid);\n\t\t\telse if (strcmp(buf, \"secinfo\") == 0)\n\t\t\t\terr = secinfo_parse(&mesg, buf, &exp);\n\t\t\telse\n\t\t\t\t/* quietly ignore unknown words and anything\n\t\t\t\t * following. Newer user-space can try to set\n\t\t\t\t * new values, then see what the result was.\n\t\t\t\t */\n\t\t\t\tbreak;\n\t\t\tif (err)\n\t\t\t\tgoto out4;\n\t\t}\n\n\t\terr = check_export(d_inode(exp.ex_path.dentry), &exp.ex_flags,\n\t\t\t\t   exp.ex_uuid);\n\t\tif (err)\n\t\t\tgoto out4;\n\t\t/*\n\t\t * No point caching this if it would immediately expire.\n\t\t * Also, this protects exportfs's dummy export from the\n\t\t * anon_uid/anon_gid checks:\n\t\t */\n\t\tif (exp.h.expiry_time < seconds_since_boot())\n\t\t\tgoto out4;\n\t\t/*\n\t\t * For some reason exportfs has been passing down an\n\t\t * invalid (-1) uid & gid on the \"dummy\" export which it\n\t\t * uses to test export support.  To make sure exportfs\n\t\t * sees errors from check_export we therefore need to\n\t\t * delay these checks till after check_export:\n\t\t */\n\t\terr = -EINVAL;\n\t\tif (!uid_valid(exp.ex_anon_uid))\n\t\t\tgoto out4;\n\t\tif (!gid_valid(exp.ex_anon_gid))\n\t\t\tgoto out4;\n\t\terr = 0;\n\n\t\tnfsd4_setup_layout_type(&exp);\n\t}\n\n\texpp = svc_export_lookup(&exp);\n\tif (expp)\n\t\texpp = svc_export_update(&exp, expp);\n\telse\n\t\terr = -ENOMEM;\n\tcache_flush();\n\tif (expp == NULL)\n\t\terr = -ENOMEM;\n\telse\n\t\texp_put(expp);\nout4:\n\tnfsd4_fslocs_free(&exp.ex_fslocs);\n\tkfree(exp.ex_uuid);\nout3:\n\tpath_put(&exp.ex_path);\nout1:\n\tauth_domain_put(dom);\nout:\n\tkfree(buf);\n\treturn err;\n}"
  },
  {
    "function_name": "uuid_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "488-507",
    "snippet": "static inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "buf",
            "EX_UUID_LEN",
            "GFP_KERNEL"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nuuid_parse(char **mesg, char *buf, unsigned char **puuid)\n{\n\tint len;\n\n\t/* more than one uuid */\n\tif (*puuid)\n\t\treturn -EINVAL;\n\n\t/* expect a 16 byte uuid encoded as \\xXXXX... */\n\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\tif (len != EX_UUID_LEN)\n\t\treturn -EINVAL;\n\n\t*puuid = kmemdup(buf, EX_UUID_LEN, GFP_KERNEL);\n\tif (*puuid == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "secinfo_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "484-485",
    "snippet": "static inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic inline int\nsecinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }"
  },
  {
    "function_name": "fsloc_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "482-483",
    "snippet": "static inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic inline int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}"
  },
  {
    "function_name": "secinfo_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "444-479",
    "snippet": "static int secinfo_parse(char **mesg, char *buf, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tu32 listsize;\n\tint err;\n\n\t/* more than one secinfo */\n\tif (exp->ex_nflavors)\n\t\treturn -EINVAL;\n\n\terr = get_uint(mesg, &listsize);\n\tif (err)\n\t\treturn err;\n\tif (listsize > MAX_SECINFO_LIST)\n\t\treturn -EINVAL;\n\n\tfor (f = exp->ex_flavors; f < exp->ex_flavors + listsize; f++) {\n\t\terr = get_uint(mesg, &f->pseudoflavor);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * XXX: It would be nice to also check whether this\n\t\t * pseudoflavor is supported, so we can discover the\n\t\t * problem at export time instead of when a client fails\n\t\t * to authenticate.\n\t\t */\n\t\terr = get_uint(mesg, &f->flags);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/* Only some flags are allowed to differ between flavors: */\n\t\tif (~NFSEXP_SECINFO_FLAGS & (f->flags ^ exp->ex_flags))\n\t\t\treturn -EINVAL;\n\t}\n\texp->ex_nflavors = listsize;\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&f->flags"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&f->pseudoflavor"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&listsize"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic int secinfo_parse(char **mesg, char *buf, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tu32 listsize;\n\tint err;\n\n\t/* more than one secinfo */\n\tif (exp->ex_nflavors)\n\t\treturn -EINVAL;\n\n\terr = get_uint(mesg, &listsize);\n\tif (err)\n\t\treturn err;\n\tif (listsize > MAX_SECINFO_LIST)\n\t\treturn -EINVAL;\n\n\tfor (f = exp->ex_flavors; f < exp->ex_flavors + listsize; f++) {\n\t\terr = get_uint(mesg, &f->pseudoflavor);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * XXX: It would be nice to also check whether this\n\t\t * pseudoflavor is supported, so we can discover the\n\t\t * problem at export time instead of when a client fails\n\t\t * to authenticate.\n\t\t */\n\t\terr = get_uint(mesg, &f->flags);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/* Only some flags are allowed to differ between flavors: */\n\t\tif (~NFSEXP_SECINFO_FLAGS & (f->flags ^ exp->ex_flags))\n\t\t\treturn -EINVAL;\n\t}\n\texp->ex_nflavors = listsize;\n\treturn 0;\n}"
  },
  {
    "function_name": "fsloc_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "387-442",
    "snippet": "static int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc)\n{\n\tint len;\n\tint migrated, i, err;\n\n\t/* more than one fsloc */\n\tif (fsloc->locations)\n\t\treturn -EINVAL;\n\n\t/* listsize */\n\terr = get_uint(mesg, &fsloc->locations_count);\n\tif (err)\n\t\treturn err;\n\tif (fsloc->locations_count > MAX_FS_LOCATIONS)\n\t\treturn -EINVAL;\n\tif (fsloc->locations_count == 0)\n\t\treturn 0;\n\n\tfsloc->locations = kzalloc(fsloc->locations_count\n\t\t\t* sizeof(struct nfsd4_fs_location), GFP_KERNEL);\n\tif (!fsloc->locations)\n\t\treturn -ENOMEM;\n\tfor (i=0; i < fsloc->locations_count; i++) {\n\t\t/* colon separated host list */\n\t\terr = -EINVAL;\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].hosts = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].hosts)\n\t\t\tgoto out_free_all;\n\t\terr = -EINVAL;\n\t\t/* slash separated path component list */\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].path = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].path)\n\t\t\tgoto out_free_all;\n\t}\n\t/* migrated */\n\terr = get_int(mesg, &migrated);\n\tif (err)\n\t\tgoto out_free_all;\n\terr = -EINVAL;\n\tif (migrated < 0 || migrated > 1)\n\t\tgoto out_free_all;\n\tfsloc->migrated = migrated;\n\treturn 0;\nout_free_all:\n\tnfsd4_fslocs_free(fsloc);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_fslocs_free",
          "args": [
            "fsloc"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fslocs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "292-307",
          "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int",
          "args": [
            "mesg",
            "&migrated"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "buf",
            "GFP_KERNEL"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "fsloc->locations_count\n\t\t\t* sizeof(struct nfsd4_fs_location)",
            "GFP_KERNEL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uint",
          "args": [
            "mesg",
            "&fsloc->locations_count"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int\nfsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc)\n{\n\tint len;\n\tint migrated, i, err;\n\n\t/* more than one fsloc */\n\tif (fsloc->locations)\n\t\treturn -EINVAL;\n\n\t/* listsize */\n\terr = get_uint(mesg, &fsloc->locations_count);\n\tif (err)\n\t\treturn err;\n\tif (fsloc->locations_count > MAX_FS_LOCATIONS)\n\t\treturn -EINVAL;\n\tif (fsloc->locations_count == 0)\n\t\treturn 0;\n\n\tfsloc->locations = kzalloc(fsloc->locations_count\n\t\t\t* sizeof(struct nfsd4_fs_location), GFP_KERNEL);\n\tif (!fsloc->locations)\n\t\treturn -ENOMEM;\n\tfor (i=0; i < fsloc->locations_count; i++) {\n\t\t/* colon separated host list */\n\t\terr = -EINVAL;\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].hosts = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].hosts)\n\t\t\tgoto out_free_all;\n\t\terr = -EINVAL;\n\t\t/* slash separated path component list */\n\t\tlen = qword_get(mesg, buf, PAGE_SIZE);\n\t\tif (len <= 0)\n\t\t\tgoto out_free_all;\n\t\terr = -ENOMEM;\n\t\tfsloc->locations[i].path = kstrdup(buf, GFP_KERNEL);\n\t\tif (!fsloc->locations[i].path)\n\t\t\tgoto out_free_all;\n\t}\n\t/* migrated */\n\terr = get_int(mesg, &migrated);\n\tif (err)\n\t\tgoto out_free_all;\n\terr = -EINVAL;\n\tif (migrated < 0 || migrated > 1)\n\t\tgoto out_free_all;\n\tfsloc->migrated = migrated;\n\treturn 0;\nout_free_all:\n\tnfsd4_fslocs_free(fsloc);\n\treturn err;\n}"
  },
  {
    "function_name": "check_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "342-383",
    "snippet": "static int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"exp_export: export of invalid fs type.\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"exp_export: export of non-dev fs without fsid\\n\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic int check_export(struct inode *inode, int *flags, unsigned char *uuid)\n{\n\n\t/*\n\t * We currently export only dirs, regular files, and (for v4\n\t * pseudoroot) symlinks.\n\t */\n\tif (!S_ISDIR(inode->i_mode) &&\n\t    !S_ISLNK(inode->i_mode) &&\n\t    !S_ISREG(inode->i_mode))\n\t\treturn -ENOTDIR;\n\n\t/*\n\t * Mountd should never pass down a writeable V4ROOT export, but,\n\t * just to make sure:\n\t */\n\tif (*flags & NFSEXP_V4ROOT)\n\t\t*flags |= NFSEXP_READONLY;\n\n\t/* There are two requirements on a filesystem to be exportable.\n\t * 1:  We must be able to identify the filesystem from a number.\n\t *       either a device number (so FS_REQUIRES_DEV needed)\n\t *       or an FSID number (so NFSEXP_FSID or ->uuid is needed).\n\t * 2:  We must be able to find an inode from a filehandle.\n\t *       This means that s_export_op must be set.\n\t */\n\tif (!(inode->i_sb->s_type->fs_flags & FS_REQUIRES_DEV) &&\n\t    !(*flags & NFSEXP_FSID) &&\n\t    uuid == NULL) {\n\t\tdprintk(\"exp_export: export of non-dev fs without fsid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!inode->i_sb->s_export_op ||\n\t    !inode->i_sb->s_export_op->fh_to_dentry) {\n\t\tdprintk(\"exp_export: export of invalid fs type.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "function_name": "svc_export_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "319-336",
    "snippet": "static void svc_export_request(struct cache_detail *cd,\n\t\t\t       struct cache_head *h,\n\t\t\t       char **bpp, int *blen)\n{\n\t/*  client path */\n\tstruct svc_export *exp = container_of(h, struct svc_export, h);\n\tchar *pth;\n\n\tqword_add(bpp, blen, exp->ex_client->name);\n\tpth = d_path(&exp->ex_path, *bpp, *blen);\n\tif (IS_ERR(pth)) {\n\t\t/* is this correct? */\n\t\t(*bpp)[0] = '\\n';\n\t\treturn;\n\t}\n\tqword_add(bpp, blen, pth);\n\t(*bpp)[-1] = '\\n';\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "pth"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pth"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "&exp->ex_path",
            "*bpp",
            "*blen"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "exp->ex_client->name"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_export",
            "h"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void svc_export_request(struct cache_detail *cd,\n\t\t\t       struct cache_head *h,\n\t\t\t       char **bpp, int *blen)\n{\n\t/*  client path */\n\tstruct svc_export *exp = container_of(h, struct svc_export, h);\n\tchar *pth;\n\n\tqword_add(bpp, blen, exp->ex_client->name);\n\tpth = d_path(&exp->ex_path, *bpp, *blen);\n\tif (IS_ERR(pth)) {\n\t\t/* is this correct? */\n\t\t(*bpp)[0] = '\\n';\n\t\treturn;\n\t}\n\tqword_add(bpp, blen, pth);\n\t(*bpp)[-1] = '\\n';\n}"
  },
  {
    "function_name": "svc_export_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "309-317",
    "snippet": "static void svc_export_put(struct kref *ref)\n{\n\tstruct svc_export *exp = container_of(ref, struct svc_export, h.ref);\n\tpath_put(&exp->ex_path);\n\tauth_domain_put(exp->ex_client);\n\tnfsd4_fslocs_free(&exp->ex_fslocs);\n\tkfree(exp->ex_uuid);\n\tkfree(exp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_export *svc_export_lookup(struct svc_export *);",
      "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exp"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exp->ex_uuid"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_fslocs_free",
          "args": [
            "&exp->ex_fslocs"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_fslocs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "292-307",
          "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "exp->ex_client"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&exp->ex_path"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structsvc_export",
            "h.ref"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstatic void svc_export_put(struct kref *ref)\n{\n\tstruct svc_export *exp = container_of(ref, struct svc_export, h.ref);\n\tpath_put(&exp->ex_path);\n\tauth_domain_put(exp->ex_client);\n\tnfsd4_fslocs_free(&exp->ex_fslocs);\n\tkfree(exp->ex_uuid);\n\tkfree(exp);\n}"
  },
  {
    "function_name": "nfsd4_fslocs_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "292-307",
    "snippet": "static void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locations"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locations[i].hosts"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locations[i].path"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic void nfsd4_fslocs_free(struct nfsd4_fs_locations *fsloc)\n{\n\tstruct nfsd4_fs_location *locations = fsloc->locations;\n\tint i;\n\n\tif (!locations)\n\t\treturn;\n\n\tfor (i = 0; i < fsloc->locations_count; i++) {\n\t\tkfree(locations[i].path);\n\t\tkfree(locations[i].hosts);\n\t}\n\n\tkfree(locations);\n\tfsloc->locations = NULL;\n}"
  },
  {
    "function_name": "svc_expkey_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "274-286",
    "snippet": "static struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_expkey",
            "h"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_update",
          "args": [
            "cd",
            "&new->h",
            "&old->h",
            "hash"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_hash",
          "args": [
            "new"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "248-259",
          "snippet": "static int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)",
            "#define\tEXPKEY_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n#define\tEXPKEY_HASHBITS\t\t8\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\n\nstatic struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_expkey_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "261-272",
    "snippet": "static struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "structsvc_expkey",
            "h"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sunrpc_cache_lookup",
          "args": [
            "cd",
            "&item->h",
            "hash"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_hash",
          "args": [
            "item"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "248-259",
          "snippet": "static int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)",
            "#define\tEXPKEY_HASHBITS\t\t8"
          ],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n#define\tEXPKEY_HASHBITS\t\t8\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "svc_expkey_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "248-259",
    "snippet": "static int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)",
      "#define\tEXPKEY_HASHBITS\t\t8"
    ],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "item->ek_client",
            "EXPKEY_HASHBITS"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_mem",
          "args": [
            "cp",
            "len",
            "EXPKEY_HASHBITS"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "item->ek_fsidtype"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\n#define\tEXPKEY_HASHMASK\t\t(EXPKEY_HASHMAX -1)\n#define\tEXPKEY_HASHBITS\t\t8\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int\nsvc_expkey_hash(struct svc_expkey *item)\n{\n\tint hash = item->ek_fsidtype;\n\tchar * cp = (char*)item->ek_fsid;\n\tint len = key_len(item->ek_fsidtype);\n\n\thash ^= hash_mem(cp, len, EXPKEY_HASHBITS);\n\thash ^= hash_ptr(item->ek_client, EXPKEY_HASHBITS);\n\thash &= EXPKEY_HASHMASK;\n\treturn hash;\n}"
  },
  {
    "function_name": "expkey_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "225-232",
    "snippet": "static struct cache_head *expkey_alloc(void)\n{\n\tstruct svc_expkey *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*i)",
            "GFP_KERNEL"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct cache_head *expkey_alloc(void)\n{\n\tstruct svc_expkey *i = kmalloc(sizeof(*i), GFP_KERNEL);\n\tif (i)\n\t\treturn &i->h;\n\telse\n\t\treturn NULL;\n}"
  },
  {
    "function_name": "expkey_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "215-223",
    "snippet": "static inline void expkey_update(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tnew->ek_path = item->ek_path;\n\tpath_get(&item->ek_path);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&item->ek_path"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_expkey",
            "h"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_expkey",
            "h"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic inline void expkey_update(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tnew->ek_path = item->ek_path;\n\tpath_get(&item->ek_path);\n}"
  },
  {
    "function_name": "expkey_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "202-213",
    "snippet": "static inline void expkey_init(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tkref_get(&item->ek_client->ref);\n\tnew->ek_client = item->ek_client;\n\tnew->ek_fsidtype = item->ek_fsidtype;\n\n\tmemcpy(new->ek_fsid, item->ek_fsid, sizeof(new->ek_fsid));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->ek_fsid",
            "item->ek_fsid",
            "sizeof(new->ek_fsid)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&item->ek_client->ref"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "citem",
            "structsvc_expkey",
            "h"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cnew",
            "structsvc_expkey",
            "h"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic inline void expkey_init(struct cache_head *cnew,\n\t\t\t\t   struct cache_head *citem)\n{\n\tstruct svc_expkey *new = container_of(cnew, struct svc_expkey, h);\n\tstruct svc_expkey *item = container_of(citem, struct svc_expkey, h);\n\n\tkref_get(&item->ek_client->ref);\n\tnew->ek_client = item->ek_client;\n\tnew->ek_fsidtype = item->ek_fsidtype;\n\n\tmemcpy(new->ek_fsid, item->ek_fsid, sizeof(new->ek_fsid));\n}"
  },
  {
    "function_name": "expkey_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "190-200",
    "snippet": "static inline int expkey_match (struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_expkey *orig = container_of(a, struct svc_expkey, h);\n\tstruct svc_expkey *new = container_of(b, struct svc_expkey, h);\n\n\tif (orig->ek_fsidtype != new->ek_fsidtype ||\n\t    orig->ek_client != new->ek_client ||\n\t    memcmp(orig->ek_fsid, new->ek_fsid, key_len(orig->ek_fsidtype)) != 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "orig->ek_fsid",
            "new->ek_fsid",
            "key_len(orig->ek_fsidtype)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "orig->ek_fsidtype"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structsvc_expkey",
            "h"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structsvc_expkey",
            "h"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic inline int expkey_match (struct cache_head *a, struct cache_head *b)\n{\n\tstruct svc_expkey *orig = container_of(a, struct svc_expkey, h);\n\tstruct svc_expkey *new = container_of(b, struct svc_expkey, h);\n\n\tif (orig->ek_fsidtype != new->ek_fsidtype ||\n\t    orig->ek_client != new->ek_client ||\n\t    memcmp(orig->ek_fsid, new->ek_fsid, key_len(orig->ek_fsidtype)) != 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "expkey_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "165-188",
    "snippet": "static int expkey_show(struct seq_file *m,\n\t\t       struct cache_detail *cd,\n\t\t       struct cache_head *h)\n{\n\tstruct svc_expkey *ek ;\n\tint i;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#domain fsidtype fsid [path]\\n\");\n\t\treturn 0;\n\t}\n\tek = container_of(h, struct svc_expkey, h);\n\tseq_printf(m, \"%s %d 0x\", ek->ek_client->name,\n\t\t   ek->ek_fsidtype);\n\tfor (i=0; i < key_len(ek->ek_fsidtype)/4; i++)\n\t\tseq_printf(m, \"%08x\", ek->ek_fsid[i]);\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\tseq_printf(m, \" \");\n\t\tseq_path(m, &ek->ek_path, \"\\\\ \\t\\n\");\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_path",
          "args": [
            "m",
            "&ek->ek_path",
            "\"\\\\ \\t\\n\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" \""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&h->flags"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_VALID",
            "&h->flags"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%08x\"",
            "ek->ek_fsid[i]"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "ek->ek_fsidtype"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %d 0x\"",
            "ek->ek_client->name",
            "ek->ek_fsidtype"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_expkey",
            "h"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#domain fsidtype fsid [path]\\n\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic int expkey_show(struct seq_file *m,\n\t\t       struct cache_detail *cd,\n\t\t       struct cache_head *h)\n{\n\tstruct svc_expkey *ek ;\n\tint i;\n\n\tif (h ==NULL) {\n\t\tseq_puts(m, \"#domain fsidtype fsid [path]\\n\");\n\t\treturn 0;\n\t}\n\tek = container_of(h, struct svc_expkey, h);\n\tseq_printf(m, \"%s %d 0x\", ek->ek_client->name,\n\t\t   ek->ek_fsidtype);\n\tfor (i=0; i < key_len(ek->ek_fsidtype)/4; i++)\n\t\tseq_printf(m, \"%08x\", ek->ek_fsid[i]);\n\tif (test_bit(CACHE_VALID, &h->flags) && \n\t    !test_bit(CACHE_NEGATIVE, &h->flags)) {\n\t\tseq_printf(m, \" \");\n\t\tseq_path(m, &ek->ek_path, \"\\\\ \\t\\n\");\n\t}\n\tseq_printf(m, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "expkey_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "70-163",
    "snippet": "static int expkey_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client fsidtype fsid expiry [path] */\n\tchar *buf;\n\tint len;\n\tstruct auth_domain *dom = NULL;\n\tint err;\n\tint fsidtype;\n\tchar *ep;\n\tstruct svc_expkey key;\n\tstruct svc_expkey *ek = NULL;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\tdprintk(\"found domain %s\\n\", buf);\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tfsidtype = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tdprintk(\"found fsidtype %d\\n\", fsidtype);\n\tif (key_len(fsidtype)==0) /* invalid type */\n\t\tgoto out;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tdprintk(\"found fsid length %d\\n\", len);\n\tif (len != key_len(fsidtype))\n\t\tgoto out;\n\n\t/* OK, we seem to have a valid key */\n\tkey.h.flags = 0;\n\tkey.h.expiry_time = get_expiry(&mesg);\n\tif (key.h.expiry_time == 0)\n\t\tgoto out;\n\n\tkey.ek_client = dom;\t\n\tkey.ek_fsidtype = fsidtype;\n\tmemcpy(key.ek_fsid, buf, len);\n\n\tek = svc_expkey_lookup(cd, &key);\n\terr = -ENOMEM;\n\tif (!ek)\n\t\tgoto out;\n\n\t/* now we want a pathname, or empty meaning NEGATIVE  */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len < 0)\n\t\tgoto out;\n\tdprintk(\"Path seems to be <%s>\\n\", buf);\n\terr = 0;\n\tif (len == 0) {\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\terr = kern_path(buf, 0, &key.ek_path);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdprintk(\"Found the path %s\\n\", buf);\n\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t\tpath_put(&key.ek_path);\n\t}\n\tcache_flush();\n out:\n\tif (ek)\n\t\tcache_put(&ek->h, cd);\n\tif (dom)\n\t\tauth_domain_put(dom);\n\tkfree(buf);\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "dom"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_put",
          "args": [
            "&ek->h",
            "cd"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_flush",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&key.ek_path"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_update",
          "args": [
            "cd",
            "&key",
            "ek"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "274-286",
          "snippet": "static struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);",
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
            "static struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t\t\t\t    struct svc_expkey *old);\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct svc_export *svc_export_update(struct svc_export *new,\n\t\t\t\t\t    struct svc_export *old);\n\nstatic struct svc_expkey *\nsvc_expkey_update(struct cache_detail *cd, struct svc_expkey *new,\n\t\t  struct svc_expkey *old)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(new);\n\n\tch = sunrpc_cache_update(cd, &new->h, &old->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Found the path %s\\n\"",
            "buf"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "buf",
            "0",
            "&key.ek_path"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&key.h.flags"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Path seems to be <%s>\\n\"",
            "buf"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_expkey_lookup",
          "args": [
            "cd",
            "&key"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "svc_expkey_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "261-272",
          "snippet": "static struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic struct svc_expkey *\nsvc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *item)\n{\n\tstruct cache_head *ch;\n\tint hash = svc_expkey_hash(item);\n\n\tch = sunrpc_cache_lookup(cd, &item->h, hash);\n\tif (ch)\n\t\treturn container_of(ch, struct svc_expkey, h);\n\telse\n\t\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key.ek_fsid",
            "buf",
            "len"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_expiry",
          "args": [
            "&mesg"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "fsidtype"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"found fsid length %d\\n\"",
            "len"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"found fsidtype %d\\n\"",
            "fsidtype"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buf",
            "&ep",
            "10"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"found domain %s\\n\"",
            "buf"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_find",
          "args": [
            "buf"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_get",
          "args": [
            "&mesg",
            "buf",
            "PAGE_SIZE"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic int expkey_parse(struct cache_detail *cd, char *mesg, int mlen)\n{\n\t/* client fsidtype fsid expiry [path] */\n\tchar *buf;\n\tint len;\n\tstruct auth_domain *dom = NULL;\n\tint err;\n\tint fsidtype;\n\tchar *ep;\n\tstruct svc_expkey key;\n\tstruct svc_expkey *ek = NULL;\n\n\tif (mesg[mlen - 1] != '\\n')\n\t\treturn -EINVAL;\n\tmesg[mlen-1] = 0;\n\n\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!buf)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\n\terr = -ENOENT;\n\tdom = auth_domain_find(buf);\n\tif (!dom)\n\t\tgoto out;\n\tdprintk(\"found domain %s\\n\", buf);\n\n\terr = -EINVAL;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tfsidtype = simple_strtoul(buf, &ep, 10);\n\tif (*ep)\n\t\tgoto out;\n\tdprintk(\"found fsidtype %d\\n\", fsidtype);\n\tif (key_len(fsidtype)==0) /* invalid type */\n\t\tgoto out;\n\tif ((len=qword_get(&mesg, buf, PAGE_SIZE)) <= 0)\n\t\tgoto out;\n\tdprintk(\"found fsid length %d\\n\", len);\n\tif (len != key_len(fsidtype))\n\t\tgoto out;\n\n\t/* OK, we seem to have a valid key */\n\tkey.h.flags = 0;\n\tkey.h.expiry_time = get_expiry(&mesg);\n\tif (key.h.expiry_time == 0)\n\t\tgoto out;\n\n\tkey.ek_client = dom;\t\n\tkey.ek_fsidtype = fsidtype;\n\tmemcpy(key.ek_fsid, buf, len);\n\n\tek = svc_expkey_lookup(cd, &key);\n\terr = -ENOMEM;\n\tif (!ek)\n\t\tgoto out;\n\n\t/* now we want a pathname, or empty meaning NEGATIVE  */\n\terr = -EINVAL;\n\tlen = qword_get(&mesg, buf, PAGE_SIZE);\n\tif (len < 0)\n\t\tgoto out;\n\tdprintk(\"Path seems to be <%s>\\n\", buf);\n\terr = 0;\n\tif (len == 0) {\n\t\tset_bit(CACHE_NEGATIVE, &key.h.flags);\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\terr = kern_path(buf, 0, &key.ek_path);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdprintk(\"Found the path %s\\n\", buf);\n\n\t\tek = svc_expkey_update(cd, &key, ek);\n\t\tif (!ek)\n\t\t\terr = -ENOMEM;\n\t\tpath_put(&key.ek_path);\n\t}\n\tcache_flush();\n out:\n\tif (ek)\n\t\tcache_put(&ek->h, cd);\n\tif (dom)\n\t\tauth_domain_put(dom);\n\tkfree(buf);\n\treturn err;\n}"
  },
  {
    "function_name": "expkey_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "51-64",
    "snippet": "static void expkey_request(struct cache_detail *cd,\n\t\t\t   struct cache_head *h,\n\t\t\t   char **bpp, int *blen)\n{\n\t/* client fsidtype \\xfsid */\n\tstruct svc_expkey *ek = container_of(h, struct svc_expkey, h);\n\tchar type[5];\n\n\tqword_add(bpp, blen, ek->ek_client->name);\n\tsnprintf(type, 5, \"%d\", ek->ek_fsidtype);\n\tqword_add(bpp, blen, type);\n\tqword_addhex(bpp, blen, (char*)ek->ek_fsid, key_len(ek->ek_fsidtype));\n\t(*bpp)[-1] = '\\n';\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);",
      "static struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "qword_addhex",
          "args": [
            "bpp",
            "blen",
            "(char*)ek->ek_fsid",
            "key_len(ek->ek_fsidtype)"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "ek->ek_fsidtype"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "type"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "type",
            "5",
            "\"%d\"",
            "ek->ek_fsidtype"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qword_add",
          "args": [
            "bpp",
            "blen",
            "ek->ek_client->name"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "h",
            "structsvc_expkey",
            "h"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\nstatic struct flags {\n\tint flag;\n\tchar *name[2];\n} expflags[] = {\n\t{ NFSEXP_READONLY, {\"ro\", \"rw\"}},\n\t{ NFSEXP_INSECURE_PORT, {\"insecure\", \"\"}},\n\t{ NFSEXP_ROOTSQUASH, {\"root_squash\", \"no_root_squash\"}},\n\t{ NFSEXP_ALLSQUASH, {\"all_squash\", \"\"}},\n\t{ NFSEXP_ASYNC, {\"async\", \"sync\"}},\n\t{ NFSEXP_GATHERED_WRITES, {\"wdelay\", \"no_wdelay\"}},\n\t{ NFSEXP_NOREADDIRPLUS, {\"nordirplus\", \"\"}},\n\t{ NFSEXP_NOHIDE, {\"nohide\", \"\"}},\n\t{ NFSEXP_CROSSMOUNT, {\"crossmnt\", \"\"}},\n\t{ NFSEXP_NOSUBTREECHECK, {\"no_subtree_check\", \"\"}},\n\t{ NFSEXP_NOAUTHNLM, {\"insecure_locks\", \"\"}},\n\t{ NFSEXP_V4ROOT, {\"v4root\", \"\"}},\n\t{ NFSEXP_PNFS, {\"pnfs\", \"\"}},\n\t{ 0, {\"\", \"\"}}\n};\n\nstatic void expkey_request(struct cache_detail *cd,\n\t\t\t   struct cache_head *h,\n\t\t\t   char **bpp, int *blen)\n{\n\t/* client fsidtype \\xfsid */\n\tstruct svc_expkey *ek = container_of(h, struct svc_expkey, h);\n\tchar type[5];\n\n\tqword_add(bpp, blen, ek->ek_client->name);\n\tsnprintf(type, 5, \"%d\", ek->ek_fsidtype);\n\tqword_add(bpp, blen, type);\n\tqword_addhex(bpp, blen, (char*)ek->ek_fsid, key_len(ek->ek_fsidtype));\n\t(*bpp)[-1] = '\\n';\n}"
  },
  {
    "function_name": "expkey_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
    "lines": "40-49",
    "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"nfsfh.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auth_domain_put",
          "args": [
            "key->ek_client"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&key->ek_path"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_NEGATIVE",
            "&key->h.flags"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CACHE_VALID",
            "&key->h.flags"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ref",
            "structsvc_expkey",
            "h.ref"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
  }
]