[
  {
    "function_name": "nfsd4_scsi_fence_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "379-387",
    "snippet": "static void\nnfsd4_scsi_fence_client(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct block_device *bdev = ls->ls_file->f_path.mnt->mnt_sb->s_bdev;\n\n\tbdev->bd_disk->fops->pr_ops->pr_preempt(bdev, NFSD_MDS_PR_KEY,\n\t\t\tnfsd4_scsi_pr_key(clp), 0, true);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [
      "#define NFSD_MDS_PR_KEY\t\t0x0100000000000000ULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev->bd_disk->fops->pr_ops->pr_preempt",
          "args": [
            "bdev",
            "NFSD_MDS_PR_KEY",
            "nfsd4_scsi_pr_key(clp)",
            "0",
            "true"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_scsi_pr_key",
          "args": [
            "clp"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_scsi_pr_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
          "lines": "299-302",
          "snippet": "static u64 nfsd4_scsi_pr_key(struct nfs4_client *clp)\n{\n\treturn ((u64)clp->cl_clientid.cl_boot << 32) | clp->cl_clientid.cl_id;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <scsi/scsi_common.h>",
            "#include <scsi/scsi_proto.h>",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/pr.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic u64 nfsd4_scsi_pr_key(struct nfs4_client *clp)\n{\n\treturn ((u64)clp->cl_clientid.cl_boot << 32) | clp->cl_clientid.cl_id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\n#define NFSD_MDS_PR_KEY\t\t0x0100000000000000ULL\n\nstatic void\nnfsd4_scsi_fence_client(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct block_device *bdev = ls->ls_file->f_path.mnt->mnt_sb->s_bdev;\n\n\tbdev->bd_disk->fops->pr_ops->pr_preempt(bdev, NFSD_MDS_PR_KEY,\n\t\t\tnfsd4_scsi_pr_key(clp), 0, true);\n}"
  },
  {
    "function_name": "nfsd4_scsi_proc_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "364-377",
    "snippet": "static __be32\nnfsd4_scsi_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\n\tnr_iomaps = nfsd4_scsi_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, 1 << inode->i_blkbits);\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\treturn nfsd4_block_commit_blocks(inode, lcp, iomaps, nr_iomaps);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_block_commit_blocks",
          "args": [
            "inode",
            "lcp",
            "iomaps",
            "nr_iomaps"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_commit_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
          "lines": "115-138",
          "snippet": "static __be32\nnfsd4_block_commit_blocks(struct inode *inode, struct nfsd4_layoutcommit *lcp,\n\t\tstruct iomap *iomaps, int nr_iomaps)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tint error;\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <scsi/scsi_common.h>",
            "#include <scsi/scsi_proto.h>",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/pr.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_commit_blocks(struct inode *inode, struct nfsd4_layoutcommit *lcp,\n\t\tstruct iomap *iomaps, int nr_iomaps)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tint error;\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "nr_iomaps"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_scsi_decode_layoutupdate",
          "args": [
            "lcp->lc_up_layout",
            "lcp->lc_up_len",
            "&iomaps",
            "1 << inode->i_blkbits"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_scsi_decode_layoutupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayoutxdr.c",
          "lines": "175-224",
          "snippet": "int\nnfsd4_scsi_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, expected, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\texpected = sizeof(__be32) + nr_iomaps * PNFS_SCSI_RANGE_SIZE;\n\tif (len != expected) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tu64 val;\n\n\t\tp = xdr_decode_hyper(p, &val);\n\t\tif (val & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset 0x%llx\\n\", __func__, val);\n\t\t\tgoto fail;\n\t\t}\n\t\tiomaps[i].offset = val;\n\n\t\tp = xdr_decode_hyper(p, &val);\n\t\tif (val & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length 0x%llx\\n\", __func__, val);\n\t\t\tgoto fail;\n\t\t}\n\t\tiomaps[i].length = val;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"blocklayoutxdr.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfs4.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\nint\nnfsd4_scsi_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, expected, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\texpected = sizeof(__be32) + nr_iomaps * PNFS_SCSI_RANGE_SIZE;\n\tif (len != expected) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, expected);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tu64 val;\n\n\t\tp = xdr_decode_hyper(p, &val);\n\t\tif (val & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset 0x%llx\\n\", __func__, val);\n\t\t\tgoto fail;\n\t\t}\n\t\tiomaps[i].offset = val;\n\n\t\tp = xdr_decode_hyper(p, &val);\n\t\tif (val & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length 0x%llx\\n\", __func__, val);\n\t\t\tgoto fail;\n\t\t}\n\t\tiomaps[i].length = val;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_scsi_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\n\tnr_iomaps = nfsd4_scsi_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, 1 << inode->i_blkbits);\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\treturn nfsd4_block_commit_blocks(inode, lcp, iomaps, nr_iomaps);\n}"
  },
  {
    "function_name": "nfsd4_scsi_proc_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "355-363",
    "snippet": "static __be32\nnfsd4_scsi_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (sb->s_bdev != sb->s_bdev->bd_contains)\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_scsi(sb, clp, gdp));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "nfsd4_block_get_device_info_scsi(sb, clp, gdp)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_block_get_device_info_scsi",
          "args": [
            "sb",
            "clp",
            "gdp"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_get_device_info_scsi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
          "lines": "304-353",
          "snippet": "static int\nnfsd4_block_get_device_info_scsi(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\tconst struct pr_ops *ops;\n\tint error;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SCSI;\n\tb->scsi.pr_key = nfsd4_scsi_pr_key(clp);\n\n\terror = nfsd4_scsi_identify_device(sb->s_bdev, b);\n\tif (error)\n\t\treturn error;\n\n\tops = sb->s_bdev->bd_disk->fops->pr_ops;\n\tif (!ops) {\n\t\tpr_err(\"pNFS: device %s does not support PRs.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_register(sb->s_bdev, 0, NFSD_MDS_PR_KEY, true);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to register key for device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_reserve(sb->s_bdev, NFSD_MDS_PR_KEY,\n\t\t\tPR_EXCLUSIVE_ACCESS_REG_ONLY, 0);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to reserve device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <scsi/scsi_common.h>",
            "#include <scsi/scsi_proto.h>",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/pr.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [
            "#define NFSD_MDS_PR_KEY\t\t0x0100000000000000ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\n#define NFSD_MDS_PR_KEY\t\t0x0100000000000000ULL\n\nstatic int\nnfsd4_block_get_device_info_scsi(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\tconst struct pr_ops *ops;\n\tint error;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SCSI;\n\tb->scsi.pr_key = nfsd4_scsi_pr_key(clp);\n\n\terror = nfsd4_scsi_identify_device(sb->s_bdev, b);\n\tif (error)\n\t\treturn error;\n\n\tops = sb->s_bdev->bd_disk->fops->pr_ops;\n\tif (!ops) {\n\t\tpr_err(\"pNFS: device %s does not support PRs.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_register(sb->s_bdev, 0, NFSD_MDS_PR_KEY, true);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to register key for device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_reserve(sb->s_bdev, NFSD_MDS_PR_KEY,\n\t\t\tPR_EXCLUSIVE_ACCESS_REG_ONLY, 0);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to reserve device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_scsi_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (sb->s_bdev != sb->s_bdev->bd_contains)\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_scsi(sb, clp, gdp));\n}"
  },
  {
    "function_name": "nfsd4_block_get_device_info_scsi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "304-353",
    "snippet": "static int\nnfsd4_block_get_device_info_scsi(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\tconst struct pr_ops *ops;\n\tint error;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SCSI;\n\tb->scsi.pr_key = nfsd4_scsi_pr_key(clp);\n\n\terror = nfsd4_scsi_identify_device(sb->s_bdev, b);\n\tif (error)\n\t\treturn error;\n\n\tops = sb->s_bdev->bd_disk->fops->pr_ops;\n\tif (!ops) {\n\t\tpr_err(\"pNFS: device %s does not support PRs.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_register(sb->s_bdev, 0, NFSD_MDS_PR_KEY, true);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to register key for device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_reserve(sb->s_bdev, NFSD_MDS_PR_KEY,\n\t\t\tPR_EXCLUSIVE_ACCESS_REG_ONLY, 0);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to reserve device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [
      "#define NFSD_MDS_PR_KEY\t\t0x0100000000000000ULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pNFS: failed to reserve device %s.\\n\"",
            "sb->s_id"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->pr_reserve",
          "args": [
            "sb->s_bdev",
            "NFSD_MDS_PR_KEY",
            "PR_EXCLUSIVE_ACCESS_REG_ONLY",
            "0"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pNFS: failed to register key for device %s.\\n\"",
            "sb->s_id"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->pr_register",
          "args": [
            "sb->s_bdev",
            "0",
            "NFSD_MDS_PR_KEY",
            "true"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pNFS: device %s does not support PRs.\\n\"",
            "sb->s_id"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_scsi_identify_device",
          "args": [
            "sb->s_bdev",
            "b"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_scsi_identify_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
          "lines": "209-291",
          "snippet": "static int nfsd4_scsi_identify_device(struct block_device *bdev,\n\t\tstruct pnfs_block_volume *b)\n{\n\tstruct request_queue *q = bdev->bd_disk->queue;\n\tstruct request *rq;\n\tsize_t bufflen = 252, len, id_len;\n\tu8 *buf, *d, type, assoc;\n\tint error;\n\n\tbuf = kzalloc(bufflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trq = blk_get_request(q, READ, GFP_KERNEL);\n\tif (IS_ERR(rq)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_free_buf;\n\t}\n\tblk_rq_set_block_pc(rq);\n\n\terror = blk_rq_map_kern(q, rq, buf, bufflen, GFP_KERNEL);\n\tif (error)\n\t\tgoto out_put_request;\n\n\trq->cmd[0] = INQUIRY;\n\trq->cmd[1] = 1;\n\trq->cmd[2] = 0x83;\n\trq->cmd[3] = bufflen >> 8;\n\trq->cmd[4] = bufflen & 0xff;\n\trq->cmd_len = COMMAND_SIZE(INQUIRY);\n\n\terror = blk_execute_rq(rq->q, NULL, rq, 1);\n\tif (error) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 failed with: %x\\n\",\n\t\t\trq->errors);\n\t\tgoto out_put_request;\n\t}\n\n\tlen = (buf[2] << 8) + buf[3] + 4;\n\tif (len > bufflen) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 response invalid (len = %zd)\\n\",\n\t\t\tlen);\n\t\tgoto out_put_request;\n\t}\n\n\td = buf + 4;\n\tfor (d = buf + 4; d < buf + len; d += id_len + 4) {\n\t\tid_len = d[3];\n\t\ttype = d[1] & 0xf;\n\t\tassoc = (d[1] >> 4) & 0x3;\n\n\t\t/*\n\t\t * We only care about a EUI-64 and NAA designator types\n\t\t * with LU association.\n\t\t */\n\t\tif (assoc != 0x00)\n\t\t\tcontinue;\n\t\tif (type != 0x02 && type != 0x03)\n\t\t\tcontinue;\n\t\tif (id_len != 8 && id_len != 12 && id_len != 16)\n\t\t\tcontinue;\n\n\t\tb->scsi.code_set = PS_CODE_SET_BINARY;\n\t\tb->scsi.designator_type = type == 0x02 ?\n\t\t\tPS_DESIGNATOR_EUI64 : PS_DESIGNATOR_NAA;\n\t\tb->scsi.designator_len = id_len;\n\t\tmemcpy(b->scsi.designator, d + 4, id_len);\n\n\t\t/*\n\t\t * If we found a 8 or 12 byte descriptor continue on to\n\t\t * see if a 16 byte one is available.  If we find a\n\t\t * 16 byte descriptor we're done.\n\t\t */\n\t\tif (id_len == 16)\n\t\t\tbreak;\n\t}\n\nout_put_request:\n\tblk_put_request(rq);\nout_free_buf:\n\tkfree(buf);\n\treturn error;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <scsi/scsi_common.h>",
            "#include <scsi/scsi_proto.h>",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/pr.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic int nfsd4_scsi_identify_device(struct block_device *bdev,\n\t\tstruct pnfs_block_volume *b)\n{\n\tstruct request_queue *q = bdev->bd_disk->queue;\n\tstruct request *rq;\n\tsize_t bufflen = 252, len, id_len;\n\tu8 *buf, *d, type, assoc;\n\tint error;\n\n\tbuf = kzalloc(bufflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trq = blk_get_request(q, READ, GFP_KERNEL);\n\tif (IS_ERR(rq)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_free_buf;\n\t}\n\tblk_rq_set_block_pc(rq);\n\n\terror = blk_rq_map_kern(q, rq, buf, bufflen, GFP_KERNEL);\n\tif (error)\n\t\tgoto out_put_request;\n\n\trq->cmd[0] = INQUIRY;\n\trq->cmd[1] = 1;\n\trq->cmd[2] = 0x83;\n\trq->cmd[3] = bufflen >> 8;\n\trq->cmd[4] = bufflen & 0xff;\n\trq->cmd_len = COMMAND_SIZE(INQUIRY);\n\n\terror = blk_execute_rq(rq->q, NULL, rq, 1);\n\tif (error) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 failed with: %x\\n\",\n\t\t\trq->errors);\n\t\tgoto out_put_request;\n\t}\n\n\tlen = (buf[2] << 8) + buf[3] + 4;\n\tif (len > bufflen) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 response invalid (len = %zd)\\n\",\n\t\t\tlen);\n\t\tgoto out_put_request;\n\t}\n\n\td = buf + 4;\n\tfor (d = buf + 4; d < buf + len; d += id_len + 4) {\n\t\tid_len = d[3];\n\t\ttype = d[1] & 0xf;\n\t\tassoc = (d[1] >> 4) & 0x3;\n\n\t\t/*\n\t\t * We only care about a EUI-64 and NAA designator types\n\t\t * with LU association.\n\t\t */\n\t\tif (assoc != 0x00)\n\t\t\tcontinue;\n\t\tif (type != 0x02 && type != 0x03)\n\t\t\tcontinue;\n\t\tif (id_len != 8 && id_len != 12 && id_len != 16)\n\t\t\tcontinue;\n\n\t\tb->scsi.code_set = PS_CODE_SET_BINARY;\n\t\tb->scsi.designator_type = type == 0x02 ?\n\t\t\tPS_DESIGNATOR_EUI64 : PS_DESIGNATOR_NAA;\n\t\tb->scsi.designator_len = id_len;\n\t\tmemcpy(b->scsi.designator, d + 4, id_len);\n\n\t\t/*\n\t\t * If we found a 8 or 12 byte descriptor continue on to\n\t\t * see if a 16 byte one is available.  If we find a\n\t\t * 16 byte descriptor we're done.\n\t\t */\n\t\tif (id_len == 16)\n\t\t\tbreak;\n\t}\n\nout_put_request:\n\tblk_put_request(rq);\nout_free_buf:\n\tkfree(buf);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_scsi_pr_key",
          "args": [
            "clp"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_scsi_pr_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
          "lines": "299-302",
          "snippet": "static u64 nfsd4_scsi_pr_key(struct nfs4_client *clp)\n{\n\treturn ((u64)clp->cl_clientid.cl_boot << 32) | clp->cl_clientid.cl_id;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <scsi/scsi_common.h>",
            "#include <scsi/scsi_proto.h>",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/pr.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic u64 nfsd4_scsi_pr_key(struct nfs4_client *clp)\n{\n\treturn ((u64)clp->cl_clientid.cl_boot << 32) | clp->cl_clientid.cl_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume)",
            "GFP_KERNEL"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\n#define NFSD_MDS_PR_KEY\t\t0x0100000000000000ULL\n\nstatic int\nnfsd4_block_get_device_info_scsi(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\tconst struct pr_ops *ops;\n\tint error;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SCSI;\n\tb->scsi.pr_key = nfsd4_scsi_pr_key(clp);\n\n\terror = nfsd4_scsi_identify_device(sb->s_bdev, b);\n\tif (error)\n\t\treturn error;\n\n\tops = sb->s_bdev->bd_disk->fops->pr_ops;\n\tif (!ops) {\n\t\tpr_err(\"pNFS: device %s does not support PRs.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_register(sb->s_bdev, 0, NFSD_MDS_PR_KEY, true);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to register key for device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\terror = ops->pr_reserve(sb->s_bdev, NFSD_MDS_PR_KEY,\n\t\t\tPR_EXCLUSIVE_ACCESS_REG_ONLY, 0);\n\tif (error) {\n\t\tpr_err(\"pNFS: failed to reserve device %s.\\n\",\n\t\t\tsb->s_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_scsi_pr_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "299-302",
    "snippet": "static u64 nfsd4_scsi_pr_key(struct nfs4_client *clp)\n{\n\treturn ((u64)clp->cl_clientid.cl_boot << 32) | clp->cl_clientid.cl_id;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic u64 nfsd4_scsi_pr_key(struct nfs4_client *clp)\n{\n\treturn ((u64)clp->cl_clientid.cl_boot << 32) | clp->cl_clientid.cl_id;\n}"
  },
  {
    "function_name": "nfsd4_scsi_identify_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "209-291",
    "snippet": "static int nfsd4_scsi_identify_device(struct block_device *bdev,\n\t\tstruct pnfs_block_volume *b)\n{\n\tstruct request_queue *q = bdev->bd_disk->queue;\n\tstruct request *rq;\n\tsize_t bufflen = 252, len, id_len;\n\tu8 *buf, *d, type, assoc;\n\tint error;\n\n\tbuf = kzalloc(bufflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trq = blk_get_request(q, READ, GFP_KERNEL);\n\tif (IS_ERR(rq)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_free_buf;\n\t}\n\tblk_rq_set_block_pc(rq);\n\n\terror = blk_rq_map_kern(q, rq, buf, bufflen, GFP_KERNEL);\n\tif (error)\n\t\tgoto out_put_request;\n\n\trq->cmd[0] = INQUIRY;\n\trq->cmd[1] = 1;\n\trq->cmd[2] = 0x83;\n\trq->cmd[3] = bufflen >> 8;\n\trq->cmd[4] = bufflen & 0xff;\n\trq->cmd_len = COMMAND_SIZE(INQUIRY);\n\n\terror = blk_execute_rq(rq->q, NULL, rq, 1);\n\tif (error) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 failed with: %x\\n\",\n\t\t\trq->errors);\n\t\tgoto out_put_request;\n\t}\n\n\tlen = (buf[2] << 8) + buf[3] + 4;\n\tif (len > bufflen) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 response invalid (len = %zd)\\n\",\n\t\t\tlen);\n\t\tgoto out_put_request;\n\t}\n\n\td = buf + 4;\n\tfor (d = buf + 4; d < buf + len; d += id_len + 4) {\n\t\tid_len = d[3];\n\t\ttype = d[1] & 0xf;\n\t\tassoc = (d[1] >> 4) & 0x3;\n\n\t\t/*\n\t\t * We only care about a EUI-64 and NAA designator types\n\t\t * with LU association.\n\t\t */\n\t\tif (assoc != 0x00)\n\t\t\tcontinue;\n\t\tif (type != 0x02 && type != 0x03)\n\t\t\tcontinue;\n\t\tif (id_len != 8 && id_len != 12 && id_len != 16)\n\t\t\tcontinue;\n\n\t\tb->scsi.code_set = PS_CODE_SET_BINARY;\n\t\tb->scsi.designator_type = type == 0x02 ?\n\t\t\tPS_DESIGNATOR_EUI64 : PS_DESIGNATOR_NAA;\n\t\tb->scsi.designator_len = id_len;\n\t\tmemcpy(b->scsi.designator, d + 4, id_len);\n\n\t\t/*\n\t\t * If we found a 8 or 12 byte descriptor continue on to\n\t\t * see if a 16 byte one is available.  If we find a\n\t\t * 16 byte descriptor we're done.\n\t\t */\n\t\tif (id_len == 16)\n\t\t\tbreak;\n\t}\n\nout_put_request:\n\tblk_put_request(rq);\nout_free_buf:\n\tkfree(buf);\n\treturn error;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_put_request",
          "args": [
            "rq"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "b->scsi.designator",
            "d + 4",
            "id_len"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pNFS: INQUIRY 0x83 response invalid (len = %zd)\\n\"",
            "len"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pNFS: INQUIRY 0x83 failed with: %x\\n\"",
            "rq->errors"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_execute_rq",
          "args": [
            "rq->q",
            "NULL",
            "rq",
            "1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMMAND_SIZE",
          "args": [
            "INQUIRY"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_map_kern",
          "args": [
            "q",
            "rq",
            "buf",
            "bufflen",
            "GFP_KERNEL"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_rq_set_block_pc",
          "args": [
            "rq"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rq"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_get_request",
          "args": [
            "q",
            "READ",
            "GFP_KERNEL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "bufflen",
            "GFP_KERNEL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic int nfsd4_scsi_identify_device(struct block_device *bdev,\n\t\tstruct pnfs_block_volume *b)\n{\n\tstruct request_queue *q = bdev->bd_disk->queue;\n\tstruct request *rq;\n\tsize_t bufflen = 252, len, id_len;\n\tu8 *buf, *d, type, assoc;\n\tint error;\n\n\tbuf = kzalloc(bufflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trq = blk_get_request(q, READ, GFP_KERNEL);\n\tif (IS_ERR(rq)) {\n\t\terror = -ENOMEM;\n\t\tgoto out_free_buf;\n\t}\n\tblk_rq_set_block_pc(rq);\n\n\terror = blk_rq_map_kern(q, rq, buf, bufflen, GFP_KERNEL);\n\tif (error)\n\t\tgoto out_put_request;\n\n\trq->cmd[0] = INQUIRY;\n\trq->cmd[1] = 1;\n\trq->cmd[2] = 0x83;\n\trq->cmd[3] = bufflen >> 8;\n\trq->cmd[4] = bufflen & 0xff;\n\trq->cmd_len = COMMAND_SIZE(INQUIRY);\n\n\terror = blk_execute_rq(rq->q, NULL, rq, 1);\n\tif (error) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 failed with: %x\\n\",\n\t\t\trq->errors);\n\t\tgoto out_put_request;\n\t}\n\n\tlen = (buf[2] << 8) + buf[3] + 4;\n\tif (len > bufflen) {\n\t\tpr_err(\"pNFS: INQUIRY 0x83 response invalid (len = %zd)\\n\",\n\t\t\tlen);\n\t\tgoto out_put_request;\n\t}\n\n\td = buf + 4;\n\tfor (d = buf + 4; d < buf + len; d += id_len + 4) {\n\t\tid_len = d[3];\n\t\ttype = d[1] & 0xf;\n\t\tassoc = (d[1] >> 4) & 0x3;\n\n\t\t/*\n\t\t * We only care about a EUI-64 and NAA designator types\n\t\t * with LU association.\n\t\t */\n\t\tif (assoc != 0x00)\n\t\t\tcontinue;\n\t\tif (type != 0x02 && type != 0x03)\n\t\t\tcontinue;\n\t\tif (id_len != 8 && id_len != 12 && id_len != 16)\n\t\t\tcontinue;\n\n\t\tb->scsi.code_set = PS_CODE_SET_BINARY;\n\t\tb->scsi.designator_type = type == 0x02 ?\n\t\t\tPS_DESIGNATOR_EUI64 : PS_DESIGNATOR_NAA;\n\t\tb->scsi.designator_len = id_len;\n\t\tmemcpy(b->scsi.designator, d + 4, id_len);\n\n\t\t/*\n\t\t * If we found a 8 or 12 byte descriptor continue on to\n\t\t * see if a 16 byte one is available.  If we find a\n\t\t * 16 byte descriptor we're done.\n\t\t */\n\t\tif (id_len == 16)\n\t\t\tbreak;\n\t}\n\nout_put_request:\n\tblk_put_request(rq);\nout_free_buf:\n\tkfree(buf);\n\treturn error;\n}"
  },
  {
    "function_name": "nfsd4_block_proc_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "173-186",
    "snippet": "static __be32\nnfsd4_block_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\n\tnr_iomaps = nfsd4_block_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, 1 << inode->i_blkbits);\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\treturn nfsd4_block_commit_blocks(inode, lcp, iomaps, nr_iomaps);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_block_commit_blocks",
          "args": [
            "inode",
            "lcp",
            "iomaps",
            "nr_iomaps"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_commit_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
          "lines": "115-138",
          "snippet": "static __be32\nnfsd4_block_commit_blocks(struct inode *inode, struct nfsd4_layoutcommit *lcp,\n\t\tstruct iomap *iomaps, int nr_iomaps)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tint error;\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <scsi/scsi_common.h>",
            "#include <scsi/scsi_proto.h>",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/pr.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_commit_blocks(struct inode *inode, struct nfsd4_layoutcommit *lcp,\n\t\tstruct iomap *iomaps, int nr_iomaps)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tint error;\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "nr_iomaps"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_block_decode_layoutupdate",
          "args": [
            "lcp->lc_up_layout",
            "lcp->lc_up_len",
            "&iomaps",
            "1 << inode->i_blkbits"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_decode_layoutupdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayoutxdr.c",
          "lines": "103-173",
          "snippet": "int\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\tlen -= sizeof(u32);\n\tif (len % PNFS_BLOCK_EXTENT_SIZE) {\n\t\tdprintk(\"%s: extent array invalid: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\tif (nr_iomaps != len / PNFS_BLOCK_EXTENT_SIZE) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, nr_iomaps);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tstruct pnfs_block_extent bex;\n\n\t\tmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\n\t\tp += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\n\n\t\tp = xdr_decode_hyper(p, &bex.foff);\n\t\tif (bex.foff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset 0x%llx\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.len);\n\t\tif (bex.len & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length 0x%llx\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.soff);\n\t\tif (bex.soff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned disk offset 0x%llx\\n\",\n\t\t\t\t__func__, bex.soff);\n\t\t\tgoto fail;\n\t\t}\n\t\tbex.es = be32_to_cpup(p++);\n\t\tif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\n\t\t\tdprintk(\"%s: incorrect extent state %d\\n\",\n\t\t\t\t__func__, bex.es);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tiomaps[i].offset = bex.foff;\n\t\tiomaps[i].length = bex.len;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"blocklayoutxdr.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfs4.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayoutxdr.h\"\n#include \"nfsd.h\"\n#include <linux/nfs4.h>\n#include <linux/exportfs.h>\n#include <linux/sunrpc/svc.h>\n\nint\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\n\t\tu32 block_size)\n{\n\tstruct iomap *iomaps;\n\tu32 nr_iomaps, i;\n\n\tif (len < sizeof(u32)) {\n\t\tdprintk(\"%s: extent array too small: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\tlen -= sizeof(u32);\n\tif (len % PNFS_BLOCK_EXTENT_SIZE) {\n\t\tdprintk(\"%s: extent array invalid: %u\\n\", __func__, len);\n\t\treturn -EINVAL;\n\t}\n\n\tnr_iomaps = be32_to_cpup(p++);\n\tif (nr_iomaps != len / PNFS_BLOCK_EXTENT_SIZE) {\n\t\tdprintk(\"%s: extent array size mismatch: %u/%u\\n\",\n\t\t\t__func__, len, nr_iomaps);\n\t\treturn -EINVAL;\n\t}\n\n\tiomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\n\tif (!iomaps) {\n\t\tdprintk(\"%s: failed to allocate extent array\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < nr_iomaps; i++) {\n\t\tstruct pnfs_block_extent bex;\n\n\t\tmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\n\t\tp += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\n\n\t\tp = xdr_decode_hyper(p, &bex.foff);\n\t\tif (bex.foff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned offset 0x%llx\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.len);\n\t\tif (bex.len & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned length 0x%llx\\n\",\n\t\t\t\t__func__, bex.foff);\n\t\t\tgoto fail;\n\t\t}\n\t\tp = xdr_decode_hyper(p, &bex.soff);\n\t\tif (bex.soff & (block_size - 1)) {\n\t\t\tdprintk(\"%s: unaligned disk offset 0x%llx\\n\",\n\t\t\t\t__func__, bex.soff);\n\t\t\tgoto fail;\n\t\t}\n\t\tbex.es = be32_to_cpup(p++);\n\t\tif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\n\t\t\tdprintk(\"%s: incorrect extent state %d\\n\",\n\t\t\t\t__func__, bex.es);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tiomaps[i].offset = bex.foff;\n\t\tiomaps[i].length = bex.len;\n\t}\n\n\t*iomapp = iomaps;\n\treturn nr_iomaps;\nfail:\n\tkfree(iomaps);\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_proc_layoutcommit(struct inode *inode,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tstruct iomap *iomaps;\n\tint nr_iomaps;\n\n\tnr_iomaps = nfsd4_block_decode_layoutupdate(lcp->lc_up_layout,\n\t\t\tlcp->lc_up_len, &iomaps, 1 << inode->i_blkbits);\n\tif (nr_iomaps < 0)\n\t\treturn nfserrno(nr_iomaps);\n\n\treturn nfsd4_block_commit_blocks(inode, lcp, iomaps, nr_iomaps);\n}"
  },
  {
    "function_name": "nfsd4_block_proc_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "163-171",
    "snippet": "static __be32\nnfsd4_block_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (sb->s_bdev != sb->s_bdev->bd_contains)\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_simple(sb, gdp));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "nfsd4_block_get_device_info_simple(sb, gdp)"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_block_get_device_info_simple",
          "args": [
            "sb",
            "gdp"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_block_get_device_info_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
          "lines": "141-161",
          "snippet": "static int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"blocklayoutxdr.h\"",
            "#include <scsi/scsi_common.h>",
            "#include <scsi/scsi_proto.h>",
            "#include <linux/nfsd/debug.h>",
            "#include <linux/pr.h>",
            "#include <linux/slab.h>",
            "#include <linux/genhd.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_proc_getdeviceinfo(struct super_block *sb,\n\t\tstruct nfs4_client *clp,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tif (sb->s_bdev != sb->s_bdev->bd_contains)\n\t\treturn nfserr_inval;\n\treturn nfserrno(nfsd4_block_get_device_info_simple(sb, gdp));\n}"
  },
  {
    "function_name": "nfsd4_block_get_device_info_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "141-161",
    "snippet": "static int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb->s_export_op->get_uuid",
          "args": [
            "sb",
            "b->simple.sig",
            "&b->simple.sig_len",
            "&b->simple.offset"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume)",
            "GFP_KERNEL"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic int\nnfsd4_block_get_device_info_simple(struct super_block *sb,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tstruct pnfs_block_deviceaddr *dev;\n\tstruct pnfs_block_volume *b;\n\n\tdev = kzalloc(sizeof(struct pnfs_block_deviceaddr) +\n\t\t      sizeof(struct pnfs_block_volume), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tgdp->gd_device = dev;\n\n\tdev->nr_volumes = 1;\n\tb = &dev->volumes[0];\n\n\tb->type = PNFS_BLOCK_VOLUME_SIMPLE;\n\tb->simple.sig_len = PNFS_BLOCK_UUID_LEN;\n\treturn sb->s_export_op->get_uuid(sb, b->simple.sig, &b->simple.sig_len,\n\t\t\t&b->simple.offset);\n}"
  },
  {
    "function_name": "nfsd4_block_commit_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "115-138",
    "snippet": "static __be32\nnfsd4_block_commit_blocks(struct inode *inode, struct nfsd4_layoutcommit *lcp,\n\t\tstruct iomap *iomaps, int nr_iomaps)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tint error;\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "error"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iomaps"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_export_op->commit_blocks",
          "args": [
            "inode",
            "iomaps",
            "nr_iomaps",
            "&iattr"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fs_time",
          "args": [
            "inode->i_sb"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&lcp->lc_mtime",
            "&inode->i_mtime"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_commit_blocks(struct inode *inode, struct nfsd4_layoutcommit *lcp,\n\t\tstruct iomap *iomaps, int nr_iomaps)\n{\n\tloff_t new_size = lcp->lc_last_wr + 1;\n\tstruct iattr iattr = { .ia_valid = 0 };\n\tint error;\n\n\tif (lcp->lc_mtime.tv_nsec == UTIME_NOW ||\n\t    timespec_compare(&lcp->lc_mtime, &inode->i_mtime) < 0)\n\t\tlcp->lc_mtime = current_fs_time(inode->i_sb);\n\tiattr.ia_valid |= ATTR_ATIME | ATTR_CTIME | ATTR_MTIME;\n\tiattr.ia_atime = iattr.ia_ctime = iattr.ia_mtime = lcp->lc_mtime;\n\n\tif (new_size > i_size_read(inode)) {\n\t\tiattr.ia_valid |= ATTR_SIZE;\n\t\tiattr.ia_size = new_size;\n\t}\n\n\terror = inode->i_sb->s_export_op->commit_blocks(inode, iomaps,\n\t\t\tnr_iomaps, &iattr);\n\tkfree(iomaps);\n\treturn nfserrno(error);\n}"
  },
  {
    "function_name": "nfsd4_block_proc_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/blocklayout.c",
    "lines": "19-113",
    "snippet": "static __be32\nnfsd4_block_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,\n\t\tstruct nfsd4_layoutget *args)\n{\n\tstruct nfsd4_layout_seg *seg = &args->lg_seg;\n\tstruct super_block *sb = inode->i_sb;\n\tu32 block_size = (1 << inode->i_blkbits);\n\tstruct pnfs_block_extent *bex;\n\tstruct iomap iomap;\n\tu32 device_generation = 0;\n\tint error;\n\n\tif (seg->offset & (block_size - 1)) {\n\t\tdprintk(\"pnfsd: I/O misaligned\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\t/*\n\t * Some clients barf on non-zero block numbers for NONE or INVALID\n\t * layouts, so make sure to zero the whole structure.\n\t */\n\terror = -ENOMEM;\n\tbex = kzalloc(sizeof(*bex), GFP_KERNEL);\n\tif (!bex)\n\t\tgoto out_error;\n\targs->lg_content = bex;\n\n\terror = sb->s_export_op->map_blocks(inode, seg->offset, seg->length,\n\t\t\t\t\t    &iomap, seg->iomode != IOMODE_READ,\n\t\t\t\t\t    &device_generation);\n\tif (error) {\n\t\tif (error == -ENXIO)\n\t\t\tgoto out_layoutunavailable;\n\t\tgoto out_error;\n\t}\n\n\tif (iomap.length < args->lg_minlength) {\n\t\tdprintk(\"pnfsd: extent smaller than minlength\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (seg->iomode == IOMODE_READ)\n\t\t\tbex->es = PNFS_BLOCK_READ_DATA;\n\t\telse\n\t\t\tbex->es = PNFS_BLOCK_READWRITE_DATA;\n\t\tbex->soff = (iomap.blkno << 9);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tif (seg->iomode & IOMODE_RW) {\n\t\t\t/*\n\t\t\t * Crack monkey special case from section 2.3.1.\n\t\t\t */\n\t\t\tif (args->lg_minlength == 0) {\n\t\t\t\tdprintk(\"pnfsd: no soup for you!\\n\");\n\t\t\t\tgoto out_layoutunavailable;\n\t\t\t}\n\n\t\t\tbex->es = PNFS_BLOCK_INVALID_DATA;\n\t\t\tbex->soff = (iomap.blkno << 9);\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_HOLE:\n\t\tif (seg->iomode == IOMODE_READ) {\n\t\t\tbex->es = PNFS_BLOCK_NONE_DATA;\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_DELALLOC:\n\tdefault:\n\t\tWARN(1, \"pnfsd: filesystem returned %d extent\\n\", iomap.type);\n\t\tgoto out_layoutunavailable;\n\t}\n\n\terror = nfsd4_set_deviceid(&bex->vol_id, fhp, device_generation);\n\tif (error)\n\t\tgoto out_error;\n\tbex->foff = iomap.offset;\n\tbex->len = iomap.length;\n\n\tseg->offset = iomap.offset;\n\tseg->length = iomap.length;\n\n\tdprintk(\"GET: 0x%llx:0x%llx %d\\n\", bex->foff, bex->len, bex->es);\n\treturn 0;\n\nout_error:\n\tseg->length = 0;\n\treturn nfserrno(error);\nout_layoutunavailable:\n\tseg->length = 0;\n\treturn nfserr_layoutunavailable;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"blocklayoutxdr.h\"",
      "#include <scsi/scsi_common.h>",
      "#include <scsi/scsi_proto.h>",
      "#include <linux/nfsd/debug.h>",
      "#include <linux/pr.h>",
      "#include <linux/slab.h>",
      "#include <linux/genhd.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "error"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"GET: 0x%llx:0x%llx %d\\n\"",
            "bex->foff",
            "bex->len",
            "bex->es"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_set_deviceid",
          "args": [
            "&bex->vol_id",
            "fhp",
            "device_generation"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "107-121",
          "snippet": "int\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nint\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"pnfsd: filesystem returned %d extent\\n\"",
            "iomap.type"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: no soup for you!\\n\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: extent smaller than minlength\\n\""
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_export_op->map_blocks",
          "args": [
            "inode",
            "seg->offset",
            "seg->length",
            "&iomap",
            "seg->iomode != IOMODE_READ",
            "&device_generation"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bex)",
            "GFP_KERNEL"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"pnfsd: I/O misaligned\\n\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"blocklayoutxdr.h\"\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <linux/nfsd/debug.h>\n#include <linux/pr.h>\n#include <linux/slab.h>\n#include <linux/genhd.h>\n#include <linux/exportfs.h>\n\nstatic __be32\nnfsd4_block_proc_layoutget(struct inode *inode, const struct svc_fh *fhp,\n\t\tstruct nfsd4_layoutget *args)\n{\n\tstruct nfsd4_layout_seg *seg = &args->lg_seg;\n\tstruct super_block *sb = inode->i_sb;\n\tu32 block_size = (1 << inode->i_blkbits);\n\tstruct pnfs_block_extent *bex;\n\tstruct iomap iomap;\n\tu32 device_generation = 0;\n\tint error;\n\n\tif (seg->offset & (block_size - 1)) {\n\t\tdprintk(\"pnfsd: I/O misaligned\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\t/*\n\t * Some clients barf on non-zero block numbers for NONE or INVALID\n\t * layouts, so make sure to zero the whole structure.\n\t */\n\terror = -ENOMEM;\n\tbex = kzalloc(sizeof(*bex), GFP_KERNEL);\n\tif (!bex)\n\t\tgoto out_error;\n\targs->lg_content = bex;\n\n\terror = sb->s_export_op->map_blocks(inode, seg->offset, seg->length,\n\t\t\t\t\t    &iomap, seg->iomode != IOMODE_READ,\n\t\t\t\t\t    &device_generation);\n\tif (error) {\n\t\tif (error == -ENXIO)\n\t\t\tgoto out_layoutunavailable;\n\t\tgoto out_error;\n\t}\n\n\tif (iomap.length < args->lg_minlength) {\n\t\tdprintk(\"pnfsd: extent smaller than minlength\\n\");\n\t\tgoto out_layoutunavailable;\n\t}\n\n\tswitch (iomap.type) {\n\tcase IOMAP_MAPPED:\n\t\tif (seg->iomode == IOMODE_READ)\n\t\t\tbex->es = PNFS_BLOCK_READ_DATA;\n\t\telse\n\t\t\tbex->es = PNFS_BLOCK_READWRITE_DATA;\n\t\tbex->soff = (iomap.blkno << 9);\n\t\tbreak;\n\tcase IOMAP_UNWRITTEN:\n\t\tif (seg->iomode & IOMODE_RW) {\n\t\t\t/*\n\t\t\t * Crack monkey special case from section 2.3.1.\n\t\t\t */\n\t\t\tif (args->lg_minlength == 0) {\n\t\t\t\tdprintk(\"pnfsd: no soup for you!\\n\");\n\t\t\t\tgoto out_layoutunavailable;\n\t\t\t}\n\n\t\t\tbex->es = PNFS_BLOCK_INVALID_DATA;\n\t\t\tbex->soff = (iomap.blkno << 9);\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_HOLE:\n\t\tif (seg->iomode == IOMODE_READ) {\n\t\t\tbex->es = PNFS_BLOCK_NONE_DATA;\n\t\t\tbreak;\n\t\t}\n\t\t/*FALLTHRU*/\n\tcase IOMAP_DELALLOC:\n\tdefault:\n\t\tWARN(1, \"pnfsd: filesystem returned %d extent\\n\", iomap.type);\n\t\tgoto out_layoutunavailable;\n\t}\n\n\terror = nfsd4_set_deviceid(&bex->vol_id, fhp, device_generation);\n\tif (error)\n\t\tgoto out_error;\n\tbex->foff = iomap.offset;\n\tbex->len = iomap.length;\n\n\tseg->offset = iomap.offset;\n\tseg->length = iomap.length;\n\n\tdprintk(\"GET: 0x%llx:0x%llx %d\\n\", bex->foff, bex->len, bex->es);\n\treturn 0;\n\nout_error:\n\tseg->length = 0;\n\treturn nfserrno(error);\nout_layoutunavailable:\n\tseg->length = 0;\n\treturn nfserr_layoutunavailable;\n}"
  }
]