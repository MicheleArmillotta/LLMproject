[
  {
    "function_name": "nfsd_reply_cache_stats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "606-609",
    "snippet": "int nfsd_reply_cache_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, nfsd_reply_cache_stats_show, NULL);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "nfsd_reply_cache_stats_show",
            "NULL"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nint nfsd_reply_cache_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, nfsd_reply_cache_stats_show, NULL);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_stats_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "590-604",
    "snippet": "static int nfsd_reply_cache_stats_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"max entries:           %u\\n\", max_drc_entries);\n\tseq_printf(m, \"num entries:           %u\\n\",\n\t\t\tatomic_read(&num_drc_entries));\n\tseq_printf(m, \"hash buckets:          %u\\n\", 1 << maskbits);\n\tseq_printf(m, \"mem usage:             %u\\n\", drc_mem_usage);\n\tseq_printf(m, \"cache hits:            %u\\n\", nfsdstats.rchits);\n\tseq_printf(m, \"cache misses:          %u\\n\", nfsdstats.rcmisses);\n\tseq_printf(m, \"not cached:            %u\\n\", nfsdstats.rcnocache);\n\tseq_printf(m, \"payload misses:        %u\\n\", payload_misses);\n\tseq_printf(m, \"longest chain len:     %u\\n\", longest_chain);\n\tseq_printf(m, \"cachesize at longest:  %u\\n\", longest_chain_cachesize);\n\treturn 0;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tmax_drc_entries;",
      "static unsigned int\t\tmaskbits;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tpayload_misses;",
      "static unsigned int\t\tdrc_mem_usage;",
      "static unsigned int\t\tlongest_chain;",
      "static unsigned int\t\tlongest_chain_cachesize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"cachesize at longest:  %u\\n\"",
            "longest_chain_cachesize"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"longest chain len:     %u\\n\"",
            "longest_chain"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"payload misses:        %u\\n\"",
            "payload_misses"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"not cached:            %u\\n\"",
            "nfsdstats.rcnocache"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"cache misses:          %u\\n\"",
            "nfsdstats.rcmisses"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"cache hits:            %u\\n\"",
            "nfsdstats.rchits"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"mem usage:             %u\\n\"",
            "drc_mem_usage"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"hash buckets:          %u\\n\"",
            "1 << maskbits"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"num entries:           %u\\n\"",
            "atomic_read(&num_drc_entries)"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"max entries:           %u\\n\"",
            "max_drc_entries"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic unsigned int\t\tmaskbits;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tpayload_misses;\nstatic unsigned int\t\tdrc_mem_usage;\nstatic unsigned int\t\tlongest_chain;\nstatic unsigned int\t\tlongest_chain_cachesize;\n\nstatic int nfsd_reply_cache_stats_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"max entries:           %u\\n\", max_drc_entries);\n\tseq_printf(m, \"num entries:           %u\\n\",\n\t\t\tatomic_read(&num_drc_entries));\n\tseq_printf(m, \"hash buckets:          %u\\n\", 1 << maskbits);\n\tseq_printf(m, \"mem usage:             %u\\n\", drc_mem_usage);\n\tseq_printf(m, \"cache hits:            %u\\n\", nfsdstats.rchits);\n\tseq_printf(m, \"cache misses:          %u\\n\", nfsdstats.rcmisses);\n\tseq_printf(m, \"not cached:            %u\\n\", nfsdstats.rcnocache);\n\tseq_printf(m, \"payload misses:        %u\\n\", payload_misses);\n\tseq_printf(m, \"longest chain len:     %u\\n\", longest_chain);\n\tseq_printf(m, \"cachesize at longest:  %u\\n\", longest_chain_cachesize);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd_cache_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "570-583",
    "snippet": "static int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char*)vec->iov_base + vec->iov_len",
            "data->iov_base",
            "data->iov_len"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\"",
            "data->iov_len"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);\n\nstatic int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}"
  },
  {
    "function_name": "nfsd_cache_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "509-563",
    "snippet": "void\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static unsigned int\t\tdrc_mem_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SECURE",
            "&rqstp->rq_flags"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_put_end",
          "args": [
            "b",
            "rp"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "lru_put_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "219-224",
          "snippet": "static void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free",
          "args": [
            "b",
            "rp"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "148-154",
          "snippet": "static void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cachv->iov_base",
            "statp",
            "bufsize"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "bufsize",
            "GFP_KERNEL"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd: RC_REPLSTAT/reply len %d!\\n\"",
            "len"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_hash",
          "args": [
            "rp->c_xid"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "115-119",
          "snippet": "static u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmaskbits;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmaskbits;\n\nstatic u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_mem_usage;\n\nvoid\nnfsd_cache_update(struct svc_rqst *rqstp, int cachetype, __be32 *statp)\n{\n\tstruct svc_cacherep *rp = rqstp->rq_cacherep;\n\tstruct kvec\t*resv = &rqstp->rq_res.head[0], *cachv;\n\tu32\t\thash;\n\tstruct nfsd_drc_bucket *b;\n\tint\t\tlen;\n\tsize_t\t\tbufsize = 0;\n\n\tif (!rp)\n\t\treturn;\n\n\thash = nfsd_cache_hash(rp->c_xid);\n\tb = &drc_hashtbl[hash];\n\n\tlen = resv->iov_len - ((char*)statp - (char*)resv->iov_base);\n\tlen >>= 2;\n\n\t/* Don't cache excessive amounts of data and XDR failures */\n\tif (!statp || len > (256 >> 2)) {\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\n\tswitch (cachetype) {\n\tcase RC_REPLSTAT:\n\t\tif (len != 1)\n\t\t\tprintk(\"nfsd: RC_REPLSTAT/reply len %d!\\n\",len);\n\t\trp->c_replstat = *statp;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tcachv = &rp->c_replvec;\n\t\tbufsize = len << 2;\n\t\tcachv->iov_base = kmalloc(bufsize, GFP_KERNEL);\n\t\tif (!cachv->iov_base) {\n\t\t\tnfsd_reply_cache_free(b, rp);\n\t\t\treturn;\n\t\t}\n\t\tcachv->iov_len = bufsize;\n\t\tmemcpy(cachv->iov_base, statp, bufsize);\n\t\tbreak;\n\tcase RC_NOCACHE:\n\t\tnfsd_reply_cache_free(b, rp);\n\t\treturn;\n\t}\n\tspin_lock(&b->cache_lock);\n\tdrc_mem_usage += bufsize;\n\tlru_put_end(b, rp);\n\trp->c_secure = test_bit(RQ_SECURE, &rqstp->rq_flags);\n\trp->c_type = cachetype;\n\trp->c_state = RC_DONE;\n\tspin_unlock(&b->cache_lock);\n\treturn;\n}"
  },
  {
    "function_name": "nfsd_cache_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "380-491",
    "snippet": "int\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tdrc_mem_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "135-146",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"nfsd: bad repcache type %d\\n\"",
            "rp->c_type"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_append",
          "args": [
            "rqstp",
            "&rp->c_replvec"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "570-583",
          "snippet": "static int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic int\tnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);\n\nstatic int\nnfsd_cache_append(struct svc_rqst *rqstp, struct kvec *data)\n{\n\tstruct kvec\t*vec = &rqstp->rq_res.head[0];\n\n\tif (vec->iov_len + data->iov_len > PAGE_SIZE) {\n\t\tprintk(KERN_WARNING \"nfsd: cached reply too large (%Zd).\\n\",\n\t\t\t\tdata->iov_len);\n\t\treturn 0;\n\t}\n\tmemcpy((char*)vec->iov_base + vec->iov_len, data->iov_base, data->iov_len);\n\tvec->iov_len += data->iov_len;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_putu32",
          "args": [
            "&rqstp->rq_res.head[0]",
            "rp->c_replstat"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SECURE",
            "&rqstp->rq_flags"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_put_end",
          "args": [
            "b",
            "rp"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "lru_put_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "219-224",
          "snippet": "static void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rp->c_replvec.iov_base"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_set_port",
          "args": [
            "(struct sockaddr *)&rp->c_addr",
            "rpc_get_port(svc_addr(rqstp))"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_get_port",
          "args": [
            "svc_addr(rqstp)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_copy_addr",
          "args": [
            "(struct sockaddr *)&rp->c_addr",
            "svc_addr(rqstp)"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: unable to allocate DRC entry!\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rp"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_search",
          "args": [
            "b",
            "rqstp",
            "csum"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "343-371",
          "snippet": "static struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tlongest_chain;",
            "static unsigned int\t\tlongest_chain_cachesize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tlongest_chain;\nstatic unsigned int\t\tlongest_chain_cachesize;\n\nstatic struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_bucket",
          "args": [
            "b"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "prune_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "226-246",
          "snippet": "static long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmax_drc_entries;",
            "static atomic_t\t\t\tnum_drc_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic atomic_t\t\t\tnum_drc_entries;\n\nstatic long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&num_drc_entries"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rp"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_alloc",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "121-133",
          "snippet": "static struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\n\nstatic struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cache_csum",
          "args": [
            "rqstp"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "284-312",
          "snippet": "static __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cache_hash",
          "args": [
            "xid"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "115-119",
          "snippet": "static u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmaskbits;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmaskbits;\n\nstatic u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nint\nnfsd_cache_lookup(struct svc_rqst *rqstp)\n{\n\tstruct svc_cacherep\t*rp, *found;\n\t__be32\t\t\txid = rqstp->rq_xid;\n\tu32\t\t\tproto =  rqstp->rq_prot,\n\t\t\t\tvers = rqstp->rq_vers,\n\t\t\t\tproc = rqstp->rq_proc;\n\t__wsum\t\t\tcsum;\n\tu32 hash = nfsd_cache_hash(xid);\n\tstruct nfsd_drc_bucket *b = &drc_hashtbl[hash];\n\tunsigned long\t\tage;\n\tint type = rqstp->rq_cachetype;\n\tint rtn = RC_DOIT;\n\n\trqstp->rq_cacherep = NULL;\n\tif (type == RC_NOCACHE) {\n\t\tnfsdstats.rcnocache++;\n\t\treturn rtn;\n\t}\n\n\tcsum = nfsd_cache_csum(rqstp);\n\n\t/*\n\t * Since the common case is a cache miss followed by an insert,\n\t * preallocate an entry.\n\t */\n\trp = nfsd_reply_cache_alloc();\n\tspin_lock(&b->cache_lock);\n\tif (likely(rp)) {\n\t\tatomic_inc(&num_drc_entries);\n\t\tdrc_mem_usage += sizeof(*rp);\n\t}\n\n\t/* go ahead and prune the cache */\n\tprune_bucket(b);\n\n\tfound = nfsd_cache_search(b, rqstp, csum);\n\tif (found) {\n\t\tif (likely(rp))\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\trp = found;\n\t\tgoto found_entry;\n\t}\n\n\tif (!rp) {\n\t\tdprintk(\"nfsd: unable to allocate DRC entry!\\n\");\n\t\tgoto out;\n\t}\n\n\tnfsdstats.rcmisses++;\n\trqstp->rq_cacherep = rp;\n\trp->c_state = RC_INPROG;\n\trp->c_xid = xid;\n\trp->c_proc = proc;\n\trpc_copy_addr((struct sockaddr *)&rp->c_addr, svc_addr(rqstp));\n\trpc_set_port((struct sockaddr *)&rp->c_addr, rpc_get_port(svc_addr(rqstp)));\n\trp->c_prot = proto;\n\trp->c_vers = vers;\n\trp->c_len = rqstp->rq_arg.len;\n\trp->c_csum = csum;\n\n\tlru_put_end(b, rp);\n\n\t/* release any buffer */\n\tif (rp->c_type == RC_REPLBUFF) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t\trp->c_replvec.iov_base = NULL;\n\t}\n\trp->c_type = RC_NOCACHE;\n out:\n\tspin_unlock(&b->cache_lock);\n\treturn rtn;\n\nfound_entry:\n\tnfsdstats.rchits++;\n\t/* We found a matching entry which is either in progress or done. */\n\tage = jiffies - rp->c_timestamp;\n\tlru_put_end(b, rp);\n\n\trtn = RC_DROPIT;\n\t/* Request being processed or excessive rexmits */\n\tif (rp->c_state == RC_INPROG || age < RC_DELAY)\n\t\tgoto out;\n\n\t/* From the hall of fame of impractical attacks:\n\t * Is this a user who tries to snoop on the cache? */\n\trtn = RC_DOIT;\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && rp->c_secure)\n\t\tgoto out;\n\n\t/* Compose RPC reply header */\n\tswitch (rp->c_type) {\n\tcase RC_NOCACHE:\n\t\tbreak;\n\tcase RC_REPLSTAT:\n\t\tsvc_putu32(&rqstp->rq_res.head[0], rp->c_replstat);\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tcase RC_REPLBUFF:\n\t\tif (!nfsd_cache_append(rqstp, &rp->c_replvec))\n\t\t\tgoto out;\t/* should not happen */\n\t\trtn = RC_REPLY;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad repcache type %d\\n\", rp->c_type);\n\t\tnfsd_reply_cache_free_locked(rp);\n\t}\n\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd_cache_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "343-371",
    "snippet": "static struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tlongest_chain;",
      "static unsigned int\t\tlongest_chain_cachesize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "longest_chain_cachesize",
            "atomic_read(&num_drc_entries)"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_match",
          "args": [
            "rqstp",
            "csum",
            "rp"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "314-336",
          "snippet": "static bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tpayload_misses;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tpayload_misses;\n\nstatic bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rp",
            "rh",
            "c_lru"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tlongest_chain;\nstatic unsigned int\t\tlongest_chain_cachesize;\n\nstatic struct svc_cacherep *\nnfsd_cache_search(struct nfsd_drc_bucket *b, struct svc_rqst *rqstp,\n\t\t__wsum csum)\n{\n\tstruct svc_cacherep\t*rp, *ret = NULL;\n\tstruct list_head \t*rh = &b->lru_head;\n\tunsigned int\t\tentries = 0;\n\n\tlist_for_each_entry(rp, rh, c_lru) {\n\t\t++entries;\n\t\tif (nfsd_cache_match(rqstp, csum, rp)) {\n\t\t\tret = rp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* tally hash chain length stats */\n\tif (entries > longest_chain) {\n\t\tlongest_chain = entries;\n\t\tlongest_chain_cachesize = atomic_read(&num_drc_entries);\n\t} else if (entries == longest_chain) {\n\t\t/* prefer to keep the smallest cachesize possible here */\n\t\tlongest_chain_cachesize = min_t(unsigned int,\n\t\t\t\tlongest_chain_cachesize,\n\t\t\t\tatomic_read(&num_drc_entries));\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_cache_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "314-336",
    "snippet": "static bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tpayload_misses;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_get_port",
          "args": [
            "(struct sockaddr *)&rp->c_addr"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_get_port",
          "args": [
            "svc_addr(rqstp)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "svc_addr(rqstp)",
            "(struct sockaddr *)&rp->c_addr"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tpayload_misses;\n\nstatic bool\nnfsd_cache_match(struct svc_rqst *rqstp, __wsum csum, struct svc_cacherep *rp)\n{\n\t/* Check RPC XID first */\n\tif (rqstp->rq_xid != rp->c_xid)\n\t\treturn false;\n\t/* compare checksum of NFS data */\n\tif (csum != rp->c_csum) {\n\t\t++payload_misses;\n\t\treturn false;\n\t}\n\n\t/* Other discriminators */\n\tif (rqstp->rq_proc != rp->c_proc ||\n\t    rqstp->rq_prot != rp->c_prot ||\n\t    rqstp->rq_vers != rp->c_vers ||\n\t    rqstp->rq_arg.len != rp->c_len ||\n\t    !rpc_cmp_addr(svc_addr(rqstp), (struct sockaddr *)&rp->c_addr) ||\n\t    rpc_get_port(svc_addr(rqstp)) != rpc_get_port((struct sockaddr *)&rp->c_addr))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "nfsd_cache_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "284-312",
    "snippet": "static __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "csum_partial",
          "args": [
            "p",
            "len",
            "csum"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE - base",
            "csum_len"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "buf->pages[idx]"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "csum_partial",
          "args": [
            "p",
            "len",
            "0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "buf->head[0].iov_len",
            "csum_len"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "buf->head[0].iov_len + buf->page_len",
            "RC_CSUMLEN"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic __wsum\nnfsd_cache_csum(struct svc_rqst *rqstp)\n{\n\tint idx;\n\tunsigned int base;\n\t__wsum csum;\n\tstruct xdr_buf *buf = &rqstp->rq_arg;\n\tconst unsigned char *p = buf->head[0].iov_base;\n\tsize_t csum_len = min_t(size_t, buf->head[0].iov_len + buf->page_len,\n\t\t\t\tRC_CSUMLEN);\n\tsize_t len = min(buf->head[0].iov_len, csum_len);\n\n\t/* rq_arg.head first */\n\tcsum = csum_partial(p, len, 0);\n\tcsum_len -= len;\n\n\t/* Continue into page array */\n\tidx = buf->page_base / PAGE_SIZE;\n\tbase = buf->page_base & ~PAGE_MASK;\n\twhile (csum_len) {\n\t\tp = page_address(buf->pages[idx]) + base;\n\t\tlen = min_t(size_t, PAGE_SIZE - base, csum_len);\n\t\tcsum = csum_partial(p, len, csum);\n\t\tcsum_len -= len;\n\t\tbase = 0;\n\t\t++idx;\n\t}\n\treturn csum;\n}"
  },
  {
    "function_name": "nfsd_reply_cache_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "276-280",
    "snippet": "static unsigned long\nnfsd_reply_cache_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn prune_cache_entries();\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);",
      "static unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prune_cache_entries",
          "args": [],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "prune_cache_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "252-268",
          "snippet": "static long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\treturn freed;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static unsigned int\t\tdrc_hashsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_hashsize;\n\nstatic long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\treturn freed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);\nstatic unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);\n\nstatic unsigned long\nnfsd_reply_cache_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn prune_cache_entries();\n}"
  },
  {
    "function_name": "nfsd_reply_cache_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "270-274",
    "snippet": "static unsigned long\nnfsd_reply_cache_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn atomic_read(&num_drc_entries);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);",
      "static unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned long nfsd_reply_cache_count(struct shrinker *shrink,\n\t\t\t\t\t    struct shrink_control *sc);\nstatic unsigned long nfsd_reply_cache_scan(struct shrinker *shrink,\n\t\t\t\t\t   struct shrink_control *sc);\n\nstatic unsigned long\nnfsd_reply_cache_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn atomic_read(&num_drc_entries);\n}"
  },
  {
    "function_name": "prune_cache_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "252-268",
    "snippet": "static long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\treturn freed;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static unsigned int\t\tdrc_hashsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prune_bucket",
          "args": [
            "b"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "prune_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "226-246",
          "snippet": "static long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int\t\tmax_drc_entries;",
            "static atomic_t\t\t\tnum_drc_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic atomic_t\t\t\tnum_drc_entries;\n\nstatic long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&b->lru_head"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic unsigned int\t\tdrc_hashsize;\n\nstatic long\nprune_cache_entries(void)\n{\n\tunsigned int i;\n\tlong freed = 0;\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct nfsd_drc_bucket *b = &drc_hashtbl[i];\n\n\t\tif (list_empty(&b->lru_head))\n\t\t\tcontinue;\n\t\tspin_lock(&b->cache_lock);\n\t\tfreed += prune_bucket(b);\n\t\tspin_unlock(&b->cache_lock);\n\t}\n\treturn freed;\n}"
  },
  {
    "function_name": "prune_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "226-246",
    "snippet": "static long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tmax_drc_entries;",
      "static atomic_t\t\t\tnum_drc_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "135-146",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "rp->c_timestamp + RC_EXPIRE"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&num_drc_entries"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "rp",
            "tmp",
            "&b->lru_head",
            "c_lru"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmax_drc_entries;\nstatic atomic_t\t\t\tnum_drc_entries;\n\nstatic long\nprune_bucket(struct nfsd_drc_bucket *b)\n{\n\tstruct svc_cacherep *rp, *tmp;\n\tlong freed = 0;\n\n\tlist_for_each_entry_safe(rp, tmp, &b->lru_head, c_lru) {\n\t\t/*\n\t\t * Don't free entries attached to calls that are still\n\t\t * in-progress, but do keep scanning the list.\n\t\t */\n\t\tif (rp->c_state == RC_INPROG)\n\t\t\tcontinue;\n\t\tif (atomic_read(&num_drc_entries) <= max_drc_entries &&\n\t\t    time_before(jiffies, rp->c_timestamp + RC_EXPIRE))\n\t\t\tbreak;\n\t\tnfsd_reply_cache_free_locked(rp);\n\t\tfreed++;\n\t}\n\treturn freed;\n}"
  },
  {
    "function_name": "lru_put_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "219-224",
    "snippet": "static void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&rp->c_lru",
            "&b->lru_head"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nlru_put_end(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\trp->c_timestamp = jiffies;\n\tlist_move_tail(&rp->c_lru, &b->lru_head);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "192-213",
    "snippet": "void nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static struct kmem_cache\t*drc_slab;",
      "static unsigned int\t\tdrc_hashsize;",
      "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "drc_slab"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "drc_hashtbl"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "135-146",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structsvc_cacherep",
            "c_lru"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&nfsd_reply_cache_shrinker"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tdrc_hashsize;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nvoid nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}"
  },
  {
    "function_name": "nfsd_reply_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "156-190",
    "snippet": "int nfsd_reply_cache_init(void)\n{\n\tunsigned int hashsize;\n\tunsigned int i;\n\tint status = 0;\n\n\tmax_drc_entries = nfsd_cache_size_limit();\n\tatomic_set(&num_drc_entries, 0);\n\thashsize = nfsd_hashsize(max_drc_entries);\n\tmaskbits = ilog2(hashsize);\n\n\tstatus = register_shrinker(&nfsd_reply_cache_shrinker);\n\tif (status)\n\t\treturn status;\n\n\tdrc_slab = kmem_cache_create(\"nfsd_drc\", sizeof(struct svc_cacherep),\n\t\t\t\t\t0, 0, NULL);\n\tif (!drc_slab)\n\t\tgoto out_nomem;\n\n\tdrc_hashtbl = kcalloc(hashsize, sizeof(*drc_hashtbl), GFP_KERNEL);\n\tif (!drc_hashtbl)\n\t\tgoto out_nomem;\n\tfor (i = 0; i < hashsize; i++) {\n\t\tINIT_LIST_HEAD(&drc_hashtbl[i].lru_head);\n\t\tspin_lock_init(&drc_hashtbl[i].cache_lock);\n\t}\n\tdrc_hashsize = hashsize;\n\n\treturn 0;\nout_nomem:\n\tprintk(KERN_ERR \"nfsd: failed to allocate reply cache\\n\");\n\tnfsd_reply_cache_shutdown();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd_drc_bucket\t*drc_hashtbl;",
      "static struct kmem_cache\t*drc_slab;",
      "static unsigned int\t\tmax_drc_entries;",
      "static unsigned int\t\tmaskbits;",
      "static unsigned int\t\tdrc_hashsize;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reply_cache_shutdown",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "192-213",
          "snippet": "void nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct nfsd_drc_bucket\t*drc_hashtbl;",
            "static struct kmem_cache\t*drc_slab;",
            "static unsigned int\t\tdrc_hashsize;",
            "static struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tdrc_hashsize;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nvoid nfsd_reply_cache_shutdown(void)\n{\n\tstruct svc_cacherep\t*rp;\n\tunsigned int i;\n\n\tunregister_shrinker(&nfsd_reply_cache_shrinker);\n\n\tfor (i = 0; i < drc_hashsize; i++) {\n\t\tstruct list_head *head = &drc_hashtbl[i].lru_head;\n\t\twhile (!list_empty(head)) {\n\t\t\trp = list_first_entry(head, struct svc_cacherep, c_lru);\n\t\t\tnfsd_reply_cache_free_locked(rp);\n\t\t}\n\t}\n\n\tkfree (drc_hashtbl);\n\tdrc_hashtbl = NULL;\n\tdrc_hashsize = 0;\n\n\tkmem_cache_destroy(drc_slab);\n\tdrc_slab = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nfsd: failed to allocate reply cache\\n\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&drc_hashtbl[i].cache_lock"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&drc_hashtbl[i].lru_head"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "hashsize",
            "sizeof(*drc_hashtbl)",
            "GFP_KERNEL"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd_drc\"",
            "sizeof(struct svc_cacherep)",
            "0",
            "0",
            "NULL"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&nfsd_reply_cache_shrinker"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "hashsize"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_hashsize",
          "args": [
            "max_drc_entries"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_hashsize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "109-113",
          "snippet": "static unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define TARGET_BUCKET_SIZE\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\n#define TARGET_BUCKET_SIZE\t64\n\nstatic unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&num_drc_entries",
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_cache_size_limit",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cache_size_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "95-103",
          "snippet": "static unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct nfsd_drc_bucket\t*drc_hashtbl;\nstatic struct kmem_cache\t*drc_slab;\nstatic unsigned int\t\tmax_drc_entries;\nstatic unsigned int\t\tmaskbits;\nstatic unsigned int\t\tdrc_hashsize;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic struct shrinker nfsd_reply_cache_shrinker = {\n\t.scan_objects = nfsd_reply_cache_scan,\n\t.count_objects = nfsd_reply_cache_count,\n\t.seeks\t= 1,\n};\n\nint nfsd_reply_cache_init(void)\n{\n\tunsigned int hashsize;\n\tunsigned int i;\n\tint status = 0;\n\n\tmax_drc_entries = nfsd_cache_size_limit();\n\tatomic_set(&num_drc_entries, 0);\n\thashsize = nfsd_hashsize(max_drc_entries);\n\tmaskbits = ilog2(hashsize);\n\n\tstatus = register_shrinker(&nfsd_reply_cache_shrinker);\n\tif (status)\n\t\treturn status;\n\n\tdrc_slab = kmem_cache_create(\"nfsd_drc\", sizeof(struct svc_cacherep),\n\t\t\t\t\t0, 0, NULL);\n\tif (!drc_slab)\n\t\tgoto out_nomem;\n\n\tdrc_hashtbl = kcalloc(hashsize, sizeof(*drc_hashtbl), GFP_KERNEL);\n\tif (!drc_hashtbl)\n\t\tgoto out_nomem;\n\tfor (i = 0; i < hashsize; i++) {\n\t\tINIT_LIST_HEAD(&drc_hashtbl[i].lru_head);\n\t\tspin_lock_init(&drc_hashtbl[i].cache_lock);\n\t}\n\tdrc_hashsize = hashsize;\n\n\treturn 0;\nout_nomem:\n\tprintk(KERN_ERR \"nfsd: failed to allocate reply cache\\n\");\n\tnfsd_reply_cache_shutdown();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nfsd_reply_cache_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "148-154",
    "snippet": "static void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_reply_cache_free_locked",
          "args": [
            "rp"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reply_cache_free_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
          "lines": "135-146",
          "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/checksum.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/highmem.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache\t*drc_slab;",
            "static atomic_t\t\t\tnum_drc_entries;",
            "static unsigned int\t\tdrc_mem_usage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&b->cache_lock"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic void\nnfsd_reply_cache_free(struct nfsd_drc_bucket *b, struct svc_cacherep *rp)\n{\n\tspin_lock(&b->cache_lock);\n\tnfsd_reply_cache_free_locked(rp);\n\tspin_unlock(&b->cache_lock);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_free_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "135-146",
    "snippet": "static void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*drc_slab;",
      "static atomic_t\t\t\tnum_drc_entries;",
      "static unsigned int\t\tdrc_mem_usage;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "drc_slab",
            "rp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&num_drc_entries"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rp->c_lru"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rp->c_replvec.iov_base"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\nstatic atomic_t\t\t\tnum_drc_entries;\nstatic unsigned int\t\tdrc_mem_usage;\n\nstatic void\nnfsd_reply_cache_free_locked(struct svc_cacherep *rp)\n{\n\tif (rp->c_type == RC_REPLBUFF && rp->c_replvec.iov_base) {\n\t\tdrc_mem_usage -= rp->c_replvec.iov_len;\n\t\tkfree(rp->c_replvec.iov_base);\n\t}\n\tlist_del(&rp->c_lru);\n\tatomic_dec(&num_drc_entries);\n\tdrc_mem_usage -= sizeof(*rp);\n\tkmem_cache_free(drc_slab, rp);\n}"
  },
  {
    "function_name": "nfsd_reply_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "121-133",
    "snippet": "static struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache\t*drc_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rp->c_lru"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "drc_slab",
            "GFP_KERNEL"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache\t*drc_slab;\n\nstatic struct svc_cacherep *\nnfsd_reply_cache_alloc(void)\n{\n\tstruct svc_cacherep\t*rp;\n\n\trp = kmem_cache_alloc(drc_slab, GFP_KERNEL);\n\tif (rp) {\n\t\trp->c_state = RC_UNUSED;\n\t\trp->c_type = RC_NOCACHE;\n\t\tINIT_LIST_HEAD(&rp->c_lru);\n\t}\n\treturn rp;\n}"
  },
  {
    "function_name": "nfsd_cache_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "115-119",
    "snippet": "static u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int\t\tmaskbits;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "be32_to_cpu(xid)",
            "maskbits"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "xid"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\t\tmaskbits;\n\nstatic u32\nnfsd_cache_hash(__be32 xid)\n{\n\treturn hash_32(be32_to_cpu(xid), maskbits);\n}"
  },
  {
    "function_name": "nfsd_hashsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "109-113",
    "snippet": "static unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define TARGET_BUCKET_SIZE\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "limit / TARGET_BUCKET_SIZE"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\n#define TARGET_BUCKET_SIZE\t64\n\nstatic unsigned int\nnfsd_hashsize(unsigned int limit)\n{\n\treturn roundup_pow_of_two(limit / TARGET_BUCKET_SIZE);\n}"
  },
  {
    "function_name": "nfsd_cache_size_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfscache.c",
    "lines": "95-103",
    "snippet": "static unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"nfsd.h\"",
      "#include <net/checksum.h>",
      "#include <linux/hash.h>",
      "#include <linux/log2.h>",
      "#include <linux/highmem.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "limit",
            "256*1024"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "int_sqrt",
          "args": [
            "low_pages"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/checksum.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/highmem.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/slab.h>\n\nstatic unsigned int\nnfsd_cache_size_limit(void)\n{\n\tunsigned int limit;\n\tunsigned long low_pages = totalram_pages - totalhigh_pages;\n\n\tlimit = (16 * int_sqrt(low_pages)) << (PAGE_SHIFT-10);\n\treturn min_t(unsigned int, limit, 256*1024);\n}"
  }
]