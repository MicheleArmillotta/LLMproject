[
  {
    "function_name": "nfs4svc_encode_compoundres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4491-4512",
    "snippet": "int\nnfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundres *resp)\n{\n\t/*\n\t * All that remains is to write the tag and operation count...\n\t */\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\n\tWARN_ON_ONCE(buf->len != buf->head[0].iov_len + buf->page_len +\n\t\t\t\t buf->tail[0].iov_len);\n\n\trqstp->rq_next_page = resp->xdr.page_ptr + 1;\n\n\tp = resp->tagp;\n\t*p++ = htonl(resp->taglen);\n\tmemcpy(p, resp->tag, resp->taglen);\n\tp += XDR_QUADLEN(resp->taglen);\n\t*p++ = htonl(resp->opcnt);\n\n\tnfsd4_sequence_done(resp);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_sequence_done",
          "args": [
            "resp"
          ],
          "line": 4510
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_sequence_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3046-3060",
          "snippet": "void\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->opcnt"
          ],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "resp->taglen"
          ],
          "line": 4507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "resp->tag",
            "resp->taglen"
          ],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->taglen"
          ],
          "line": 4505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "buf->len != buf->head[0].iov_len + buf->page_len +\n\t\t\t\t buf->tail[0].iov_len"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nint\nnfs4svc_encode_compoundres(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundres *resp)\n{\n\t/*\n\t * All that remains is to write the tag and operation count...\n\t */\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\n\tWARN_ON_ONCE(buf->len != buf->head[0].iov_len + buf->page_len +\n\t\t\t\t buf->tail[0].iov_len);\n\n\trqstp->rq_next_page = resp->xdr.page_ptr + 1;\n\n\tp = resp->tagp;\n\t*p++ = htonl(resp->taglen);\n\tmemcpy(p, resp->tag, resp->taglen);\n\tp += XDR_QUADLEN(resp->taglen);\n\t*p++ = htonl(resp->opcnt);\n\n\tnfsd4_sequence_done(resp);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs4svc_decode_compoundargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4470-4489",
    "snippet": "int\nnfs4svc_decode_compoundargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundargs *args)\n{\n\tif (rqstp->rq_arg.head[0].iov_len % 4) {\n\t\t/* client is nuts */\n\t\tdprintk(\"%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)\",\n\t\t\t__func__, svc_addr(rqstp), be32_to_cpu(rqstp->rq_xid));\n\t\treturn 0;\n\t}\n\targs->p = p;\n\targs->end = rqstp->rq_arg.head[0].iov_base + rqstp->rq_arg.head[0].iov_len;\n\targs->pagelist = rqstp->rq_arg.pages;\n\targs->pagelen = rqstp->rq_arg.page_len;\n\targs->tmpp = NULL;\n\targs->to_free = NULL;\n\targs->ops = args->iops;\n\targs->rqstp = rqstp;\n\n\treturn !nfsd4_decode_compound(args);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_compound",
          "args": [
            "args"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_compound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1826-1912",
          "snippet": "static __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen);\n\tSAVEMEM(argp->tag, argp->taglen);\n\tREAD_BUF(8);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [
            "static nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_CLONE]\t\t= (nfsd4_dec)nfsd4_decode_clone,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_CLONE]\t\t= (nfsd4_dec)nfsd4_decode_clone,\n};\n\nstatic __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen);\n\tSAVEMEM(argp->tag, argp->taglen);\n\tREAD_BUF(8);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)\"",
            "__func__",
            "svc_addr(rqstp)",
            "be32_to_cpu(rqstp->rq_xid)"
          ],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rqstp->rq_xid"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nint\nnfs4svc_decode_compoundargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd4_compoundargs *args)\n{\n\tif (rqstp->rq_arg.head[0].iov_len % 4) {\n\t\t/* client is nuts */\n\t\tdprintk(\"%s: compound not properly padded! (peeraddr=%pISc xid=0x%x)\",\n\t\t\t__func__, svc_addr(rqstp), be32_to_cpu(rqstp->rq_xid));\n\t\treturn 0;\n\t}\n\targs->p = p;\n\targs->end = rqstp->rq_arg.head[0].iov_base + rqstp->rq_arg.head[0].iov_len;\n\targs->pagelist = rqstp->rq_arg.pages;\n\targs->pagelen = rqstp->rq_arg.page_len;\n\targs->tmpp = NULL;\n\targs->to_free = NULL;\n\targs->ops = args->iops;\n\targs->rqstp = rqstp;\n\n\treturn !nfsd4_decode_compound(args);\n}"
  },
  {
    "function_name": "nfsd4_release_compoundargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4451-4468",
    "snippet": "int nfsd4_release_compoundargs(void *rq, __be32 *p, void *resp)\n{\n\tstruct svc_rqst *rqstp = rq;\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\tif (args->ops != args->iops) {\n\t\tkfree(args->ops);\n\t\targs->ops = args->iops;\n\t}\n\tkfree(args->tmpp);\n\targs->tmpp = NULL;\n\twhile (args->to_free) {\n\t\tstruct svcxdr_tmpbuf *tb = args->to_free;\n\t\targs->to_free = tb->next;\n\t\tkfree(tb);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tb"
          ],
          "line": 4465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->tmpp"
          ],
          "line": 4460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "args->ops"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nint nfsd4_release_compoundargs(void *rq, __be32 *p, void *resp)\n{\n\tstruct svc_rqst *rqstp = rq;\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\tif (args->ops != args->iops) {\n\t\tkfree(args->ops);\n\t\targs->ops = args->iops;\n\t}\n\tkfree(args->tmpp);\n\targs->tmpp = NULL;\n\twhile (args->to_free) {\n\t\tstruct svcxdr_tmpbuf *tb = args->to_free;\n\t\targs->to_free = tb->next;\n\t\tkfree(tb);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs4svc_encode_voidres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4445-4449",
    "snippet": "int\nnfs4svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n        return xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nint\nnfs4svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n        return xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsd4_encode_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4426-4443",
    "snippet": "void\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\n{\n\t__be32 *p;\n\tstruct nfs4_replay *rp = op->replay;\n\n\tBUG_ON(!rp);\n\n\tp = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\t*p++ = rp->rp_status;  /* already xdr'ed */\n\n\tp = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "rp->rp_buf",
            "rp->rp_buflen"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "op->opnum"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 + rp->rp_buflen"
          ],
          "line": 4434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rp"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_encode_replay(struct xdr_stream *xdr, struct nfsd4_op *op)\n{\n\t__be32 *p;\n\tstruct nfs4_replay *rp = op->replay;\n\n\tBUG_ON(!rp);\n\n\tp = xdr_reserve_space(xdr, 8 + rp->rp_buflen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\t*p++ = rp->rp_status;  /* already xdr'ed */\n\n\tp = xdr_encode_opaque_fixed(p, rp->rp_buf, rp->rp_buflen);\n}"
  },
  {
    "function_name": "nfsd4_encode_operation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4353-4418",
    "snippet": "void\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_CLONE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "post_err_offset - 4",
            "&op->status",
            "4"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_bytes_from_xdr_buf",
          "args": [
            "xdr->buf",
            "post_err_offset",
            "so->so_replay.rp_buf",
            "len"
          ],
          "line": 4412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "post_err_offset"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_on_nonidempotent_op",
          "args": [
            "op"
          ],
          "line": 4404
        },
        "resolved": true,
        "details": {
          "function_name": "warn_on_nonidempotent_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4proc.c",
          "lines": "2350-2357",
          "snippet": "void warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nvoid warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "&resp->cstate"
          ],
          "line": 4386
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_resp_size",
          "args": [
            "resp",
            "space_needed"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_resp_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "4337-4351",
          "snippet": "__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_last_compound_op",
          "args": [
            "rqstp"
          ],
          "line": 4382
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_last_compound_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "628-634",
          "snippet": "static inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_commit_encode",
          "args": [
            "xdr"
          ],
          "line": 4377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encoder",
          "args": [
            "resp",
            "op->status",
            "&op->u"
          ],
          "line": 4376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]"
          ],
          "line": 4373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "nfsd4_enc_ops"
          ],
          "line": 4373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "op->opnum"
          ],
          "line": 4368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_CLONE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};\n\nvoid\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}"
  },
  {
    "function_name": "nfsd4_check_resp_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4337-4351",
    "snippet": "__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "&resp->cstate"
          ],
          "line": 4344
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n__be32 nfsd4_check_resp_size(struct nfsd4_compoundres *resp, u32 respsize)\n{\n\tstruct xdr_buf *buf = &resp->rqstp->rq_res;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\tif (buf->len + respsize <= buf->buflen)\n\t\treturn nfs_ok;\n\tif (!nfsd4_has_session(&resp->cstate))\n\t\treturn nfserr_resource;\n\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_rep_too_big_to_cache;\n\t}\n\treturn nfserr_rep_too_big;\n}"
  },
  {
    "function_name": "nfsd4_encode_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4227-4231",
    "snippet": "static __be32\nnfsd4_encode_noop(struct nfsd4_compoundres *resp, __be32 nfserr, void *p)\n{\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_noop(struct nfsd4_compoundres *resp, __be32 nfserr, void *p)\n{\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4211-4225",
    "snippet": "static __be32\nnfsd4_encode_seek(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_seek *seek)\n{\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(&resp->xdr, 4 + 8);\n\t*p++ = cpu_to_be32(seek->seek_eof);\n\tp = xdr_encode_hyper(p, seek->seek_pos);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "seek->seek_pos"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seek->seek_eof"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "&resp->xdr",
            "4 + 8"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_seek(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_seek *seek)\n{\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(&resp->xdr, 4 + 8);\n\t*p++ = cpu_to_be32(seek->seek_eof);\n\tp = xdr_encode_hyper(p, seek->seek_pos);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4191-4208",
    "snippet": "static __be32\nnfsd4_encode_layoutreturn(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lrp->lrs_present);\n\tif (lrp->lrs_present)\n\t\treturn nfsd4_encode_stateid(xdr, &lrp->lr_sid);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&lrp->lr_sid"
          ],
          "line": 4206
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3024-3036",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lrp->lrs_present"
          ],
          "line": 4204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_layoutreturn(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lrp->lrs_present);\n\tif (lrp->lrs_present)\n\t\treturn nfsd4_encode_stateid(xdr, &lrp->lr_sid);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_encode_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4167-4189",
    "snippet": "static __be32\nnfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_layoutcommit *lcp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lcp->lc_size_chg);\n\tif (lcp->lc_size_chg) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_hyper(p, lcp->lc_newsize);\n\t}\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "lcp->lc_newsize"
          ],
          "line": 4185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 4182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lcp->lc_size_chg"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_layoutcommit(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_layoutcommit *lcp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(lcp->lc_size_chg);\n\tif (lcp->lc_size_chg) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_hyper(p, lcp->lc_newsize);\n\t}\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_encode_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4132-4165",
    "snippet": "static __be32\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "lgp->lg_content"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->encode_layoutget",
          "args": [
            "xdr",
            "lgp"
          ],
          "line": 4161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lgp->lg_layout_type"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lgp->lg_seg.iomode"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "lgp->lg_seg.length"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "lgp->lg_seg.offset"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 4155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&lgp->lg_sid.si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "lgp->lg_sid.si_generation"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "36 + sizeof(stateid_opaque_t)"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: err %d\\n\"",
            "__func__",
            "nfserr"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(1);\t/* we always set return-on-close */\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\n\t*p++ = cpu_to_be32(1);\t/* we always return a single layout */\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4062-4130",
    "snippet": "static __be32\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\t/* If maxcount is 0 then just update notifications */\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\t/*\n\t\t\t * We don't bother to burden the layout drivers with\n\t\t\t * enforcing gd_maxcount, just tell the client to\n\t\t\t * come back with a bigger buffer if it's not enough.\n\t\t\t */\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t/* bitmap length */\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\n\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 /* notifications */;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "needed_len"
          ],
          "line": 4126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 4121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: maxcount too small\\n\"",
            "__func__"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: done: %d\\n\"",
            "__func__",
            "be32_to_cpu(nfserr)"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "nfserr"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "gdev->gd_device"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "gdev->gd_notify_types"
          ],
          "line": 4104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->encode_getdeviceinfo",
          "args": [
            "xdr",
            "gdev"
          ],
          "line": 4085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "gdev->gd_layout_type"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: err %d\\n\"",
            "__func__",
            "nfserr"
          ],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\n\t/* If maxcount is 0 then just update notifications */\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\t/*\n\t\t\t * We don't bother to burden the layout drivers with\n\t\t\t * enforcing gd_maxcount, just tell the client to\n\t\t\t * come back with a bigger buffer if it's not enough.\n\t\t\t */\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t/* bitmap length */\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\n\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 /* notifications */;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd4_encode_test_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4038-4059",
    "snippet": "static __be32\nnfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_test_stateid_id *stateid, *next;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4 + (4 * test_stateid->ts_num_ids));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = htonl(test_stateid->ts_num_ids);\n\n\tlist_for_each_entry_safe(stateid, next, &test_stateid->ts_stateid_list, ts_id_list) {\n\t\t*p++ = stateid->ts_id_status;\n\t}\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stateid",
            "next",
            "&test_stateid->ts_stateid_list",
            "ts_id_list"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "test_stateid->ts_num_ids"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + (4 * test_stateid->ts_num_ids)"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_test_stateid(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t  struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_test_stateid_id *stateid, *next;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4 + (4 * test_stateid->ts_num_ids));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = htonl(test_stateid->ts_num_ids);\n\n\tlist_for_each_entry_safe(stateid, next, &test_stateid->ts_stateid_list, ts_id_list) {\n\t\t*p++ = stateid->ts_id_status;\n\t}\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "4012-4036",
    "snippet": "static __be32\nnfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 20);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, seq->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(seq->seqid);\n\t*p++ = cpu_to_be32(seq->slotid);\n\t/* Note slotid's are numbered from zero: */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_highest_slotid */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_target_highest_slotid */\n\t*p++ = cpu_to_be32(seq->status_flags);\n\n\tresp->cstate.data_offset = xdr->buf->len; /* DRC cache data pointer */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->status_flags"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->maxslots - 1"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->maxslots - 1"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->slotid"
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "seq->seqid"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "seq->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_MAX_SESSIONID_LEN + 20"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_sequence(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 20);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, seq->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(seq->seqid);\n\t*p++ = cpu_to_be32(seq->slotid);\n\t/* Note slotid's are numbered from zero: */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_highest_slotid */\n\t*p++ = cpu_to_be32(seq->maxslots - 1); /* sr_target_highest_slotid */\n\t*p++ = cpu_to_be32(seq->status_flags);\n\n\tresp->cstate.data_offset = xdr->buf->len; /* DRC cache data pointer */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3956-4010",
    "snippet": "static __be32\nnfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 24);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, sess->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(sess->seqid);\n\t*p++ = cpu_to_be32(sess->flags);\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxops);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->fore_channel.nr_rdma_attrs);\n\n\tif (sess->fore_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->fore_channel.rdma_attrs);\n\t}\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->back_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->back_channel.maxops);\n\t*p++ = cpu_to_be32(sess->back_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->back_channel.nr_rdma_attrs);\n\n\tif (sess->back_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->back_channel.rdma_attrs);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.rdma_attrs"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.nr_rdma_attrs"
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxreqs"
          ],
          "line": 4000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxops"
          ],
          "line": 3999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxresp_cached"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxresp_sz"
          ],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->back_channel.maxreq_sz"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "28"
          ],
          "line": 3992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.rdma_attrs"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.nr_rdma_attrs"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxreqs"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxops"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxresp_cached"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxresp_sz"
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->fore_channel.maxreq_sz"
          ],
          "line": 3978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "28"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->flags"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sess->seqid"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "sess->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "24"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_create_session(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 24);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = xdr_encode_opaque_fixed(p, sess->sessionid.data,\n\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t*p++ = cpu_to_be32(sess->seqid);\n\t*p++ = cpu_to_be32(sess->flags);\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxops);\n\t*p++ = cpu_to_be32(sess->fore_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->fore_channel.nr_rdma_attrs);\n\n\tif (sess->fore_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->fore_channel.rdma_attrs);\n\t}\n\n\tp = xdr_reserve_space(xdr, 28);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(0); /* headerpadsz */\n\t*p++ = cpu_to_be32(sess->back_channel.maxreq_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_sz);\n\t*p++ = cpu_to_be32(sess->back_channel.maxresp_cached);\n\t*p++ = cpu_to_be32(sess->back_channel.maxops);\n\t*p++ = cpu_to_be32(sess->back_channel.maxreqs);\n\t*p++ = cpu_to_be32(sess->back_channel.nr_rdma_attrs);\n\n\tif (sess->back_channel.nr_rdma_attrs) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(sess->back_channel.rdma_attrs);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_exchange_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3878-3954",
    "snippet": "static __be32\nnfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\tchar *major_id;\n\tchar *server_scope;\n\tint major_id_sz;\n\tint server_scope_sz;\n\tuint64_t minor_id = 0;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tmajor_id = utsname()->nodename;\n\tmajor_id_sz = strlen(major_id);\n\tserver_scope = utsname()->nodename;\n\tserver_scope_sz = strlen(server_scope);\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* eir_clientid */ +\n\t\t4 /* eir_sequenceid */ +\n\t\t4 /* eir_flags */ +\n\t\t4 /* spr_how */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tp = xdr_encode_opaque_fixed(p, &exid->clientid, 8);\n\t*p++ = cpu_to_be32(exid->seqid);\n\t*p++ = cpu_to_be32(exid->flags);\n\n\t*p++ = cpu_to_be32(exid->spa_how);\n\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce, spo_must_allow */\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\n\t\t/* spo_must_enforce bitmap: */\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[0]);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[1]);\n\t\t/* empty spo_must_allow bitmap: */\n\t\t*p++ = cpu_to_be32(0);\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* so_minor_id */ +\n\t\t4 /* so_major_id.len */ +\n\t\t(XDR_QUADLEN(major_id_sz) * 4) +\n\t\t4 /* eir_server_scope.len */ +\n\t\t(XDR_QUADLEN(server_scope_sz) * 4) +\n\t\t4 /* eir_server_impl_id.count (0) */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* The server_owner struct */\n\tp = xdr_encode_hyper(p, minor_id);      /* Minor id */\n\t/* major id */\n\tp = xdr_encode_opaque(p, major_id, major_id_sz);\n\n\t/* Server scope */\n\tp = xdr_encode_opaque(p, server_scope, server_scope_sz);\n\n\t/* Implementation id */\n\t*p++ = cpu_to_be32(0);\t/* zero length nfs_impl_id4 array */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const u32 nfs4_minimal_spo_must_enforce[2] = {\n\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t      1 << (OP_EXCHANGE_ID - 32) |\n\t      1 << (OP_CREATE_SESSION - 32) |\n\t      1 << (OP_DESTROY_SESSION - 32) |\n\t      1 << (OP_DESTROY_CLIENTID - 32)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "server_scope",
            "server_scope_sz"
          ],
          "line": 3949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "major_id",
            "major_id_sz"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "minor_id"
          ],
          "line": 3944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 /* so_minor_id */ +\n\t\t4 /* so_major_id.len */ +\n\t\t(XDR_QUADLEN(major_id_sz) * 4) +\n\t\t4 /* eir_server_scope.len */ +\n\t\t(XDR_QUADLEN(server_scope_sz) * 4) +\n\t\t4/* eir_server_impl_id.count (0) */"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "server_scope_sz"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "major_id_sz"
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nfs4_minimal_spo_must_enforce[1]"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nfs4_minimal_spo_must_enforce[0]"
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "exid->spa_how"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "exid->flags"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "exid->seqid"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&exid->clientid",
            "8"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 /* eir_clientid */ +\n\t\t4 /* eir_sequenceid */ +\n\t\t4 /* eir_flags */ +\n\t\t4/* spr_how */"
          ],
          "line": 3898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server_scope"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "major_id"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic const u32 nfs4_minimal_spo_must_enforce[2] = {\n\t[1] = 1 << (OP_BIND_CONN_TO_SESSION - 32) |\n\t      1 << (OP_EXCHANGE_ID - 32) |\n\t      1 << (OP_CREATE_SESSION - 32) |\n\t      1 << (OP_DESTROY_SESSION - 32) |\n\t      1 << (OP_DESTROY_CLIENTID - 32)\n};\n\nstatic __be32\nnfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\tchar *major_id;\n\tchar *server_scope;\n\tint major_id_sz;\n\tint server_scope_sz;\n\tuint64_t minor_id = 0;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tmajor_id = utsname()->nodename;\n\tmajor_id_sz = strlen(major_id);\n\tserver_scope = utsname()->nodename;\n\tserver_scope_sz = strlen(server_scope);\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* eir_clientid */ +\n\t\t4 /* eir_sequenceid */ +\n\t\t4 /* eir_flags */ +\n\t\t4 /* spr_how */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\tp = xdr_encode_opaque_fixed(p, &exid->clientid, 8);\n\t*p++ = cpu_to_be32(exid->seqid);\n\t*p++ = cpu_to_be32(exid->flags);\n\n\t*p++ = cpu_to_be32(exid->spa_how);\n\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce, spo_must_allow */\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\n\t\t/* spo_must_enforce bitmap: */\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[0]);\n\t\t*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[1]);\n\t\t/* empty spo_must_allow bitmap: */\n\t\t*p++ = cpu_to_be32(0);\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tp = xdr_reserve_space(xdr,\n\t\t8 /* so_minor_id */ +\n\t\t4 /* so_major_id.len */ +\n\t\t(XDR_QUADLEN(major_id_sz) * 4) +\n\t\t4 /* eir_server_scope.len */ +\n\t\t(XDR_QUADLEN(server_scope_sz) * 4) +\n\t\t4 /* eir_server_impl_id.count (0) */);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* The server_owner struct */\n\tp = xdr_encode_hyper(p, minor_id);      /* Minor id */\n\t/* major id */\n\tp = xdr_encode_opaque(p, major_id, major_id_sz);\n\n\t/* Server scope */\n\tp = xdr_encode_opaque(p, server_scope, server_scope_sz);\n\n\t/* Implementation id */\n\t*p++ = cpu_to_be32(0);\t/* zero length nfs_impl_id4 array */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3852-3868",
    "snippet": "static __be32\nnfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_write *write)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(write->wr_bytes_written);\n\t\t*p++ = cpu_to_be32(write->wr_how_written);\n\t\tp = xdr_encode_opaque_fixed(p, write->wr_verifier.data,\n\t\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "write->wr_verifier.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "write->wr_how_written"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "write->wr_bytes_written"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_write *write)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(write->wr_bytes_written);\n\t\t*p++ = cpu_to_be32(write->wr_how_written);\n\t\tp = xdr_encode_opaque_fixed(p, write->wr_verifier.data,\n\t\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_setclientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3828-3850",
    "snippet": "static __be32\nnfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setclientid *scd)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8 + NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_clientid, 8);\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_confirm,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\telse if (nfserr == nfserr_clid_inuse) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&scd->se_confirm",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&scd->se_clientid",
            "8"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8 + NFS4_VERIFIER_SIZE"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_setclientid(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setclientid *scd)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8 + NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_clientid, 8);\n\t\tp = xdr_encode_opaque_fixed(p, &scd->se_confirm,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\telse if (nfserr == nfserr_clid_inuse) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3804-3826",
    "snippet": "static __be32\nnfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setattr *setattr)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 16);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tif (nfserr) {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\telse {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[0]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[1]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[2]);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "setattr->sa_bmval[2]"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "setattr->sa_bmval[1]"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "setattr->sa_bmval[0]"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_setattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_setattr *setattr)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 16);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tif (nfserr) {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\telse {\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[0]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[1]);\n\t\t*p++ = cpu_to_be32(setattr->sa_bmval[2]);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_secinfo_no_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3791-3798",
    "snippet": "static __be32\nnfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo_no_name *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->sin_exp);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_do_encode_secinfo",
          "args": [
            "xdr",
            "nfserr",
            "secinfo->sin_exp"
          ],
          "line": 3797
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_do_encode_secinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3706-3780",
          "snippet": "static __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_secinfo_no_name(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo_no_name *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->sin_exp);\n}"
  },
  {
    "function_name": "nfsd4_encode_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3782-3789",
    "snippet": "static __be32\nnfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->si_exp);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_do_encode_secinfo",
          "args": [
            "xdr",
            "nfserr",
            "secinfo->si_exp"
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_do_encode_secinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3706-3780",
          "snippet": "static __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_secinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\treturn nfsd4_do_encode_secinfo(xdr, nfserr, secinfo->si_exp);\n}"
  },
  {
    "function_name": "nfsd4_do_encode_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3706-3780",
    "snippet": "static __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 3778
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "supported"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\"",
            "pf"
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "pf"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "info.service"
          ],
          "line": 3758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "info.qop"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "info.oid.data",
            "info.oid.len"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "RPC_AUTH_GSS"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_LEN",
          "args": [
            "info.oid.len"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpcauth_get_gssinfo",
          "args": [
            "pf",
            "&info"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gss_flavor",
          "args": [
            "exp->ex_client"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_do_encode_secinfo(struct xdr_stream *xdr,\n\t\t\t __be32 nfserr, struct svc_export *exp)\n{\n\tu32 i, nflavs, supported;\n\tstruct exp_flavor_info *flavs;\n\tstruct exp_flavor_info def_flavs[2];\n\t__be32 *p, *flavorsp;\n\tstatic bool report = true;\n\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tif (exp->ex_nflavors) {\n\t\tflavs = exp->ex_flavors;\n\t\tnflavs = exp->ex_nflavors;\n\t} else { /* Handling of some defaults in absence of real secinfo: */\n\t\tflavs = def_flavs;\n\t\tif (exp->ex_client->flavour->flavour == RPC_AUTH_UNIX) {\n\t\t\tnflavs = 2;\n\t\t\tflavs[0].pseudoflavor = RPC_AUTH_UNIX;\n\t\t\tflavs[1].pseudoflavor = RPC_AUTH_NULL;\n\t\t} else if (exp->ex_client->flavour->flavour == RPC_AUTH_GSS) {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= svcauth_gss_flavor(exp->ex_client);\n\t\t} else {\n\t\t\tnflavs = 1;\n\t\t\tflavs[0].pseudoflavor\n\t\t\t\t\t= exp->ex_client->flavour->flavour;\n\t\t}\n\t}\n\n\tsupported = 0;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\tflavorsp = p++;\t\t/* to be backfilled later */\n\n\tfor (i = 0; i < nflavs; i++) {\n\t\trpc_authflavor_t pf = flavs[i].pseudoflavor;\n\t\tstruct rpcsec_gss_info info;\n\n\t\tif (rpcauth_get_gssinfo(pf, &info) == 0) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4 + 4 +\n\t\t\t\t\t      XDR_LEN(info.oid.len) + 4 + 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(RPC_AUTH_GSS);\n\t\t\tp = xdr_encode_opaque(p,  info.oid.data, info.oid.len);\n\t\t\t*p++ = cpu_to_be32(info.qop);\n\t\t\t*p++ = cpu_to_be32(info.service);\n\t\t} else if (pf < RPC_AUTH_MAXFLAVOR) {\n\t\t\tsupported++;\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out;\n\t\t\t*p++ = cpu_to_be32(pf);\n\t\t} else {\n\t\t\tif (report)\n\t\t\t\tpr_warn(\"NFS: SECINFO: security flavor %u \"\n\t\t\t\t\t\"is not supported\\n\", pf);\n\t\t}\n\t}\n\n\tif (nflavs != supported)\n\t\treport = false;\n\t*flavorsp = htonl(supported);\n\tnfserr = 0;\nout:\n\tif (exp)\n\t\texp_put(exp);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3690-3704",
    "snippet": "static __be32\nnfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_rename *rename)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 40);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &rename->rn_sinfo);\n\t\tp = encode_cinfo(p, &rename->rn_tinfo);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&rename->rn_tinfo"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1925-1938",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "40"
          ],
          "line": 3697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_rename(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_rename *rename)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 40);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &rename->rn_sinfo);\n\t\tp = encode_cinfo(p, &rename->rn_tinfo);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3675-3688",
    "snippet": "static __be32\nnfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_remove *remove)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &remove->rm_cinfo);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&remove->rm_cinfo"
          ],
          "line": 3685
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1925-1938",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_remove(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_remove *remove)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &remove->rm_cinfo);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3582-3673",
    "snippet": "static __be32\nnfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readdir *readdir)\n{\n\tint maxcount;\n\tint bytes_left;\n\tloff_t offset;\n\t__be64 wire_offset;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint starting_len = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* XXX: Following NFSv3, we ignore the READDIR verifier for now. */\n\t*p++ = cpu_to_be32(0);\n\t*p++ = cpu_to_be32(0);\n\tresp->xdr.buf->head[0].iov_len = ((char *)resp->xdr.p)\n\t\t\t\t- (char *)resp->xdr.buf->head[0].iov_base;\n\n\t/*\n\t * Number of bytes left for directory entries allowing for the\n\t * final 8 bytes of the readdir and a following failed op:\n\t */\n\tbytes_left = xdr->buf->buflen - xdr->buf->len\n\t\t\t- COMPOUND_ERR_SLACK_SPACE - 8;\n\tif (bytes_left < 0) {\n\t\tnfserr = nfserr_resource;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(u32, readdir->rd_maxcount, INT_MAX);\n\t/*\n\t * Note the rfc defines rd_maxcount as the size of the\n\t * READDIR4resok structure, which includes the verifier above\n\t * and the 8 bytes encoded at the end of this function:\n\t */\n\tif (maxcount < 16) {\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(int, maxcount-16, bytes_left);\n\n\t/* RFC 3530 14.2.24 allows us to ignore dircount when it's 0: */\n\tif (!readdir->rd_dircount)\n\t\treaddir->rd_dircount = INT_MAX;\n\n\treaddir->xdr = xdr;\n\treaddir->rd_maxcount = maxcount;\n\treaddir->common.err = 0;\n\treaddir->cookie_offset = 0;\n\n\toffset = readdir->rd_cookie;\n\tnfserr = nfsd_readdir(readdir->rd_rqstp, readdir->rd_fhp,\n\t\t\t      &offset,\n\t\t\t      &readdir->common, nfsd4_encode_dirent);\n\tif (nfserr == nfs_ok &&\n\t    readdir->common.err == nfserr_toosmall &&\n\t    xdr->buf->len == starting_len + 8) {\n\t\t/* nothing encoded; which limit did we hit?: */\n\t\tif (maxcount - 16 < bytes_left)\n\t\t\t/* It was the fault of rd_maxcount: */\n\t\t\tnfserr = nfserr_toosmall;\n\t\telse\n\t\t\t/* We ran out of buffer space: */\n\t\t\tnfserr = nfserr_resource;\n\t}\n\tif (nfserr)\n\t\tgoto err_no_verf;\n\n\tif (readdir->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, readdir->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err_no_verf;\n\t}\n\t*p++ = 0;\t/* no more entries */\n\t*p++ = htonl(readdir->common.err == nfserr_eof);\n\n\treturn 0;\nerr_no_verf:\n\txdr_truncate_encode(xdr, starting_len);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "readdir->common.err == nfserr_eof"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "readdir->cookie_offset",
            "&wire_offset",
            "8"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "offset"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readdir",
          "args": [
            "readdir->rd_rqstp",
            "readdir->rd_fhp",
            "&offset",
            "&readdir->common",
            "nfsd4_encode_dirent"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1890-1921",
          "snippet": "__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tfput(file);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tfput(file);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "maxcount-16",
            "bytes_left"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "readdir->rd_maxcount",
            "INT_MAX"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_readdir(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readdir *readdir)\n{\n\tint maxcount;\n\tint bytes_left;\n\tloff_t offset;\n\t__be64 wire_offset;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint starting_len = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/* XXX: Following NFSv3, we ignore the READDIR verifier for now. */\n\t*p++ = cpu_to_be32(0);\n\t*p++ = cpu_to_be32(0);\n\tresp->xdr.buf->head[0].iov_len = ((char *)resp->xdr.p)\n\t\t\t\t- (char *)resp->xdr.buf->head[0].iov_base;\n\n\t/*\n\t * Number of bytes left for directory entries allowing for the\n\t * final 8 bytes of the readdir and a following failed op:\n\t */\n\tbytes_left = xdr->buf->buflen - xdr->buf->len\n\t\t\t- COMPOUND_ERR_SLACK_SPACE - 8;\n\tif (bytes_left < 0) {\n\t\tnfserr = nfserr_resource;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(u32, readdir->rd_maxcount, INT_MAX);\n\t/*\n\t * Note the rfc defines rd_maxcount as the size of the\n\t * READDIR4resok structure, which includes the verifier above\n\t * and the 8 bytes encoded at the end of this function:\n\t */\n\tif (maxcount < 16) {\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto err_no_verf;\n\t}\n\tmaxcount = min_t(int, maxcount-16, bytes_left);\n\n\t/* RFC 3530 14.2.24 allows us to ignore dircount when it's 0: */\n\tif (!readdir->rd_dircount)\n\t\treaddir->rd_dircount = INT_MAX;\n\n\treaddir->xdr = xdr;\n\treaddir->rd_maxcount = maxcount;\n\treaddir->common.err = 0;\n\treaddir->cookie_offset = 0;\n\n\toffset = readdir->rd_cookie;\n\tnfserr = nfsd_readdir(readdir->rd_rqstp, readdir->rd_fhp,\n\t\t\t      &offset,\n\t\t\t      &readdir->common, nfsd4_encode_dirent);\n\tif (nfserr == nfs_ok &&\n\t    readdir->common.err == nfserr_toosmall &&\n\t    xdr->buf->len == starting_len + 8) {\n\t\t/* nothing encoded; which limit did we hit?: */\n\t\tif (maxcount - 16 < bytes_left)\n\t\t\t/* It was the fault of rd_maxcount: */\n\t\t\tnfserr = nfserr_toosmall;\n\t\telse\n\t\t\t/* We ran out of buffer space: */\n\t\t\tnfserr = nfserr_resource;\n\t}\n\tif (nfserr)\n\t\tgoto err_no_verf;\n\n\tif (readdir->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, readdir->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err_no_verf;\n\t}\n\t*p++ = 0;\t/* no more entries */\n\t*p++ = htonl(readdir->common.err == nfserr_eof);\n\n\treturn 0;\nerr_no_verf:\n\txdr_truncate_encode(xdr, starting_len);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3537-3580",
    "snippet": "static __be32\nnfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readlink *readlink)\n{\n\tint maxcount;\n\t__be32 wire_count;\n\tint zero = 0;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint length_offset = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tmaxcount = PAGE_SIZE;\n\n\tp = xdr_reserve_space(xdr, maxcount);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t/*\n\t * XXX: By default, the ->readlink() VFS op will truncate symlinks\n\t * if they would overflow the buffer.  Is this kosher in NFSv4?  If\n\t * not, one easy fix is: if ->readlink() precisely fills the buffer,\n\t * assume that truncation occurred, and return NFS4ERR_RESOURCE.\n\t */\n\tnfserr = nfsd_readlink(readlink->rl_rqstp, readlink->rl_fhp,\n\t\t\t\t\t\t(char *)p, &maxcount);\n\tif (nfserr == nfserr_isdir)\n\t\tnfserr = nfserr_inval;\n\tif (nfserr) {\n\t\txdr_truncate_encode(xdr, length_offset);\n\t\treturn nfserr;\n\t}\n\n\twire_count = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, length_offset, &wire_count, 4);\n\txdr_truncate_encode(xdr, length_offset + 4 + ALIGN(maxcount, 4));\n\tif (maxcount & 3)\n\t\twrite_bytes_to_xdr_buf(xdr->buf, length_offset + 4 + maxcount,\n\t\t\t\t\t\t&zero, 4 - (maxcount&3));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "length_offset + 4 + maxcount",
            "&zero",
            "4 - (maxcount&3)"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "length_offset + 4 + ALIGN(maxcount, 4)"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "maxcount",
            "4"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "length_offset",
            "&wire_count",
            "4"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "maxcount"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "length_offset"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readlink",
          "args": [
            "readlink->rl_rqstp",
            "readlink->rl_fhp",
            "(char *)p",
            "&maxcount"
          ],
          "line": 3564
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1450-1490",
          "snippet": "__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "maxcount"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_readlink(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_readlink *readlink)\n{\n\tint maxcount;\n\t__be32 wire_count;\n\tint zero = 0;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tint length_offset = xdr->buf->len;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tmaxcount = PAGE_SIZE;\n\n\tp = xdr_reserve_space(xdr, maxcount);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t/*\n\t * XXX: By default, the ->readlink() VFS op will truncate symlinks\n\t * if they would overflow the buffer.  Is this kosher in NFSv4?  If\n\t * not, one easy fix is: if ->readlink() precisely fills the buffer,\n\t * assume that truncation occurred, and return NFS4ERR_RESOURCE.\n\t */\n\tnfserr = nfsd_readlink(readlink->rl_rqstp, readlink->rl_fhp,\n\t\t\t\t\t\t(char *)p, &maxcount);\n\tif (nfserr == nfserr_isdir)\n\t\tnfserr = nfserr_inval;\n\tif (nfserr) {\n\t\txdr_truncate_encode(xdr, length_offset);\n\t\treturn nfserr;\n\t}\n\n\twire_count = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, length_offset, &wire_count, 4);\n\txdr_truncate_encode(xdr, length_offset + 4 + ALIGN(maxcount, 4));\n\tif (maxcount & 3)\n\t\twrite_bytes_to_xdr_buf(xdr->buf, length_offset + 4 + maxcount,\n\t\t\t\t\t\t&zero, 4 - (maxcount&3));\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3483-3535",
    "snippet": "static __be32\nnfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_read *read)\n{\n\tunsigned long maxcount;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct file *file = read->rd_filp;\n\tint starting_len = xdr->buf->len;\n\tstruct raparms *ra = NULL;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\tgoto out;\n\n\tp = xdr_reserve_space(xdr, 8); /* eof flag and byte count */\n\tif (!p) {\n\t\tWARN_ON_ONCE(test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags));\n\t\tnfserr = nfserr_resource;\n\t\tgoto out;\n\t}\n\tif (resp->xdr.buf->page_len &&\n\t    test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)) {\n\t\tWARN_ON_ONCE(1);\n\t\tnfserr = nfserr_resource;\n\t\tgoto out;\n\t}\n\txdr_commit_encode(xdr);\n\n\tmaxcount = svc_max_payload(resp->rqstp);\n\tmaxcount = min_t(unsigned long, maxcount,\n\t\t\t (xdr->buf->buflen - xdr->buf->len));\n\tmaxcount = min_t(unsigned long, maxcount, read->rd_length);\n\n\tif (read->rd_tmp_file)\n\t\tra = nfsd_init_raparms(file);\n\n\tif (file->f_op->splice_read &&\n\t    test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags))\n\t\tnfserr = nfsd4_encode_splice_read(resp, read, file, maxcount);\n\telse\n\t\tnfserr = nfsd4_encode_readv(resp, read, file, maxcount);\n\n\tif (ra)\n\t\tnfsd_put_raparams(file, ra);\n\n\tif (nfserr)\n\t\txdr_truncate_encode(xdr, starting_len);\n\nout:\n\tif (file)\n\t\tfput(file);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_put_raparams",
          "args": [
            "file",
            "ra"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_put_raparams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "786-795",
          "snippet": "void nfsd_put_raparams(struct file *file, struct raparms *ra)\n{\n\tstruct raparm_hbucket *rab = &raparm_hash[ra->p_hindex];\n\n\tspin_lock(&rab->pb_lock);\n\tra->p_ra = file->f_ra;\n\tra->p_set = 1;\n\tra->p_count--;\n\tspin_unlock(&rab->pb_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nvoid nfsd_put_raparams(struct file *file, struct raparms *ra)\n{\n\tstruct raparm_hbucket *rab = &raparm_hash[ra->p_hindex];\n\n\tspin_lock(&rab->pb_lock);\n\tra->p_ra = file->f_ra;\n\tra->p_set = 1;\n\tra->p_count--;\n\tspin_unlock(&rab->pb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_readv",
          "args": [
            "resp",
            "read",
            "file",
            "maxcount"
          ],
          "line": 3523
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3423-3481",
          "snippet": "static __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tlen = maxcount;\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tlen = maxcount;\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_splice_read",
          "args": [
            "resp",
            "read",
            "file",
            "maxcount"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3360-3421",
          "snippet": "static __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tlong len;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tlen = maxcount;\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tlong len;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tlen = maxcount;\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SPLICE_OK",
            "&resp->rqstp->rq_flags"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_init_raparms",
          "args": [
            "file"
          ],
          "line": 3517
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_init_raparms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "738-784",
          "snippet": "struct raparms *\nnfsd_init_raparms(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tdev_t dev = inode->i_sb->s_dev;\n\tino_t ino = inode->i_ino;\n\tstruct raparms\t*ra, **rap, **frap = NULL;\n\tint depth = 0;\n\tunsigned int hash;\n\tstruct raparm_hbucket *rab;\n\n\thash = jhash_2words(dev, ino, 0xfeedbeef) & RAPARM_HASH_MASK;\n\trab = &raparm_hash[hash];\n\n\tspin_lock(&rab->pb_lock);\n\tfor (rap = &rab->pb_head; (ra = *rap); rap = &ra->p_next) {\n\t\tif (ra->p_ino == ino && ra->p_dev == dev)\n\t\t\tgoto found;\n\t\tdepth++;\n\t\tif (ra->p_count == 0)\n\t\t\tfrap = rap;\n\t}\n\tdepth = nfsdstats.ra_size;\n\tif (!frap) {\t\n\t\tspin_unlock(&rab->pb_lock);\n\t\treturn NULL;\n\t}\n\trap = frap;\n\tra = *frap;\n\tra->p_dev = dev;\n\tra->p_ino = ino;\n\tra->p_set = 0;\n\tra->p_hindex = hash;\nfound:\n\tif (rap != &rab->pb_head) {\n\t\t*rap = ra->p_next;\n\t\tra->p_next   = rab->pb_head;\n\t\trab->pb_head = ra;\n\t}\n\tra->p_count++;\n\tnfsdstats.ra_depth[depth*10/nfsdstats.ra_size]++;\n\tspin_unlock(&rab->pb_lock);\n\n\tif (ra->p_set)\n\t\tfile->f_ra = ra->p_ra;\n\treturn ra;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RAPARM_HASH_MASK\t(RAPARM_HASH_SIZE-1)"
          ],
          "globals_used": [
            "static struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n#define RAPARM_HASH_MASK\t(RAPARM_HASH_SIZE-1)\n\nstatic struct raparm_hbucket\traparm_hash[RAPARM_HASH_SIZE];\n\nstruct raparms *\nnfsd_init_raparms(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tdev_t dev = inode->i_sb->s_dev;\n\tino_t ino = inode->i_ino;\n\tstruct raparms\t*ra, **rap, **frap = NULL;\n\tint depth = 0;\n\tunsigned int hash;\n\tstruct raparm_hbucket *rab;\n\n\thash = jhash_2words(dev, ino, 0xfeedbeef) & RAPARM_HASH_MASK;\n\trab = &raparm_hash[hash];\n\n\tspin_lock(&rab->pb_lock);\n\tfor (rap = &rab->pb_head; (ra = *rap); rap = &ra->p_next) {\n\t\tif (ra->p_ino == ino && ra->p_dev == dev)\n\t\t\tgoto found;\n\t\tdepth++;\n\t\tif (ra->p_count == 0)\n\t\t\tfrap = rap;\n\t}\n\tdepth = nfsdstats.ra_size;\n\tif (!frap) {\t\n\t\tspin_unlock(&rab->pb_lock);\n\t\treturn NULL;\n\t}\n\trap = frap;\n\tra = *frap;\n\tra->p_dev = dev;\n\tra->p_ino = ino;\n\tra->p_set = 0;\n\tra->p_hindex = hash;\nfound:\n\tif (rap != &rab->pb_head) {\n\t\t*rap = ra->p_next;\n\t\tra->p_next   = rab->pb_head;\n\t\trab->pb_head = ra;\n\t}\n\tra->p_count++;\n\tnfsdstats.ra_depth[depth*10/nfsdstats.ra_size]++;\n\tspin_unlock(&rab->pb_lock);\n\n\tif (ra->p_set)\n\t\tfile->f_ra = ra->p_ra;\n\treturn ra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "maxcount",
            "read->rd_length"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "maxcount",
            "(xdr->buf->buflen - xdr->buf->len)"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "resp->rqstp"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_commit_encode",
          "args": [
            "xdr"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SPLICE_OK",
            "&resp->rqstp->rq_flags"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SPLICE_OK",
            "&resp->rqstp->rq_flags"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\t  struct nfsd4_read *read)\n{\n\tunsigned long maxcount;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct file *file = read->rd_filp;\n\tint starting_len = xdr->buf->len;\n\tstruct raparms *ra = NULL;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\tgoto out;\n\n\tp = xdr_reserve_space(xdr, 8); /* eof flag and byte count */\n\tif (!p) {\n\t\tWARN_ON_ONCE(test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags));\n\t\tnfserr = nfserr_resource;\n\t\tgoto out;\n\t}\n\tif (resp->xdr.buf->page_len &&\n\t    test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags)) {\n\t\tWARN_ON_ONCE(1);\n\t\tnfserr = nfserr_resource;\n\t\tgoto out;\n\t}\n\txdr_commit_encode(xdr);\n\n\tmaxcount = svc_max_payload(resp->rqstp);\n\tmaxcount = min_t(unsigned long, maxcount,\n\t\t\t (xdr->buf->buflen - xdr->buf->len));\n\tmaxcount = min_t(unsigned long, maxcount, read->rd_length);\n\n\tif (read->rd_tmp_file)\n\t\tra = nfsd_init_raparms(file);\n\n\tif (file->f_op->splice_read &&\n\t    test_bit(RQ_SPLICE_OK, &resp->rqstp->rq_flags))\n\t\tnfserr = nfsd4_encode_splice_read(resp, read, file, maxcount);\n\telse\n\t\tnfserr = nfsd4_encode_readv(resp, read, file, maxcount);\n\n\tif (ra)\n\t\tnfsd_put_raparams(file, ra);\n\n\tif (nfserr)\n\t\txdr_truncate_encode(xdr, starting_len);\n\nout:\n\tif (file)\n\t\tfput(file);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3423-3481",
    "snippet": "static __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tlen = maxcount;\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "starting_len + 8 + maxcount",
            "&zzz",
            "pad"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "starting_len + 4",
            "&tmp",
            "4"
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "maxcount"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "starting_len",
            "&tmp",
            "4"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "eof"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_eof_on_read",
          "args": [
            "len",
            "maxcount",
            "read->rd_offset",
            "d_inode(read->rd_fhp->fh_dentry)->i_size"
          ],
          "line": 3468
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_eof_on_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "142-159",
          "snippet": "static inline bool nfsd_eof_on_read(long requested, long read,\n\t\t\t\tloff_t offset, loff_t size)\n{\n\t/* We assume a short read means eof: */\n\tif (requested > read)\n\t\treturn true;\n\t/*\n\t * A non-short read might also reach end of file.  The spec\n\t * still requires us to set eof in that case.\n\t *\n\t * Further operations may have modified the file size since\n\t * the read, so the following check is not atomic with the read.\n\t * We've only seen that cause a problem for a client in the case\n\t * where the read returned a count of 0 without setting eof.\n\t * That case was fixed by the addition of the above check.\n\t */\n\treturn (offset + read >= size);\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline bool nfsd_eof_on_read(long requested, long read,\n\t\t\t\tloff_t offset, loff_t size)\n{\n\t/* We assume a short read means eof: */\n\tif (requested > read)\n\t\treturn true;\n\t/*\n\t * A non-short read might also reach end of file.  The spec\n\t * still requires us to set eof in that case.\n\t *\n\t * Further operations may have modified the file size since\n\t * the read, so the following check is not atomic with the read.\n\t * We've only seen that cause a problem for a client in the case\n\t * where the read returned a count of 0 without setting eof.\n\t * That case was fixed by the addition of the above check.\n\t */\n\treturn (offset + read >= size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "read->rd_fhp->fh_dentry"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len + 8 + ((maxcount+3)&~3)"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readv",
          "args": [
            "file",
            "read->rd_offset",
            "resp->rqstp->rq_vec",
            "read->rd_vlen",
            "&maxcount"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "865-876",
          "snippet": "__be32 nfsd_readv(struct file *file, loff_t offset, struct kvec *vec, int vlen,\n\t\tunsigned long *count)\n{\n\tmm_segment_t oldfs;\n\tint host_err;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\thost_err = vfs_readv(file, (struct iovec __user *)vec, vlen, &offset, 0);\n\tset_fs(oldfs);\n\treturn nfsd_finish_read(file, count, host_err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd_readv(struct file *file, loff_t offset, struct kvec *vec, int vlen,\n\t\tunsigned long *count)\n{\n\tmm_segment_t oldfs;\n\tint host_err;\n\n\toldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\thost_err = vfs_readv(file, (struct iovec __user *)vec, vlen, &offset, 0);\n\tset_fs(oldfs);\n\treturn nfsd_finish_read(file, count, host_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!p"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "(thislen+3)&~3"
          ],
          "line": 3452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "len",
            "PAGE_SIZE"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!p"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "(thislen+3)&~3"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "long",
            "len",
            "((void *)xdr->end - (void *)xdr->p)"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_readv(struct nfsd4_compoundres *resp,\n\t\t\t\t struct nfsd4_read *read,\n\t\t\t\t struct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tu32 eof;\n\tint v;\n\tint starting_len = xdr->buf->len - 8;\n\tlong len;\n\tint thislen;\n\t__be32 nfserr;\n\t__be32 tmp;\n\t__be32 *p;\n\tu32 zzz = 0;\n\tint pad;\n\n\tlen = maxcount;\n\tv = 0;\n\n\tthislen = min_t(long, len, ((void *)xdr->end - (void *)xdr->p));\n\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\tWARN_ON_ONCE(!p);\n\tresp->rqstp->rq_vec[v].iov_base = p;\n\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\tv++;\n\tlen -= thislen;\n\n\twhile (len) {\n\t\tthislen = min_t(long, len, PAGE_SIZE);\n\t\tp = xdr_reserve_space(xdr, (thislen+3)&~3);\n\t\tWARN_ON_ONCE(!p);\n\t\tresp->rqstp->rq_vec[v].iov_base = p;\n\t\tresp->rqstp->rq_vec[v].iov_len = thislen;\n\t\tv++;\n\t\tlen -= thislen;\n\t}\n\tread->rd_vlen = v;\n\n\tlen = maxcount;\n\tnfserr = nfsd_readv(file, read->rd_offset, resp->rqstp->rq_vec,\n\t\t\tread->rd_vlen, &maxcount);\n\tif (nfserr)\n\t\treturn nfserr;\n\txdr_truncate_encode(xdr, starting_len + 8 + ((maxcount+3)&~3));\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\ttmp = htonl(eof);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len    , &tmp, 4);\n\ttmp = htonl(maxcount);\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 4, &tmp, 4);\n\n\tpad = (maxcount&3) ? 4 - (maxcount&3) : 0;\n\twrite_bytes_to_xdr_buf(xdr->buf, starting_len + 8 + maxcount,\n\t\t\t\t\t\t\t\t&zzz, pad);\n\treturn 0;\n\n}"
  },
  {
    "function_name": "nfsd4_encode_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3360-3421",
    "snippet": "static __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tlong len;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tlen = maxcount;\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "(void *)xdr->end - (void *)xdr->p",
            "buf->buflen - buf->len"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "maxcount"
          ],
          "line": 3394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "eof"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_eof_on_read",
          "args": [
            "len",
            "maxcount",
            "read->rd_offset",
            "d_inode(read->rd_fhp->fh_dentry)->i_size"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_eof_on_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "142-159",
          "snippet": "static inline bool nfsd_eof_on_read(long requested, long read,\n\t\t\t\tloff_t offset, loff_t size)\n{\n\t/* We assume a short read means eof: */\n\tif (requested > read)\n\t\treturn true;\n\t/*\n\t * A non-short read might also reach end of file.  The spec\n\t * still requires us to set eof in that case.\n\t *\n\t * Further operations may have modified the file size since\n\t * the read, so the following check is not atomic with the read.\n\t * We've only seen that cause a problem for a client in the case\n\t * where the read returned a count of 0 without setting eof.\n\t * That case was fixed by the addition of the above check.\n\t */\n\treturn (offset + read >= size);\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline bool nfsd_eof_on_read(long requested, long read,\n\t\t\t\tloff_t offset, loff_t size)\n{\n\t/* We assume a short read means eof: */\n\tif (requested > read)\n\t\treturn true;\n\t/*\n\t * A non-short read might also reach end of file.  The spec\n\t * still requires us to set eof in that case.\n\t *\n\t * Further operations may have modified the file size since\n\t * the read, so the following check is not atomic with the read.\n\t * We've only seen that cause a problem for a client in the case\n\t * where the read returned a count of 0 without setting eof.\n\t * That case was fixed by the addition of the above check.\n\t */\n\treturn (offset + read >= size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "read->rd_fhp->fh_dentry"
          ],
          "line": 3391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_splice_read",
          "args": [
            "read->rd_rqstp",
            "file",
            "read->rd_offset",
            "&maxcount"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "849-863",
          "snippet": "__be32 nfsd_splice_read(struct svc_rqst *rqstp,\n\t\t     struct file *file, loff_t offset, unsigned long *count)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= 0,\n\t\t.total_len\t= *count,\n\t\t.pos\t\t= offset,\n\t\t.u.data\t\t= rqstp,\n\t};\n\tint host_err;\n\n\trqstp->rq_next_page = rqstp->rq_respages + 1;\n\thost_err = splice_direct_to_actor(file, &sd, nfsd_direct_splice_actor);\n\treturn nfsd_finish_read(file, count, host_err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd_splice_read(struct svc_rqst *rqstp,\n\t\t     struct file *file, loff_t offset, unsigned long *count)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= 0,\n\t\t.total_len\t= *count,\n\t\t.pos\t\t= offset,\n\t\t.u.data\t\t= rqstp,\n\t};\n\tint host_err;\n\n\trqstp->rq_next_page = rqstp->rq_respages + 1;\n\thost_err = splice_direct_to_actor(file, &sd, nfsd_direct_splice_actor);\n\treturn nfsd_finish_read(file, count, host_err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_splice_read(\n\t\t\t\tstruct nfsd4_compoundres *resp,\n\t\t\t\tstruct nfsd4_read *read,\n\t\t\t\tstruct file *file, unsigned long maxcount)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct xdr_buf *buf = xdr->buf;\n\tu32 eof;\n\tlong len;\n\tint space_left;\n\t__be32 nfserr;\n\t__be32 *p = xdr->p - 2;\n\n\t/* Make sure there will be room for padding if needed */\n\tif (xdr->end - xdr->p < 1)\n\t\treturn nfserr_resource;\n\n\tlen = maxcount;\n\tnfserr = nfsd_splice_read(read->rd_rqstp, file,\n\t\t\t\t  read->rd_offset, &maxcount);\n\tif (nfserr) {\n\t\t/*\n\t\t * nfsd_splice_actor may have already messed with the\n\t\t * page length; reset it so as not to confuse\n\t\t * xdr_truncate_encode:\n\t\t */\n\t\tbuf->page_len = 0;\n\t\treturn nfserr;\n\t}\n\n\teof = nfsd_eof_on_read(len, maxcount, read->rd_offset,\n\t\t\t\td_inode(read->rd_fhp->fh_dentry)->i_size);\n\n\t*(p++) = htonl(eof);\n\t*(p++) = htonl(maxcount);\n\n\tbuf->page_len = maxcount;\n\tbuf->len += maxcount;\n\txdr->page_ptr += (buf->page_base + maxcount + PAGE_SIZE - 1)\n\t\t\t\t\t\t\t/ PAGE_SIZE;\n\n\t/* Use rest of head for padding and remaining ops: */\n\tbuf->tail[0].iov_base = xdr->p;\n\tbuf->tail[0].iov_len = 0;\n\txdr->iov = buf->tail;\n\tif (maxcount&3) {\n\t\tint pad = 4 - (maxcount&3);\n\n\t\t*(xdr->p++) = 0;\n\n\t\tbuf->tail[0].iov_base += maxcount&3;\n\t\tbuf->tail[0].iov_len = pad;\n\t\tbuf->len += pad;\n\t}\n\n\tspace_left = min_t(int, (void *)xdr->end - (void *)xdr->p,\n\t\t\t\tbuf->buflen - buf->len);\n\tbuf->buflen = buf->len + space_left;\n\txdr->end = (__be32 *)((void *)xdr->end + space_left);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_open_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3349-3358",
    "snippet": "static __be32\nnfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_downgrade *od)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &od->od_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&od->od_stateid"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3024-3036",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_open_downgrade(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_downgrade *od)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &od->od_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_open_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3338-3347",
    "snippet": "static __be32\nnfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_confirm *oc)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &oc->oc_resp_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&oc->oc_resp_stateid"
          ],
          "line": 3344
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3024-3036",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_open_confirm(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open_confirm *oc)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &oc->oc_resp_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3240-3336",
    "snippet": "static __be32\nnfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open *open)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfsd4_encode_stateid(xdr, &open->op_stateid);\n\tif (nfserr)\n\t\tgoto out;\n\tp = xdr_reserve_space(xdr, 24);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = encode_cinfo(p, &open->op_cinfo);\n\t*p++ = cpu_to_be32(open->op_rflags);\n\n\tnfserr = nfsd4_encode_bitmap(xdr, open->op_bmval[0], open->op_bmval[1],\n\t\t\t\t\topen->op_bmval[2]);\n\tif (nfserr)\n\t\tgoto out;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p++ = cpu_to_be32(open->op_delegate_type);\n\tswitch (open->op_delegate_type) {\n\tcase NFS4_OPEN_DELEGATE_NONE:\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_READ:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(open->op_recall);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 32);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\n\t\t/*\n\t\t * TODO: space_limit's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_LIMIT_SIZE);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_NONE_EXT: /* 4.1 */\n\t\tswitch (open->op_why_no_deleg) {\n\t\tcase WND4_CONTENTION:\n\t\tcase WND4_RESOURCE:\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t\t/* deleg signaling not supported yet: */\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t/* XXX save filehandle here */\nout:\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_why_no_deleg"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_why_no_deleg"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "~(u32)0"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "~(u32)0"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_LIMIT_SIZE"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "32"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&open->op_delegate_stateid"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3024-3036",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_recall"
          ],
          "line": 3278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_delegate_type"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_bitmap",
          "args": [
            "xdr",
            "open->op_bmval[0]",
            "open->op_bmval[1]",
            "open->op_bmval[2]"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2252-2283",
          "snippet": "static __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "open->op_rflags"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&open->op_cinfo"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1925-1938",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "24"
          ],
          "line": 3252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_open(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_open *open)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (nfserr)\n\t\tgoto out;\n\n\tnfserr = nfsd4_encode_stateid(xdr, &open->op_stateid);\n\tif (nfserr)\n\t\tgoto out;\n\tp = xdr_reserve_space(xdr, 24);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp = encode_cinfo(p, &open->op_cinfo);\n\t*p++ = cpu_to_be32(open->op_rflags);\n\n\tnfserr = nfsd4_encode_bitmap(xdr, open->op_bmval[0], open->op_bmval[1],\n\t\t\t\t\topen->op_bmval[2]);\n\tif (nfserr)\n\t\tgoto out;\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t*p++ = cpu_to_be32(open->op_delegate_type);\n\tswitch (open->op_delegate_type) {\n\tcase NFS4_OPEN_DELEGATE_NONE:\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_READ:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(open->op_recall);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_WRITE:\n\t\tnfserr = nfsd4_encode_stateid(xdr, &open->op_delegate_stateid);\n\t\tif (nfserr)\n\t\t\treturn nfserr;\n\t\tp = xdr_reserve_space(xdr, 32);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\n\t\t/*\n\t\t * TODO: space_limit's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_LIMIT_SIZE);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\t\t*p++ = cpu_to_be32(~(u32)0);\n\n\t\t/*\n\t\t * TODO: ACE's in delegations\n\t\t */\n\t\t*p++ = cpu_to_be32(NFS4_ACE_ACCESS_ALLOWED_ACE_TYPE);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(0);   /* XXX: is NULL principal ok? */\n\t\tbreak;\n\tcase NFS4_OPEN_DELEGATE_NONE_EXT: /* 4.1 */\n\t\tswitch (open->op_why_no_deleg) {\n\t\tcase WND4_CONTENTION:\n\t\tcase WND4_RESOURCE:\n\t\t\tp = xdr_reserve_space(xdr, 8);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t\t/* deleg signaling not supported yet: */\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\t*p++ = cpu_to_be32(open->op_why_no_deleg);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\t/* XXX save filehandle here */\nout:\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3224-3237",
    "snippet": "static __be32\nnfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_link *link)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &link->li_cinfo);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&link->li_cinfo"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1925-1938",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_link(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_link *link)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = encode_cinfo(p, &link->li_cinfo);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_locku",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3212-3221",
    "snippet": "static __be32\nnfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_locku *locku)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &locku->lu_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&locku->lu_stateid"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3024-3036",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_locku(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_locku *locku)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &locku->lu_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_lockt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3202-3210",
    "snippet": "static __be32\nnfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lockt *lockt)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr == nfserr_denied)\n\t\tnfsd4_encode_lock_denied(xdr, &lockt->lt_denied);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_lock_denied",
          "args": [
            "xdr",
            "&lockt->lt_denied"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3154-3187",
          "snippet": "static __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_lockt(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lockt *lockt)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr == nfserr_denied)\n\t\tnfsd4_encode_lock_denied(xdr, &lockt->lt_denied);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3189-3200",
    "snippet": "static __be32\nnfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\n\telse if (nfserr == nfserr_denied)\n\t\tnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_lock_denied",
          "args": [
            "xdr",
            "&lock->lk_denied"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3154-3187",
          "snippet": "static __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&lock->lk_resp_stateid"
          ],
          "line": 3195
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3024-3036",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_lock(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_lock *lock)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &lock->lk_resp_stateid);\n\telse if (nfserr == nfserr_denied)\n\t\tnfserr = nfsd4_encode_lock_denied(xdr, &lock->lk_denied);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_lock_denied",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3154-3187",
    "snippet": "static __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64)0"
          ],
          "line": 3183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "conf->data"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "conf->data",
            "conf->len"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&ld->ld_clientid",
            "8"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ld->ld_type"
          ],
          "line": 3177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "ld->ld_length"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "ld->ld_start"
          ],
          "line": 3175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "conf->data"
          ],
          "line": 3168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "32 + XDR_LEN(conf->len)"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_LEN",
          "args": [
            "conf->len"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_lock_denied(struct xdr_stream *xdr, struct nfsd4_lock_denied *ld)\n{\n\tstruct xdr_netobj *conf = &ld->ld_owner;\n\t__be32 *p;\n\nagain:\n\tp = xdr_reserve_space(xdr, 32 + XDR_LEN(conf->len));\n\tif (!p) {\n\t\t/*\n\t\t * Don't fail to return the result just because we can't\n\t\t * return the conflicting open:\n\t\t */\n\t\tif (conf->len) {\n\t\t\tkfree(conf->data);\n\t\t\tconf->len = 0;\n\t\t\tconf->data = NULL;\n\t\t\tgoto again;\n\t\t}\n\t\treturn nfserr_resource;\n\t}\n\tp = xdr_encode_hyper(p, ld->ld_start);\n\tp = xdr_encode_hyper(p, ld->ld_length);\n\t*p++ = cpu_to_be32(ld->ld_type);\n\tif (conf->len) {\n\t\tp = xdr_encode_opaque_fixed(p, &ld->ld_clientid, 8);\n\t\tp = xdr_encode_opaque(p, conf->data, conf->len);\n\t\tkfree(conf->data);\n\t}  else {  /* non - nfsv4 lock in conflict, no clientid nor owner */\n\t\tp = xdr_encode_hyper(p, (u64)0); /* clientid */\n\t\t*p++ = cpu_to_be32(0); /* length of owner name */\n\t}\n\treturn nfserr_denied;\n}"
  },
  {
    "function_name": "nfsd4_encode_getfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3132-3148",
    "snippet": "static __be32\nnfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh **fhpp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct svc_fh *fhp = *fhpp;\n\tunsigned int len;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tlen = fhp->fh_handle.fh_size;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base, len);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "&fhp->fh_handle.fh_base",
            "len"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len + 4"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_getfh(struct nfsd4_compoundres *resp, __be32 nfserr, struct svc_fh **fhpp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct svc_fh *fhp = *fhpp;\n\tunsigned int len;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tlen = fhp->fh_handle.fh_size;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base, len);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3117-3130",
    "snippet": "static __be32\nnfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getattr *getattr)\n{\n\tstruct svc_fh *fhp = getattr->ga_fhp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tnfserr = nfsd4_encode_fattr(xdr, fhp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\t    getattr->ga_bmval,\n\t\t\t\t    resp->rqstp, 0);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_fattr",
          "args": [
            "xdr",
            "fhp",
            "fhp->fh_export",
            "fhp->fh_dentry",
            "getattr->ga_bmval",
            "resp->rqstp",
            "0"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2289-2813",
          "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
            "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_getattr(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_getattr *getattr)\n{\n\tstruct svc_fh *fhp = getattr->ga_fhp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (nfserr)\n\t\treturn nfserr;\n\n\tnfserr = nfsd4_encode_fattr(xdr, fhp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\t    getattr->ga_bmval,\n\t\t\t\t    resp->rqstp, 0);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3100-3115",
    "snippet": "static __be32\nnfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_create *create)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tencode_cinfo(p, &create->cr_cinfo);\n\t\tnfserr = nfsd4_encode_bitmap(xdr, create->cr_bmval[0],\n\t\t\t\tcreate->cr_bmval[1], create->cr_bmval[2]);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_bitmap",
          "args": [
            "xdr",
            "create->cr_bmval[0]",
            "create->cr_bmval[1]",
            "create->cr_bmval[2]"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2252-2283",
          "snippet": "static __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_cinfo",
          "args": [
            "p",
            "&create->cr_cinfo"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "encode_cinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1925-1938",
          "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_create(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_create *create)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 20);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tencode_cinfo(p, &create->cr_cinfo);\n\t\tnfserr = nfsd4_encode_bitmap(xdr, create->cr_bmval[0],\n\t\t\t\tcreate->cr_bmval[1], create->cr_bmval[2]);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3084-3098",
    "snippet": "static __be32\nnfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_commit *commit)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, commit->co_verf.data,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "commit->co_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 3091
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_commit(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_commit *commit)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_VERIFIER_SIZE);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, commit->co_verf.data,\n\t\t\t\t\t\tNFS4_VERIFIER_SIZE);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3072-3081",
    "snippet": "static __be32\nnfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_close *close)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &close->cl_stateid);\n\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_stateid",
          "args": [
            "xdr",
            "&close->cl_stateid"
          ],
          "line": 3078
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "3024-3036",
          "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_close(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_close *close)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\n\tif (!nfserr)\n\t\tnfserr = nfsd4_encode_stateid(xdr, &close->cl_stateid);\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3054-3070",
    "snippet": "static __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, bcts->sessionid.data,\n\t\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t\t*p++ = cpu_to_be32(bcts->dir);\n\t\t/* Upshifting from TCP to RDMA is not supported */\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bcts->dir"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "bcts->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "NFS4_MAX_SESSIONID_LEN + 8"
          ],
          "line": 3060
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_bind_conn_to_session(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN + 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque_fixed(p, bcts->sessionid.data,\n\t\t\t\t\t\tNFS4_MAX_SESSIONID_LEN);\n\t\t*p++ = cpu_to_be32(bcts->dir);\n\t\t/* Upshifting from TCP to RDMA is not supported */\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3038-3052",
    "snippet": "static __be32\nnfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_access *access)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(access->ac_supported);\n\t\t*p++ = cpu_to_be32(access->ac_resp_access);\n\t}\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "access->ac_resp_access"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "access->ac_supported"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_access(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_access *access)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\n\tif (!nfserr) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(access->ac_supported);\n\t\t*p++ = cpu_to_be32(access->ac_resp_access);\n\t}\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_encode_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "3024-3036",
    "snippet": "static __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "&sid->si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sid->si_generation"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "sizeof(stateid_t)"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_stateid(struct xdr_stream *xdr, stateid_t *sid)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, sizeof(stateid_t));\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(sid->si_generation);\n\tp = xdr_encode_opaque_fixed(p, &sid->si_opaque,\n\t\t\t\t\tsizeof(stateid_opaque_t));\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_dirent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2934-3022",
    "snippet": "static int\nnfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\n\t\t    loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\n\tstruct xdr_stream *xdr = cd->xdr;\n\tint start_offset = xdr->buf->len;\n\tint cookie_offset;\n\tu32 name_and_cookie;\n\tint entry_bytes;\n\t__be32 nfserr = nfserr_toosmall;\n\t__be64 wire_offset;\n\t__be32 *p;\n\n\t/* In nfsv4, \".\" and \"..\" never make it onto the wire.. */\n\tif (name && isdotent(name, namlen)) {\n\t\tcd->common.err = nfs_ok;\n\t\treturn 0;\n\t}\n\n\tif (cd->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto fail;\n\t*p++ = xdr_one;                             /* mark entry present */\n\tcookie_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 3*4 + namlen);\n\tif (!p)\n\t\tgoto fail;\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);    /* offset of next entry */\n\tp = xdr_encode_array(p, name, namlen);      /* name length & name */\n\n\tnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\tbreak;\n\tcase nfserr_resource:\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto fail;\n\tcase nfserr_noent:\n\t\txdr_truncate_encode(xdr, start_offset);\n\t\tgoto skip_entry;\n\tdefault:\n\t\t/*\n\t\t * If the client requested the RDATTR_ERROR attribute,\n\t\t * we stuff the error code into this attribute\n\t\t * and continue.  If this attribute was not requested,\n\t\t * then in accordance with the spec, we fail the\n\t\t * entire READDIR operation(!)\n\t\t */\n\t\tif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\n\t\t\tgoto fail;\n\t\tp = nfsd4_encode_rdattr_error(xdr, nfserr);\n\t\tif (p == NULL) {\n\t\t\tnfserr = nfserr_toosmall;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tnfserr = nfserr_toosmall;\n\tentry_bytes = xdr->buf->len - start_offset;\n\tif (entry_bytes > cd->rd_maxcount)\n\t\tgoto fail;\n\tcd->rd_maxcount -= entry_bytes;\n\t/*\n\t * RFC 3530 14.2.24 describes rd_dircount as only a \"hint\", so\n\t * let's always let through the first entry, at least:\n\t */\n\tif (!cd->rd_dircount)\n\t\tgoto fail;\n\tname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\n\tif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\n\t\tgoto fail;\n\tcd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\n\n\tcd->cookie_offset = cookie_offset;\nskip_entry:\n\tcd->common.err = nfs_ok;\n\treturn 0;\nfail:\n\txdr_truncate_encode(xdr, start_offset);\n\tcd->common.err = nfserr;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "start_offset"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cd->rd_dircount",
            "name_and_cookie"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "namlen"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_rdattr_error",
          "args": [
            "xdr",
            "nfserr"
          ],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_rdattr_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2917-2932",
          "snippet": "static __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "start_offset"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_dirent_fattr",
          "args": [
            "xdr",
            "cd",
            "name",
            "namlen"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_dirent_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2855-2915",
          "snippet": "static __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len_unlocked(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (d_really_is_negative(dentry)) {\n\t\t/*\n\t\t * we're not holding the i_mutex here, so there's\n\t\t * a window where this directory entry could have gone\n\t\t * away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len_unlocked(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (d_really_is_negative(dentry)) {\n\t\t/*\n\t\t * we're not holding the i_mutex here, so there's\n\t\t * a window where this directory entry could have gone\n\t\t * away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_array",
          "args": [
            "p",
            "name",
            "namlen"
          ],
          "line": 2970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS_OFFSET_MAX"
          ],
          "line": 2969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "3*4 + namlen"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "cd->cookie_offset",
            "&wire_offset",
            "8"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "offset"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdotent",
          "args": [
            "name",
            "namlen"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ccd",
            "structnfsd4_readdir",
            "common"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_encode_dirent(void *ccdv, const char *name, int namlen,\n\t\t    loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd4_readdir *cd = container_of(ccd, struct nfsd4_readdir, common);\n\tstruct xdr_stream *xdr = cd->xdr;\n\tint start_offset = xdr->buf->len;\n\tint cookie_offset;\n\tu32 name_and_cookie;\n\tint entry_bytes;\n\t__be32 nfserr = nfserr_toosmall;\n\t__be64 wire_offset;\n\t__be32 *p;\n\n\t/* In nfsv4, \".\" and \"..\" never make it onto the wire.. */\n\tif (name && isdotent(name, namlen)) {\n\t\tcd->common.err = nfs_ok;\n\t\treturn 0;\n\t}\n\n\tif (cd->cookie_offset) {\n\t\twire_offset = cpu_to_be64(offset);\n\t\twrite_bytes_to_xdr_buf(xdr->buf, cd->cookie_offset,\n\t\t\t\t\t\t\t&wire_offset, 8);\n\t}\n\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto fail;\n\t*p++ = xdr_one;                             /* mark entry present */\n\tcookie_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 3*4 + namlen);\n\tif (!p)\n\t\tgoto fail;\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);    /* offset of next entry */\n\tp = xdr_encode_array(p, name, namlen);      /* name length & name */\n\n\tnfserr = nfsd4_encode_dirent_fattr(xdr, cd, name, namlen);\n\tswitch (nfserr) {\n\tcase nfs_ok:\n\t\tbreak;\n\tcase nfserr_resource:\n\t\tnfserr = nfserr_toosmall;\n\t\tgoto fail;\n\tcase nfserr_noent:\n\t\txdr_truncate_encode(xdr, start_offset);\n\t\tgoto skip_entry;\n\tdefault:\n\t\t/*\n\t\t * If the client requested the RDATTR_ERROR attribute,\n\t\t * we stuff the error code into this attribute\n\t\t * and continue.  If this attribute was not requested,\n\t\t * then in accordance with the spec, we fail the\n\t\t * entire READDIR operation(!)\n\t\t */\n\t\tif (!(cd->rd_bmval[0] & FATTR4_WORD0_RDATTR_ERROR))\n\t\t\tgoto fail;\n\t\tp = nfsd4_encode_rdattr_error(xdr, nfserr);\n\t\tif (p == NULL) {\n\t\t\tnfserr = nfserr_toosmall;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tnfserr = nfserr_toosmall;\n\tentry_bytes = xdr->buf->len - start_offset;\n\tif (entry_bytes > cd->rd_maxcount)\n\t\tgoto fail;\n\tcd->rd_maxcount -= entry_bytes;\n\t/*\n\t * RFC 3530 14.2.24 describes rd_dircount as only a \"hint\", so\n\t * let's always let through the first entry, at least:\n\t */\n\tif (!cd->rd_dircount)\n\t\tgoto fail;\n\tname_and_cookie = 4 + 4 * XDR_QUADLEN(namlen) + 8;\n\tif (name_and_cookie > cd->rd_dircount && cd->cookie_offset)\n\t\tgoto fail;\n\tcd->rd_dircount -= min(cd->rd_dircount, name_and_cookie);\n\n\tcd->cookie_offset = cookie_offset;\nskip_entry:\n\tcd->common.err = nfs_ok;\n\treturn 0;\nfail:\n\txdr_truncate_encode(xdr, start_offset);\n\tcd->common.err = nfserr;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "nfsd4_encode_rdattr_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2917-2932",
    "snippet": "static __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "4"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "0"
          ],
          "line": 2927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "FATTR4_WORD0_RDATTR_ERROR"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "2"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "20"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *\nnfsd4_encode_rdattr_error(struct xdr_stream *xdr, __be32 nfserr)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 20);\n\tif (!p)\n\t\treturn NULL;\n\t*p++ = htonl(2);\n\t*p++ = htonl(FATTR4_WORD0_RDATTR_ERROR); /* bmval0 */\n\t*p++ = htonl(0);\t\t\t /* bmval1 */\n\n\t*p++ = htonl(4);     /* attribute length */\n\t*p++ = nfserr;       /* no htonl */\n\treturn p;\n}"
  },
  {
    "function_name": "nfsd4_encode_dirent_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2855-2915",
    "snippet": "static __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len_unlocked(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (d_really_is_negative(dentry)) {\n\t\t/*\n\t\t * we're not holding the i_mutex here, so there's\n\t\t * a window where this directory entry could have gone\n\t\t * away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_fattr",
          "args": [
            "xdr",
            "NULL",
            "exp",
            "dentry",
            "cd->rd_bmval",
            "cd->rd_rqstp",
            "ignore_crossmnt"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2289-2813",
          "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
            "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_nfsd_access",
          "args": [
            "exp",
            "cd->rd_rqstp"
          ],
          "line": 2903
        },
        "resolved": true,
        "details": {
          "function_name": "check_nfsd_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "938-958",
          "snippet": "__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_cross_mnt",
          "args": [
            "cd->rd_rqstp",
            "&dentry",
            "&exp"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_cross_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "84-131",
          "snippet": "int\nnfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp, \n\t\t        struct svc_export **expp)\n{\n\tstruct svc_export *exp = *expp, *exp2 = NULL;\n\tstruct dentry *dentry = *dpp;\n\tstruct path path = {.mnt = mntget(exp->ex_path.mnt),\n\t\t\t    .dentry = dget(dentry)};\n\tint err = 0;\n\n\terr = follow_down(&path);\n\tif (err < 0)\n\t\tgoto out;\n\n\texp2 = rqst_exp_get_by_name(rqstp, &path);\n\tif (IS_ERR(exp2)) {\n\t\terr = PTR_ERR(exp2);\n\t\t/*\n\t\t * We normally allow NFS clients to continue\n\t\t * \"underneath\" a mountpoint that is not exported.\n\t\t * The exception is V4ROOT, where no traversal is ever\n\t\t * allowed without an explicit export of the new\n\t\t * directory.\n\t\t */\n\t\tif (err == -ENOENT && !(exp->ex_flags & NFSEXP_V4ROOT))\n\t\t\terr = 0;\n\t\tpath_put(&path);\n\t\tgoto out;\n\t}\n\tif (nfsd_v4client(rqstp) ||\n\t\t(exp->ex_flags & NFSEXP_CROSSMOUNT) || EX_NOHIDE(exp2)) {\n\t\t/* successfully crossed mount point */\n\t\t/*\n\t\t * This is subtle: path.dentry is *not* on path.mnt\n\t\t * at this point.  The only reason we are safe is that\n\t\t * original mnt is pinned down by exp, so we should\n\t\t * put path *before* putting exp\n\t\t */\n\t\t*dpp = path.dentry;\n\t\tpath.dentry = dentry;\n\t\t*expp = exp2;\n\t\texp2 = exp;\n\t}\n\tpath_put(&path);\n\texp_put(exp2);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint\nnfsd_cross_mnt(struct svc_rqst *rqstp, struct dentry **dpp, \n\t\t        struct svc_export **expp)\n{\n\tstruct svc_export *exp = *expp, *exp2 = NULL;\n\tstruct dentry *dentry = *dpp;\n\tstruct path path = {.mnt = mntget(exp->ex_path.mnt),\n\t\t\t    .dentry = dget(dentry)};\n\tint err = 0;\n\n\terr = follow_down(&path);\n\tif (err < 0)\n\t\tgoto out;\n\n\texp2 = rqst_exp_get_by_name(rqstp, &path);\n\tif (IS_ERR(exp2)) {\n\t\terr = PTR_ERR(exp2);\n\t\t/*\n\t\t * We normally allow NFS clients to continue\n\t\t * \"underneath\" a mountpoint that is not exported.\n\t\t * The exception is V4ROOT, where no traversal is ever\n\t\t * allowed without an explicit export of the new\n\t\t * directory.\n\t\t */\n\t\tif (err == -ENOENT && !(exp->ex_flags & NFSEXP_V4ROOT))\n\t\t\terr = 0;\n\t\tpath_put(&path);\n\t\tgoto out;\n\t}\n\tif (nfsd_v4client(rqstp) ||\n\t\t(exp->ex_flags & NFSEXP_CROSSMOUNT) || EX_NOHIDE(exp2)) {\n\t\t/* successfully crossed mount point */\n\t\t/*\n\t\t * This is subtle: path.dentry is *not* on path.mnt\n\t\t * at this point.  The only reason we are safe is that\n\t\t * original mnt is pinned down by exp, so we should\n\t\t * put path *before* putting exp\n\t\t */\n\t\t*dpp = path.dentry;\n\t\tpath.dentry = dentry;\n\t\t*expp = exp2;\n\t\texp2 = exp;\n\t}\n\tpath_put(&path);\n\texp_put(exp2);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "attributes_need_mount",
          "args": [
            "cd->rd_bmval"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "attributes_need_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2846-2853",
          "snippet": "static inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_mountpoint",
          "args": [
            "dentry",
            "exp"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "171-180",
          "snippet": "int nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)\n{\n\tif (d_mountpoint(dentry))\n\t\treturn 1;\n\tif (nfsd4_is_junction(dentry))\n\t\treturn 1;\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn 0;\n\treturn d_inode(dentry) != NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)\n{\n\tif (d_mountpoint(dentry))\n\t\treturn 1;\n\tif (nfsd4_is_junction(dentry))\n\t\treturn 1;\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn 0;\n\treturn d_inode(dentry) != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "exp"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "107-111",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_negative",
          "args": [
            "dentry"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len_unlocked",
          "args": [
            "name",
            "cd->rd_fhp->fh_dentry",
            "namlen"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_dirent_fattr(struct xdr_stream *xdr, struct nfsd4_readdir *cd,\n\t\t\tconst char *name, int namlen)\n{\n\tstruct svc_export *exp = cd->rd_fhp->fh_export;\n\tstruct dentry *dentry;\n\t__be32 nfserr;\n\tint ignore_crossmnt = 0;\n\n\tdentry = lookup_one_len_unlocked(name, cd->rd_fhp->fh_dentry, namlen);\n\tif (IS_ERR(dentry))\n\t\treturn nfserrno(PTR_ERR(dentry));\n\tif (d_really_is_negative(dentry)) {\n\t\t/*\n\t\t * we're not holding the i_mutex here, so there's\n\t\t * a window where this directory entry could have gone\n\t\t * away.\n\t\t */\n\t\tdput(dentry);\n\t\treturn nfserr_noent;\n\t}\n\n\texp_get(exp);\n\t/*\n\t * In the case of a mountpoint, the client may be asking for\n\t * attributes that are only properties of the underlying filesystem\n\t * as opposed to the cross-mounted file system. In such a case,\n\t * we will not follow the cross mount and will fill the attribtutes\n\t * directly from the mountpoint dentry.\n\t */\n\tif (nfsd_mountpoint(dentry, exp)) {\n\t\tint err;\n\n\t\tif (!(exp->ex_flags & NFSEXP_V4ROOT)\n\t\t\t\t&& !attributes_need_mount(cd->rd_bmval)) {\n\t\t\tignore_crossmnt = 1;\n\t\t\tgoto out_encode;\n\t\t}\n\t\t/*\n\t\t * Why the heck aren't we just using nfsd_lookup??\n\t\t * Different \".\"/\"..\" handling?  Something else?\n\t\t * At least, add a comment here to explain....\n\t\t */\n\t\terr = nfsd_cross_mnt(cd->rd_rqstp, &dentry, &exp);\n\t\tif (err) {\n\t\t\tnfserr = nfserrno(err);\n\t\t\tgoto out_put;\n\t\t}\n\t\tnfserr = check_nfsd_access(exp, cd->rd_rqstp);\n\t\tif (nfserr)\n\t\t\tgoto out_put;\n\n\t}\nout_encode:\n\tnfserr = nfsd4_encode_fattr(xdr, NULL, exp, dentry, cd->rd_bmval,\n\t\t\t\t\tcd->rd_rqstp, ignore_crossmnt);\nout_put:\n\tdput(dentry);\n\texp_put(exp);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "attributes_need_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2846-2853",
    "snippet": "static inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline int attributes_need_mount(u32 *bmval)\n{\n\tif (bmval[0] & ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))\n\t\treturn 1;\n\tif (bmval[1] & ~FATTR4_WORD1_MOUNTED_ON_FILEID)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_fattr_to_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2830-2844",
    "snippet": "__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\n\t\t\tstruct svc_fh *fhp, struct svc_export *exp,\n\t\t\tstruct dentry *dentry, u32 *bmval,\n\t\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tstruct xdr_buf dummy;\n\tstruct xdr_stream xdr;\n\t__be32 ret;\n\n\tsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\n\tret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\n\t\t\t\t\t\t\tignore_crossmnt);\n\t*p = xdr.p;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_fattr",
          "args": [
            "&xdr",
            "fhp",
            "exp",
            "dentry",
            "bmval",
            "rqstp",
            "ignore_crossmnt"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2289-2813",
          "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
            "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svcxdr_init_encode_from_buffer",
          "args": [
            "&xdr",
            "&dummy",
            "*p",
            "words << 2"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_init_encode_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2815-2828",
          "snippet": "static void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n__be32 nfsd4_encode_fattr_to_buf(__be32 **p, int words,\n\t\t\tstruct svc_fh *fhp, struct svc_export *exp,\n\t\t\tstruct dentry *dentry, u32 *bmval,\n\t\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tstruct xdr_buf dummy;\n\tstruct xdr_stream xdr;\n\t__be32 ret;\n\n\tsvcxdr_init_encode_from_buffer(&xdr, &dummy, *p, words << 2);\n\tret = nfsd4_encode_fattr(&xdr, fhp, exp, dentry, bmval, rqstp,\n\t\t\t\t\t\t\tignore_crossmnt);\n\t*p = xdr.p;\n\treturn ret;\n}"
  },
  {
    "function_name": "svcxdr_init_encode_from_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2815-2828",
    "snippet": "static void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(struct xdr_buf)"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void svcxdr_init_encode_from_buffer(struct xdr_stream *xdr,\n\t\t\t\tstruct xdr_buf *buf, __be32 *p, int bytes)\n{\n\txdr->scratch.iov_len = 0;\n\tmemset(buf, 0, sizeof(struct xdr_buf));\n\tbuf->head[0].iov_base = p;\n\tbuf->head[0].iov_len = 0;\n\tbuf->len = 0;\n\txdr->buf = buf;\n\txdr->iov = buf->head;\n\txdr->p = p;\n\txdr->end = (void *)p + bytes;\n\tbuf->buflen = bytes;\n}"
  },
  {
    "function_name": "nfsd4_encode_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2289-2813",
    "snippet": "static __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL",
      "#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_truncate_encode",
          "args": [
            "xdr",
            "starting_len"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tempfh"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "tempfh"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "acl"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "context",
            "contextlen"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "attrlen_offset",
            "&attrlen",
            "4"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "xdr->buf->len - attrlen_offset - 4"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_security_label",
          "args": [
            "xdr",
            "rqstp",
            "context",
            "contextlen"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_security_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2213-2216",
          "snippet": "static inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_bitmap",
          "args": [
            "xdr",
            "NFSD_SUPPATTR_EXCLCREAT_WORD0",
            "NFSD_SUPPATTR_EXCLCREAT_WORD1",
            "NFSD_SUPPATTR_EXCLCREAT_WORD2"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2252-2283",
          "snippet": "static __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.blksize"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_layout_type",
          "args": [
            "xdr",
            "exp->ex_layout_type"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_layout_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2166-2185",
          "snippet": "static inline __be32\nnfsd4_encode_layout_type(struct xdr_stream *xdr, enum pnfs_layouttype layout_type)\n{\n\t__be32 *p;\n\n\tif (layout_type) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(layout_type);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_encode_layout_type(struct xdr_stream *xdr, enum pnfs_layouttype layout_type)\n{\n\t__be32 *p;\n\n\tif (layout_type) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(layout_type);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "ino"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_parent_attributes",
          "args": [
            "exp",
            "&parent_stat"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "get_parent_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2237-2250",
          "snippet": "static int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.mtime.tv_nsec"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(s64)stat.mtime.tv_sec"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.ctime.tv_nsec"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(s64)stat.ctime.tv_sec"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.atime.tv_nsec"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(s64)stat.atime.tv_sec"
          ],
          "line": 2710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "dummy64"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(u32) MINOR(stat.rdev)"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "stat.rdev"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "(u32) MAJOR(stat.rdev)"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "stat.rdev"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_group",
          "args": [
            "xdr",
            "rqstp",
            "stat.gid"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4idmap.c",
          "lines": "658-663",
          "snippet": "__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_user",
          "args": [
            "xdr",
            "rqstp",
            "stat.uid"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4idmap.c",
          "lines": "651-656",
          "snippet": "__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.nlink"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat.mode & S_IALLUGO"
          ],
          "line": 2647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) svc_max_payload(rqstp)"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) svc_max_payload(rqstp)"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "statfs.f_namelen"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "255"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "exp->ex_path.mnt->mnt_sb->s_maxbytes"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_fs_locations",
          "args": [
            "xdr",
            "rqstp",
            "exp"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fs_locations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2117-2138",
          "snippet": "static __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) statfs.f_files"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) statfs.f_ffree"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) statfs.f_ffree"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "stat.ino"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "&fhp->fh_handle.fh_base",
            "fhp->fh_handle.fh_size"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "fhp->fh_handle.fh_size + 4"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "dentry->d_inode"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_aclname",
          "args": [
            "xdr",
            "rqstp",
            "ace"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_aclname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2154-2164",
          "snippet": "static inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ace->flag"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ace->type"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4*3"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "acl->naces"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "rdattr_err"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nn->nfsd4_lease"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "exp->ex_uuid",
            "EX_UUID_LEN"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "MINOR(stat.dev)"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "stat.dev"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "MAJOR(stat.dev)"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "stat.dev"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64)0"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64)exp->ex_fsid"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsid_source",
          "args": [
            "fhp"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "fsid_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "663-689",
          "snippet": "enum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nenum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS4_REFERRAL_FSID_MINOR"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS4_REFERRAL_FSID_MAJOR"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "stat.size"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_change",
          "args": [
            "p",
            "&stat",
            "d_inode(dentry)"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "encode_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1914-1923",
          "snippet": "static __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "NFS4_FH_PERSISTENT"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "dummy"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_file_type",
          "args": [
            "stat.mode"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2140-2152",
          "snippet": "static u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word2"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word1"
          ],
          "line": 2413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word0"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word1"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "word0"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "dentry->d_inode"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs2",
          "args": [
            "minorversion"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "371-378",
          "snippet": "static inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)",
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD2 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_2_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_1_SUPPORTED_ATTRS_WORD2 | \\\n\tNFSD4_2_SECURITY_ATTRS)\n#define NFSD4_1_SUPPORTED_ATTRS_WORD2 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD2\t| PNFSD_SUPPORTED_ATTRS_WORD2 | \\\n\t FATTR4_WORD2_SUPPATTR_EXCLCREAT)\n#define NFSD4_SUPPORTED_ATTRS_WORD2 0\n\nstatic inline u32 nfsd_suppattrs2(u32 minorversion)\n{\n\tswitch (minorversion) {\n\tdefault: return NFSD4_2_SUPPORTED_ATTRS_WORD2;\n\tcase 1:  return NFSD4_1_SUPPORTED_ATTRS_WORD2;\n\tcase 0:  return NFSD4_SUPPORTED_ATTRS_WORD2;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs1",
          "args": [
            "minorversion"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "365-369",
          "snippet": "static inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)",
            "#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD1 \\\n\t(NFSD4_SUPPORTED_ATTRS_WORD1\t| PNFSD_SUPPORTED_ATTRS_WORD1)\n#define NFSD4_SUPPORTED_ATTRS_WORD1                                                         \\\n(FATTR4_WORD1_MODE              | FATTR4_WORD1_NO_TRUNC     | FATTR4_WORD1_NUMLINKS         \\\n | FATTR4_WORD1_OWNER\t        | FATTR4_WORD1_OWNER_GROUP  | FATTR4_WORD1_RAWDEV           \\\n | FATTR4_WORD1_SPACE_AVAIL     | FATTR4_WORD1_SPACE_FREE   | FATTR4_WORD1_SPACE_TOTAL      \\\n | FATTR4_WORD1_SPACE_USED      | FATTR4_WORD1_TIME_ACCESS  | FATTR4_WORD1_TIME_ACCESS_SET  \\\n | FATTR4_WORD1_TIME_DELTA   | FATTR4_WORD1_TIME_METADATA    \\\n | FATTR4_WORD1_TIME_MODIFY     | FATTR4_WORD1_TIME_MODIFY_SET | FATTR4_WORD1_MOUNTED_ON_FILEID)\n\nstatic inline u32 nfsd_suppattrs1(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD1\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_suppattrs0",
          "args": [
            "minorversion"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_suppattrs0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "359-363",
          "snippet": "static inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0",
            "#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\n#define NFSD4_1_SUPPORTED_ATTRS_WORD0 \\\n\tNFSD4_SUPPORTED_ATTRS_WORD0\n#define NFSD4_SUPPORTED_ATTRS_WORD0                                                         \\\n(FATTR4_WORD0_SUPPORTED_ATTRS   | FATTR4_WORD0_TYPE         | FATTR4_WORD0_FH_EXPIRE_TYPE   \\\n | FATTR4_WORD0_CHANGE          | FATTR4_WORD0_SIZE         | FATTR4_WORD0_LINK_SUPPORT     \\\n | FATTR4_WORD0_SYMLINK_SUPPORT | FATTR4_WORD0_NAMED_ATTR   | FATTR4_WORD0_FSID             \\\n | FATTR4_WORD0_UNIQUE_HANDLES  | FATTR4_WORD0_LEASE_TIME   | FATTR4_WORD0_RDATTR_ERROR     \\\n | FATTR4_WORD0_ACLSUPPORT      | FATTR4_WORD0_CANSETTIME   | FATTR4_WORD0_CASE_INSENSITIVE \\\n | FATTR4_WORD0_CASE_PRESERVING | FATTR4_WORD0_CHOWN_RESTRICTED                             \\\n | FATTR4_WORD0_FILEHANDLE      | FATTR4_WORD0_FILEID       | FATTR4_WORD0_FILES_AVAIL      \\\n | FATTR4_WORD0_FILES_FREE      | FATTR4_WORD0_FILES_TOTAL  | FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_HOMOGENEOUS      \\\n | FATTR4_WORD0_MAXFILESIZE     | FATTR4_WORD0_MAXLINK      | FATTR4_WORD0_MAXNAME          \\\n | FATTR4_WORD0_MAXREAD         | FATTR4_WORD0_MAXWRITE     | FATTR4_WORD0_ACL)\n\nstatic inline u32 nfsd_suppattrs0(u32 minorversion)\n{\n\treturn minorversion ? NFSD4_1_SUPPORTED_ATTRS_WORD0\n\t\t\t    : NFSD4_SUPPORTED_ATTRS_WORD0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getsecctx",
          "args": [
            "d_inode(dentry)",
            "&context",
            "&contextlen"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_get_nfs4_acl",
          "args": [
            "rqstp",
            "dentry",
            "&acl"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_nfs4_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4acl.c",
          "lines": "128-177",
          "snippet": "int\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tstruct nfs4_acl **acl)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error = 0;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\tint size = 0;\n\n\tpacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (!pacl)\n\t\tpacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\n\tif (IS_ERR(pacl))\n\t\treturn PTR_ERR(pacl);\n\n\t/* allocate for worst case: one (deny, allow) pair each: */\n\tsize += 2 * pacl->a_count;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = NFS4_ACL_DIR;\n\t\tdpacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(dpacl)) {\n\t\t\terror = PTR_ERR(dpacl);\n\t\t\tgoto rel_pacl;\n\t\t}\n\n\t\tif (dpacl)\n\t\t\tsize += 2 * dpacl->a_count;\n\t}\n\n\t*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\n\tif (*acl == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*acl)->naces = 0;\n\n\t_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\n\n\tif (dpacl)\n\t\t_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\n\nout:\n\tposix_acl_release(dpacl);\nrel_pacl:\n\tposix_acl_release(pacl);\n\treturn error;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define NFS4_ACL_DIR\t\t0x02",
            "#define NFS4_ACL_TYPE_DEFAULT\t0x01"
          ],
          "globals_used": [
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\n#define NFS4_ACL_DIR\t\t0x02\n#define NFS4_ACL_TYPE_DEFAULT\t0x01\n\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint\nnfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry,\n\t\tstruct nfs4_acl **acl)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error = 0;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\tint size = 0;\n\n\tpacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (!pacl)\n\t\tpacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\n\tif (IS_ERR(pacl))\n\t\treturn PTR_ERR(pacl);\n\n\t/* allocate for worst case: one (deny, allow) pair each: */\n\tsize += 2 * pacl->a_count;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tflags = NFS4_ACL_DIR;\n\t\tdpacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(dpacl)) {\n\t\t\terror = PTR_ERR(dpacl);\n\t\t\tgoto rel_pacl;\n\t\t}\n\n\t\tif (dpacl)\n\t\t\tsize += 2 * dpacl->a_count;\n\t}\n\n\t*acl = kmalloc(nfs4_acl_bytes(size), GFP_KERNEL);\n\tif (*acl == NULL) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*acl)->naces = 0;\n\n\t_posix_to_nfsv4_one(pacl, *acl, flags & ~NFS4_ACL_TYPE_DEFAULT);\n\n\tif (dpacl)\n\t\t_posix_to_nfsv4_one(dpacl, *acl, flags | NFS4_ACL_TYPE_DEFAULT);\n\nout:\n\tposix_acl_release(dpacl);\nrel_pacl:\n\tposix_acl_release(pacl);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "tempfh",
            "exp",
            "dentry",
            "NULL"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "tempfh",
            "NFS4_FHSIZE"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct svc_fh)",
            "GFP_KERNEL"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_statfs",
          "args": [
            "&path",
            "&statfs"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&path",
            "&stat"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fattr_handle_absent_fs",
          "args": [
            "&bmval0",
            "&bmval1",
            "&bmval2",
            "&rdattr_err"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "fattr_handle_absent_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2219-2234",
          "snippet": "static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\t*bmval2 &= WORD2_ABSENT_FS_ATTRS;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define WORD2_ABSENT_FS_ATTRS 0",
            "#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID",
            "#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define WORD2_ABSENT_FS_ATTRS 0\n#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID\n#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)\n\nstatic __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\t*bmval2 &= WORD2_ABSENT_FS_ATTRS;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval2 & ~nfsd_suppattrs2(minorversion)"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval1 & ~nfsd_suppattrs1(minorversion)"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval0 & ~nfsd_suppattrs0(minorversion)"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bmval1 & NFSD_WRITEONLY_ATTRS_WORD1"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define NFS4_REFERRAL_FSID_MINOR\t0x8000000ULL\n#define NFS4_REFERRAL_FSID_MAJOR\t0x8000000ULL\n\nstatic __be32\nnfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,\n\t\tstruct svc_export *exp,\n\t\tstruct dentry *dentry, u32 *bmval,\n\t\tstruct svc_rqst *rqstp, int ignore_crossmnt)\n{\n\tu32 bmval0 = bmval[0];\n\tu32 bmval1 = bmval[1];\n\tu32 bmval2 = bmval[2];\n\tstruct kstat stat;\n\tstruct svc_fh *tempfh = NULL;\n\tstruct kstatfs statfs;\n\t__be32 *p;\n\tint starting_len = xdr->buf->len;\n\tint attrlen_offset;\n\t__be32 attrlen;\n\tu32 dummy;\n\tu64 dummy64;\n\tu32 rdattr_err = 0;\n\t__be32 status;\n\tint err;\n\tstruct nfs4_acl *acl = NULL;\n\tvoid *context = NULL;\n\tint contextlen;\n\tbool contextsupport = false;\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tu32 minorversion = resp->cstate.minorversion;\n\tstruct path path = {\n\t\t.mnt\t= exp->ex_path.mnt,\n\t\t.dentry\t= dentry,\n\t};\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tBUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);\n\tBUG_ON(bmval0 & ~nfsd_suppattrs0(minorversion));\n\tBUG_ON(bmval1 & ~nfsd_suppattrs1(minorversion));\n\tBUG_ON(bmval2 & ~nfsd_suppattrs2(minorversion));\n\n\tif (exp->ex_fslocs.migrated) {\n\t\tstatus = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\terr = vfs_getattr(&path, &stat);\n\tif (err)\n\t\tgoto out_nfserr;\n\tif ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |\n\t\t\tFATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||\n\t    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |\n\t\t       FATTR4_WORD1_SPACE_TOTAL))) {\n\t\terr = vfs_statfs(&path, &statfs);\n\t\tif (err)\n\t\t\tgoto out_nfserr;\n\t}\n\tif ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {\n\t\ttempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);\n\t\tstatus = nfserr_jukebox;\n\t\tif (!tempfh)\n\t\t\tgoto out;\n\t\tfh_init(tempfh, NFS4_FHSIZE);\n\t\tstatus = fh_compose(tempfh, exp, dentry, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tfhp = tempfh;\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\terr = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);\n\t\tif (err == -EOPNOTSUPP)\n\t\t\tbmval0 &= ~FATTR4_WORD0_ACL;\n\t\telse if (err == -EINVAL) {\n\t\t\tstatus = nfserr_attrnotsupp;\n\t\t\tgoto out;\n\t\t} else if (err != 0)\n\t\t\tgoto out_nfserr;\n\t}\n\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||\n\t     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\terr = security_inode_getsecctx(d_inode(dentry),\n\t\t\t\t\t\t&context, &contextlen);\n\t\tcontextsupport = (err == 0);\n\t\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\t\tif (err == -EOPNOTSUPP)\n\t\t\t\tbmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\t\telse if (err)\n\t\t\t\tgoto out_nfserr;\n\t\t}\n\t}\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\n\tstatus = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);\n\tif (status)\n\t\tgoto out;\n\n\tattrlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_resource;\n\tp++;                /* to be backfilled later */\n\n\tif (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {\n\t\tu32 word0 = nfsd_suppattrs0(minorversion);\n\t\tu32 word1 = nfsd_suppattrs1(minorversion);\n\t\tu32 word2 = nfsd_suppattrs2(minorversion);\n\n\t\tif (!IS_POSIXACL(dentry->d_inode))\n\t\t\tword0 &= ~FATTR4_WORD0_ACL;\n\t\tif (!contextsupport)\n\t\t\tword2 &= ~FATTR4_WORD2_SECURITY_LABEL;\n\t\tif (!word2) {\n\t\t\tp = xdr_reserve_space(xdr, 12);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(2);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t} else {\n\t\t\tp = xdr_reserve_space(xdr, 16);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(3);\n\t\t\t*p++ = cpu_to_be32(word0);\n\t\t\t*p++ = cpu_to_be32(word1);\n\t\t\t*p++ = cpu_to_be32(word2);\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy = nfs4_file_type(stat.mode);\n\t\tif (dummy == NF4BAD) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out;\n\t\t}\n\t\t*p++ = cpu_to_be32(dummy);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);\n\t\telse\n\t\t\t*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|\n\t\t\t\t\t\tNFS4_FH_VOL_RENAME);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHANGE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = encode_change(p, &stat, d_inode(dentry));\n\t}\n\tif (bmval0 & FATTR4_WORD0_SIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_NAMED_ATTR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FSID) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tif (exp->ex_fslocs.migrated) {\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);\n\t\t\tp = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);\n\t\t} else switch(fsid_source(fhp)) {\n\t\tcase FSIDSOURCE_FSID:\n\t\t\tp = xdr_encode_hyper(p, (u64)exp->ex_fsid);\n\t\t\tp = xdr_encode_hyper(p, (u64)0);\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_DEV:\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MAJOR(stat.dev));\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\t*p++ = cpu_to_be32(MINOR(stat.dev));\n\t\t\tbreak;\n\t\tcase FSIDSOURCE_UUID:\n\t\t\tp = xdr_encode_opaque_fixed(p, exp->ex_uuid,\n\t\t\t\t\t\t\t\tEX_UUID_LEN);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_LEASE_TIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(nn->nfsd4_lease);\n\t}\n\tif (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(rdattr_err);\n\t}\n\tif (bmval0 & FATTR4_WORD0_ACL) {\n\t\tstruct nfs4_ace *ace;\n\n\t\tif (acl == NULL) {\n\t\t\tp = xdr_reserve_space(xdr, 4);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\n\t\t\t*p++ = cpu_to_be32(0);\n\t\t\tgoto out_acl;\n\t\t}\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(acl->naces);\n\n\t\tfor (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {\n\t\t\tp = xdr_reserve_space(xdr, 4*3);\n\t\t\tif (!p)\n\t\t\t\tgoto out_resource;\n\t\t\t*p++ = cpu_to_be32(ace->type);\n\t\t\t*p++ = cpu_to_be32(ace->flag);\n\t\t\t*p++ = cpu_to_be32(ace->access_mask &\n\t\t\t\t\t\t\tNFS4_ACE_MASK_ALL);\n\t\t\tstatus = nfsd4_encode_aclname(xdr, rqstp, ace);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t}\n\t}\nout_acl:\n\tif (bmval0 & FATTR4_WORD0_ACLSUPPORT) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?\n\t\t\tACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CANSETTIME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEHANDLE) {\n\t\tp = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,\n\t\t\t\t\tfhp->fh_handle.fh_size);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILEID) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, stat.ino);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_ffree);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FILES_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) statfs.f_files);\n\t}\n\tif (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {\n\t\tstatus = nfsd4_encode_fs_locations(xdr, rqstp, exp);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXFILESIZE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXLINK) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(255);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXNAME) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(statfs.f_namelen);\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXREAD) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval0 & FATTR4_WORD0_MAXWRITE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));\n\t}\n\tif (bmval1 & FATTR4_WORD1_MODE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.mode & S_IALLUGO);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NO_TRUNC) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t}\n\tif (bmval1 & FATTR4_WORD1_NUMLINKS) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.nlink);\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER) {\n\t\tstatus = nfsd4_encode_user(xdr, rqstp, stat.uid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_OWNER_GROUP) {\n\t\tstatus = nfsd4_encode_group(xdr, rqstp, stat.gid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tif (bmval1 & FATTR4_WORD1_RAWDEV) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));\n\t\t*p++ = cpu_to_be32((u32) MINOR(stat.rdev));\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_FREE) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_SPACE_USED) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tdummy64 = (u64)stat.blocks << 9;\n\t\tp = xdr_encode_hyper(p, dummy64);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_ACCESS) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.atime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_DELTA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_METADATA) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.ctime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_TIME_MODIFY) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\tp = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat.mtime.tv_nsec);\n\t}\n\tif (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {\n\t\tstruct kstat parent_stat;\n\t\tu64 ino = stat.ino;\n\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n                \tgoto out_resource;\n\t\t/*\n\t\t * Get parent's attributes if not ignoring crossmount\n\t\t * and this is the root of a cross-mounted filesystem.\n\t\t */\n\t\tif (ignore_crossmnt == 0 &&\n\t\t    dentry == exp->ex_path.mnt->mnt_root) {\n\t\t\terr = get_parent_attributes(exp, &parent_stat);\n\t\t\tif (err)\n\t\t\t\tgoto out_nfserr;\n\t\t\tino = parent_stat.ino;\n\t\t}\n\t\tp = xdr_encode_hyper(p, ino);\n\t}\n#ifdef CONFIG_NFSD_PNFS\n\tif (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {\n\t\tstatus = nfsd4_encode_layout_type(xdr, exp->ex_layout_type);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(stat.blksize);\n\t}\n#endif /* CONFIG_NFSD_PNFS */\n\tif (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {\n\t\tstatus = nfsd4_encode_bitmap(xdr, NFSD_SUPPATTR_EXCLCREAT_WORD0,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD1,\n\t\t\t\t\t\t  NFSD_SUPPATTR_EXCLCREAT_WORD2);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tstatus = nfsd4_encode_security_label(xdr, rqstp, context,\n\t\t\t\t\t\t\t\tcontextlen);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tattrlen = htonl(xdr->buf->len - attrlen_offset - 4);\n\twrite_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);\n\tstatus = nfs_ok;\n\nout:\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (context)\n\t\tsecurity_release_secctx(context, contextlen);\n#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */\n\tkfree(acl);\n\tif (tempfh) {\n\t\tfh_put(tempfh);\n\t\tkfree(tempfh);\n\t}\n\tif (status)\n\t\txdr_truncate_encode(xdr, starting_len);\n\treturn status;\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto out;\nout_resource:\n\tstatus = nfserr_resource;\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd4_encode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2252-2283",
    "snippet": "static __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval0"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval1"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval0"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "12"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval2"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval1"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bmval0"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "3"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "16"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_encode_bitmap(struct xdr_stream *xdr, u32 bmval0, u32 bmval1, u32 bmval2)\n{\n\t__be32 *p;\n\n\tif (bmval2) {\n\t\tp = xdr_reserve_space(xdr, 16);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(3);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t\t*p++ = cpu_to_be32(bmval2);\n\t} else if (bmval1) {\n\t\tp = xdr_reserve_space(xdr, 12);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(2);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t\t*p++ = cpu_to_be32(bmval1);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\tgoto out_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(bmval0);\n\t}\n\n\treturn 0;\nout_resource:\n\treturn nfserr_resource;\n}"
  },
  {
    "function_name": "get_parent_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2237-2250",
    "snippet": "static int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&path",
            "stat"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_up",
          "args": [
            "&path"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&path"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int get_parent_attributes(struct svc_export *exp, struct kstat *stat)\n{\n\tstruct path path = exp->ex_path;\n\tint err;\n\n\tpath_get(&path);\n\twhile (follow_up(&path)) {\n\t\tif (path.dentry != path.mnt->mnt_root)\n\t\t\tbreak;\n\t}\n\terr = vfs_getattr(&path, stat);\n\tpath_put(&path);\n\treturn err;\n}"
  },
  {
    "function_name": "fattr_handle_absent_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2219-2234",
    "snippet": "static __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\t*bmval2 &= WORD2_ABSENT_FS_ATTRS;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define WORD2_ABSENT_FS_ATTRS 0",
      "#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID",
      "#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define WORD2_ABSENT_FS_ATTRS 0\n#define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID\n#define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \\\n\t\t\t      FATTR4_WORD0_RDATTR_ERROR)\n\nstatic __be32 fattr_handle_absent_fs(u32 *bmval0, u32 *bmval1, u32 *bmval2, u32 *rdattr_err)\n{\n\t/* As per referral draft:  */\n\tif (*bmval0 & ~WORD0_ABSENT_FS_ATTRS ||\n\t    *bmval1 & ~WORD1_ABSENT_FS_ATTRS) {\n\t\tif (*bmval0 & FATTR4_WORD0_RDATTR_ERROR ||\n\t            *bmval0 & FATTR4_WORD0_FS_LOCATIONS)\n\t\t\t*rdattr_err = NFSERR_MOVED;\n\t\telse\n\t\t\treturn nfserr_moved;\n\t}\n\t*bmval0 &= WORD0_ABSENT_FS_ATTRS;\n\t*bmval1 &= WORD1_ABSENT_FS_ATTRS;\n\t*bmval2 &= WORD2_ABSENT_FS_ATTRS;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_security_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2213-2216",
    "snippet": "static inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{ return 0; }"
  },
  {
    "function_name": "nfsd4_encode_security_label",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2193-2211",
    "snippet": "static inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + 4 + 4 + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/*\n\t * For now we use a 0 here to indicate the null translation; in\n\t * the future we may place a call to translation code here.\n\t */\n\t*p++ = cpu_to_be32(0); /* lfs */\n\t*p++ = cpu_to_be32(0); /* pi */\n\tp = xdr_encode_opaque(p, context, len);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "context",
            "len"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len + 4 + 4 + 4"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_encode_security_label(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t    void *context, int len)\n{\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, len + 4 + 4 + 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\n\t/*\n\t * For now we use a 0 here to indicate the null translation; in\n\t * the future we may place a call to translation code here.\n\t */\n\t*p++ = cpu_to_be32(0); /* lfs */\n\t*p++ = cpu_to_be32(0); /* pi */\n\tp = xdr_encode_opaque(p, context, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_layout_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2166-2185",
    "snippet": "static inline __be32\nnfsd4_encode_layout_type(struct xdr_stream *xdr, enum pnfs_layouttype layout_type)\n{\n\t__be32 *p;\n\n\tif (layout_type) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(layout_type);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "layout_type"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "8"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_encode_layout_type(struct xdr_stream *xdr, enum pnfs_layouttype layout_type)\n{\n\t__be32 *p;\n\n\tif (layout_type) {\n\t\tp = xdr_reserve_space(xdr, 8);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(1);\n\t\t*p++ = cpu_to_be32(layout_type);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\t*p++ = cpu_to_be32(0);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_aclname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2154-2164",
    "snippet": "static inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_user",
          "args": [
            "xdr",
            "rqstp",
            "ace->who_uid"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4idmap.c",
          "lines": "651-656",
          "snippet": "__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n__be32 nfsd4_encode_user(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t kuid_t uid)\n{\n\tu32 id = from_kuid(&init_user_ns, uid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_USER, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_group",
          "args": [
            "xdr",
            "rqstp",
            "ace->who_gid"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4idmap.c",
          "lines": "658-663",
          "snippet": "__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n__be32 nfsd4_encode_group(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t\t  kgid_t gid)\n{\n\tu32 id = from_kgid(&init_user_ns, gid);\n\treturn encode_name_from_id(xdr, rqstp, IDMAP_TYPE_GROUP, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_acl_write_who",
          "args": [
            "xdr",
            "ace->whotype"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_write_who",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4acl.c",
          "lines": "867-884",
          "snippet": "__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\n{\n\t__be32 *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].type != who)\n\t\t\tcontinue;\n\t\tp = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, s2t_map[i].string,\n\t\t\t\t\ts2t_map[i].stringlen);\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn nfserr_serverfault;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};\n\n__be32 nfs4_acl_write_who(struct xdr_stream *xdr, int who)\n{\n\t__be32 *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].type != who)\n\t\t\tcontinue;\n\t\tp = xdr_reserve_space(xdr, s2t_map[i].stringlen + 4);\n\t\tif (!p)\n\t\t\treturn nfserr_resource;\n\t\tp = xdr_encode_opaque(p, s2t_map[i].string,\n\t\t\t\t\ts2t_map[i].stringlen);\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn nfserr_serverfault;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,\n\t\t     struct nfs4_ace *ace)\n{\n\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\treturn nfs4_acl_write_who(xdr, ace->whotype);\n\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\treturn nfsd4_encode_group(xdr, rqstp, ace->who_gid);\n\telse\n\t\treturn nfsd4_encode_user(xdr, rqstp, ace->who_uid);\n}"
  },
  {
    "function_name": "nfs4_file_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2140-2152",
    "snippet": "static u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic u32 nfs4_file_type(umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\treturn NF4FIFO;\n\tcase S_IFCHR:\treturn NF4CHR;\n\tcase S_IFDIR:\treturn NF4DIR;\n\tcase S_IFBLK:\treturn NF4BLK;\n\tcase S_IFLNK:\treturn NF4LNK;\n\tcase S_IFREG:\treturn NF4REG;\n\tcase S_IFSOCK:\treturn NF4SOCK;\n\tdefault:\treturn NF4BAD;\n\t};\n}"
  },
  {
    "function_name": "nfsd4_encode_fs_locations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2117-2138",
    "snippet": "static __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_fs_location4",
          "args": [
            "xdr",
            "&fslocs->locations[i]"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fs_location4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2012-2025",
          "snippet": "static __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "fslocs->locations_count"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_fsloc_fsroot",
          "args": [
            "xdr",
            "rqstp",
            "&exp->ex_path"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_fsloc_fsroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2100-2112",
          "snippet": "static __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_fs_locations(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, struct svc_export *exp)\n{\n\t__be32 status;\n\tint i;\n\t__be32 *p;\n\tstruct nfsd4_fs_locations *fslocs = &exp->ex_fslocs;\n\n\tstatus = nfsd4_encode_fsloc_fsroot(xdr, rqstp, &exp->ex_path);\n\tif (status)\n\t\treturn status;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\t*p++ = cpu_to_be32(fslocs->locations_count);\n\tfor (i=0; i<fslocs->locations_count; i++) {\n\t\tstatus = nfsd4_encode_fs_location4(xdr, &fslocs->locations[i]);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_fsloc_fsroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2100-2112",
    "snippet": "static __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp_ps"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_path",
          "args": [
            "xdr",
            "&exp_ps->ex_path",
            "path"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2030-2098",
          "snippet": "static __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (path_equal(&cur, root))\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (path_equal(&cur, root))\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(exp_ps)"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp_ps"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp_ps"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_find_fsidzero_export",
          "args": [
            "rqstp"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_find_fsidzero_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1050-1057",
          "snippet": "struct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\n\nstruct svc_export *rqst_find_fsidzero_export(struct svc_rqst *rqstp)\n{\n\tu32 fsidv[2];\n\n\tmk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);\n\n\treturn rqst_exp_find(rqstp, FSID_NUM, fsidv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_fsloc_fsroot(struct xdr_stream *xdr,\n\t\t\tstruct svc_rqst *rqstp, const struct path *path)\n{\n\tstruct svc_export *exp_ps;\n\t__be32 res;\n\n\texp_ps = rqst_find_fsidzero_export(rqstp);\n\tif (IS_ERR(exp_ps))\n\t\treturn nfserrno(PTR_ERR(exp_ps));\n\tres = nfsd4_encode_path(xdr, &exp_ps->ex_path, path);\n\texp_put(exp_ps);\n\treturn res;\n}"
  },
  {
    "function_name": "nfsd4_encode_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2030-2098",
    "snippet": "static __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (path_equal(&cur, root))\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&cur"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "components"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "components[--ncomponents]"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\")\\n\""
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"/%pd\"",
            "dentry"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "dentry->d_name.name",
            "len"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "len + 4"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ncomponents"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "cur.dentry"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "components",
            "sizeof(*new) * (ncomponents + 16)",
            "GFP_KERNEL"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "follow_up",
          "args": [
            "&cur"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_equal",
          "args": [
            "&cur",
            "root"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&cur"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_encode_components(\""
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_path(struct xdr_stream *xdr,\n\t\t\t\tconst struct path *root,\n\t\t\t\tconst struct path *path)\n{\n\tstruct path cur = *path;\n\t__be32 *p;\n\tstruct dentry **components = NULL;\n\tunsigned int ncomponents = 0;\n\t__be32 err = nfserr_jukebox;\n\n\tdprintk(\"nfsd4_encode_components(\");\n\n\tpath_get(&cur);\n\t/* First walk the path up to the nfsd root, and store the\n\t * dentries/path components in an array.\n\t */\n\tfor (;;) {\n\t\tif (path_equal(&cur, root))\n\t\t\tbreak;\n\t\tif (cur.dentry == cur.mnt->mnt_root) {\n\t\t\tif (follow_up(&cur))\n\t\t\t\tcontinue;\n\t\t\tgoto out_free;\n\t\t}\n\t\tif ((ncomponents & 15) == 0) {\n\t\t\tstruct dentry **new;\n\t\t\tnew = krealloc(components,\n\t\t\t\t\tsizeof(*new) * (ncomponents + 16),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!new)\n\t\t\t\tgoto out_free;\n\t\t\tcomponents = new;\n\t\t}\n\t\tcomponents[ncomponents++] = cur.dentry;\n\t\tcur.dentry = dget_parent(cur.dentry);\n\t}\n\terr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out_free;\n\t*p++ = cpu_to_be32(ncomponents);\n\n\twhile (ncomponents) {\n\t\tstruct dentry *dentry = components[ncomponents - 1];\n\t\tunsigned int len;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tlen = dentry->d_name.len;\n\t\tp = xdr_reserve_space(xdr, len + 4);\n\t\tif (!p) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_free;\n\t\t}\n\t\tp = xdr_encode_opaque(p, dentry->d_name.name, len);\n\t\tdprintk(\"/%pd\", dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(dentry);\n\t\tncomponents--;\n\t}\n\n\terr = 0;\nout_free:\n\tdprintk(\")\\n\");\n\twhile (ncomponents)\n\t\tdput(components[--ncomponents]);\n\tkfree(components);\n\tpath_put(&cur);\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd4_encode_fs_location4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2012-2025",
    "snippet": "static __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_components",
          "args": [
            "xdr",
            "'/'",
            "location->path"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_components",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "2003-2007",
          "snippet": "static __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_encode_components_esc",
          "args": [
            "xdr",
            "':'",
            "location->hosts",
            "'['",
            "']'"
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_components_esc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1943-1998",
          "snippet": "static __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_fs_location4(struct xdr_stream *xdr,\n\t\t\t\t\tstruct nfsd4_fs_location *location)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_encode_components_esc(xdr, ':', location->hosts,\n\t\t\t\t\t\t'[', ']');\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_encode_components(xdr, '/', location->path);\n\tif (status)\n\t\treturn status;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_encode_components",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "2003-2007",
    "snippet": "static __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_components_esc",
          "args": [
            "xdr",
            "sep",
            "components",
            "0",
            "0"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_components_esc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1943-1998",
          "snippet": "static __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_components(struct xdr_stream *xdr, char sep,\n\t\t\t\t      char *components)\n{\n\treturn nfsd4_encode_components_esc(xdr, sep, components, 0, 0);\n}"
  },
  {
    "function_name": "nfsd4_encode_components_esc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1943-1998",
    "snippet": "static __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_bytes_to_xdr_buf",
          "args": [
            "xdr->buf",
            "pathlen_offset",
            "&pathlen",
            "4"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "count"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "str",
            "strlen"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "strlen + 4"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_encode_components(%s)\\n\"",
            "components"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_encode_components_esc(struct xdr_stream *xdr, char sep,\n\t\t\t\t\t  char *components, char esc_enter,\n\t\t\t\t\t  char esc_exit)\n{\n\t__be32 *p;\n\t__be32 pathlen;\n\tint pathlen_offset;\n\tint strlen, count=0;\n\tchar *str, *end, *next;\n\n\tdprintk(\"nfsd4_encode_components(%s)\\n\", components);\n\n\tpathlen_offset = xdr->buf->len;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\treturn nfserr_resource;\n\tp++; /* We will fill this in with @count later */\n\n\tend = str = components;\n\twhile (*end) {\n\t\tbool found_esc = false;\n\n\t\t/* try to parse as esc_start, ..., esc_end, sep */\n\t\tif (*str == esc_enter) {\n\t\t\tfor (; *end && (*end != esc_exit); end++)\n\t\t\t\t/* find esc_exit or end of string */;\n\t\t\tnext = end + 1;\n\t\t\tif (*end && (!*next || *next == sep)) {\n\t\t\t\tstr++;\n\t\t\t\tfound_esc = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!found_esc)\n\t\t\tfor (; *end && (*end != sep); end++)\n\t\t\t\t/* find sep or end of string */;\n\n\t\tstrlen = end - str;\n\t\tif (strlen) {\n\t\t\tp = xdr_reserve_space(xdr, strlen + 4);\n\t\t\tif (!p)\n\t\t\t\treturn nfserr_resource;\n\t\t\tp = xdr_encode_opaque(p, str, strlen);\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\t\tend++;\n\t\tif (found_esc)\n\t\t\tend = next;\n\n\t\tstr = end;\n\t}\n\tpathlen = htonl(count);\n\twrite_bytes_to_xdr_buf(xdr->buf, pathlen_offset, &pathlen, 4);\n\treturn 0;\n}"
  },
  {
    "function_name": "encode_cinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1925-1938",
    "snippet": "static __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->after_ctime_nsec"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->after_ctime_sec"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->before_ctime_nsec"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->before_ctime_sec"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "c->after_change"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "c->before_change"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c->atomic"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_cinfo(__be32 *p, struct nfsd4_change_info *c)\n{\n\t*p++ = cpu_to_be32(c->atomic);\n\tif (c->change_supported) {\n\t\tp = xdr_encode_hyper(p, c->before_change);\n\t\tp = xdr_encode_hyper(p, c->after_change);\n\t} else {\n\t\t*p++ = cpu_to_be32(c->before_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->before_ctime_nsec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_sec);\n\t\t*p++ = cpu_to_be32(c->after_ctime_nsec);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "encode_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1914-1923",
    "snippet": "static __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat->ctime.tv_nsec"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "stat->ctime.tv_sec"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "inode->i_version"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_I_VERSION",
          "args": [
            "inode"
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *encode_change(__be32 *p, struct kstat *stat, struct inode *inode)\n{\n\tif (IS_I_VERSION(inode)) {\n\t\tp = xdr_encode_hyper(p, inode->i_version);\n\t} else {\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_sec);\n\t\t*p++ = cpu_to_be32(stat->ctime.tv_nsec);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "nfsd4_decode_compound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1826-1912",
    "snippet": "static __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen);\n\tSAVEMEM(argp->tag, argp->taglen);\n\tREAD_BUF(8);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [
      "static nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_CLONE]\t\t= (nfsd4_dec)nfsd4_decode_clone,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "RQ_SPLICE_OK",
            "&argp->rqstp->rq_flags"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_reserve",
          "args": [
            "argp->rqstp",
            "max_reply + readbytes"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_max_reply",
          "args": [
            "argp->rqstp",
            "op"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_max_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4proc.c",
          "lines": "2338-2348",
          "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define op_encode_hdr_size\t\t(2)"
          ],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cache_this_op",
          "args": [
            "op"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cache_this_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4proc.c",
          "lines": "1576-1581",
          "snippet": "bool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nbool nfsd4_cache_this_op(struct nfsd4_op *op)\n{\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn false;\n\treturn OPDESC(op)->op_flags & OP_CACHEME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_dec_ops[op->opnum]",
          "args": [
            "argp",
            "&op->u"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_opnum_in_range",
          "args": [
            "argp",
            "op"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_opnum_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "1812-1824",
          "snippet": "static inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: couldn't allocate room for COMPOUND\\n\""
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "argp->opcnt * sizeof(*argp->ops)",
            "GFP_KERNEL"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "argp->iops"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "argp->taglen"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "argp->tag",
            "argp->taglen"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "argp->taglen"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic nfsd4_dec nfsd4_dec_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_dec)nfsd4_decode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_dec)nfsd4_decode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_dec)nfsd4_decode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_dec)nfsd4_decode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DELEGRETURN]\t= (nfsd4_dec)nfsd4_decode_delegreturn,\n\t[OP_GETATTR]\t\t= (nfsd4_dec)nfsd4_decode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_LINK]\t\t= (nfsd4_dec)nfsd4_decode_link,\n\t[OP_LOCK]\t\t= (nfsd4_dec)nfsd4_decode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_dec)nfsd4_decode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_dec)nfsd4_decode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_dec)nfsd4_decode_lookup,\n\t[OP_LOOKUPP]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_OPEN]\t\t= (nfsd4_dec)nfsd4_decode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_dec)nfsd4_decode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_dec)nfsd4_decode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_dec)nfsd4_decode_putfh,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_dec)nfsd4_decode_putpubfh,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_READ]\t\t= (nfsd4_dec)nfsd4_decode_read,\n\t[OP_READDIR]\t\t= (nfsd4_dec)nfsd4_decode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_REMOVE]\t\t= (nfsd4_dec)nfsd4_decode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_dec)nfsd4_decode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_dec)nfsd4_decode_renew,\n\t[OP_RESTOREFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_dec)nfsd4_decode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_dec)nfsd4_decode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_dec)nfsd4_decode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_dec)nfsd4_decode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_dec)nfsd4_decode_setclientid_confirm,\n\t[OP_VERIFY]\t\t= (nfsd4_dec)nfsd4_decode_verify,\n\t[OP_WRITE]\t\t= (nfsd4_dec)nfsd4_decode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_dec)nfsd4_decode_release_lockowner,\n\n\t/* new operations for NFSv4.1 */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_dec)nfsd4_decode_backchannel_ctl,\n\t[OP_BIND_CONN_TO_SESSION]= (nfsd4_dec)nfsd4_decode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_dec)nfsd4_decode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_dec)nfsd4_decode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_dec)nfsd4_decode_destroy_session,\n\t[OP_FREE_STATEID]\t= (nfsd4_dec)nfsd4_decode_free_stateid,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_GETDEVICELIST]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_dec)nfsd4_decode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_dec)nfsd4_decode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_TEST_STATEID]\t= (nfsd4_dec)nfsd4_decode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_dec)nfsd4_decode_destroy_clientid,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_dec)nfsd4_decode_reclaim_complete,\n\n\t/* new operations for NFSv4.2 */\n\t[OP_ALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_COPY]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_dec)nfsd4_decode_fallocate,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTERROR]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_READ_PLUS]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_SEEK]\t\t= (nfsd4_dec)nfsd4_decode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_dec)nfsd4_decode_notsupp,\n\t[OP_CLONE]\t\t= (nfsd4_dec)nfsd4_decode_clone,\n};\n\nstatic __be32\nnfsd4_decode_compound(struct nfsd4_compoundargs *argp)\n{\n\tDECODE_HEAD;\n\tstruct nfsd4_op *op;\n\tbool cachethis = false;\n\tint auth_slack= argp->rqstp->rq_auth_slack;\n\tint max_reply = auth_slack + 8; /* opcnt, status */\n\tint readcount = 0;\n\tint readbytes = 0;\n\tint i;\n\n\tREAD_BUF(4);\n\targp->taglen = be32_to_cpup(p++);\n\tREAD_BUF(argp->taglen);\n\tSAVEMEM(argp->tag, argp->taglen);\n\tREAD_BUF(8);\n\targp->minorversion = be32_to_cpup(p++);\n\targp->opcnt = be32_to_cpup(p++);\n\tmax_reply += 4 + (XDR_QUADLEN(argp->taglen) << 2);\n\n\tif (argp->taglen > NFSD4_MAX_TAGLEN)\n\t\tgoto xdr_error;\n\tif (argp->opcnt > 100)\n\t\tgoto xdr_error;\n\n\tif (argp->opcnt > ARRAY_SIZE(argp->iops)) {\n\t\targp->ops = kzalloc(argp->opcnt * sizeof(*argp->ops), GFP_KERNEL);\n\t\tif (!argp->ops) {\n\t\t\targp->ops = argp->iops;\n\t\t\tdprintk(\"nfsd: couldn't allocate room for COMPOUND\\n\");\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tif (argp->minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\targp->opcnt = 0;\n\n\tfor (i = 0; i < argp->opcnt; i++) {\n\t\top = &argp->ops[i];\n\t\top->replay = NULL;\n\n\t\tREAD_BUF(4);\n\t\top->opnum = be32_to_cpup(p++);\n\n\t\tif (nfsd4_opnum_in_range(argp, op))\n\t\t\top->status = nfsd4_dec_ops[op->opnum](argp, &op->u);\n\t\telse {\n\t\t\top->opnum = OP_ILLEGAL;\n\t\t\top->status = nfserr_op_illegal;\n\t\t}\n\t\t/*\n\t\t * We'll try to cache the result in the DRC if any one\n\t\t * op in the compound wants to be cached:\n\t\t */\n\t\tcachethis |= nfsd4_cache_this_op(op);\n\n\t\tif (op->opnum == OP_READ) {\n\t\t\treadcount++;\n\t\t\treadbytes += nfsd4_max_reply(argp->rqstp, op);\n\t\t} else\n\t\t\tmax_reply += nfsd4_max_reply(argp->rqstp, op);\n\t\t/*\n\t\t * OP_LOCK may return a conflicting lock.  (Special case\n\t\t * because it will just skip encoding this if it runs\n\t\t * out of xdr buffer space, and it is the only operation\n\t\t * that behaves this way.)\n\t\t */\n\t\tif (op->opnum == OP_LOCK)\n\t\t\tmax_reply += NFS4_OPAQUE_LIMIT;\n\n\t\tif (op->status) {\n\t\t\targp->opcnt = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Sessions make the DRC unnecessary: */\n\tif (argp->minorversion)\n\t\tcachethis = false;\n\tsvc_reserve(argp->rqstp, max_reply + readbytes);\n\targp->rqstp->rq_cachetype = cachethis ? RC_REPLBUFF : RC_NOCACHE;\n\n\tif (readcount > 1 || max_reply > PAGE_SIZE - auth_slack)\n\t\tclear_bit(RQ_SPLICE_OK, &argp->rqstp->rq_flags);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_opnum_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1812-1824",
    "snippet": "static inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline bool\nnfsd4_opnum_in_range(struct nfsd4_compoundargs *argp, struct nfsd4_op *op)\n{\n\tif (op->opnum < FIRST_NFS4_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 0 && op->opnum > LAST_NFS40_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 1 && op->opnum > LAST_NFS41_OP)\n\t\treturn false;\n\telse if (argp->minorversion == 2 && op->opnum > LAST_NFS42_OP)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "nfsd4_decode_notsupp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1720-1724",
    "snippet": "static __be32\nnfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfserr_notsupp;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_decode_notsupp(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfserr_notsupp;\n}"
  },
  {
    "function_name": "nfsd4_decode_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1714-1718",
    "snippet": "static __be32\nnfsd4_decode_noop(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfs_ok;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_decode_noop(struct nfsd4_compoundargs *argp, void *p)\n{\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_decode_seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1698-1712",
    "snippet": "static __be32\nnfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &seek->seek_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(8 + 4);\n\tp = xdr_decode_hyper(p, &seek->seek_offset);\n\tseek->seek_whence = be32_to_cpup(p);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&seek->seek_offset"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8 + 4"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&seek->seek_stateid"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_seek(struct nfsd4_compoundargs *argp, struct nfsd4_seek *seek)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &seek->seek_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(8 + 4);\n\tp = xdr_decode_hyper(p, &seek->seek_offset);\n\tseek->seek_whence = be32_to_cpup(p);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1679-1696",
    "snippet": "static __be32\nnfsd4_decode_clone(struct nfsd4_compoundargs *argp, struct nfsd4_clone *clone)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &clone->cl_src_stateid);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_stateid(argp, &clone->cl_dst_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(8 + 8 + 8);\n\tp = xdr_decode_hyper(p, &clone->cl_src_pos);\n\tp = xdr_decode_hyper(p, &clone->cl_dst_pos);\n\tp = xdr_decode_hyper(p, &clone->cl_count);\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&clone->cl_count"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&clone->cl_dst_pos"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&clone->cl_src_pos"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8 + 8 + 8"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&clone->cl_dst_stateid"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_clone(struct nfsd4_compoundargs *argp, struct nfsd4_clone *clone)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &clone->cl_src_stateid);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_stateid(argp, &clone->cl_dst_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(8 + 8 + 8);\n\tp = xdr_decode_hyper(p, &clone->cl_src_pos);\n\tp = xdr_decode_hyper(p, &clone->cl_dst_pos);\n\tp = xdr_decode_hyper(p, &clone->cl_count);\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1662-1677",
    "snippet": "static __be32\nnfsd4_decode_fallocate(struct nfsd4_compoundargs *argp,\n\t\t       struct nfsd4_fallocate *fallocate)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &fallocate->falloc_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &fallocate->falloc_offset);\n\txdr_decode_hyper(p, &fallocate->falloc_length);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&fallocate->falloc_length"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&fallocate->falloc_offset"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&fallocate->falloc_stateid"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fallocate(struct nfsd4_compoundargs *argp,\n\t\t       struct nfsd4_fallocate *fallocate)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &fallocate->falloc_stateid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &fallocate->falloc_offset);\n\txdr_decode_hyper(p, &fallocate->falloc_length);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_layoutreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1627-1659",
    "snippet": "static __be32\nnfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(16);\n\tlrp->lr_reclaim = be32_to_cpup(p++);\n\tlrp->lr_layout_type = be32_to_cpup(p++);\n\tlrp->lr_seg.iomode = be32_to_cpup(p++);\n\tlrp->lr_return_type = be32_to_cpup(p++);\n\tif (lrp->lr_return_type == RETURN_FILE) {\n\t\tREAD_BUF(16);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.offset);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.length);\n\n\t\tstatus = nfsd4_decode_stateid(argp, &lrp->lr_sid);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tREAD_BUF(4);\n\t\tlrp->lrf_body_len = be32_to_cpup(p++);\n\t\tif (lrp->lrf_body_len > 0) {\n\t\t\tREAD_BUF(lrp->lrf_body_len);\n\t\t\tREADMEM(lrp->lrf_body, lrp->lrf_body_len);\n\t\t}\n\t} else {\n\t\tlrp->lr_seg.offset = 0;\n\t\tlrp->lr_seg.length = NFS4_MAX_UINT64;\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lrp->lrf_body",
            "lrp->lrf_body_len"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lrp->lrf_body_len"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lrp->lr_sid"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lrp->lr_seg.length"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lrp->lr_seg.offset"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_layoutreturn(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(16);\n\tlrp->lr_reclaim = be32_to_cpup(p++);\n\tlrp->lr_layout_type = be32_to_cpup(p++);\n\tlrp->lr_seg.iomode = be32_to_cpup(p++);\n\tlrp->lr_return_type = be32_to_cpup(p++);\n\tif (lrp->lr_return_type == RETURN_FILE) {\n\t\tREAD_BUF(16);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.offset);\n\t\tp = xdr_decode_hyper(p, &lrp->lr_seg.length);\n\n\t\tstatus = nfsd4_decode_stateid(argp, &lrp->lr_sid);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tREAD_BUF(4);\n\t\tlrp->lrf_body_len = be32_to_cpup(p++);\n\t\tif (lrp->lrf_body_len > 0) {\n\t\t\tREAD_BUF(lrp->lrf_body_len);\n\t\t\tREADMEM(lrp->lrf_body, lrp->lrf_body_len);\n\t\t}\n\t} else {\n\t\tlrp->lr_seg.offset = 0;\n\t\tlrp->lr_seg.length = NFS4_MAX_UINT64;\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_layoutcommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1579-1625",
    "snippet": "static __be32\nnfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tDECODE_HEAD;\n\tu32 timechange;\n\n\tREAD_BUF(20);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.offset);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.length);\n\tlcp->lc_reclaim = be32_to_cpup(p++);\n\n\tstatus = nfsd4_decode_stateid(argp, &lcp->lc_sid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(4);\n\tlcp->lc_newoffset = be32_to_cpup(p++);\n\tif (lcp->lc_newoffset) {\n\t\tREAD_BUF(8);\n\t\tp = xdr_decode_hyper(p, &lcp->lc_last_wr);\n\t} else\n\t\tlcp->lc_last_wr = 0;\n\tREAD_BUF(4);\n\ttimechange = be32_to_cpup(p++);\n\tif (timechange) {\n\t\tstatus = nfsd4_decode_time(argp, &lcp->lc_mtime);\n\t\tif (status)\n\t\t\treturn status;\n\t} else {\n\t\tlcp->lc_mtime.tv_nsec = UTIME_NOW;\n\t}\n\tREAD_BUF(8);\n\tlcp->lc_layout_type = be32_to_cpup(p++);\n\n\t/*\n\t * Save the layout update in XDR format and let the layout driver deal\n\t * with it later.\n\t */\n\tlcp->lc_up_len = be32_to_cpup(p++);\n\tif (lcp->lc_up_len > 0) {\n\t\tREAD_BUF(lcp->lc_up_len);\n\t\tREADMEM(lcp->lc_up_layout, lcp->lc_up_len);\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lcp->lc_up_layout",
            "lcp->lc_up_len"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lcp->lc_up_len"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_time",
          "args": [
            "argp",
            "&lcp->lc_mtime"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "243-257",
          "snippet": "static __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lcp->lc_last_wr"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lcp->lc_sid"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lcp->lc_seg.length"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lcp->lc_seg.offset"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "20"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_layoutcommit(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutcommit *lcp)\n{\n\tDECODE_HEAD;\n\tu32 timechange;\n\n\tREAD_BUF(20);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.offset);\n\tp = xdr_decode_hyper(p, &lcp->lc_seg.length);\n\tlcp->lc_reclaim = be32_to_cpup(p++);\n\n\tstatus = nfsd4_decode_stateid(argp, &lcp->lc_sid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(4);\n\tlcp->lc_newoffset = be32_to_cpup(p++);\n\tif (lcp->lc_newoffset) {\n\t\tREAD_BUF(8);\n\t\tp = xdr_decode_hyper(p, &lcp->lc_last_wr);\n\t} else\n\t\tlcp->lc_last_wr = 0;\n\tREAD_BUF(4);\n\ttimechange = be32_to_cpup(p++);\n\tif (timechange) {\n\t\tstatus = nfsd4_decode_time(argp, &lcp->lc_mtime);\n\t\tif (status)\n\t\t\treturn status;\n\t} else {\n\t\tlcp->lc_mtime.tv_nsec = UTIME_NOW;\n\t}\n\tREAD_BUF(8);\n\tlcp->lc_layout_type = be32_to_cpup(p++);\n\n\t/*\n\t * Save the layout update in XDR format and let the layout driver deal\n\t * with it later.\n\t */\n\tlcp->lc_up_len = be32_to_cpup(p++);\n\tif (lcp->lc_up_len > 0) {\n\t\tREAD_BUF(lcp->lc_up_len);\n\t\tREADMEM(lcp->lc_up_layout, lcp->lc_up_len);\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_layoutget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1555-1577",
    "snippet": "static __be32\nnfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(36);\n\tlgp->lg_signal = be32_to_cpup(p++);\n\tlgp->lg_layout_type = be32_to_cpup(p++);\n\tlgp->lg_seg.iomode = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.offset);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.length);\n\tp = xdr_decode_hyper(p, &lgp->lg_minlength);\n\n\tstatus = nfsd4_decode_stateid(argp, &lgp->lg_sid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(4);\n\tlgp->lg_maxcount = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lgp->lg_sid"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lgp->lg_minlength"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lgp->lg_seg.length"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lgp->lg_seg.offset"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "36"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_layoutget(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(36);\n\tlgp->lg_signal = be32_to_cpup(p++);\n\tlgp->lg_layout_type = be32_to_cpup(p++);\n\tlgp->lg_seg.iomode = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.offset);\n\tp = xdr_decode_hyper(p, &lgp->lg_seg.length);\n\tp = xdr_decode_hyper(p, &lgp->lg_minlength);\n\n\tstatus = nfsd4_decode_stateid(argp, &lgp->lg_sid);\n\tif (status)\n\t\treturn status;\n\n\tREAD_BUF(4);\n\tlgp->lg_maxcount = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_getdeviceinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1530-1553",
    "snippet": "static __be32\nnfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tDECODE_HEAD;\n\tu32 num, i;\n\n\tREAD_BUF(sizeof(struct nfsd4_deviceid) + 3 * 4);\n\tCOPYMEM(&gdev->gd_devid, sizeof(struct nfsd4_deviceid));\n\tgdev->gd_layout_type = be32_to_cpup(p++);\n\tgdev->gd_maxcount = be32_to_cpup(p++);\n\tnum = be32_to_cpup(p++);\n\tif (num) {\n\t\tREAD_BUF(4 * num);\n\t\tgdev->gd_notify_types = be32_to_cpup(p++);\n\t\tfor (i = 1; i < num; i++) {\n\t\t\tif (be32_to_cpup(p++)) {\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4 * num"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&gdev->gd_devid",
            "sizeof(struct nfsd4_deviceid)"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(struct nfsd4_deviceid) + 3 * 4"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_getdeviceinfo(struct nfsd4_compoundargs *argp,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tDECODE_HEAD;\n\tu32 num, i;\n\n\tREAD_BUF(sizeof(struct nfsd4_deviceid) + 3 * 4);\n\tCOPYMEM(&gdev->gd_devid, sizeof(struct nfsd4_deviceid));\n\tgdev->gd_layout_type = be32_to_cpup(p++);\n\tgdev->gd_maxcount = be32_to_cpup(p++);\n\tnum = be32_to_cpup(p++);\n\tif (num) {\n\t\tREAD_BUF(4 * num);\n\t\tgdev->gd_notify_types = be32_to_cpup(p++);\n\t\tfor (i = 1; i < num; i++) {\n\t\t\tif (be32_to_cpup(p++)) {\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_reclaim_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1519-1527",
    "snippet": "static __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trc->rca_one_fs = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_reclaim_complete(struct nfsd4_compoundargs *argp, struct nfsd4_reclaim_complete *rc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trc->rca_one_fs = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_destroy_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1509-1517",
    "snippet": "static __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp, struct nfsd4_destroy_clientid *dc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tCOPYMEM(&dc->clientid, 8);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&dc->clientid",
            "8"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_destroy_clientid(struct nfsd4_compoundargs *argp, struct nfsd4_destroy_clientid *dc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tCOPYMEM(&dc->clientid, 8);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_test_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1473-1507",
    "snippet": "static __be32\nnfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, struct nfsd4_test_stateid *test_stateid)\n{\n\tint i;\n\t__be32 *p, status;\n\tstruct nfsd4_test_stateid_id *stateid;\n\n\tREAD_BUF(4);\n\ttest_stateid->ts_num_ids = ntohl(*p++);\n\n\tINIT_LIST_HEAD(&test_stateid->ts_stateid_list);\n\n\tfor (i = 0; i < test_stateid->ts_num_ids; i++) {\n\t\tstateid = svcxdr_tmpalloc(argp, sizeof(*stateid));\n\t\tif (!stateid) {\n\t\t\tstatus = nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&stateid->ts_id_list);\n\t\tlist_add_tail(&stateid->ts_id_list, &test_stateid->ts_stateid_list);\n\n\t\tstatus = nfsd4_decode_stateid(argp, &stateid->ts_id_stateid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = 0;\nout:\n\treturn status;\nxdr_error:\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\", __FILE__, __LINE__);\n\tstatus = nfserr_bad_xdr;\n\tgoto out;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: xdr error (%s:%d)\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&stateid->ts_id_stateid"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&stateid->ts_id_list",
            "&test_stateid->ts_stateid_list"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&stateid->ts_id_list"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "-ENOMEM"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "sizeof(*stateid)"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "186-197",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&test_stateid->ts_stateid_list"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_decode_test_stateid(struct nfsd4_compoundargs *argp, struct nfsd4_test_stateid *test_stateid)\n{\n\tint i;\n\t__be32 *p, status;\n\tstruct nfsd4_test_stateid_id *stateid;\n\n\tREAD_BUF(4);\n\ttest_stateid->ts_num_ids = ntohl(*p++);\n\n\tINIT_LIST_HEAD(&test_stateid->ts_stateid_list);\n\n\tfor (i = 0; i < test_stateid->ts_num_ids; i++) {\n\t\tstateid = svcxdr_tmpalloc(argp, sizeof(*stateid));\n\t\tif (!stateid) {\n\t\t\tstatus = nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&stateid->ts_id_list);\n\t\tlist_add_tail(&stateid->ts_id_list, &test_stateid->ts_stateid_list);\n\n\t\tstatus = nfsd4_decode_stateid(argp, &stateid->ts_id_stateid);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tstatus = 0;\nout:\n\treturn status;\nxdr_error:\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\", __FILE__, __LINE__);\n\tstatus = nfserr_bad_xdr;\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd4_decode_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1457-1471",
    "snippet": "static __be32\nnfsd4_decode_sequence(struct nfsd4_compoundargs *argp,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 16);\n\tCOPYMEM(seq->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tseq->seqid = be32_to_cpup(p++);\n\tseq->slotid = be32_to_cpup(p++);\n\tseq->maxslots = be32_to_cpup(p++);\n\tseq->cachethis = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "seq->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_MAX_SESSIONID_LEN + 16"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_sequence(struct nfsd4_compoundargs *argp,\n\t\t      struct nfsd4_sequence *seq)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 16);\n\tCOPYMEM(seq->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tseq->seqid = be32_to_cpup(p++);\n\tseq->slotid = be32_to_cpup(p++);\n\tseq->maxslots = be32_to_cpup(p++);\n\tseq->cachethis = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_free_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1444-1455",
    "snippet": "static __be32\nnfsd4_decode_free_stateid(struct nfsd4_compoundargs *argp,\n\t\t\t  struct nfsd4_free_stateid *free_stateid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tfree_stateid->fr_stateid.si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&free_stateid->fr_stateid.si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&free_stateid->fr_stateid.si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(stateid_t)"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_free_stateid(struct nfsd4_compoundargs *argp,\n\t\t\t  struct nfsd4_free_stateid *free_stateid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tfree_stateid->fr_stateid.si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&free_stateid->fr_stateid.si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_destroy_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1433-1442",
    "snippet": "static __be32\nnfsd4_decode_destroy_session(struct nfsd4_compoundargs *argp,\n\t\t\t     struct nfsd4_destroy_session *destroy_session)\n{\n\tDECODE_HEAD;\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN);\n\tCOPYMEM(destroy_session->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "destroy_session->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_destroy_session(struct nfsd4_compoundargs *argp,\n\t\t\t     struct nfsd4_destroy_session *destroy_session)\n{\n\tDECODE_HEAD;\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN);\n\tCOPYMEM(destroy_session->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1381-1431",
    "snippet": "static __be32\nnfsd4_decode_create_session(struct nfsd4_compoundargs *argp,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tREAD_BUF(16);\n\tCOPYMEM(&sess->clientid, 8);\n\tsess->seqid = be32_to_cpup(p++);\n\tsess->flags = be32_to_cpup(p++);\n\n\t/* Fore channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->fore_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->fore_channel.maxops = be32_to_cpup(p++);\n\tsess->fore_channel.maxreqs = be32_to_cpup(p++);\n\tsess->fore_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->fore_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->fore_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->fore_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many fore channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\t/* Back channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->back_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->back_channel.maxops = be32_to_cpup(p++);\n\tsess->back_channel.maxreqs = be32_to_cpup(p++);\n\tsess->back_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->back_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->back_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->back_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many back channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\tREAD_BUF(4);\n\tsess->callback_prog = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &sess->cb_sec);\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_cb_sec",
          "args": [
            "argp",
            "&sess->cb_sec"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "472-550",
          "snippet": "static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Too many back channel attr bitmaps!\\n\""
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "28"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Too many fore channel attr bitmaps!\\n\""
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "28"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&sess->clientid",
            "8"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_create_session(struct nfsd4_compoundargs *argp,\n\t\t\t    struct nfsd4_create_session *sess)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tREAD_BUF(16);\n\tCOPYMEM(&sess->clientid, 8);\n\tsess->seqid = be32_to_cpup(p++);\n\tsess->flags = be32_to_cpup(p++);\n\n\t/* Fore channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->fore_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->fore_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->fore_channel.maxops = be32_to_cpup(p++);\n\tsess->fore_channel.maxreqs = be32_to_cpup(p++);\n\tsess->fore_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->fore_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->fore_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->fore_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many fore channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\t/* Back channel attrs */\n\tREAD_BUF(28);\n\tdummy = be32_to_cpup(p++); /* headerpadsz is always 0 */\n\tsess->back_channel.maxreq_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_sz = be32_to_cpup(p++);\n\tsess->back_channel.maxresp_cached = be32_to_cpup(p++);\n\tsess->back_channel.maxops = be32_to_cpup(p++);\n\tsess->back_channel.maxreqs = be32_to_cpup(p++);\n\tsess->back_channel.nr_rdma_attrs = be32_to_cpup(p++);\n\tif (sess->back_channel.nr_rdma_attrs == 1) {\n\t\tREAD_BUF(4);\n\t\tsess->back_channel.rdma_attrs = be32_to_cpup(p++);\n\t} else if (sess->back_channel.nr_rdma_attrs > 1) {\n\t\tdprintk(\"Too many back channel attr bitmaps!\\n\");\n\t\tgoto xdr_error;\n\t}\n\n\tREAD_BUF(4);\n\tsess->callback_prog = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &sess->cb_sec);\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_exchange_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1277-1379",
    "snippet": "static __be32\nnfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tint dummy, tmp;\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(exid->verifier.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &exid->clname);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(4);\n\texid->flags = be32_to_cpup(p++);\n\n\t/* Ignore state_protect4_a */\n\tREAD_BUF(4);\n\texid->spa_how = be32_to_cpup(p++);\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* spo_must_allow */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\t\tbreak;\n\tcase SP4_SSV:\n\t\t/* ssp_ops */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* ssp_hash_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_encr_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_window and ssp_num_gss_handles */\n\t\tREAD_BUF(8);\n\t\tdummy = be32_to_cpup(p++);\n\t\tdummy = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* Ignore Implementation ID */\n\tREAD_BUF(4);    /* nfs_impl_id4 array length */\n\tdummy = be32_to_cpup(p++);\n\n\tif (dummy > 1)\n\t\tgoto xdr_error;\n\n\tif (dummy == 1) {\n\t\t/* nii_domain */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_name */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_date */\n\t\tREAD_BUF(12);\n\t\tp += 3;\n\t}\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_opaque",
          "args": [
            "argp",
            "&exid->clname"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "832-847",
          "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "exid->verifier.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,\n\t\t\t struct nfsd4_exchange_id *exid)\n{\n\tint dummy, tmp;\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(exid->verifier.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &exid->clname);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(4);\n\texid->flags = be32_to_cpup(p++);\n\n\t/* Ignore state_protect4_a */\n\tREAD_BUF(4);\n\texid->spa_how = be32_to_cpup(p++);\n\tswitch (exid->spa_how) {\n\tcase SP4_NONE:\n\t\tbreak;\n\tcase SP4_MACH_CRED:\n\t\t/* spo_must_enforce */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* spo_must_allow */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\t\tbreak;\n\tcase SP4_SSV:\n\t\t/* ssp_ops */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy * 4);\n\t\tp += dummy;\n\n\t\t/* ssp_hash_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_encr_algs<> */\n\t\tREAD_BUF(4);\n\t\ttmp = be32_to_cpup(p++);\n\t\twhile (tmp--) {\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t}\n\n\t\t/* ssp_window and ssp_num_gss_handles */\n\t\tREAD_BUF(8);\n\t\tdummy = be32_to_cpup(p++);\n\t\tdummy = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* Ignore Implementation ID */\n\tREAD_BUF(4);    /* nfs_impl_id4 array length */\n\tdummy = be32_to_cpup(p++);\n\n\tif (dummy > 1)\n\t\tgoto xdr_error;\n\n\tif (dummy == 1) {\n\t\t/* nii_domain */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_name */\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy);\n\t\tp += XDR_QUADLEN(dummy);\n\n\t\t/* nii_date */\n\t\tREAD_BUF(12);\n\t\tp += 3;\n\t}\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_release_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1258-1275",
    "snippet": "static __be32\nnfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, struct nfsd4_release_lockowner *rlockowner)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(12);\n\tCOPYMEM(&rlockowner->rl_clientid, sizeof(clientid_t));\n\trlockowner->rl_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(rlockowner->rl_owner.len);\n\tREADMEM(rlockowner->rl_owner.data, rlockowner->rl_owner.len);\n\n\tif (argp->minorversion && !zero_clientid(&rlockowner->rl_clientid))\n\t\treturn nfserr_inval;\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_clientid",
          "args": [
            "&rlockowner->rl_clientid"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "zero_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "173-176",
          "snippet": "static int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "rlockowner->rl_owner.data",
            "rlockowner->rl_owner.len"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "rlockowner->rl_owner.len"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&rlockowner->rl_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_release_lockowner(struct nfsd4_compoundargs *argp, struct nfsd4_release_lockowner *rlockowner)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(12);\n\tCOPYMEM(&rlockowner->rl_clientid, sizeof(clientid_t));\n\trlockowner->rl_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(rlockowner->rl_owner.len);\n\tREADMEM(rlockowner->rl_owner.data, rlockowner->rl_owner.len);\n\n\tif (argp->minorversion && !zero_clientid(&rlockowner->rl_clientid))\n\t\treturn nfserr_inval;\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1207-1256",
    "snippet": "static __be32\nnfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)\n{\n\tint avail;\n\tint len;\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &write->wr_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &write->wr_offset);\n\twrite->wr_stable_how = be32_to_cpup(p++);\n\tif (write->wr_stable_how > 2)\n\t\tgoto xdr_error;\n\twrite->wr_buflen = be32_to_cpup(p++);\n\n\t/* Sorry .. no magic macros for this.. *\n\t * READ_BUF(write->wr_buflen);\n\t * SAVEMEM(write->wr_buf, write->wr_buflen);\n\t */\n\tavail = (char*)argp->end - (char*)argp->p;\n\tif (avail + argp->pagelen < write->wr_buflen) {\n\t\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\tgoto xdr_error;\n\t}\n\twrite->wr_head.iov_base = p;\n\twrite->wr_head.iov_len = avail;\n\twrite->wr_pagelist = argp->pagelist;\n\n\tlen = XDR_QUADLEN(write->wr_buflen) << 2;\n\tif (len >= avail) {\n\t\tint pages;\n\n\t\tlen -= avail;\n\n\t\tpages = len >> PAGE_SHIFT;\n\t\targp->pagelist += pages;\n\t\targp->pagelen -= pages * PAGE_SIZE;\n\t\tlen -= pages * PAGE_SIZE;\n\n\t\targp->p = (__be32 *)page_address(argp->pagelist[0]);\n\t\targp->pagelist++;\n\t\targp->end = argp->p + XDR_QUADLEN(PAGE_SIZE);\n\t}\n\targp->p += XDR_QUADLEN(len);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "len"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "argp->pagelist[0]"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "write->wr_buflen"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: xdr error (%s:%d)\\n\"",
            "__FILE__",
            "__LINE__"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&write->wr_offset"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&write->wr_stateid"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)\n{\n\tint avail;\n\tint len;\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &write->wr_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &write->wr_offset);\n\twrite->wr_stable_how = be32_to_cpup(p++);\n\tif (write->wr_stable_how > 2)\n\t\tgoto xdr_error;\n\twrite->wr_buflen = be32_to_cpup(p++);\n\n\t/* Sorry .. no magic macros for this.. *\n\t * READ_BUF(write->wr_buflen);\n\t * SAVEMEM(write->wr_buf, write->wr_buflen);\n\t */\n\tavail = (char*)argp->end - (char*)argp->p;\n\tif (avail + argp->pagelen < write->wr_buflen) {\n\t\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\n\t\t\t\t__FILE__, __LINE__);\n\t\tgoto xdr_error;\n\t}\n\twrite->wr_head.iov_base = p;\n\twrite->wr_head.iov_len = avail;\n\twrite->wr_pagelist = argp->pagelist;\n\n\tlen = XDR_QUADLEN(write->wr_buflen) << 2;\n\tif (len >= avail) {\n\t\tint pages;\n\n\t\tlen -= avail;\n\n\t\tpages = len >> PAGE_SHIFT;\n\t\targp->pagelist += pages;\n\t\targp->pagelen -= pages * PAGE_SIZE;\n\t\tlen -= pages * PAGE_SIZE;\n\n\t\targp->p = (__be32 *)page_address(argp->pagelist[0]);\n\t\targp->pagelist++;\n\t\targp->end = argp->p + XDR_QUADLEN(PAGE_SIZE);\n\t}\n\targp->p += XDR_QUADLEN(len);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1188-1205",
    "snippet": "static __be32\nnfsd4_decode_verify(struct nfsd4_compoundargs *argp, struct nfsd4_verify *verify)\n{\n\tDECODE_HEAD;\n\n\tif ((status = nfsd4_decode_bitmap(argp, verify->ve_bmval)))\n\t\tgoto out;\n\n\t/* For convenience's sake, we compare raw xdr'd attributes in\n\t * nfsd4_proc_verify */\n\n\tREAD_BUF(4);\n\tverify->ve_attrlen = be32_to_cpup(p++);\n\tREAD_BUF(verify->ve_attrlen);\n\tSAVEMEM(verify->ve_attrval, verify->ve_attrlen);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "verify->ve_attrval",
            "verify->ve_attrlen"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "verify->ve_attrlen"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "verify->ve_bmval"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "259-283",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_verify(struct nfsd4_compoundargs *argp, struct nfsd4_verify *verify)\n{\n\tDECODE_HEAD;\n\n\tif ((status = nfsd4_decode_bitmap(argp, verify->ve_bmval)))\n\t\tgoto out;\n\n\t/* For convenience's sake, we compare raw xdr'd attributes in\n\t * nfsd4_proc_verify */\n\n\tREAD_BUF(4);\n\tverify->ve_attrlen = be32_to_cpup(p++);\n\tREAD_BUF(verify->ve_attrlen);\n\tSAVEMEM(verify->ve_attrval, verify->ve_attrlen);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_setclientid_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1172-1185",
    "snippet": "static __be32\nnfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid_confirm *scd_c)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(8 + NFS4_VERIFIER_SIZE);\n\tCOPYMEM(&scd_c->sc_clientid, 8);\n\tCOPYMEM(&scd_c->sc_confirm, NFS4_VERIFIER_SIZE);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&scd_c->sc_confirm",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&scd_c->sc_clientid",
            "8"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8 + NFS4_VERIFIER_SIZE"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_setclientid_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid_confirm *scd_c)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(8 + NFS4_VERIFIER_SIZE);\n\tCOPYMEM(&scd_c->sc_clientid, 8);\n\tCOPYMEM(&scd_c->sc_confirm, NFS4_VERIFIER_SIZE);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_setclientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1142-1170",
    "snippet": "static __be32\nnfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid *setclientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(setclientid->se_verf.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &setclientid->se_name);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\tREAD_BUF(8);\n\tsetclientid->se_callback_prog = be32_to_cpup(p++);\n\tsetclientid->se_callback_netid_len = be32_to_cpup(p++);\n\tREAD_BUF(setclientid->se_callback_netid_len);\n\tSAVEMEM(setclientid->se_callback_netid_val, setclientid->se_callback_netid_len);\n\tREAD_BUF(4);\n\tsetclientid->se_callback_addr_len = be32_to_cpup(p++);\n\n\tREAD_BUF(setclientid->se_callback_addr_len);\n\tSAVEMEM(setclientid->se_callback_addr_val, setclientid->se_callback_addr_len);\n\tREAD_BUF(4);\n\tsetclientid->se_callback_ident = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "setclientid->se_callback_addr_val",
            "setclientid->se_callback_addr_len"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "setclientid->se_callback_addr_len"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "setclientid->se_callback_netid_val",
            "setclientid->se_callback_netid_len"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "setclientid->se_callback_netid_len"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_opaque",
          "args": [
            "argp",
            "&setclientid->se_name"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "832-847",
          "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "setclientid->se_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclientid *setclientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\tCOPYMEM(setclientid->se_verf.data, NFS4_VERIFIER_SIZE);\n\n\tstatus = nfsd4_decode_opaque(argp, &setclientid->se_name);\n\tif (status)\n\t\treturn nfserr_bad_xdr;\n\tREAD_BUF(8);\n\tsetclientid->se_callback_prog = be32_to_cpup(p++);\n\tsetclientid->se_callback_netid_len = be32_to_cpup(p++);\n\tREAD_BUF(setclientid->se_callback_netid_len);\n\tSAVEMEM(setclientid->se_callback_netid_val, setclientid->se_callback_netid_len);\n\tREAD_BUF(4);\n\tsetclientid->se_callback_addr_len = be32_to_cpup(p++);\n\n\tREAD_BUF(setclientid->se_callback_addr_len);\n\tSAVEMEM(setclientid->se_callback_addr_val, setclientid->se_callback_addr_len);\n\tREAD_BUF(4);\n\tsetclientid->se_callback_ident = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1130-1140",
    "snippet": "static __be32\nnfsd4_decode_setattr(struct nfsd4_compoundargs *argp, struct nfsd4_setattr *setattr)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid(argp, &setattr->sa_stateid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_fattr(argp, setattr->sa_bmval, &setattr->sa_iattr,\n\t\t\t\t  &setattr->sa_acl, &setattr->sa_label);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_fattr",
          "args": [
            "argp",
            "setattr->sa_bmval",
            "&setattr->sa_iattr",
            "&setattr->sa_acl",
            "&setattr->sa_label"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "285-447",
          "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&setattr->sa_stateid"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_decode_setattr(struct nfsd4_compoundargs *argp, struct nfsd4_setattr *setattr)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_decode_stateid(argp, &setattr->sa_stateid);\n\tif (status)\n\t\treturn status;\n\treturn nfsd4_decode_fattr(argp, setattr->sa_bmval, &setattr->sa_iattr,\n\t\t\t\t  &setattr->sa_acl, &setattr->sa_label);\n}"
  },
  {
    "function_name": "nfsd4_decode_secinfo_no_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1119-1128",
    "snippet": "static __be32\nnfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo_no_name *sin)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsin->sin_style = be32_to_cpup(p++);\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_secinfo_no_name(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo_no_name *sin)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsin->sin_style = be32_to_cpup(p++);\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_secinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1103-1117",
    "snippet": "static __be32\nnfsd4_decode_secinfo(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsecinfo->si_namelen = be32_to_cpup(p++);\n\tREAD_BUF(secinfo->si_namelen);\n\tSAVEMEM(secinfo->si_name, secinfo->si_namelen);\n\tstatus = check_filename(secinfo->si_name, secinfo->si_namelen);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "secinfo->si_name",
            "secinfo->si_namelen"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "68-81",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "secinfo->si_name",
            "secinfo->si_namelen"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "secinfo->si_namelen"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_secinfo(struct nfsd4_compoundargs *argp,\n\t\t     struct nfsd4_secinfo *secinfo)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tsecinfo->si_namelen = be32_to_cpup(p++);\n\tREAD_BUF(secinfo->si_namelen);\n\tSAVEMEM(secinfo->si_name, secinfo->si_namelen);\n\tstatus = check_filename(secinfo->si_name, secinfo->si_namelen);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_renew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1089-1101",
    "snippet": "static __be32\nnfsd4_decode_renew(struct nfsd4_compoundargs *argp, clientid_t *clientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(clientid, sizeof(clientid_t));\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "clientid",
            "sizeof(clientid_t)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(clientid_t)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_renew(struct nfsd4_compoundargs *argp, clientid_t *clientid)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(clientid, sizeof(clientid_t));\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1068-1087",
    "snippet": "static __be32\nnfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trename->rn_snamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_snamelen);\n\tSAVEMEM(rename->rn_sname, rename->rn_snamelen);\n\tREAD_BUF(4);\n\trename->rn_tnamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_tnamelen);\n\tSAVEMEM(rename->rn_tname, rename->rn_tnamelen);\n\tif ((status = check_filename(rename->rn_sname, rename->rn_snamelen)))\n\t\treturn status;\n\tif ((status = check_filename(rename->rn_tname, rename->rn_tnamelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "rename->rn_tname",
            "rename->rn_tnamelen"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "68-81",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "rename->rn_tname",
            "rename->rn_tnamelen"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "rename->rn_tnamelen"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "rename->rn_sname",
            "rename->rn_snamelen"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "rename->rn_snamelen"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\trename->rn_snamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_snamelen);\n\tSAVEMEM(rename->rn_sname, rename->rn_snamelen);\n\tREAD_BUF(4);\n\trename->rn_tnamelen = be32_to_cpup(p++);\n\tREAD_BUF(rename->rn_tnamelen);\n\tSAVEMEM(rename->rn_tname, rename->rn_tnamelen);\n\tif ((status = check_filename(rename->rn_sname, rename->rn_snamelen)))\n\t\treturn status;\n\tif ((status = check_filename(rename->rn_tname, rename->rn_tnamelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1053-1066",
    "snippet": "static __be32\nnfsd4_decode_remove(struct nfsd4_compoundargs *argp, struct nfsd4_remove *remove)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tremove->rm_namelen = be32_to_cpup(p++);\n\tREAD_BUF(remove->rm_namelen);\n\tSAVEMEM(remove->rm_name, remove->rm_namelen);\n\tif ((status = check_filename(remove->rm_name, remove->rm_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "remove->rm_name",
            "remove->rm_namelen"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "68-81",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "remove->rm_name",
            "remove->rm_namelen"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "remove->rm_namelen"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_remove(struct nfsd4_compoundargs *argp, struct nfsd4_remove *remove)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tremove->rm_namelen = be32_to_cpup(p++);\n\tREAD_BUF(remove->rm_namelen);\n\tSAVEMEM(remove->rm_name, remove->rm_namelen);\n\tif ((status = check_filename(remove->rm_name, remove->rm_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1037-1051",
    "snippet": "static __be32\nnfsd4_decode_readdir(struct nfsd4_compoundargs *argp, struct nfsd4_readdir *readdir)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(24);\n\tp = xdr_decode_hyper(p, &readdir->rd_cookie);\n\tCOPYMEM(readdir->rd_verf.data, sizeof(readdir->rd_verf.data));\n\treaddir->rd_dircount = be32_to_cpup(p++);\n\treaddir->rd_maxcount = be32_to_cpup(p++);\n\tif ((status = nfsd4_decode_bitmap(argp, readdir->rd_bmval)))\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "readdir->rd_bmval"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "259-283",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "readdir->rd_verf.data",
            "sizeof(readdir->rd_verf.data)"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&readdir->rd_cookie"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "24"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_readdir(struct nfsd4_compoundargs *argp, struct nfsd4_readdir *readdir)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(24);\n\tp = xdr_decode_hyper(p, &readdir->rd_cookie);\n\tCOPYMEM(readdir->rd_verf.data, sizeof(readdir->rd_verf.data));\n\treaddir->rd_dircount = be32_to_cpup(p++);\n\treaddir->rd_maxcount = be32_to_cpup(p++);\n\tif ((status = nfsd4_decode_bitmap(argp, readdir->rd_bmval)))\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1022-1035",
    "snippet": "static __be32\nnfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &read->rd_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &read->rd_offset);\n\tread->rd_length = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&read->rd_offset"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&read->rd_stateid"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_read(struct nfsd4_compoundargs *argp, struct nfsd4_read *read)\n{\n\tDECODE_HEAD;\n\n\tstatus = nfsd4_decode_stateid(argp, &read->rd_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &read->rd_offset);\n\tread->rd_length = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_putpubfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "1014-1020",
    "snippet": "static __be32\nnfsd4_decode_putpubfh(struct nfsd4_compoundargs *argp, void *p)\n{\n\tif (argp->minorversion == 0)\n\t\treturn nfs_ok;\n\treturn nfserr_notsupp;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_decode_putpubfh(struct nfsd4_compoundargs *argp, void *p)\n{\n\tif (argp->minorversion == 0)\n\t\treturn nfs_ok;\n\treturn nfserr_notsupp;\n}"
  },
  {
    "function_name": "nfsd4_decode_putfh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "999-1012",
    "snippet": "static __be32\nnfsd4_decode_putfh(struct nfsd4_compoundargs *argp, struct nfsd4_putfh *putfh)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tputfh->pf_fhlen = be32_to_cpup(p++);\n\tif (putfh->pf_fhlen > NFS4_FHSIZE)\n\t\tgoto xdr_error;\n\tREAD_BUF(putfh->pf_fhlen);\n\tSAVEMEM(putfh->pf_fhval, putfh->pf_fhlen);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "putfh->pf_fhval",
            "putfh->pf_fhlen"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "putfh->pf_fhlen"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_putfh(struct nfsd4_compoundargs *argp, struct nfsd4_putfh *putfh)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tputfh->pf_fhlen = be32_to_cpup(p++);\n\tif (putfh->pf_fhlen > NFS4_FHSIZE)\n\t\tgoto xdr_error;\n\tREAD_BUF(putfh->pf_fhlen);\n\tSAVEMEM(putfh->pf_fhval, putfh->pf_fhlen);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_open_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "979-997",
    "snippet": "static __be32\nnfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, struct nfsd4_open_downgrade *open_down)\n{\n\tDECODE_HEAD;\n\t\t    \n\tstatus = nfsd4_decode_stateid(argp, &open_down->od_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_down->od_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_share_access(argp, &open_down->od_share_access,\n\t\t\t\t\t   &open_down->od_deleg_want, NULL);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_share_deny(argp, &open_down->od_share_deny);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_share_deny",
          "args": [
            "argp",
            "&open_down->od_share_deny"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "818-830",
          "snippet": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_share_access",
          "args": [
            "argp",
            "&open_down->od_share_access",
            "&open_down->od_deleg_want",
            "NULL"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "765-816",
          "snippet": "static __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&open_down->od_stateid"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_open_downgrade(struct nfsd4_compoundargs *argp, struct nfsd4_open_downgrade *open_down)\n{\n\tDECODE_HEAD;\n\t\t    \n\tstatus = nfsd4_decode_stateid(argp, &open_down->od_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_down->od_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_share_access(argp, &open_down->od_share_access,\n\t\t\t\t\t   &open_down->od_deleg_want, NULL);\n\tif (status)\n\t\treturn status;\n\tstatus = nfsd4_decode_share_deny(argp, &open_down->od_share_deny);\n\tif (status)\n\t\treturn status;\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_open_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "962-977",
    "snippet": "static __be32\nnfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_open_confirm *open_conf)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_stateid(argp, &open_conf->oc_req_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_conf->oc_seqid = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&open_conf->oc_req_stateid"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_open_confirm(struct nfsd4_compoundargs *argp, struct nfsd4_open_confirm *open_conf)\n{\n\tDECODE_HEAD;\n\n\tif (argp->minorversion >= 1)\n\t\treturn nfserr_notsupp;\n\n\tstatus = nfsd4_decode_stateid(argp, &open_conf->oc_req_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(4);\n\topen_conf->oc_seqid = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "849-960",
    "snippet": "static __be32\nnfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tmemset(open->op_bmval, 0, sizeof(open->op_bmval));\n\topen->op_iattr.ia_valid = 0;\n\topen->op_openowner = NULL;\n\n\topen->op_xdr_error = 0;\n\t/* seqid, share_access, share_deny, clientid, ownerlen */\n\tREAD_BUF(4);\n\topen->op_seqid = be32_to_cpup(p++);\n\t/* decode, yet ignore deleg_when until supported */\n\tstatus = nfsd4_decode_share_access(argp, &open->op_share_access,\n\t\t\t\t\t   &open->op_deleg_want, &dummy);\n\tif (status)\n\t\tgoto xdr_error;\n\tstatus = nfsd4_decode_share_deny(argp, &open->op_share_deny);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(&open->op_clientid, sizeof(clientid_t));\n\tstatus = nfsd4_decode_opaque(argp, &open->op_owner);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(4);\n\topen->op_create = be32_to_cpup(p++);\n\tswitch (open->op_create) {\n\tcase NFS4_OPEN_NOCREATE:\n\t\tbreak;\n\tcase NFS4_OPEN_CREATE:\n\t\tREAD_BUF(4);\n\t\topen->op_createmode = be32_to_cpup(p++);\n\t\tswitch (open->op_createmode) {\n\t\tcase NFS4_CREATE_UNCHECKED:\n\t\tcase NFS4_CREATE_GUARDED:\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE:\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (argp->minorversion < 1)\n\t\t\t\tgoto xdr_error;\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* open_claim */\n\tREAD_BUF(4);\n\topen->op_claim_type = be32_to_cpup(p++);\n\tswitch (open->op_claim_type) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tREAD_BUF(4);\n\t\topen->op_delegate_type = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\t/* void */\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&open->op_delegate_stateid"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "open->op_fname.data",
            "open->op_fname.len"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "68-81",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "open->op_fname.data",
            "open->op_fname.len"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "open->op_fname.len"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "open->op_fname.data",
            "open->op_fname.len"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "open->op_fname.len"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_fattr",
          "args": [
            "argp",
            "open->op_bmval",
            "&open->op_iattr",
            "&open->op_acl",
            "&open->op_label"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "285-447",
          "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "open->op_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "open->op_verf.data",
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_VERIFIER_SIZE"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_opaque",
          "args": [
            "argp",
            "&open->op_owner"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_opaque",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "832-847",
          "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&open->op_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(clientid_t)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_share_deny",
          "args": [
            "argp",
            "&open->op_share_deny"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "818-830",
          "snippet": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_share_access",
          "args": [
            "argp",
            "&open->op_share_access",
            "&open->op_deleg_want",
            "&dummy"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_share_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "765-816",
          "snippet": "static __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "open->op_bmval",
            "0",
            "sizeof(open->op_bmval)"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_open(struct nfsd4_compoundargs *argp, struct nfsd4_open *open)\n{\n\tDECODE_HEAD;\n\tu32 dummy;\n\n\tmemset(open->op_bmval, 0, sizeof(open->op_bmval));\n\topen->op_iattr.ia_valid = 0;\n\topen->op_openowner = NULL;\n\n\topen->op_xdr_error = 0;\n\t/* seqid, share_access, share_deny, clientid, ownerlen */\n\tREAD_BUF(4);\n\topen->op_seqid = be32_to_cpup(p++);\n\t/* decode, yet ignore deleg_when until supported */\n\tstatus = nfsd4_decode_share_access(argp, &open->op_share_access,\n\t\t\t\t\t   &open->op_deleg_want, &dummy);\n\tif (status)\n\t\tgoto xdr_error;\n\tstatus = nfsd4_decode_share_deny(argp, &open->op_share_deny);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(sizeof(clientid_t));\n\tCOPYMEM(&open->op_clientid, sizeof(clientid_t));\n\tstatus = nfsd4_decode_opaque(argp, &open->op_owner);\n\tif (status)\n\t\tgoto xdr_error;\n\tREAD_BUF(4);\n\topen->op_create = be32_to_cpup(p++);\n\tswitch (open->op_create) {\n\tcase NFS4_OPEN_NOCREATE:\n\t\tbreak;\n\tcase NFS4_OPEN_CREATE:\n\t\tREAD_BUF(4);\n\t\topen->op_createmode = be32_to_cpup(p++);\n\t\tswitch (open->op_createmode) {\n\t\tcase NFS4_CREATE_UNCHECKED:\n\t\tcase NFS4_CREATE_GUARDED:\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE:\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tbreak;\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (argp->minorversion < 1)\n\t\t\t\tgoto xdr_error;\n\t\t\tREAD_BUF(NFS4_VERIFIER_SIZE);\n\t\t\tCOPYMEM(open->op_verf.data, NFS4_VERIFIER_SIZE);\n\t\t\tstatus = nfsd4_decode_fattr(argp, open->op_bmval,\n\t\t\t\t&open->op_iattr, &open->op_acl, &open->op_label);\n\t\t\tif (status)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\t/* open_claim */\n\tREAD_BUF(4);\n\topen->op_claim_type = be32_to_cpup(p++);\n\tswitch (open->op_claim_type) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\tcase NFS4_OPEN_CLAIM_DELEGATE_PREV:\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tREAD_BUF(4);\n\t\topen->op_delegate_type = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\topen->op_fname.len = be32_to_cpup(p++);\n\t\tREAD_BUF(open->op_fname.len);\n\t\tSAVEMEM(open->op_fname.data, open->op_fname.len);\n\t\tif ((status = check_filename(open->op_fname.data, open->op_fname.len)))\n\t\t\treturn status;\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_FH:\n\tcase NFS4_OPEN_CLAIM_DELEG_PREV_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\t/* void */\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEG_CUR_FH:\n\t\tif (argp->minorversion < 1)\n\t\t\tgoto xdr_error;\n\t\tstatus = nfsd4_decode_stateid(argp, &open->op_delegate_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tbreak;\n\tdefault:\n\t\tgoto xdr_error;\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_opaque",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "832-847",
    "snippet": "static __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "o->data",
            "o->len"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "o->len"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_opaque(struct nfsd4_compoundargs *argp, struct xdr_netobj *o)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\to->len = be32_to_cpup(p++);\n\n\tif (o->len == 0 || o->len > NFS4_OPAQUE_LIMIT)\n\t\treturn nfserr_bad_xdr;\n\n\tREAD_BUF(o->len);\n\tSAVEMEM(o->data, o->len);\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
  },
  {
    "function_name": "nfsd4_decode_share_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "818-830",
    "snippet": "static __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_share_deny(struct nfsd4_compoundargs *argp, u32 *x)\n{\n\t__be32 *p;\n\n\tREAD_BUF(4);\n\t*x = be32_to_cpup(p++);\n\t/* Note: unlinke access bits, deny bits may be zero. */\n\tif (*x & ~NFS4_SHARE_DENY_BOTH)\n\t\treturn nfserr_bad_xdr;\n\treturn nfs_ok;\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
  },
  {
    "function_name": "nfsd4_decode_share_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "765-816",
    "snippet": "static __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_decode_share_access(struct nfsd4_compoundargs *argp, u32 *share_access, u32 *deleg_want, u32 *deleg_when)\n{\n\t__be32 *p;\n\tu32 w;\n\n\tREAD_BUF(4);\n\tw = be32_to_cpup(p++);\n\t*share_access = w & NFS4_SHARE_ACCESS_MASK;\n\t*deleg_want = w & NFS4_SHARE_WANT_MASK;\n\tif (deleg_when)\n\t\t*deleg_when = w & NFS4_SHARE_WHEN_MASK;\n\n\tswitch (w & NFS4_SHARE_ACCESS_MASK) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_ACCESS_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\tif (!argp->minorversion)\n\t\treturn nfserr_bad_xdr;\n\tswitch (w & NFS4_SHARE_WANT_MASK) {\n\tcase NFS4_SHARE_WANT_NO_PREFERENCE:\n\tcase NFS4_SHARE_WANT_READ_DELEG:\n\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\tcase NFS4_SHARE_WANT_NO_DELEG:\n\tcase NFS4_SHARE_WANT_CANCEL:\n\t\tbreak;\n\tdefault:\n\t\treturn nfserr_bad_xdr;\n\t}\n\tw &= ~NFS4_SHARE_WANT_MASK;\n\tif (!w)\n\t\treturn nfs_ok;\n\n\tif (!deleg_when)\t/* open_downgrade */\n\t\treturn nfserr_inval;\n\tswitch (w) {\n\tcase NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL:\n\tcase NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED:\n\tcase (NFS4_SHARE_SIGNAL_DELEG_WHEN_RESRC_AVAIL |\n\t      NFS4_SHARE_PUSH_DELEG_WHEN_UNCONTENDED):\n\t\treturn nfs_ok;\n\t}\nxdr_error:\n\treturn nfserr_bad_xdr;\n}"
  },
  {
    "function_name": "nfsd4_decode_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "750-763",
    "snippet": "static __be32\nnfsd4_decode_lookup(struct nfsd4_compoundargs *argp, struct nfsd4_lookup *lookup)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlookup->lo_len = be32_to_cpup(p++);\n\tREAD_BUF(lookup->lo_len);\n\tSAVEMEM(lookup->lo_name, lookup->lo_len);\n\tif ((status = check_filename(lookup->lo_name, lookup->lo_len)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "lookup->lo_name",
            "lookup->lo_len"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "68-81",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "lookup->lo_name",
            "lookup->lo_len"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lookup->lo_len"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_lookup(struct nfsd4_compoundargs *argp, struct nfsd4_lookup *lookup)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlookup->lo_len = be32_to_cpup(p++);\n\tREAD_BUF(lookup->lo_len);\n\tSAVEMEM(lookup->lo_name, lookup->lo_len);\n\tif ((status = check_filename(lookup->lo_name, lookup->lo_len)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_locku",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "730-748",
    "snippet": "static __be32\nnfsd4_decode_locku(struct nfsd4_compoundargs *argp, struct nfsd4_locku *locku)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tlocku->lu_type = be32_to_cpup(p++);\n\tif ((locku->lu_type < NFS4_READ_LT) || (locku->lu_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlocku->lu_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_stateid(argp, &locku->lu_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &locku->lu_offset);\n\tp = xdr_decode_hyper(p, &locku->lu_length);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&locku->lu_length"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&locku->lu_offset"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&locku->lu_stateid"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_locku(struct nfsd4_compoundargs *argp, struct nfsd4_locku *locku)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(8);\n\tlocku->lu_type = be32_to_cpup(p++);\n\tif ((locku->lu_type < NFS4_READ_LT) || (locku->lu_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlocku->lu_seqid = be32_to_cpup(p++);\n\tstatus = nfsd4_decode_stateid(argp, &locku->lu_stateid);\n\tif (status)\n\t\treturn status;\n\tREAD_BUF(16);\n\tp = xdr_decode_hyper(p, &locku->lu_offset);\n\tp = xdr_decode_hyper(p, &locku->lu_length);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_lockt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "711-728",
    "snippet": "static __be32\nnfsd4_decode_lockt(struct nfsd4_compoundargs *argp, struct nfsd4_lockt *lockt)\n{\n\tDECODE_HEAD;\n\t\t        \n\tREAD_BUF(32);\n\tlockt->lt_type = be32_to_cpup(p++);\n\tif((lockt->lt_type < NFS4_READ_LT) || (lockt->lt_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tp = xdr_decode_hyper(p, &lockt->lt_offset);\n\tp = xdr_decode_hyper(p, &lockt->lt_length);\n\tCOPYMEM(&lockt->lt_clientid, 8);\n\tlockt->lt_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(lockt->lt_owner.len);\n\tREADMEM(lockt->lt_owner.data, lockt->lt_owner.len);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lockt->lt_owner.data",
            "lockt->lt_owner.len"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lockt->lt_owner.len"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&lockt->lt_clientid",
            "8"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lockt->lt_length"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lockt->lt_offset"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "32"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_lockt(struct nfsd4_compoundargs *argp, struct nfsd4_lockt *lockt)\n{\n\tDECODE_HEAD;\n\t\t        \n\tREAD_BUF(32);\n\tlockt->lt_type = be32_to_cpup(p++);\n\tif((lockt->lt_type < NFS4_READ_LT) || (lockt->lt_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tp = xdr_decode_hyper(p, &lockt->lt_offset);\n\tp = xdr_decode_hyper(p, &lockt->lt_length);\n\tCOPYMEM(&lockt->lt_clientid, 8);\n\tlockt->lt_owner.len = be32_to_cpup(p++);\n\tREAD_BUF(lockt->lt_owner.len);\n\tREADMEM(lockt->lt_owner.data, lockt->lt_owner.len);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "671-709",
    "snippet": "static __be32\nnfsd4_decode_lock(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)\n{\n\tDECODE_HEAD;\n\n\t/*\n\t* type, reclaim(boolean), offset, length, new_lock_owner(boolean)\n\t*/\n\tREAD_BUF(28);\n\tlock->lk_type = be32_to_cpup(p++);\n\tif ((lock->lk_type < NFS4_READ_LT) || (lock->lk_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlock->lk_reclaim = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lock->lk_offset);\n\tp = xdr_decode_hyper(p, &lock->lk_length);\n\tlock->lk_is_new = be32_to_cpup(p++);\n\n\tif (lock->lk_is_new) {\n\t\tREAD_BUF(4);\n\t\tlock->lk_new_open_seqid = be32_to_cpup(p++);\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_new_open_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(8 + sizeof(clientid_t));\n\t\tlock->lk_new_lock_seqid = be32_to_cpup(p++);\n\t\tCOPYMEM(&lock->lk_new_clientid, sizeof(clientid_t));\n\t\tlock->lk_new_owner.len = be32_to_cpup(p++);\n\t\tREAD_BUF(lock->lk_new_owner.len);\n\t\tREADMEM(lock->lk_new_owner.data, lock->lk_new_owner.len);\n\t} else {\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_old_lock_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\tlock->lk_old_lock_seqid = be32_to_cpup(p++);\n\t}\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&lock->lk_old_lock_stateid"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "lock->lk_new_owner.data",
            "lock->lk_new_owner.len"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "lock->lk_new_owner.len"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&lock->lk_new_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8 + sizeof(clientid_t)"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lock->lk_length"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&lock->lk_offset"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "28"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_lock(struct nfsd4_compoundargs *argp, struct nfsd4_lock *lock)\n{\n\tDECODE_HEAD;\n\n\t/*\n\t* type, reclaim(boolean), offset, length, new_lock_owner(boolean)\n\t*/\n\tREAD_BUF(28);\n\tlock->lk_type = be32_to_cpup(p++);\n\tif ((lock->lk_type < NFS4_READ_LT) || (lock->lk_type > NFS4_WRITEW_LT))\n\t\tgoto xdr_error;\n\tlock->lk_reclaim = be32_to_cpup(p++);\n\tp = xdr_decode_hyper(p, &lock->lk_offset);\n\tp = xdr_decode_hyper(p, &lock->lk_length);\n\tlock->lk_is_new = be32_to_cpup(p++);\n\n\tif (lock->lk_is_new) {\n\t\tREAD_BUF(4);\n\t\tlock->lk_new_open_seqid = be32_to_cpup(p++);\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_new_open_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(8 + sizeof(clientid_t));\n\t\tlock->lk_new_lock_seqid = be32_to_cpup(p++);\n\t\tCOPYMEM(&lock->lk_new_clientid, sizeof(clientid_t));\n\t\tlock->lk_new_owner.len = be32_to_cpup(p++);\n\t\tREAD_BUF(lock->lk_new_owner.len);\n\t\tREADMEM(lock->lk_new_owner.data, lock->lk_new_owner.len);\n\t} else {\n\t\tstatus = nfsd4_decode_stateid(argp, &lock->lk_old_lock_stateid);\n\t\tif (status)\n\t\t\treturn status;\n\t\tREAD_BUF(4);\n\t\tlock->lk_old_lock_seqid = be32_to_cpup(p++);\n\t}\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "656-669",
    "snippet": "static __be32\nnfsd4_decode_link(struct nfsd4_compoundargs *argp, struct nfsd4_link *link)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlink->li_namelen = be32_to_cpup(p++);\n\tREAD_BUF(link->li_namelen);\n\tSAVEMEM(link->li_name, link->li_namelen);\n\tif ((status = check_filename(link->li_name, link->li_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "link->li_name",
            "link->li_namelen"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "68-81",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "link->li_name",
            "link->li_namelen"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "link->li_namelen"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_link(struct nfsd4_compoundargs *argp, struct nfsd4_link *link)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tlink->li_namelen = be32_to_cpup(p++);\n\tREAD_BUF(link->li_namelen);\n\tSAVEMEM(link->li_name, link->li_namelen);\n\tif ((status = check_filename(link->li_name, link->li_namelen)))\n\t\treturn status;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "650-654",
    "snippet": "static inline __be32\nnfsd4_decode_getattr(struct nfsd4_compoundargs *argp, struct nfsd4_getattr *getattr)\n{\n\treturn nfsd4_decode_bitmap(argp, getattr->ga_bmval);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "getattr->ga_bmval"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "259-283",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_decode_getattr(struct nfsd4_compoundargs *argp, struct nfsd4_getattr *getattr)\n{\n\treturn nfsd4_decode_bitmap(argp, getattr->ga_bmval);\n}"
  },
  {
    "function_name": "nfsd4_decode_delegreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "644-648",
    "snippet": "static inline __be32\nnfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, struct nfsd4_delegreturn *dr)\n{\n\treturn nfsd4_decode_stateid(argp, &dr->dr_stateid);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&dr->dr_stateid"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_decode_delegreturn(struct nfsd4_compoundargs *argp, struct nfsd4_delegreturn *dr)\n{\n\treturn nfsd4_decode_stateid(argp, &dr->dr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_decode_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "600-642",
    "snippet": "static __be32\nnfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tcreate->cr_type = be32_to_cpup(p++);\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tREAD_BUF(4);\n\t\tcreate->cr_datalen = be32_to_cpup(p++);\n\t\tREAD_BUF(create->cr_datalen);\n\t\tcreate->cr_data = svcxdr_dupstr(argp, p, create->cr_datalen);\n\t\tif (!create->cr_data)\n\t\t\treturn nfserr_jukebox;\n\t\tbreak;\n\tcase NF4BLK:\n\tcase NF4CHR:\n\t\tREAD_BUF(8);\n\t\tcreate->cr_specdata1 = be32_to_cpup(p++);\n\t\tcreate->cr_specdata2 = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NF4SOCK:\n\tcase NF4FIFO:\n\tcase NF4DIR:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREAD_BUF(4);\n\tcreate->cr_namelen = be32_to_cpup(p++);\n\tREAD_BUF(create->cr_namelen);\n\tSAVEMEM(create->cr_name, create->cr_namelen);\n\tif ((status = check_filename(create->cr_name, create->cr_namelen)))\n\t\treturn status;\n\n\tstatus = nfsd4_decode_fattr(argp, create->cr_bmval, &create->cr_iattr,\n\t\t\t\t    &create->cr_acl, &create->cr_label);\n\tif (status)\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_fattr",
          "args": [
            "argp",
            "create->cr_bmval",
            "&create->cr_iattr",
            "&create->cr_acl",
            "&create->cr_label"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "285-447",
          "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_filename",
          "args": [
            "create->cr_name",
            "create->cr_namelen"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "check_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "68-81",
          "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "create->cr_name",
            "create->cr_namelen"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "create->cr_namelen"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_dupstr",
          "args": [
            "argp",
            "p",
            "create->cr_datalen"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_dupstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "206-216",
          "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "create->cr_datalen"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_create(struct nfsd4_compoundargs *argp, struct nfsd4_create *create)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tcreate->cr_type = be32_to_cpup(p++);\n\tswitch (create->cr_type) {\n\tcase NF4LNK:\n\t\tREAD_BUF(4);\n\t\tcreate->cr_datalen = be32_to_cpup(p++);\n\t\tREAD_BUF(create->cr_datalen);\n\t\tcreate->cr_data = svcxdr_dupstr(argp, p, create->cr_datalen);\n\t\tif (!create->cr_data)\n\t\t\treturn nfserr_jukebox;\n\t\tbreak;\n\tcase NF4BLK:\n\tcase NF4CHR:\n\t\tREAD_BUF(8);\n\t\tcreate->cr_specdata1 = be32_to_cpup(p++);\n\t\tcreate->cr_specdata2 = be32_to_cpup(p++);\n\t\tbreak;\n\tcase NF4SOCK:\n\tcase NF4FIFO:\n\tcase NF4DIR:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tREAD_BUF(4);\n\tcreate->cr_namelen = be32_to_cpup(p++);\n\tREAD_BUF(create->cr_namelen);\n\tSAVEMEM(create->cr_name, create->cr_namelen);\n\tif ((status = check_filename(create->cr_name, create->cr_namelen)))\n\t\treturn status;\n\n\tstatus = nfsd4_decode_fattr(argp, create->cr_bmval, &create->cr_iattr,\n\t\t\t\t    &create->cr_acl, &create->cr_label);\n\tif (status)\n\t\tgoto out;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "588-598",
    "snippet": "static __be32\nnfsd4_decode_commit(struct nfsd4_compoundargs *argp, struct nfsd4_commit *commit)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &commit->co_offset);\n\tcommit->co_count = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&commit->co_offset"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_commit(struct nfsd4_compoundargs *argp, struct nfsd4_commit *commit)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &commit->co_offset);\n\tcommit->co_count = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "575-585",
    "snippet": "static __be32\nnfsd4_decode_close(struct nfsd4_compoundargs *argp, struct nfsd4_close *close)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tclose->cl_seqid = be32_to_cpup(p++);\n\treturn nfsd4_decode_stateid(argp, &close->cl_stateid);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_stateid",
          "args": [
            "argp",
            "&close->cl_stateid"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "449-459",
          "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_close(struct nfsd4_compoundargs *argp, struct nfsd4_close *close)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tclose->cl_seqid = be32_to_cpup(p++);\n\treturn nfsd4_decode_stateid(argp, &close->cl_stateid);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "563-573",
    "snippet": "static __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 8);\n\tCOPYMEM(bcts->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tbcts->dir = be32_to_cpup(p++);\n\t/* XXX: skipping ctsa_use_conn_in_rdma_mode.  Perhaps Tom Tucker\n\t * could help us figure out we should be using it. */\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "bcts->sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "NFS4_MAX_SESSIONID_LEN + 8"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_bind_conn_to_session(struct nfsd4_compoundargs *argp, struct nfsd4_bind_conn_to_session *bcts)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(NFS4_MAX_SESSIONID_LEN + 8);\n\tCOPYMEM(bcts->sessionid.data, NFS4_MAX_SESSIONID_LEN);\n\tbcts->dir = be32_to_cpup(p++);\n\t/* XXX: skipping ctsa_use_conn_in_rdma_mode.  Perhaps Tom Tucker\n\t * could help us figure out we should be using it. */\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_backchannel_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "552-561",
    "snippet": "static __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, struct nfsd4_backchannel_ctl *bc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tbc->bc_cb_program = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_decode_cb_sec",
          "args": [
            "argp",
            "&bc->bc_cb_sec"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "472-550",
          "snippet": "static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_backchannel_ctl(struct nfsd4_compoundargs *argp, struct nfsd4_backchannel_ctl *bc)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\tbc->bc_cb_program = be32_to_cpup(p++);\n\tnfsd4_decode_cb_sec(argp, &bc->bc_cb_sec);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_cb_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "472-550",
    "snippet": "static __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"Illegal callback secflavor\\n\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "kgid"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "kuid"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "gid"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy * 4"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVEMEM",
          "args": [
            "machine_name",
            "dummy"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-1"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32 nfsd4_decode_cb_sec(struct nfsd4_compoundargs *argp, struct nfsd4_cb_sec *cbs)\n{\n\tDECODE_HEAD;\n\tu32 dummy, uid, gid;\n\tchar *machine_name;\n\tint i;\n\tint nr_secflavs;\n\n\t/* callback_sec_params4 */\n\tREAD_BUF(4);\n\tnr_secflavs = be32_to_cpup(p++);\n\tif (nr_secflavs)\n\t\tcbs->flavor = (u32)(-1);\n\telse\n\t\t/* Is this legal? Be generous, take it to mean AUTH_NONE: */\n\t\tcbs->flavor = 0;\n\tfor (i = 0; i < nr_secflavs; ++i) {\n\t\tREAD_BUF(4);\n\t\tdummy = be32_to_cpup(p++);\n\t\tswitch (dummy) {\n\t\tcase RPC_AUTH_NULL:\n\t\t\t/* Nothing to read */\n\t\t\tif (cbs->flavor == (u32)(-1))\n\t\t\t\tcbs->flavor = RPC_AUTH_NULL;\n\t\t\tbreak;\n\t\tcase RPC_AUTH_UNIX:\n\t\t\tREAD_BUF(8);\n\t\t\t/* stamp */\n\t\t\tdummy = be32_to_cpup(p++);\n\n\t\t\t/* machine name */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tSAVEMEM(machine_name, dummy);\n\n\t\t\t/* uid, gid */\n\t\t\tREAD_BUF(8);\n\t\t\tuid = be32_to_cpup(p++);\n\t\t\tgid = be32_to_cpup(p++);\n\n\t\t\t/* more gids */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy * 4);\n\t\t\tif (cbs->flavor == (u32)(-1)) {\n\t\t\t\tkuid_t kuid = make_kuid(&init_user_ns, uid);\n\t\t\t\tkgid_t kgid = make_kgid(&init_user_ns, gid);\n\t\t\t\tif (uid_valid(kuid) && gid_valid(kgid)) {\n\t\t\t\t\tcbs->uid = kuid;\n\t\t\t\t\tcbs->gid = kgid;\n\t\t\t\t\tcbs->flavor = RPC_AUTH_UNIX;\n\t\t\t\t} else {\n\t\t\t\t\tdprintk(\"RPC_AUTH_UNIX with invalid\"\n\t\t\t\t\t\t\"uid or gid ignoring!\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RPC_AUTH_GSS:\n\t\t\tdprintk(\"RPC_AUTH_GSS callback secflavor \"\n\t\t\t\t\"not supported!\\n\");\n\t\t\tREAD_BUF(8);\n\t\t\t/* gcbp_service */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\t/* gcbp_handle_from_server */\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tp += XDR_QUADLEN(dummy);\n\t\t\t/* gcbp_handle_from_client */\n\t\t\tREAD_BUF(4);\n\t\t\tdummy = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"Illegal callback secflavor\\n\");\n\t\t\treturn nfserr_inval;\n\t\t}\n\t}\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "461-470",
    "snippet": "static __be32\nnfsd4_decode_access(struct nfsd4_compoundargs *argp, struct nfsd4_access *access)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\taccess->ac_req_access = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_access(struct nfsd4_compoundargs *argp, struct nfsd4_access *access)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(4);\n\taccess->ac_req_access = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "449-459",
    "snippet": "static __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "COPYMEM",
          "args": [
            "&sid->si_opaque",
            "sizeof(stateid_opaque_t)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "sizeof(stateid_t)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_stateid(struct nfsd4_compoundargs *argp, stateid_t *sid)\n{\n\tDECODE_HEAD;\n\n\tREAD_BUF(sizeof(stateid_t));\n\tsid->si_generation = be32_to_cpup(p++);\n\tCOPYMEM(&sid->si_opaque, sizeof(stateid_opaque_t));\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_fattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "285-447",
    "snippet": "static __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "expected_len - len"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_dupstr",
          "args": [
            "argp",
            "buf",
            "dummy32"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_dupstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "206-216",
          "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_time",
          "args": [
            "argp",
            "&iattr->ia_mtime"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "243-257",
          "snippet": "static __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_map_name_to_gid",
          "args": [
            "argp->rqstp",
            "buf",
            "dummy32",
            "&iattr->ia_gid"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_map_name_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4idmap.c",
          "lines": "638-649",
          "snippet": "__be32\nnfsd_map_name_to_gid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkgid_t *gid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_GROUP, name, namelen, &id);\n\t*gid = make_kgid(&init_user_ns, id);\n\tif (!gid_valid(*gid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n__be32\nnfsd_map_name_to_gid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkgid_t *gid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_GROUP, name, namelen, &id);\n\t*gid = make_kgid(&init_user_ns, id);\n\tif (!gid_valid(*gid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_map_name_to_uid",
          "args": [
            "argp->rqstp",
            "buf",
            "dummy32",
            "&iattr->ia_uid"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_map_name_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4idmap.c",
          "lines": "625-636",
          "snippet": "__be32\nnfsd_map_name_to_uid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkuid_t *uid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_USER, name, namelen, &id);\n\t*uid = make_kuid(&init_user_ns, id);\n\tif (!uid_valid(*uid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include <net/net_namespace.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n__be32\nnfsd_map_name_to_uid(struct svc_rqst *rqstp, const char *name, size_t namelen,\n\t\tkuid_t *uid)\n{\n\t__be32 status;\n\tu32 id = -1;\n\tstatus = do_name_to_id(rqstp, IDMAP_TYPE_USER, name, namelen, &id);\n\t*uid = make_kuid(&init_user_ns, id);\n\tif (!uid_valid(*uid))\n\t\tstatus = nfserr_badowner;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_acl_get_whotype",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_get_whotype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4acl.c",
          "lines": "854-865",
          "snippet": "int\nnfs4_acl_get_whotype(char *p, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].stringlen == len &&\n\t\t\t\t0 == memcmp(s2t_map[i].string, p, len))\n\t\t\treturn s2t_map[i].type;\n\t}\n\treturn NFS4_ACL_WHO_NAMED;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic struct {\n\tchar *string;\n\tint   stringlen;\n\tint type;\n} s2t_map[] = {\n\t{\n\t\t.string    = \"OWNER@\",\n\t\t.stringlen = sizeof(\"OWNER@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_OWNER,\n\t},\n\t{\n\t\t.string    = \"GROUP@\",\n\t\t.stringlen = sizeof(\"GROUP@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_GROUP,\n\t},\n\t{\n\t\t.string    = \"EVERYONE@\",\n\t\t.stringlen = sizeof(\"EVERYONE@\") - 1,\n\t\t.type      = NFS4_ACL_WHO_EVERYONE,\n\t},\n};\n\nint\nnfs4_acl_get_whotype(char *p, u32 len)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(s2t_map); i++) {\n\t\tif (s2t_map[i].stringlen == len &&\n\t\t\t\t0 == memcmp(s2t_map[i].string, p, len))\n\t\t\treturn s2t_map[i].type;\n\t}\n\treturn NFS4_ACL_WHO_NAMED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READMEM",
          "args": [
            "buf",
            "dummy32"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "dummy32"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "dummy32"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "16"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "nfs4_acl_bytes(nace)"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "186-197",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_acl_bytes",
          "args": [
            "nace"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_acl_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4acl.c",
          "lines": "827-830",
          "snippet": "int nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"acl.h\"",
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\"",
            "#include <linux/posix_acl.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static short ace2type(struct nfs4_ace *);",
            "static void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"acl.h\"\n#include \"nfsd.h\"\n#include \"nfsfh.h\"\n#include <linux/posix_acl.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic short ace2type(struct nfs4_ace *);\nstatic void _posix_to_nfsv4_one(struct posix_acl *, struct nfs4_acl *,\n\t\t\t\tunsigned int);\n\nint nfs4_acl_bytes(int entries)\n{\n\treturn sizeof(struct nfs4_acl) + entries * sizeof(struct nfs4_ace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&iattr->ia_size"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "8"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_decode_bitmap",
          "args": [
            "argp",
            "bmval"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_decode_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "259-283",
          "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
            "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval,\n\t\t   struct iattr *iattr, struct nfs4_acl **acl,\n\t\t   struct xdr_netobj *label)\n{\n\tint expected_len, len = 0;\n\tu32 dummy32;\n\tchar *buf;\n\n\tDECODE_HEAD;\n\tiattr->ia_valid = 0;\n\tif ((status = nfsd4_decode_bitmap(argp, bmval)))\n\t\treturn status;\n\n\tREAD_BUF(4);\n\texpected_len = be32_to_cpup(p++);\n\n\tif (bmval[0] & FATTR4_WORD0_SIZE) {\n\t\tREAD_BUF(8);\n\t\tlen += 8;\n\t\tp = xdr_decode_hyper(p, &iattr->ia_size);\n\t\tiattr->ia_valid |= ATTR_SIZE;\n\t}\n\tif (bmval[0] & FATTR4_WORD0_ACL) {\n\t\tu32 nace;\n\t\tstruct nfs4_ace *ace;\n\n\t\tREAD_BUF(4); len += 4;\n\t\tnace = be32_to_cpup(p++);\n\n\t\tif (nace > NFS4_ACL_MAX)\n\t\t\treturn nfserr_fbig;\n\n\t\t*acl = svcxdr_tmpalloc(argp, nfs4_acl_bytes(nace));\n\t\tif (*acl == NULL)\n\t\t\treturn nfserr_jukebox;\n\n\t\t(*acl)->naces = nace;\n\t\tfor (ace = (*acl)->aces; ace < (*acl)->aces + nace; ace++) {\n\t\t\tREAD_BUF(16); len += 16;\n\t\t\tace->type = be32_to_cpup(p++);\n\t\t\tace->flag = be32_to_cpup(p++);\n\t\t\tace->access_mask = be32_to_cpup(p++);\n\t\t\tdummy32 = be32_to_cpup(p++);\n\t\t\tREAD_BUF(dummy32);\n\t\t\tlen += XDR_QUADLEN(dummy32) << 2;\n\t\t\tREADMEM(buf, dummy32);\n\t\t\tace->whotype = nfs4_acl_get_whotype(buf, dummy32);\n\t\t\tstatus = nfs_ok;\n\t\t\tif (ace->whotype != NFS4_ACL_WHO_NAMED)\n\t\t\t\t;\n\t\t\telse if (ace->flag & NFS4_ACE_IDENTIFIER_GROUP)\n\t\t\t\tstatus = nfsd_map_name_to_gid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_gid);\n\t\t\telse\n\t\t\t\tstatus = nfsd_map_name_to_uid(argp->rqstp,\n\t\t\t\t\t\tbuf, dummy32, &ace->who_uid);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t}\n\t} else\n\t\t*acl = NULL;\n\tif (bmval[1] & FATTR4_WORD1_MODE) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tiattr->ia_mode = be32_to_cpup(p++);\n\t\tiattr->ia_mode &= (S_IFMT | S_IALLUGO);\n\t\tiattr->ia_valid |= ATTR_MODE;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_uid(argp->rqstp, buf, dummy32, &iattr->ia_uid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_UID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_OWNER_GROUP) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tif ((status = nfsd_map_name_to_gid(argp->rqstp, buf, dummy32, &iattr->ia_gid)))\n\t\t\treturn status;\n\t\tiattr->ia_valid |= ATTR_GID;\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_ACCESS_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_atime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_ATIME | ATTR_ATIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_ATIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\tif (bmval[1] & FATTR4_WORD1_TIME_MODIFY_SET) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tswitch (dummy32) {\n\t\tcase NFS4_SET_TO_CLIENT_TIME:\n\t\t\tlen += 12;\n\t\t\tstatus = nfsd4_decode_time(argp, &iattr->ia_mtime);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\t\t\tiattr->ia_valid |= (ATTR_MTIME | ATTR_MTIME_SET);\n\t\t\tbreak;\n\t\tcase NFS4_SET_TO_SERVER_TIME:\n\t\t\tiattr->ia_valid |= ATTR_MTIME;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto xdr_error;\n\t\t}\n\t}\n\n\tlabel->len = 0;\n#ifdef CONFIG_NFSD_V4_SECURITY_LABEL\n\tif (bmval[2] & FATTR4_WORD2_SECURITY_LABEL) {\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* lfs: we don't use it */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++); /* pi: we don't use it either */\n\t\tREAD_BUF(4);\n\t\tlen += 4;\n\t\tdummy32 = be32_to_cpup(p++);\n\t\tREAD_BUF(dummy32);\n\t\tif (dummy32 > NFS4_MAXLABELLEN)\n\t\t\treturn nfserr_badlabel;\n\t\tlen += (XDR_QUADLEN(dummy32) << 2);\n\t\tREADMEM(buf, dummy32);\n\t\tlabel->len = dummy32;\n\t\tlabel->data = svcxdr_dupstr(argp, buf, dummy32);\n\t\tif (!label->data)\n\t\t\treturn nfserr_jukebox;\n\t}\n#endif\n\n\tif (bmval[0] & ~NFSD_WRITEABLE_ATTRS_WORD0\n\t    || bmval[1] & ~NFSD_WRITEABLE_ATTRS_WORD1\n\t    || bmval[2] & ~NFSD_WRITEABLE_ATTRS_WORD2)\n\t\tREAD_BUF(expected_len - len);\n\telse if (len != expected_len)\n\t\tgoto xdr_error;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "259-283",
    "snippet": "static __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "bmlen << 2"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "4"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_bitmap(struct nfsd4_compoundargs *argp, u32 *bmval)\n{\n\tu32 bmlen;\n\tDECODE_HEAD;\n\n\tbmval[0] = 0;\n\tbmval[1] = 0;\n\tbmval[2] = 0;\n\n\tREAD_BUF(4);\n\tbmlen = be32_to_cpup(p++);\n\tif (bmlen > 1000)\n\t\tgoto xdr_error;\n\n\tREAD_BUF(bmlen << 2);\n\tif (bmlen > 0)\n\t\tbmval[0] = be32_to_cpup(p++);\n\tif (bmlen > 1)\n\t\tbmval[1] = be32_to_cpup(p++);\n\tif (bmlen > 2)\n\t\tbmval[2] = be32_to_cpup(p++);\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "nfsd4_decode_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "243-257",
    "snippet": "static __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out",
      "#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&sec"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_BUF",
          "args": [
            "12"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define DECODE_TAIL\t\t\t\t\\\n\tstatus = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\\\n\treturn status;\t\t\t\t\\\nxdr_error:\t\t\t\t\t\\\n\tdprintk(\"NFSD: xdr error (%s:%d)\\n\",\t\\\n\t\t\t__FILE__, __LINE__);\t\\\n\tstatus = nfserr_bad_xdr;\t\t\\\n\tgoto out\n#define DECODE_HEAD\t\t\t\t\\\n\t__be32 *p;\t\t\t\t\\\n\t__be32 status\n\nstatic __be32\nnfsd4_decode_time(struct nfsd4_compoundargs *argp, struct timespec *tv)\n{\n\tDECODE_HEAD;\n\tu64 sec;\n\n\tREAD_BUF(12);\n\tp = xdr_decode_hyper(p, &sec);\n\ttv->tv_sec = sec;\n\ttv->tv_nsec = be32_to_cpup(p++);\n\tif (tv->tv_nsec >= (u32)1000000000)\n\t\treturn nfserr_inval;\n\n\tDECODE_TAIL;\n}"
  },
  {
    "function_name": "savemem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "228-237",
    "snippet": "static char *savemem(struct nfsd4_compoundargs *argp, __be32 *p, int nbytes)\n{\n\tvoid *ret;\n\n\tret = svcxdr_tmpalloc(argp, nbytes);\n\tif (!ret)\n\t\treturn NULL;\n\tmemcpy(ret, p, nbytes);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ret",
            "p",
            "nbytes"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "nbytes"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "186-197",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *savemem(struct nfsd4_compoundargs *argp, __be32 *p, int nbytes)\n{\n\tvoid *ret;\n\n\tret = svcxdr_tmpalloc(argp, nbytes);\n\tif (!ret)\n\t\treturn NULL;\n\tmemcpy(ret, p, nbytes);\n\treturn ret;\n}"
  },
  {
    "function_name": "svcxdr_dupstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "206-216",
    "snippet": "static char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "buf",
            "len"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcxdr_tmpalloc",
          "args": [
            "argp",
            "len + 1"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "svcxdr_tmpalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "186-197",
          "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nsvcxdr_dupstr(struct nfsd4_compoundargs *argp, void *buf, u32 len)\n{\n\tchar *p = svcxdr_tmpalloc(argp, len + 1);\n\n\tif (!p)\n\t\treturn NULL;\n\tmemcpy(p, buf, len);\n\tp[len] = '\\0';\n\treturn p;\n}"
  },
  {
    "function_name": "svcxdr_tmpalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "186-197",
    "snippet": "static void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*tb) + len",
            "GFP_KERNEL"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void *\nsvcxdr_tmpalloc(struct nfsd4_compoundargs *argp, u32 len)\n{\n\tstruct svcxdr_tmpbuf *tb;\n\n\ttb = kmalloc(sizeof(*tb) + len, GFP_KERNEL);\n\tif (!tb)\n\t\treturn NULL;\n\ttb->next = argp->to_free;\n\targp->to_free = tb;\n\treturn tb->buf;\n}"
  },
  {
    "function_name": "zero_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "173-176",
    "snippet": "static int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int zero_clientid(clientid_t *clid)\n{\n\treturn (clid->cl_boot == 0) && (clid->cl_id == 0);\n}"
  },
  {
    "function_name": "read_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "140-171",
    "snippet": "static __be32 *read_buf(struct nfsd4_compoundargs *argp, u32 nbytes)\n{\n\t/* We want more bytes than seem to be available.\n\t * Maybe we need a new page, maybe we have just run out\n\t */\n\tunsigned int avail = (char *)argp->end - (char *)argp->p;\n\t__be32 *p;\n\tif (avail + argp->pagelen < nbytes)\n\t\treturn NULL;\n\tif (avail + PAGE_SIZE < nbytes) /* need more than a page !! */\n\t\treturn NULL;\n\t/* ok, we can do it with the current plus the next page */\n\tif (nbytes <= sizeof(argp->tmp))\n\t\tp = argp->tmp;\n\telse {\n\t\tkfree(argp->tmpp);\n\t\tp = argp->tmpp = kmalloc(nbytes, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\t\n\t}\n\t/*\n\t * The following memcpy is safe because read_buf is always\n\t * called with nbytes > avail, and the two cases above both\n\t * guarantee p points to at least nbytes bytes.\n\t */\n\tmemcpy(p, argp->p, avail);\n\tnext_decode_page(argp);\n\tmemcpy(((char*)p)+avail, argp->p, (nbytes - avail));\n\targp->p += XDR_QUADLEN(nbytes - avail);\n\treturn p;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "nbytes - avail"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((char*)p)+avail",
            "argp->p",
            "(nbytes - avail)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_decode_page",
          "args": [
            "argp"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "next_decode_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "127-138",
          "snippet": "static void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "argp->p",
            "avail"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "nbytes",
            "GFP_KERNEL"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "argp->tmpp"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32 *read_buf(struct nfsd4_compoundargs *argp, u32 nbytes)\n{\n\t/* We want more bytes than seem to be available.\n\t * Maybe we need a new page, maybe we have just run out\n\t */\n\tunsigned int avail = (char *)argp->end - (char *)argp->p;\n\t__be32 *p;\n\tif (avail + argp->pagelen < nbytes)\n\t\treturn NULL;\n\tif (avail + PAGE_SIZE < nbytes) /* need more than a page !! */\n\t\treturn NULL;\n\t/* ok, we can do it with the current plus the next page */\n\tif (nbytes <= sizeof(argp->tmp))\n\t\tp = argp->tmp;\n\telse {\n\t\tkfree(argp->tmpp);\n\t\tp = argp->tmpp = kmalloc(nbytes, GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn NULL;\n\t\t\n\t}\n\t/*\n\t * The following memcpy is safe because read_buf is always\n\t * called with nbytes > avail, and the two cases above both\n\t * guarantee p points to at least nbytes bytes.\n\t */\n\tmemcpy(p, argp->p, avail);\n\tnext_decode_page(argp);\n\tmemcpy(((char*)p)+avail, argp->p, (nbytes - avail));\n\targp->p += XDR_QUADLEN(nbytes - avail);\n\treturn p;\n}"
  },
  {
    "function_name": "next_decode_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "127-138",
    "snippet": "static void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "argp->pagelist[0]"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void next_decode_page(struct nfsd4_compoundargs *argp)\n{\n\targp->p = page_address(argp->pagelist[0]);\n\targp->pagelist++;\n\tif (argp->pagelen < PAGE_SIZE) {\n\t\targp->end = argp->p + (argp->pagelen>>2);\n\t\targp->pagelen = 0;\n\t} else {\n\t\targp->end = argp->p + (PAGE_SIZE>>2);\n\t\targp->pagelen -= PAGE_SIZE;\n\t}\n}"
  },
  {
    "function_name": "check_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
    "lines": "68-81",
    "snippet": "static __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/security.h>",
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"cache.h\"",
      "#include \"state.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4.h\"",
      "#include \"acl.h\"",
      "#include \"idmap.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/utsname.h>",
      "#include <linux/statfs.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isdotent",
          "args": [
            "str",
            "len"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_filename(char *str, int len)\n{\n\tint i;\n\n\tif (len == 0)\n\t\treturn nfserr_inval;\n\tif (isdotent(str, len))\n\t\treturn nfserr_badname;\n\tfor (i = 0; i < len; i++)\n\t\tif (str[i] == '/')\n\t\t\treturn nfserr_badname;\n\treturn 0;\n}"
  }
]