[
  {
    "function_name": "nfsaclsvc_release_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "334-339",
    "snippet": "static int nfsaclsvc_release_access(struct svc_rqst *rqstp, __be32 *p,\n               struct nfsd3_accessres *resp)\n{\n       fh_put(&resp->fh);\n       return 1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&resp->fh"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_release_access(struct svc_rqst *rqstp, __be32 *p,\n               struct nfsd3_accessres *resp)\n{\n       fh_put(&resp->fh);\n       return 1;\n}"
  },
  {
    "function_name": "nfsaclsvc_release_attrstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "327-332",
    "snippet": "static int nfsaclsvc_release_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&resp->fh"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_release_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfsaclsvc_release_getacl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "318-325",
    "snippet": "static int nfsaclsvc_release_getacl(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_getaclres *resp)\n{\n\tfh_put(&resp->fh);\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n\treturn 1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "resp->acl_default"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "resp->acl_access"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&resp->fh"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_release_getacl(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_getaclres *resp)\n{\n\tfh_put(&resp->fh);\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfsaclsvc_encode_accessres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "307-313",
    "snippet": "static int nfsaclsvc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_accessres *resp)\n{\n\tp = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->access);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->access"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs2svc_encode_fattr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsxdr.c",
          "lines": "200-203",
          "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_accessres *resp)\n{\n\tp = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->access);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsaclsvc_encode_attrstatres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "299-304",
    "snippet": "static int nfsaclsvc_encode_attrstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tp = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs2svc_encode_fattr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsxdr.c",
          "lines": "200-203",
          "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_encode_attrstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tp = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsaclsvc_encode_getaclres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "254-297",
    "snippet": "static int nfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_getaclres *resp)\n{\n\tstruct dentry *dentry = resp->fh.fh_dentry;\n\tstruct inode *inode;\n\tstruct kvec *head = rqstp->rq_res.head;\n\tunsigned int base;\n\tint n;\n\tint w;\n\n\t/*\n\t * Since this is version 2, the check for nfserr in\n\t * nfsd_dispatch actually ensures the following cannot happen.\n\t * However, it seems fragile to depend on that.\n\t */\n\tif (dentry == NULL || d_really_is_negative(dentry))\n\t\treturn 0;\n\tinode = d_inode(dentry);\n\n\tp = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->mask);\n\tif (!xdr_ressize_check(rqstp, p))\n\t\treturn 0;\n\tbase = (char *)p - (char *)head->iov_base;\n\n\trqstp->rq_res.page_len = w = nfsacl_size(\n\t\t(resp->mask & NFS_ACL)   ? resp->acl_access  : NULL,\n\t\t(resp->mask & NFS_DFACL) ? resp->acl_default : NULL);\n\twhile (w > 0) {\n\t\tif (!*(rqstp->rq_next_page++))\n\t\t\treturn 0;\n\t\tw -= PAGE_SIZE;\n\t}\n\n\tn = nfsacl_encode(&rqstp->rq_res, base, inode,\n\t\t\t  resp->acl_access,\n\t\t\t  resp->mask & NFS_ACL, 0);\n\tif (n > 0)\n\t\tn = nfsacl_encode(&rqstp->rq_res, base + n, inode,\n\t\t\t\t  resp->acl_default,\n\t\t\t\t  resp->mask & NFS_DFACL,\n\t\t\t\t  NFS_ACL_DEFAULT);\n\treturn (n > 0);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsacl_encode",
          "args": [
            "&rqstp->rq_res",
            "base + n",
            "inode",
            "resp->acl_default",
            "resp->mask & NFS_DFACL",
            "NFS_ACL_DEFAULT"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsacl_encode",
          "args": [
            "&rqstp->rq_res",
            "base",
            "inode",
            "resp->acl_access",
            "resp->mask & NFS_ACL",
            "0"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsacl_size",
          "args": [
            "(resp->mask & NFS_ACL)   ? resp->acl_access  : NULL",
            "(resp->mask & NFS_DFACL) ? resp->acl_default : NULL"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->mask"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs2svc_encode_fattr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_encode_fattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsxdr.c",
          "lines": "200-203",
          "snippet": "__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_negative",
          "args": [
            "dentry"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_encode_getaclres(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_getaclres *resp)\n{\n\tstruct dentry *dentry = resp->fh.fh_dentry;\n\tstruct inode *inode;\n\tstruct kvec *head = rqstp->rq_res.head;\n\tunsigned int base;\n\tint n;\n\tint w;\n\n\t/*\n\t * Since this is version 2, the check for nfserr in\n\t * nfsd_dispatch actually ensures the following cannot happen.\n\t * However, it seems fragile to depend on that.\n\t */\n\tif (dentry == NULL || d_really_is_negative(dentry))\n\t\treturn 0;\n\tinode = d_inode(dentry);\n\n\tp = nfs2svc_encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->mask);\n\tif (!xdr_ressize_check(rqstp, p))\n\t\treturn 0;\n\tbase = (char *)p - (char *)head->iov_base;\n\n\trqstp->rq_res.page_len = w = nfsacl_size(\n\t\t(resp->mask & NFS_ACL)   ? resp->acl_access  : NULL,\n\t\t(resp->mask & NFS_DFACL) ? resp->acl_default : NULL);\n\twhile (w > 0) {\n\t\tif (!*(rqstp->rq_next_page++))\n\t\t\treturn 0;\n\t\tw -= PAGE_SIZE;\n\t}\n\n\tn = nfsacl_encode(&rqstp->rq_res, base, inode,\n\t\t\t  resp->acl_access,\n\t\t\t  resp->mask & NFS_ACL, 0);\n\tif (n > 0)\n\t\tn = nfsacl_encode(&rqstp->rq_res, base + n, inode,\n\t\t\t\t  resp->acl_default,\n\t\t\t\t  resp->mask & NFS_DFACL,\n\t\t\t\t  NFS_ACL_DEFAULT);\n\treturn (n > 0);\n}"
  },
  {
    "function_name": "nfsaclsvc_encode_voidres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "248-251",
    "snippet": "static int nfsaclsvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsaclsvc_decode_accessargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "229-238",
    "snippet": "static int nfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_accessargs *argp)\n{\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\targp->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs2svc_decode_fh",
          "args": [
            "p",
            "&argp->fh"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_accessargs *argp)\n{\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\targp->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsaclsvc_decode_fhandleargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "220-227",
    "snippet": "static int nfsaclsvc_decode_fhandleargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd_fhandle *argp)\n{\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs2svc_decode_fh",
          "args": [
            "p",
            "&argp->fh"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_decode_fhandleargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd_fhandle *argp)\n{\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsaclsvc_decode_setaclargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "194-218",
    "snippet": "static int nfsaclsvc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_setaclargs *argp)\n{\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tunsigned int base;\n\tint n;\n\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\targp->mask = ntohl(*p++);\n\tif (argp->mask & ~NFS_ACL_MASK ||\n\t    !xdr_argsize_check(rqstp, p))\n\t\treturn 0;\n\n\tbase = (char *)p - (char *)head->iov_base;\n\tn = nfsacl_decode(&rqstp->rq_arg, base, NULL,\n\t\t\t  (argp->mask & NFS_ACL) ?\n\t\t\t  &argp->acl_access : NULL);\n\tif (n > 0)\n\t\tn = nfsacl_decode(&rqstp->rq_arg, base + n, NULL,\n\t\t\t\t  (argp->mask & NFS_DFACL) ?\n\t\t\t\t  &argp->acl_default : NULL);\n\treturn (n > 0);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsacl_decode",
          "args": [
            "&rqstp->rq_arg",
            "base + n",
            "NULL",
            "(argp->mask & NFS_DFACL) ?\n\t\t\t\t  &argp->acl_default : NULL"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsacl_decode",
          "args": [
            "&rqstp->rq_arg",
            "base",
            "NULL",
            "(argp->mask & NFS_ACL) ?\n\t\t\t  &argp->acl_access : NULL"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs2svc_decode_fh",
          "args": [
            "p",
            "&argp->fh"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_decode_setaclargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_setaclargs *argp)\n{\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tunsigned int base;\n\tint n;\n\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\targp->mask = ntohl(*p++);\n\tif (argp->mask & ~NFS_ACL_MASK ||\n\t    !xdr_argsize_check(rqstp, p))\n\t\treturn 0;\n\n\tbase = (char *)p - (char *)head->iov_base;\n\tn = nfsacl_decode(&rqstp->rq_arg, base, NULL,\n\t\t\t  (argp->mask & NFS_ACL) ?\n\t\t\t  &argp->acl_access : NULL);\n\tif (n > 0)\n\t\tn = nfsacl_decode(&rqstp->rq_arg, base + n, NULL,\n\t\t\t\t  (argp->mask & NFS_DFACL) ?\n\t\t\t\t  &argp->acl_default : NULL);\n\treturn (n > 0);\n}"
  },
  {
    "function_name": "nfsaclsvc_decode_getaclargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "182-191",
    "snippet": "static int nfsaclsvc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_getaclargs *argp)\n{\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\targp->mask = ntohl(*p); p++;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs2svc_decode_fh",
          "args": [
            "p",
            "&argp->fh"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "nfs2svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsxdr.c",
          "lines": "40-43",
          "snippet": "__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"xdr.h\"",
            "#include \"vfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"xdr.h\"\n#include \"vfs.h\"\n\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic int nfsaclsvc_decode_getaclargs(struct svc_rqst *rqstp, __be32 *p,\n\t\tstruct nfsd3_getaclargs *argp)\n{\n\tp = nfs2svc_decode_fh(p, &argp->fh);\n\tif (!p)\n\t\treturn 0;\n\targp->mask = ntohl(*p); p++;\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfsacld_proc_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "161-177",
    "snippet": "static __be32 nfsacld_proc_access(struct svc_rqst *rqstp, struct nfsd3_accessargs *argp,\n\t\tstruct nfsd3_accessres *resp)\n{\n\t__be32 nfserr;\n\n\tdprintk(\"nfsd: ACCESS(2acl)   %s 0x%x\\n\",\n\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\targp->access);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->access = argp->access;\n\tnfserr = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);\n\tif (nfserr)\n\t\treturn nfserr;\n\tnfserr = fh_getattr(&resp->fh, &resp->stat);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_access",
          "args": [
            "rqstp",
            "&resp->fh",
            "&resp->access",
            "NULL"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "576-632",
          "snippet": "__be32\nnfsd_access(struct svc_rqst *rqstp, struct svc_fh *fhp, u32 *access, u32 *supported)\n{\n\tstruct accessmap\t*map;\n\tstruct svc_export\t*export;\n\tstruct dentry\t\t*dentry;\n\tu32\t\t\tquery, result = 0, sresult = 0;\n\t__be32\t\t\terror;\n\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\tif (error)\n\t\tgoto out;\n\n\texport = fhp->fh_export;\n\tdentry = fhp->fh_dentry;\n\n\tif (d_is_reg(dentry))\n\t\tmap = nfs3_regaccess;\n\telse if (d_is_dir(dentry))\n\t\tmap = nfs3_diraccess;\n\telse\n\t\tmap = nfs3_anyaccess;\n\n\n\tquery = *access;\n\tfor  (; map->access; map++) {\n\t\tif (map->access & query) {\n\t\t\t__be32 err2;\n\n\t\t\tsresult |= map->access;\n\n\t\t\terr2 = nfsd_permission(rqstp, export, dentry, map->how);\n\t\t\tswitch (err2) {\n\t\t\tcase nfs_ok:\n\t\t\t\tresult |= map->access;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t/* the following error codes just mean the access was not allowed,\n\t\t\t * rather than an error occurred */\n\t\t\tcase nfserr_rofs:\n\t\t\tcase nfserr_acces:\n\t\t\tcase nfserr_perm:\n\t\t\t\t/* simply don't \"or\" in the access bit. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = err2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t*access = result;\n\tif (supported)\n\t\t*supported = sresult;\n\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_access(struct svc_rqst *rqstp, struct svc_fh *fhp, u32 *access, u32 *supported)\n{\n\tstruct accessmap\t*map;\n\tstruct svc_export\t*export;\n\tstruct dentry\t\t*dentry;\n\tu32\t\t\tquery, result = 0, sresult = 0;\n\t__be32\t\t\terror;\n\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\tif (error)\n\t\tgoto out;\n\n\texport = fhp->fh_export;\n\tdentry = fhp->fh_dentry;\n\n\tif (d_is_reg(dentry))\n\t\tmap = nfs3_regaccess;\n\telse if (d_is_dir(dentry))\n\t\tmap = nfs3_diraccess;\n\telse\n\t\tmap = nfs3_anyaccess;\n\n\n\tquery = *access;\n\tfor  (; map->access; map++) {\n\t\tif (map->access & query) {\n\t\t\t__be32 err2;\n\n\t\t\tsresult |= map->access;\n\n\t\t\terr2 = nfsd_permission(rqstp, export, dentry, map->how);\n\t\t\tswitch (err2) {\n\t\t\tcase nfs_ok:\n\t\t\t\tresult |= map->access;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t/* the following error codes just mean the access was not allowed,\n\t\t\t * rather than an error occurred */\n\t\t\tcase nfserr_rofs:\n\t\t\tcase nfserr_acces:\n\t\t\tcase nfserr_perm:\n\t\t\t\t/* simply don't \"or\" in the access bit. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terror = err2;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\t*access = result;\n\tif (supported)\n\t\t*supported = sresult;\n\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: ACCESS(2acl)   %s 0x%x\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->access"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic __be32 nfsacld_proc_access(struct svc_rqst *rqstp, struct nfsd3_accessargs *argp,\n\t\tstruct nfsd3_accessres *resp)\n{\n\t__be32 nfserr;\n\n\tdprintk(\"nfsd: ACCESS(2acl)   %s 0x%x\\n\",\n\t\t\tSVCFH_fmt(&argp->fh),\n\t\t\targp->access);\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tresp->access = argp->access;\n\tnfserr = nfsd_access(rqstp, &resp->fh, &resp->access, NULL);\n\tif (nfserr)\n\t\treturn nfserr;\n\tnfserr = fh_getattr(&resp->fh, &resp->stat);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsacld_proc_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "144-156",
    "snippet": "static __be32 nfsacld_proc_getattr(struct svc_rqst * rqstp,\n\t\tstruct nfsd_fhandle *argp, struct nfsd_attrstat *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\treturn nfserr;\n\tnfserr = fh_getattr(&resp->fh, &resp->stat);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&resp->fh",
            "0",
            "NFSD_MAY_NOP"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: GETATTR  %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic __be32 nfsacld_proc_getattr(struct svc_rqst * rqstp,\n\t\tstruct nfsd_fhandle *argp, struct nfsd_attrstat *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\treturn nfserr;\n\tnfserr = fh_getattr(&resp->fh, &resp->stat);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsacld_proc_setacl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "90-139",
    "snippet": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "error"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_drop_write",
          "args": [
            "fh"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "fh_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "121-127",
          "snippet": "static inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "argp->acl_default"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "argp->acl_access"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "fh",
            "&resp->stat"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode->i_op->set_acl",
          "args": [
            "inode",
            "argp->acl_default",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->set_acl",
          "args": [
            "inode",
            "argp->acl_access",
            "ACL_TYPE_ACCESS"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_want_write",
          "args": [
            "fh"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fh_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "112-119",
          "snippet": "static inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = true;\n\treturn ret;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = true;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "inode"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "fh->fh_dentry"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&resp->fh",
            "0",
            "NFSD_MAY_SATTR"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: SETACL(2acl)   %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsacld_proc_getacl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "30-85",
    "snippet": "static __be32 nfsacld_proc_getacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_getaclargs *argp, struct nfsd3_getaclres *resp)\n{\n\tstruct posix_acl *acl;\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\n\tdprintk(\"nfsd: GETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\tRETURN_STATUS(nfserr);\n\n\tinode = d_inode(fh->fh_dentry);\n\n\tif (argp->mask & ~NFS_ACL_MASK)\n\t\tRETURN_STATUS(nfserr_inval);\n\tresp->mask = argp->mask;\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\tif (nfserr)\n\t\tRETURN_STATUS(nfserr);\n\n\tif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\n\t\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (acl == NULL) {\n\t\t\t/* Solaris returns the inode's minimum ACL. */\n\t\t\tacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\t\t}\n\t\tif (IS_ERR(acl)) {\n\t\t\tnfserr = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_access = acl;\n\t}\n\tif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\n\t\t/* Check how Solaris handles requests for the Default ACL\n\t\t   of a non-directory! */\n\t\tacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl)) {\n\t\t\tnfserr = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_default = acl;\n\t}\n\n\t/* resp->acl_{access,default} are released in nfssvc_release_getacl. */\n\tRETURN_STATUS(0);\n\nfail:\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n\tRETURN_STATUS(nfserr);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [
      "#define ACL (1+NFS_ACL_MAX_ENTRIES*3)  /* Access Control List */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RETURN_STATUS",
          "args": [
            "nfserr"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "resp->acl_default"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "resp->acl_access"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RETURN_STATUS",
          "args": [
            "0"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(acl)"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "inode",
            "ACL_TYPE_DEFAULT"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "acl"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_from_mode",
          "args": [
            "inode->i_mode",
            "GFP_KERNEL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RETURN_STATUS",
          "args": [
            "nfserr"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "fh",
            "&resp->stat"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RETURN_STATUS",
          "args": [
            "nfserr_inval"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "fh->fh_dentry"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RETURN_STATUS",
          "args": [
            "nfserr"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&resp->fh",
            "0",
            "NFSD_MAY_NOP"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: GETACL(2acl)   %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\n#define ACL (1+NFS_ACL_MAX_ENTRIES*3)  /* Access Control List */\n\nstatic __be32 nfsacld_proc_getacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_getaclargs *argp, struct nfsd3_getaclres *resp)\n{\n\tstruct posix_acl *acl;\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\n\tdprintk(\"nfsd: GETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_NOP);\n\tif (nfserr)\n\t\tRETURN_STATUS(nfserr);\n\n\tinode = d_inode(fh->fh_dentry);\n\n\tif (argp->mask & ~NFS_ACL_MASK)\n\t\tRETURN_STATUS(nfserr_inval);\n\tresp->mask = argp->mask;\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\tif (nfserr)\n\t\tRETURN_STATUS(nfserr);\n\n\tif (resp->mask & (NFS_ACL|NFS_ACLCNT)) {\n\t\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\t\tif (acl == NULL) {\n\t\t\t/* Solaris returns the inode's minimum ACL. */\n\t\t\tacl = posix_acl_from_mode(inode->i_mode, GFP_KERNEL);\n\t\t}\n\t\tif (IS_ERR(acl)) {\n\t\t\tnfserr = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_access = acl;\n\t}\n\tif (resp->mask & (NFS_DFACL|NFS_DFACLCNT)) {\n\t\t/* Check how Solaris handles requests for the Default ACL\n\t\t   of a non-directory! */\n\t\tacl = get_acl(inode, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl)) {\n\t\t\tnfserr = nfserrno(PTR_ERR(acl));\n\t\t\tgoto fail;\n\t\t}\n\t\tresp->acl_default = acl;\n\t}\n\n\t/* resp->acl_{access,default} are released in nfssvc_release_getacl. */\n\tRETURN_STATUS(0);\n\nfail:\n\tposix_acl_release(resp->acl_access);\n\tposix_acl_release(resp->acl_default);\n\tRETURN_STATUS(nfserr);\n}"
  },
  {
    "function_name": "nfsacld_proc_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs2acl.c",
    "lines": "21-25",
    "snippet": "static __be32\nnfsacld_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr3.h\"",
      "#include \"cache.h\"",
      "#include <linux/gfp.h>",
      "#include <linux/nfsacl.h>",
      "#include \"nfsd.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr3.h\"\n#include \"cache.h\"\n#include <linux/gfp.h>\n#include <linux/nfsacl.h>\n#include \"nfsd.h\"\n\nstatic __be32\nnfsacld_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}"
  }
]