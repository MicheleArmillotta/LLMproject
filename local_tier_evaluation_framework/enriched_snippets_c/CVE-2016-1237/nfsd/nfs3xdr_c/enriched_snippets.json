[
  {
    "function_name": "nfs3svc_release_fhandle2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1109-1116",
    "snippet": "int\nnfs3svc_release_fhandle2(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fhandle_pair *resp)\n{\n\tfh_put(&resp->fh1);\n\tfh_put(&resp->fh2);\n\treturn 1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&resp->fh2"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_release_fhandle2(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fhandle_pair *resp)\n{\n\tfh_put(&resp->fh1);\n\tfh_put(&resp->fh2);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs3svc_release_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1101-1107",
    "snippet": "int\nnfs3svc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&resp->fh"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs3svc_encode_commitres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1083-1096",
    "snippet": "int\nnfs3svc_encode_commitres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\t/* Write verifier */\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nn->nfssvc_boot.tv_usec"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nn->nfssvc_boot.tv_sec"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_wcc_data",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "encode_wcc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "231-250",
          "snippet": "static __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_commitres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\t/* Write verifier */\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_pathconfres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1064-1080",
    "snippet": "int\nnfs3svc_encode_pathconfres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_pathconfres *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->p_link_max);\n\t\t*p++ = htonl(resp->p_name_max);\n\t\t*p++ = htonl(resp->p_no_trunc);\n\t\t*p++ = htonl(resp->p_chown_restricted);\n\t\t*p++ = htonl(resp->p_case_insensitive);\n\t\t*p++ = htonl(resp->p_case_preserving);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->p_case_preserving"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->p_case_insensitive"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->p_chown_restricted"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->p_no_trunc"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->p_name_max"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->p_link_max"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_pathconfres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_pathconfres *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->p_link_max);\n\t\t*p++ = htonl(resp->p_name_max);\n\t\t*p++ = htonl(resp->p_no_trunc);\n\t\t*p++ = htonl(resp->p_chown_restricted);\n\t\t*p++ = htonl(resp->p_case_insensitive);\n\t\t*p++ = htonl(resp->p_case_preserving);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_fsinfores",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1040-1061",
    "snippet": "int\nnfs3svc_encode_fsinfores(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsinfores *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->f_rtmax);\n\t\t*p++ = htonl(resp->f_rtpref);\n\t\t*p++ = htonl(resp->f_rtmult);\n\t\t*p++ = htonl(resp->f_wtmax);\n\t\t*p++ = htonl(resp->f_wtpref);\n\t\t*p++ = htonl(resp->f_wtmult);\n\t\t*p++ = htonl(resp->f_dtpref);\n\t\tp = xdr_encode_hyper(p, resp->f_maxfilesize);\n\t\t*p++ = xdr_one;\n\t\t*p++ = xdr_zero;\n\t\t*p++ = htonl(resp->f_properties);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_properties"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "resp->f_maxfilesize"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_dtpref"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_wtmult"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_wtpref"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_wtmax"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_rtmult"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_rtpref"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->f_rtmax"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_fsinfores(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsinfores *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->f_rtmax);\n\t\t*p++ = htonl(resp->f_rtpref);\n\t\t*p++ = htonl(resp->f_rtmult);\n\t\t*p++ = htonl(resp->f_wtmax);\n\t\t*p++ = htonl(resp->f_wtpref);\n\t\t*p++ = htonl(resp->f_wtmult);\n\t\t*p++ = htonl(resp->f_dtpref);\n\t\tp = xdr_encode_hyper(p, resp->f_maxfilesize);\n\t\t*p++ = xdr_one;\n\t\t*p++ = xdr_zero;\n\t\t*p++ = htonl(resp->f_properties);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_fsstatres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1018-1037",
    "snippet": "int\nnfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsstatres *resp)\n{\n\tstruct kstatfs\t*s = &resp->stats;\n\tu64\t\tbs = s->f_bsize;\n\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\tp = xdr_encode_hyper(p, bs * s->f_blocks);\t/* total bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bfree);\t/* free bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bavail);\t/* user available bytes */\n\t\tp = xdr_encode_hyper(p, s->f_files);\t/* total inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* free inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* user available inodes */\n\t\t*p++ = htonl(resp->invarsec);\t/* mean unchanged time */\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->invarsec"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "s->f_ffree"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "s->f_ffree"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "s->f_files"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "bs * s->f_bavail"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "bs * s->f_bfree"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "bs * s->f_blocks"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsstatres *resp)\n{\n\tstruct kstatfs\t*s = &resp->stats;\n\tu64\t\tbs = s->f_bsize;\n\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\tp = xdr_encode_hyper(p, bs * s->f_blocks);\t/* total bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bfree);\t/* free bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bavail);\t/* user available bytes */\n\t\tp = xdr_encode_hyper(p, s->f_files);\t/* total inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* free inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* user available inodes */\n\t\t*p++ = htonl(resp->invarsec);\t/* mean unchanged time */\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_entry_plus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1009-1015",
    "snippet": "int\nnfs3svc_encode_entry_plus(void *cd, const char *name,\n\t\t\t  int namlen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 1);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_entry",
          "args": [
            "cd",
            "name",
            "namlen",
            "offset",
            "ino",
            "d_type",
            "1"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "encode_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "873-1000",
          "snippet": "static int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [
            "#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))",
            "#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))\n#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)\n\nstatic int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_entry_plus(void *cd, const char *name,\n\t\t\t  int namlen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 1);\n}"
  },
  {
    "function_name": "nfs3svc_encode_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "1002-1007",
    "snippet": "int\nnfs3svc_encode_entry(void *cd, const char *name,\n\t\t     int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 0);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_entry",
          "args": [
            "cd",
            "name",
            "namlen",
            "offset",
            "ino",
            "d_type",
            "0"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "encode_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "873-1000",
          "snippet": "static int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [
            "#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))",
            "#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))\n#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)\n\nstatic int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_entry(void *cd, const char *name,\n\t\t     int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 0);\n}"
  },
  {
    "function_name": "encode_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "873-1000",
    "snippet": "static int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [
      "#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))",
      "#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "tmp",
            "(caddr_t)tmp+len1",
            "len2"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "tmp",
            "len1"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset_r != len1 - 4"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "p",
            "tmp",
            "num_entry_words << 2"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_entryplus_baggage",
          "args": [
            "cd",
            "p1",
            "name",
            "namlen",
            "ino"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "encode_entryplus_baggage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "841-859",
          "snippet": "static __be32 *encode_entryplus_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name, int namlen, u64 ino)\n{\n\tstruct svc_fh\t*fh = &cd->scratch;\n\t__be32 err;\n\n\tfh_init(fh, NFS3_FHSIZE);\n\terr = compose_entry_fh(cd, fh, name, namlen, ino);\n\tif (err) {\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\tgoto out;\n\t}\n\tp = encode_post_op_attr(cd->rqstp, p, fh);\n\t*p++ = xdr_one;\t\t\t/* yes, a file handle follows */\n\tp = encode_fh(p, fh);\nout:\n\tfh_put(fh);\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *encode_entryplus_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name, int namlen, u64 ino)\n{\n\tstruct svc_fh\t*fh = &cd->scratch;\n\t__be32 err;\n\n\tfh_init(fh, NFS3_FHSIZE);\n\terr = compose_entry_fh(cd, fh, name, namlen, ino);\n\tif (err) {\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\tgoto out;\n\t}\n\tp = encode_post_op_attr(cd->rqstp, p, fh);\n\t*p++ = xdr_one;\t\t\t/* yes, a file handle follows */\n\tp = encode_fh(p, fh);\nout:\n\tfh_put(fh);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_entry_baggage",
          "args": [
            "cd",
            "p1",
            "name",
            "namlen",
            "ino"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "encode_entry_baggage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "792-804",
          "snippet": "static __be32 *\nencode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,\n\t     int namlen, u64 ino)\n{\n\t*p++ = xdr_one;\t\t\t\t /* mark entry present */\n\tp    = xdr_encode_hyper(p, ino);\t /* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\n\tcd->offset = p;\t\t\t\t/* remember pointer */\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,\n\t     int namlen, u64 ino)\n{\n\t*p++ = xdr_one;\t\t\t\t /* mark entry present */\n\tp    = xdr_encode_hyper(p, ino);\t /* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\n\tcd->offset = p;\t\t\t\t/* remember pointer */\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*(page+1)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cd->buffer + elen"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*page"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "namlen"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "namlen",
            "NFS3_MAXNAMLEN"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "cd->offset",
            "offset64"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "offset64 & 0xffffffff"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "offset64 >> 32"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cd->offset1"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ccd",
            "structnfsd3_readdirres",
            "common"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))\n#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)\n\nstatic int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}"
  },
  {
    "function_name": "encode_entryplus_baggage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "841-859",
    "snippet": "static __be32 *encode_entryplus_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name, int namlen, u64 ino)\n{\n\tstruct svc_fh\t*fh = &cd->scratch;\n\t__be32 err;\n\n\tfh_init(fh, NFS3_FHSIZE);\n\terr = compose_entry_fh(cd, fh, name, namlen, ino);\n\tif (err) {\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\tgoto out;\n\t}\n\tp = encode_post_op_attr(cd->rqstp, p, fh);\n\t*p++ = xdr_one;\t\t\t/* yes, a file handle follows */\n\tp = encode_fh(p, fh);\nout:\n\tfh_put(fh);\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "fh"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_fh",
          "args": [
            "p",
            "fh"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "67-75",
          "snippet": "static __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "cd->rqstp",
            "p",
            "fh"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compose_entry_fh",
          "args": [
            "cd",
            "fh",
            "name",
            "namlen",
            "ino"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "compose_entry_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "806-839",
          "snippet": "static __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "fh",
            "NFS3_FHSIZE"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *encode_entryplus_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name, int namlen, u64 ino)\n{\n\tstruct svc_fh\t*fh = &cd->scratch;\n\t__be32 err;\n\n\tfh_init(fh, NFS3_FHSIZE);\n\terr = compose_entry_fh(cd, fh, name, namlen, ino);\n\tif (err) {\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\tgoto out;\n\t}\n\tp = encode_post_op_attr(cd->rqstp, p, fh);\n\t*p++ = xdr_one;\t\t\t/* yes, a file handle follows */\n\tp = encode_fh(p, fh);\nout:\n\tfh_put(fh);\n\treturn p;\n}"
  },
  {
    "function_name": "compose_entry_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "806-839",
    "snippet": "static __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dchild"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "fhp",
            "exp",
            "dchild",
            "&cd->fh"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_really_is_negative",
          "args": [
            "dchild"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dchild"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dchild"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len_unlocked",
          "args": [
            "name",
            "dparent",
            "namlen"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dparent"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dparent"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdotent",
          "args": [
            "name",
            "namlen"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}"
  },
  {
    "function_name": "encode_entry_baggage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "792-804",
    "snippet": "static __be32 *\nencode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,\n\t     int namlen, u64 ino)\n{\n\t*p++ = xdr_one;\t\t\t\t /* mark entry present */\n\tp    = xdr_encode_hyper(p, ino);\t /* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\n\tcd->offset = p;\t\t\t\t/* remember pointer */\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */\n\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "NFS_OFFSET_MAX"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_array",
          "args": [
            "p",
            "name",
            "namlen"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "ino"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,\n\t     int namlen, u64 ino)\n{\n\t*p++ = xdr_one;\t\t\t\t /* mark entry present */\n\tp    = xdr_encode_hyper(p, ino);\t /* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\n\tcd->offset = p;\t\t\t\t/* remember pointer */\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */\n\n\treturn p;\n}"
  },
  {
    "function_name": "nfs3svc_encode_readdirres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "768-790",
    "snippet": "int\nnfs3svc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\n\tif (resp->status == 0) {\n\t\t/* stupid readdir cookie */\n\t\tmemcpy(p, resp->verf, 8); p += 2;\n\t\txdr_ressize_check(rqstp, p);\n\t\tif (rqstp->rq_res.head[0].iov_len + (2<<2) > PAGE_SIZE)\n\t\t\treturn 1; /*No room for trailer */\n\t\trqstp->rq_res.page_len = (resp->count) << 2;\n\n\t\t/* add the 'tail' to the end of the 'head' page - page 0. */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p++ = 0;\t\t/* no more entries */\n\t\t*p++ = htonl(resp->common.err == nfserr_eof);\n\t\trqstp->rq_res.tail[0].iov_len = 2<<2;\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->common.err == nfserr_eof"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "resp->verf",
            "8"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\n\tif (resp->status == 0) {\n\t\t/* stupid readdir cookie */\n\t\tmemcpy(p, resp->verf, 8); p += 2;\n\t\txdr_ressize_check(rqstp, p);\n\t\tif (rqstp->rq_res.head[0].iov_len + (2<<2) > PAGE_SIZE)\n\t\t\treturn 1; /*No room for trailer */\n\t\trqstp->rq_res.page_len = (resp->count) << 2;\n\n\t\t/* add the 'tail' to the end of the 'head' page - page 0. */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p++ = 0;\t\t/* no more entries */\n\t\t*p++ = htonl(resp->common.err == nfserr_eof);\n\t\trqstp->rq_res.tail[0].iov_len = 2<<2;\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_linkres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "758-765",
    "snippet": "int\nnfs3svc_encode_linkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_wcc_data",
          "args": [
            "rqstp",
            "p",
            "&resp->tfh"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "encode_wcc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "231-250",
          "snippet": "static __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_linkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_renameres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "748-755",
    "snippet": "int\nnfs3svc_encode_renameres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameres *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->ffh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_wcc_data",
          "args": [
            "rqstp",
            "p",
            "&resp->tfh"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "encode_wcc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "231-250",
          "snippet": "static __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_renameres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameres *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->ffh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_createres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "734-745",
    "snippet": "int\nnfs3svc_encode_createres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\t*p++ = xdr_one;\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_wcc_data(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_wcc_data",
          "args": [
            "rqstp",
            "p",
            "&resp->dirfh"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "encode_wcc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "231-250",
          "snippet": "static __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_fh",
          "args": [
            "p",
            "&resp->fh"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "67-75",
          "snippet": "static __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_createres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\t*p++ = xdr_one;\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_wcc_data(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_writeres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "717-731",
    "snippet": "int\nnfs3svc_encode_writeres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->committed);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nn->nfssvc_boot.tv_usec"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nn->nfssvc_boot.tv_sec"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->committed"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->count"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_wcc_data",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "encode_wcc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "231-250",
          "snippet": "static __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_writeres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->committed);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_readres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "693-714",
    "snippet": "int\nnfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->eof);\n\t\t*p++ = htonl(resp->count);\t/* xdr opaque count */\n\t\txdr_ressize_check(rqstp, p);\n\t\t/* now update rqstp->rq_res to reflect data as well */\n\t\trqstp->rq_res.page_len = resp->count;\n\t\tif (resp->count & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count & 3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->count"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->eof"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->count"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->eof);\n\t\t*p++ = htonl(resp->count);\t/* xdr opaque count */\n\t\txdr_ressize_check(rqstp, p);\n\t\t/* now update rqstp->rq_res to reflect data as well */\n\t\trqstp->rq_res.page_len = resp->count;\n\t\tif (resp->count & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count & 3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_readlinkres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "672-690",
    "snippet": "int\nnfs3svc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->len);\n\t\txdr_ressize_check(rqstp, p);\n\t\trqstp->rq_res.page_len = resp->len;\n\t\tif (resp->len & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->len"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->len);\n\t\txdr_ressize_check(rqstp, p);\n\t\trqstp->rq_res.page_len = resp->len;\n\t\tif (resp->len & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_accessres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "661-669",
    "snippet": "int\nnfs3svc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0)\n\t\t*p++ = htonl(resp->access);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "resp->access"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0)\n\t\t*p++ = htonl(resp->access);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_diropres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "648-658",
    "snippet": "int\nnfs3svc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_post_op_attr(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "&resp->dirfh"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_fh",
          "args": [
            "p",
            "&resp->fh"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "67-75",
          "snippet": "static __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_post_op_attr(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_wccstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "639-645",
    "snippet": "int\nnfs3svc_encode_wccstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_wcc_data",
          "args": [
            "rqstp",
            "p",
            "&resp->fh"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "encode_wcc_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "231-250",
          "snippet": "static __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_wccstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_attrstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "626-636",
    "snippet": "int\nnfs3svc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tif (resp->status == 0) {\n\t\tlease_get_mtime(d_inode(resp->fh.fh_dentry),\n\t\t\t\t&resp->stat.mtime);\n\t\tp = encode_fattr3(rqstp, p, &resp->fh, &resp->stat);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_fattr3",
          "args": [
            "rqstp",
            "p",
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "163-187",
          "snippet": "static __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};\n\nstatic __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_get_mtime",
          "args": [
            "d_inode(resp->fh.fh_dentry)",
            "&resp->stat.mtime"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "resp->fh.fh_dentry"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tif (resp->status == 0) {\n\t\tlease_get_mtime(d_inode(resp->fh.fh_dentry),\n\t\t\t\t&resp->stat.mtime);\n\t\tp = encode_fattr3(rqstp, p, &resp->fh, &resp->stat);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_encode_voidres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "619-623",
    "snippet": "int\nnfs3svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_ressize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_commitargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "599-610",
    "snippet": "int\nnfs3svc_decode_commitargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->offset"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_commitargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_readdirplusargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "573-597",
    "snippet": "int\nnfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tint len;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf     = p; p += 2;\n\targs->dircount = ntohl(*p++);\n\targs->count    = ntohl(*p++);\n\n\tlen = args->count = min(args->count, max_blocksize);\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\t\tif (!args->buffer)\n\t\t\targs->buffer = page_address(p);\n\t\tlen -= PAGE_SIZE;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "args->count",
            "max_blocksize"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->cookie"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tint len;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf     = p; p += 2;\n\targs->dircount = ntohl(*p++);\n\targs->count    = ntohl(*p++);\n\n\tlen = args->count = min(args->count, max_blocksize);\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\t\tif (!args->buffer)\n\t\t\targs->buffer = page_address(p);\n\t\tlen -= PAGE_SIZE;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_readdirargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "556-571",
    "snippet": "int\nnfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf   = p; p += 2;\n\targs->dircount = ~0;\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*(rqstp->rq_next_page++)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "args->count",
            "PAGE_SIZE"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->cookie"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf   = p; p += 2;\n\targs->dircount = ~0;\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_linkargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "544-554",
    "snippet": "int\nnfs3svc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->tname",
            "&args->tlen"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "81-95",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->tfh"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_readlinkargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "532-542",
    "snippet": "int\nnfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*(rqstp->rq_next_page++)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_renameargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "519-530",
    "snippet": "int\nnfs3svc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->tname",
            "&args->tlen"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "81-95",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->tfh"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_mknodargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "497-517",
    "snippet": "int\nnfs3svc_decode_mknodargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_mknodargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\targs->ftype = ntohl(*p++);\n\n\tif (args->ftype == NF3BLK  || args->ftype == NF3CHR\n\t || args->ftype == NF3SOCK || args->ftype == NF3FIFO)\n\t\tp = decode_sattr3(p, &args->attrs);\n\n\tif (args->ftype == NF3BLK || args->ftype == NF3CHR) {\n\t\targs->major = ntohl(*p++);\n\t\targs->minor = ntohl(*p++);\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr3",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "97-140",
          "snippet": "static __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->name",
            "&args->len"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "81-95",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_mknodargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_mknodargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\targs->ftype = ntohl(*p++);\n\n\tif (args->ftype == NF3BLK  || args->ftype == NF3CHR\n\t || args->ftype == NF3SOCK || args->ftype == NF3FIFO)\n\t\tp = decode_sattr3(p, &args->attrs);\n\n\tif (args->ftype == NF3BLK || args->ftype == NF3CHR) {\n\t\targs->major = ntohl(*p++);\n\t\targs->minor = ntohl(*p++);\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_symlinkargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "447-495",
    "snippet": "int\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "rqstp->rq_arg.pages[0]"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "rqstp->rq_arg.page_len",
            "PAGE_SIZE"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "*(rqstp->rq_next_page++)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr3",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "97-140",
          "snippet": "static __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->fname",
            "&args->flen"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "81-95",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->ffh"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs3svc_decode_mkdirargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "435-445",
    "snippet": "int\nnfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh)) ||\n\t    !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr3",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "97-140",
          "snippet": "static __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->name",
            "&args->len"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "81-95",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh)) ||\n\t    !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_createargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "412-434",
    "snippet": "int\nnfs3svc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\tswitch (args->createmode = ntohl(*p++)) {\n\tcase NFS3_CREATE_UNCHECKED:\n\tcase NFS3_CREATE_GUARDED:\n\t\tp = decode_sattr3(p, &args->attrs);\n\t\tbreak;\n\tcase NFS3_CREATE_EXCLUSIVE:\n\t\targs->verf = p;\n\t\tp += 2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr3",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "97-140",
          "snippet": "static __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->name",
            "&args->len"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "81-95",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\tswitch (args->createmode = ntohl(*p++)) {\n\tcase NFS3_CREATE_UNCHECKED:\n\tcase NFS3_CREATE_GUARDED:\n\t\tp = decode_sattr3(p, &args->attrs);\n\t\tbreak;\n\tcase NFS3_CREATE_EXCLUSIVE:\n\t\targs->verf = p;\n\t\tp += 2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_writeargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "355-410",
    "snippet": "int\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - rqstp->rq_arg.head[0].iov_base;\n\tdlen = rqstp->rq_arg.head[0].iov_len + rqstp->rq_arg.page_len\n\t\t+ rqstp->rq_arg.tail[0].iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = rqstp->rq_arg.head[0].iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "rqstp->rq_pages[v]"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "len"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->offset"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - rqstp->rq_arg.head[0].iov_base;\n\tdlen = rqstp->rq_arg.head[0].iov_len + rqstp->rq_arg.page_len\n\t\t+ rqstp->rq_arg.tail[0].iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = rqstp->rq_arg.head[0].iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs3svc_decode_readargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "325-353",
    "snippet": "int\nnfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\tlen = min(args->count, max_blocksize);\n\n\t/* set up the kvec */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "len",
            "PAGE_SIZE"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "args->count",
            "max_blocksize"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&args->offset"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_max_payload",
          "args": [
            "rqstp"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\tlen = min(args->count, max_blocksize);\n\n\t/* set up the kvec */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_accessargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "313-323",
    "snippet": "int\nnfs3svc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_diropargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "302-311",
    "snippet": "int\nnfs3svc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_filename",
          "args": [
            "p",
            "&args->name",
            "&args->len"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "decode_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "81-95",
          "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_sattrargs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "284-300",
    "snippet": "int\nnfs3svc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\tif ((args->check_guard = ntohl(*p++)) != 0) { \n\t\tstruct timespec time; \n\t\tp = decode_time3(p, &time);\n\t\targs->guardtime = time.tv_sec;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_time3",
          "args": [
            "p",
            "&time"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "decode_time3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "39-45",
          "snippet": "static __be32 *\ndecode_time3(__be32 *p, struct timespec *time)\n{\n\ttime->tv_sec = ntohl(*p++);\n\ttime->tv_nsec = ntohl(*p++);\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_time3(__be32 *p, struct timespec *time)\n{\n\ttime->tv_sec = ntohl(*p++);\n\ttime->tv_nsec = ntohl(*p++);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_sattr3",
          "args": [
            "p",
            "&args->attrs"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "decode_sattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "97-140",
          "snippet": "static __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\tif ((args->check_guard = ntohl(*p++)) != 0) { \n\t\tstruct timespec time; \n\t\tp = decode_time3(p, &time);\n\t\targs->guardtime = time.tv_sec;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "nfs3svc_decode_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "275-282",
    "snippet": "int\nnfs3svc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_argsize_check",
          "args": [
            "rqstp",
            "p"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "&args->fh"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nint\nnfs3svc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}"
  },
  {
    "function_name": "fill_post_wcc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "255-270",
    "snippet": "void fill_post_wcc(struct svc_fh *fhp)\n{\n\t__be32 err;\n\n\tif (fhp->fh_post_saved)\n\t\tprintk(\"nfsd: inode locked twice during operation.\\n\");\n\n\terr = fh_getattr(fhp, &fhp->fh_post_attr);\n\tfhp->fh_post_change = d_inode(fhp->fh_dentry)->i_version;\n\tif (err) {\n\t\tfhp->fh_post_saved = false;\n\t\t/* Grab the ctime anyway - set_change_info might use it */\n\t\tfhp->fh_post_attr.ctime = d_inode(fhp->fh_dentry)->i_ctime;\n\t} else\n\t\tfhp->fh_post_saved = true;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "fhp->fh_dentry"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "fhp->fh_dentry"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "fhp",
            "&fhp->fh_post_attr"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd: inode locked twice during operation.\\n\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nvoid fill_post_wcc(struct svc_fh *fhp)\n{\n\t__be32 err;\n\n\tif (fhp->fh_post_saved)\n\t\tprintk(\"nfsd: inode locked twice during operation.\\n\");\n\n\terr = fh_getattr(fhp, &fhp->fh_post_attr);\n\tfhp->fh_post_change = d_inode(fhp->fh_dentry)->i_version;\n\tif (err) {\n\t\tfhp->fh_post_saved = false;\n\t\t/* Grab the ctime anyway - set_change_info might use it */\n\t\tfhp->fh_post_attr.ctime = d_inode(fhp->fh_dentry)->i_ctime;\n\t} else\n\t\tfhp->fh_post_saved = true;\n}"
  },
  {
    "function_name": "encode_wcc_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "231-250",
    "snippet": "static __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "fhp"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_saved_post_attr",
          "args": [
            "rqstp",
            "p",
            "fhp"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "encode_saved_post_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "189-195",
          "snippet": "static __be32 *\nencode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\t/* Attributes to follow */\n\t*p++ = xdr_one;\n\treturn encode_fattr3(rqstp, p, fhp, &fhp->fh_post_attr);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\t/* Attributes to follow */\n\t*p++ = xdr_one;\n\treturn encode_fattr3(rqstp, p, fhp, &fhp->fh_post_attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "encode_time3",
          "args": [
            "p",
            "&fhp->fh_pre_ctime"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "encode_time3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "32-37",
          "snippet": "static __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) fhp->fh_pre_size"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "dentry"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
  },
  {
    "function_name": "nfs3svc_encode_post_op_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "222-226",
    "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_post_op_attr",
          "args": [
            "rqstp",
            "p",
            "fhp"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_encode_post_op_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "222-226",
          "snippet": "__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}"
  },
  {
    "function_name": "encode_post_op_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "202-219",
    "snippet": "static __be32 *\nencode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry *dentry = fhp->fh_dentry;\n\tif (dentry && d_really_is_positive(dentry)) {\n\t        __be32 err;\n\t\tstruct kstat stat;\n\n\t\terr = fh_getattr(fhp, &stat);\n\t\tif (!err) {\n\t\t\t*p++ = xdr_one;\t\t/* attributes follow */\n\t\t\tlease_get_mtime(d_inode(dentry), &stat.mtime);\n\t\t\treturn encode_fattr3(rqstp, p, fhp, &stat);\n\t\t}\n\t}\n\t*p++ = xdr_zero;\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_fattr3",
          "args": [
            "rqstp",
            "p",
            "fhp",
            "&stat"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "163-187",
          "snippet": "static __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};\n\nstatic __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lease_get_mtime",
          "args": [
            "d_inode(dentry)",
            "&stat.mtime"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "fhp",
            "&stat"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "dentry"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry *dentry = fhp->fh_dentry;\n\tif (dentry && d_really_is_positive(dentry)) {\n\t        __be32 err;\n\t\tstruct kstat stat;\n\n\t\terr = fh_getattr(fhp, &stat);\n\t\tif (!err) {\n\t\t\t*p++ = xdr_one;\t\t/* attributes follow */\n\t\t\tlease_get_mtime(d_inode(dentry), &stat.mtime);\n\t\t\treturn encode_fattr3(rqstp, p, fhp, &stat);\n\t\t}\n\t}\n\t*p++ = xdr_zero;\n\treturn p;\n}"
  },
  {
    "function_name": "encode_saved_post_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "189-195",
    "snippet": "static __be32 *\nencode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\t/* Attributes to follow */\n\t*p++ = xdr_one;\n\treturn encode_fattr3(rqstp, p, fhp, &fhp->fh_post_attr);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_fattr3",
          "args": [
            "rqstp",
            "p",
            "fhp",
            "&fhp->fh_post_attr"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fattr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "163-187",
          "snippet": "static __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};\n\nstatic __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\t/* Attributes to follow */\n\t*p++ = xdr_one;\n\treturn encode_fattr3(rqstp, p, fhp, &fhp->fh_post_attr);\n}"
  },
  {
    "function_name": "encode_fattr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "163-187",
    "snippet": "static __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_time3",
          "args": [
            "p",
            "&stat->ctime"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "encode_time3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "32-37",
          "snippet": "static __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "stat->ino"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_fsid",
          "args": [
            "p",
            "fhp"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "encode_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "142-161",
          "snippet": "static __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)\n{\n\tu64 f;\n\tswitch(fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\tp = xdr_encode_hyper(p, (u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u64*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u64*)fhp->fh_export->ex_uuid)[1];\n\t\tp = xdr_encode_hyper(p, f);\n\t\tbreak;\n\t}\n\treturn p;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"netns.h\"",
            "#include \"auth.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)\n{\n\tu64 f;\n\tswitch(fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\tp = xdr_encode_hyper(p, (u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u64*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u64*)fhp->fh_export->ex_uuid)[1];\n\t\tp = xdr_encode_hyper(p, f);\n\t\tbreak;\n\t}\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) MINOR(stat->rdev)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "stat->rdev"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) MAJOR(stat->rdev)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "stat->rdev"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "((u64)stat->blocks) << 9"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) stat->size"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) NFS3_MAXPATHLEN"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "stat->mode"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) from_kgid(&init_user_ns, stat->gid)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "stat->gid"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) from_kuid(&init_user_ns, stat->uid)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "stat->uid"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) stat->nlink"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) (stat->mode & S_IALLUGO)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "stat->mode & S_IALLUGO"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "nfs3_ftypes[(stat->mode & S_IFMT) >> 12]"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};\n\nstatic __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}"
  },
  {
    "function_name": "encode_fsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "142-161",
    "snippet": "static __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)\n{\n\tu64 f;\n\tswitch(fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\tp = xdr_encode_hyper(p, (u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u64*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u64*)fhp->fh_export->ex_uuid)[1];\n\t\tp = xdr_encode_hyper(p, f);\n\t\tbreak;\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "f"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64) fhp->fh_export->ex_fsid"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_hyper",
          "args": [
            "p",
            "(u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "fhp->fh_dentry->d_sb->s_dev"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsid_source",
          "args": [
            "fhp"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "fsid_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "663-689",
          "snippet": "enum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nenum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)\n{\n\tu64 f;\n\tswitch(fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\tp = xdr_encode_hyper(p, (u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u64*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u64*)fhp->fh_export->ex_uuid)[1];\n\t\tp = xdr_encode_hyper(p, f);\n\t\tbreak;\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "decode_sattr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "97-140",
    "snippet": "static __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "newsize",
            "NFS_OFFSET_MAX"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&newsize"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "iap->ia_gid"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "ntohl(*p++)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "iap->ia_uid"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "ntohl(*p++)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}"
  },
  {
    "function_name": "decode_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "81-95",
    "snippet": "static __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_decode_string_inplace",
          "args": [
            "p",
            "namp",
            "lenp",
            "NFS3_MAXNAMLEN"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "encode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "67-75",
    "snippet": "static __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "size"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "&fhp->fh_handle.fh_base",
            "size"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "size"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "size"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}"
  },
  {
    "function_name": "nfs3svc_decode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "62-65",
    "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_fh",
          "args": [
            "p",
            "fhp"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "nfs3svc_decode_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
          "lines": "62-65",
          "snippet": "__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}"
  },
  {
    "function_name": "decode_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "47-59",
    "snippet": "static __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size;\n\tfh_init(fhp, NFS3_FHSIZE);\n\tsize = ntohl(*p++);\n\tif (size > NFS3_FHSIZE)\n\t\treturn NULL;\n\n\tmemcpy(&fhp->fh_handle.fh_base, p, size);\n\tfhp->fh_handle.fh_size = size;\n\treturn p + XDR_QUADLEN(size);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "size"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fhp->fh_handle.fh_base",
            "p",
            "size"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "fhp",
            "NFS3_FHSIZE"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size;\n\tfh_init(fhp, NFS3_FHSIZE);\n\tsize = ntohl(*p++);\n\tif (size > NFS3_FHSIZE)\n\t\treturn NULL;\n\n\tmemcpy(&fhp->fh_handle.fh_base, p, size);\n\tfhp->fh_handle.fh_size = size;\n\treturn p + XDR_QUADLEN(size);\n}"
  },
  {
    "function_name": "decode_time3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "39-45",
    "snippet": "static __be32 *\ndecode_time3(__be32 *p, struct timespec *time)\n{\n\ttime->tv_sec = ntohl(*p++);\n\ttime->tv_nsec = ntohl(*p++);\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "*p++"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\ndecode_time3(__be32 *p, struct timespec *time)\n{\n\ttime->tv_sec = ntohl(*p++);\n\ttime->tv_nsec = ntohl(*p++);\n\treturn p;\n}"
  },
  {
    "function_name": "encode_time3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs3xdr.c",
    "lines": "32-37",
    "snippet": "static __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"netns.h\"",
      "#include \"auth.h\"",
      "#include \"xdr3.h\"",
      "#include <linux/sunrpc/svc_xprt.h>",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "time->tv_nsec"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "(u32) time->tv_sec"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"netns.h\"\n#include \"auth.h\"\n#include \"xdr3.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/namei.h>\n\nstatic __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}"
  }
]