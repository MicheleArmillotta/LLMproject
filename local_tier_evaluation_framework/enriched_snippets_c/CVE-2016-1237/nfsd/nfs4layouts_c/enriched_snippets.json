[
  {
    "function_name": "nfsd4_exit_pnfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "762-776",
    "snippet": "void\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
    ],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;",
      "static struct kmem_cache *nfs4_layout_stateid_cache;",
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "map",
            "n",
            "&nfsd_devid_hash[i]",
            "hash"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs4_layout_stateid_cache"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs4_layout_cache"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nvoid\nnfsd4_exit_pnfs(void)\n{\n\tint i;\n\n\tkmem_cache_destroy(nfs4_layout_cache);\n\tkmem_cache_destroy(nfs4_layout_stateid_cache);\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tstruct nfsd4_deviceid_map *map, *n;\n\n\t\tlist_for_each_entry_safe(map, n, &nfsd_devid_hash[i], hash)\n\t\t\tkfree(map);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_init_pnfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "740-760",
    "snippet": "int\nnfsd4_init_pnfs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nfsd_devid_hash[i]);\n\n\tnfs4_layout_cache = kmem_cache_create(\"nfs4_layout\",\n\t\t\tsizeof(struct nfs4_layout), 0, 0, NULL);\n\tif (!nfs4_layout_cache)\n\t\treturn -ENOMEM;\n\n\tnfs4_layout_stateid_cache = kmem_cache_create(\"nfs4_layout_stateid\",\n\t\t\tsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\n\tif (!nfs4_layout_stateid_cache) {\n\t\tkmem_cache_destroy(nfs4_layout_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
    ],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;",
      "static struct kmem_cache *nfs4_layout_stateid_cache;",
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "nfs4_layout_cache"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfs4_layout_stateid\"",
            "sizeof(struct nfs4_layout_stateid)",
            "0",
            "0",
            "NULL"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfs4_layout\"",
            "sizeof(struct nfs4_layout)",
            "0",
            "0",
            "NULL"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nfsd_devid_hash[i]"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic struct kmem_cache *nfs4_layout_cache;\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nint\nnfsd4_init_pnfs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nfsd_devid_hash[i]);\n\n\tnfs4_layout_cache = kmem_cache_create(\"nfs4_layout\",\n\t\t\tsizeof(struct nfs4_layout), 0, 0, NULL);\n\tif (!nfs4_layout_cache)\n\t\treturn -ENOMEM;\n\n\tnfs4_layout_stateid_cache = kmem_cache_create(\"nfs4_layout_stateid\",\n\t\t\tsizeof(struct nfs4_layout_stateid), 0, 0, NULL);\n\tif (!nfs4_layout_stateid_cache) {\n\t\tkmem_cache_destroy(nfs4_layout_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_layout_lm_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "727-733",
    "snippet": "static int\nnfsd4_layout_lm_change(struct file_lock *onlist, int arg,\n\t\tstruct list_head *dispose)\n{\n\tBUG_ON(!(arg & F_UNLCK));\n\treturn lease_modify(onlist, arg, dispose);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "onlist",
            "arg",
            "dispose"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(arg & F_UNLCK)"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic int\nnfsd4_layout_lm_change(struct file_lock *onlist, int arg,\n\t\tstruct list_head *dispose)\n{\n\tBUG_ON(!(arg & F_UNLCK));\n\treturn lease_modify(onlist, arg, dispose);\n}"
  },
  {
    "function_name": "nfsd4_layout_lm_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "714-725",
    "snippet": "static bool\nnfsd4_layout_lm_break(struct file_lock *fl)\n{\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a layout isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\tnfsd4_recall_file_layout(fl->fl_owner);\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_recall_file_layout",
          "args": [
            "fl->fl_owner"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recall_file_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "309-328",
          "snippet": "static void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic bool\nnfsd4_layout_lm_break(struct file_lock *fl)\n{\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a layout isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\tnfsd4_recall_file_layout(fl->fl_owner);\n\treturn false;\n}"
  },
  {
    "function_name": "nfsd4_cb_layout_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "694-706",
    "snippet": "static void\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\ttrace_layout_recall_release(&ls->ls_stid.sc_stateid);\n\n\tnfsd4_return_all_layouts(ls, &reaplist);\n\tnfsd4_free_layouts(&reaplist);\n\tnfs4_put_stid(&ls->ls_stid);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "441-452",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_layouts",
          "args": [
            "ls",
            "&reaplist"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "558-565",
          "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_layout_recall_release",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structnfs4_layout_stateid",
            "ls_recall"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\ttrace_layout_recall_release(&ls->ls_stid.sc_stateid);\n\n\tnfsd4_return_all_layouts(ls, &reaplist);\n\tnfsd4_free_layouts(&reaplist);\n\tnfs4_put_stid(&ls->ls_stid);\n}"
  },
  {
    "function_name": "nfsd4_cb_layout_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "640-692",
    "snippet": "static int\nnfsd4_cb_layout_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tstruct nfsd_net *nn;\n\tktime_t now, cutoff;\n\tconst struct nfsd4_layout_ops *ops;\n\tLIST_HEAD(reaplist);\n\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\tcase -NFS4ERR_DELAY:\n\t\t/*\n\t\t * Anything left? If not, then call it done. Note that we don't\n\t\t * take the spinlock since this is an optimization and nothing\n\t\t * should get added until the cb counter goes to zero.\n\t\t */\n\t\tif (list_empty(&ls->ls_layouts))\n\t\t\treturn 1;\n\n\t\t/* Poll the client until it's done with the layout */\n\t\tnow = ktime_get();\n\t\tnn = net_generic(ls->ls_stid.sc_client->net, nfsd_net_id);\n\n\t\t/* Client gets 2 lease periods to return it */\n\t\tcutoff = ktime_add_ns(task->tk_start,\n\t\t\t\t\t nn->nfsd4_lease * NSEC_PER_SEC * 2);\n\n\t\tif (ktime_before(now, cutoff)) {\n\t\t\trpc_delay(task, HZ/100); /* 10 mili-seconds */\n\t\t\treturn 0;\n\t\t}\n\t\t/* Fallthrough */\n\tcase -NFS4ERR_NOMATCHING_LAYOUT:\n\t\ttrace_layout_recall_done(&ls->ls_stid.sc_stateid);\n\t\ttask->tk_status = 0;\n\t\treturn 1;\n\tdefault:\n\t\t/*\n\t\t * Unknown error or non-responding client, we'll need to fence.\n\t\t */\n\t\ttrace_layout_recall_fail(&ls->ls_stid.sc_stateid);\n\n\t\tops = nfsd4_layout_ops[ls->ls_layout_type];\n\t\tif (ops->fence_client)\n\t\t\tops->fence_client(ls);\n\t\telse\n\t\t\tnfsd4_cb_layout_fail(ls);\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct nfsd4_layout_ops *nfsd4_layout_ops[LAYOUT_TYPE_MAX] =  {\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\t[LAYOUT_BLOCK_VOLUME]\t= &bl_layout_ops,\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\t[LAYOUT_SCSI]\t\t= &scsi_layout_ops,\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_cb_layout_fail",
          "args": [
            "ls"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cb_layout_fail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "597-627",
          "snippet": "static void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops->fence_client",
          "args": [
            "ls"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_recall_fail",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_recall_done",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "HZ/100"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_before",
          "args": [
            "now",
            "cutoff"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "task->tk_start",
            "nn->nfsd4_lease * NSEC_PER_SEC * 2"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "ls->ls_stid.sc_client->net",
            "nfsd_net_id"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_layouts"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structnfs4_layout_stateid",
            "ls_recall"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nconst struct nfsd4_layout_ops *nfsd4_layout_ops[LAYOUT_TYPE_MAX] =  {\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\t[LAYOUT_BLOCK_VOLUME]\t= &bl_layout_ops,\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\t[LAYOUT_SCSI]\t\t= &scsi_layout_ops,\n#endif\n};\n\nstatic int\nnfsd4_cb_layout_done(struct nfsd4_callback *cb, struct rpc_task *task)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tstruct nfsd_net *nn;\n\tktime_t now, cutoff;\n\tconst struct nfsd4_layout_ops *ops;\n\tLIST_HEAD(reaplist);\n\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\tcase -NFS4ERR_DELAY:\n\t\t/*\n\t\t * Anything left? If not, then call it done. Note that we don't\n\t\t * take the spinlock since this is an optimization and nothing\n\t\t * should get added until the cb counter goes to zero.\n\t\t */\n\t\tif (list_empty(&ls->ls_layouts))\n\t\t\treturn 1;\n\n\t\t/* Poll the client until it's done with the layout */\n\t\tnow = ktime_get();\n\t\tnn = net_generic(ls->ls_stid.sc_client->net, nfsd_net_id);\n\n\t\t/* Client gets 2 lease periods to return it */\n\t\tcutoff = ktime_add_ns(task->tk_start,\n\t\t\t\t\t nn->nfsd4_lease * NSEC_PER_SEC * 2);\n\n\t\tif (ktime_before(now, cutoff)) {\n\t\t\trpc_delay(task, HZ/100); /* 10 mili-seconds */\n\t\t\treturn 0;\n\t\t}\n\t\t/* Fallthrough */\n\tcase -NFS4ERR_NOMATCHING_LAYOUT:\n\t\ttrace_layout_recall_done(&ls->ls_stid.sc_stateid);\n\t\ttask->tk_status = 0;\n\t\treturn 1;\n\tdefault:\n\t\t/*\n\t\t * Unknown error or non-responding client, we'll need to fence.\n\t\t */\n\t\ttrace_layout_recall_fail(&ls->ls_stid.sc_stateid);\n\n\t\tops = nfsd4_layout_ops[ls->ls_layout_type];\n\t\tif (ops->fence_client)\n\t\t\tops->fence_client(ls);\n\t\telse\n\t\t\tnfsd4_cb_layout_fail(ls);\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cb_layout_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "629-638",
    "snippet": "static void\nnfsd4_cb_layout_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\n\tmutex_lock(&ls->ls_mutex);\n\tnfs4_inc_and_copy_stateid(&ls->ls_recall_sid, &ls->ls_stid);\n\tmutex_unlock(&ls->ls_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_mutex"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&ls->ls_recall_sid",
            "&ls->ls_stid"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_mutex"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cb",
            "structnfs4_layout_stateid",
            "ls_recall"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_cb_layout_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\n\tmutex_lock(&ls->ls_mutex);\n\tnfs4_inc_and_copy_stateid(&ls->ls_recall_sid, &ls->ls_stid);\n\tmutex_unlock(&ls->ls_mutex);\n}"
  },
  {
    "function_name": "nfsd4_cb_layout_fail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "597-627",
    "snippet": "static void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\"",
            "addr_str",
            "error"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_usermodehelper",
          "args": [
            "argv[0]",
            "argv",
            "envp",
            "UMH_WAIT_PROC"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\"",
            "addr_str"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&clp->cl_addr",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_cb_layout_fail(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tchar addr_str[INET6_ADDRSTRLEN];\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\tchar *argv[8];\n\tint error;\n\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, addr_str, sizeof(addr_str));\n\n\tprintk(KERN_WARNING\n\t\t\"nfsd: client %s failed to respond to layout recall. \"\n\t\t\"  Fencing..\\n\", addr_str);\n\n\targv[0] = \"/sbin/nfsd-recall-failed\";\n\targv[1] = addr_str;\n\targv[2] = ls->ls_file->f_path.mnt->mnt_sb->s_id;\n\targv[3] = NULL;\n\n\terror = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (error) {\n\t\tprintk(KERN_ERR \"nfsd: fence failed for client %s: %d!\\n\",\n\t\t\taddr_str, error);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_return_all_file_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "581-595",
    "snippet": "void\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "441-452",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_layouts",
          "args": [
            "ls",
            "&reaplist"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "558-565",
          "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ls",
            "n",
            "&fp->fi_lo_states",
            "ls_perfile"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nvoid\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
  },
  {
    "function_name": "nfsd4_return_all_client_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "567-579",
    "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "441-452",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_layouts",
          "args": [
            "ls",
            "&reaplist"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "558-565",
          "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ls",
            "n",
            "&clp->cl_lo_states",
            "ls_perclnt"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
  },
  {
    "function_name": "nfsd4_return_all_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "558-565",
    "snippet": "static void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&ls->ls_layouts",
            "reaplist"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_return_all_layouts(struct nfs4_layout_stateid *ls,\n\t\tstruct list_head *reaplist)\n{\n\tspin_lock(&ls->ls_lock);\n\tlist_splice_init(&ls->ls_layouts, reaplist);\n\tspin_unlock(&ls->ls_lock);\n}"
  },
  {
    "function_name": "nfsd4_return_client_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "522-556",
    "snippet": "__be32\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_layout *lp, *t;\n\tLIST_HEAD(reaplist);\n\n\tlrp->lrs_present = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\n\t\tif (ls->ls_layout_type != lrp->lr_layout_type)\n\t\t\tcontinue;\n\n\t\tif (lrp->lr_return_type == RETURN_FSID &&\n\t\t    !fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\n\t\t\t\t   &cstate->current_fh.fh_handle))\n\t\t\tcontinue;\n\n\t\tspin_lock(&ls->ls_lock);\n\t\tlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\n\t\t\tif (lrp->lr_seg.iomode == IOMODE_ANY ||\n\t\t\t    lrp->lr_seg.iomode == lp->lo_seg.iomode)\n\t\t\t\tlist_move_tail(&lp->lo_perstate, &reaplist);\n\t\t}\n\t\tspin_unlock(&ls->ls_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "441-452",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lp->lo_perstate",
            "&reaplist"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lp",
            "t",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_fsid_match",
          "args": [
            "&ls->ls_stid.sc_file->fi_fhandle",
            "&cstate->current_fh.fh_handle"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "fh_fsid_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "200-207",
          "snippet": "static inline bool fh_fsid_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_fsid_type != fh2->fh_fsid_type)\n\t\treturn false;\n\tif (memcmp(fh1->fh_fsid, fh2->fh_fsid, key_len(fh1->fh_fsid_type)) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline bool fh_fsid_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_fsid_type != fh2->fh_fsid_type)\n\t\treturn false;\n\tif (memcmp(fh1->fh_fsid, fh2->fh_fsid, key_len(fh1->fh_fsid_type)) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ls",
            "n",
            "&clp->cl_lo_states",
            "ls_perclnt"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n__be32\nnfsd4_return_client_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_layout *lp, *t;\n\tLIST_HEAD(reaplist);\n\n\tlrp->lrs_present = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt) {\n\t\tif (ls->ls_layout_type != lrp->lr_layout_type)\n\t\t\tcontinue;\n\n\t\tif (lrp->lr_return_type == RETURN_FSID &&\n\t\t    !fh_fsid_match(&ls->ls_stid.sc_file->fi_fhandle,\n\t\t\t\t   &cstate->current_fh.fh_handle))\n\t\t\tcontinue;\n\n\t\tspin_lock(&ls->ls_lock);\n\t\tlist_for_each_entry_safe(lp, t, &ls->ls_layouts, lo_perstate) {\n\t\t\tif (lrp->lr_seg.iomode == IOMODE_ANY ||\n\t\t\t    lrp->lr_seg.iomode == lp->lo_seg.iomode)\n\t\t\t\tlist_move_tail(&lp->lo_perstate, &reaplist);\n\t\t}\n\t\tspin_unlock(&ls->ls_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_return_file_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "479-520",
    "snippet": "__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found)\n\t\t\tnfs4_inc_and_copy_stateid(&lrp->lr_sid, &ls->ls_stid);\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tmutex_unlock(&ls->ls_mutex);\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_free_layouts",
          "args": [
            "&reaplist"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_free_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "441-452",
          "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_mutex"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_unhash_stid",
          "args": [
            "&ls->ls_stid"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_unhash_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "776-779",
          "snippet": "void nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_layoutstate_unhash",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&lrp->lr_sid",
            "&ls->ls_stid"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_layouts"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_return_file_layout",
          "args": [
            "lp",
            "&lrp->lr_seg",
            "&reaplist"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_file_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "479-520",
          "snippet": "__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found)\n\t\t\tnfs4_inc_and_copy_stateid(&lrp->lr_sid, &ls->ls_stid);\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tmutex_unlock(&ls->ls_mutex);\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "layouts_overlapping",
          "args": [
            "lp",
            "&lrp->lr_seg"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "layouts_overlapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "346-356",
          "snippet": "static bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lp",
            "n",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_return_lookup_fail",
          "args": [
            "&lrp->lr_sid"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_preprocess_layout_stateid",
          "args": [
            "rqstp",
            "cstate",
            "&lrp->lr_sid",
            "false",
            "lrp->lr_layout_type",
            "&ls"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_preprocess_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "255-307",
          "snippet": "__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t\tmutex_lock(&ls->ls_mutex);\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tmutex_lock(&ls->ls_mutex);\n\t\tif (nfsd4_stateid_generation_after(stateid, &stid->sc_stateid))\n\t\t\tgoto out_unlock_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_unlock_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_unlock_stid:\n\tmutex_unlock(&ls->ls_mutex);\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t\tmutex_lock(&ls->ls_mutex);\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tmutex_lock(&ls->ls_mutex);\n\t\tif (nfsd4_stateid_generation_after(stateid, &stid->sc_stateid))\n\t\t\tgoto out_unlock_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_unlock_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_unlock_stid:\n\tmutex_unlock(&ls->ls_mutex);\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n__be32\nnfsd4_return_file_layouts(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_layoutreturn *lrp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_layout *lp, *n;\n\tLIST_HEAD(reaplist);\n\t__be32 nfserr;\n\tint found = 0;\n\n\tnfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lrp->lr_sid,\n\t\t\t\t\t\tfalse, lrp->lr_layout_type,\n\t\t\t\t\t\t&ls);\n\tif (nfserr) {\n\t\ttrace_layout_return_lookup_fail(&lrp->lr_sid);\n\t\treturn nfserr;\n\t}\n\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry_safe(lp, n, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_overlapping(lp, &lrp->lr_seg)) {\n\t\t\tnfsd4_return_file_layout(lp, &lrp->lr_seg, &reaplist);\n\t\t\tfound++;\n\t\t}\n\t}\n\tif (!list_empty(&ls->ls_layouts)) {\n\t\tif (found)\n\t\t\tnfs4_inc_and_copy_stateid(&lrp->lr_sid, &ls->ls_stid);\n\t\tlrp->lrs_present = 1;\n\t} else {\n\t\ttrace_layoutstate_unhash(&ls->ls_stid.sc_stateid);\n\t\tnfs4_unhash_stid(&ls->ls_stid);\n\t\tlrp->lrs_present = 0;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\n\tmutex_unlock(&ls->ls_mutex);\n\tnfs4_put_stid(&ls->ls_stid);\n\tnfsd4_free_layouts(&reaplist);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_return_file_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "454-477",
    "snippet": "static void\nnfsd4_return_file_layout(struct nfs4_layout *lp, struct nfsd4_layout_seg *seg,\n\t\tstruct list_head *reaplist)\n{\n\tstruct nfsd4_layout_seg *lo = &lp->lo_seg;\n\tu64 end = layout_end(lo);\n\n\tif (seg->offset <= lo->offset) {\n\t\tif (layout_end(seg) >= end) {\n\t\t\tlist_move_tail(&lp->lo_perstate, reaplist);\n\t\t\treturn;\n\t\t}\n\t\tlo->offset = layout_end(seg);\n\t} else {\n\t\t/* retain the whole layout segment on a split. */\n\t\tif (layout_end(seg) < end) {\n\t\t\tdprintk(\"%s: split not supported\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tend = seg->offset;\n\t}\n\n\tlayout_update_len(lo, end);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "layout_update_len",
          "args": [
            "lo",
            "end"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "layout_update_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "337-344",
          "snippet": "static void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: split not supported\\n\"",
            "__func__"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layout_end",
          "args": [
            "seg"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "layout_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "330-335",
          "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lp->lo_perstate",
            "reaplist"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_return_file_layout(struct nfs4_layout *lp, struct nfsd4_layout_seg *seg,\n\t\tstruct list_head *reaplist)\n{\n\tstruct nfsd4_layout_seg *lo = &lp->lo_seg;\n\tu64 end = layout_end(lo);\n\n\tif (seg->offset <= lo->offset) {\n\t\tif (layout_end(seg) >= end) {\n\t\t\tlist_move_tail(&lp->lo_perstate, reaplist);\n\t\t\treturn;\n\t\t}\n\t\tlo->offset = layout_end(seg);\n\t} else {\n\t\t/* retain the whole layout segment on a split. */\n\t\tif (layout_end(seg) < end) {\n\t\t\tdprintk(\"%s: split not supported\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tend = seg->offset;\n\t}\n\n\tlayout_update_len(lo, end);\n}"
  },
  {
    "function_name": "nfsd4_free_layouts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "441-452",
    "snippet": "static void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_cache",
            "lp"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&lp->lo_state->ls_stid"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&lp->lo_perstate"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "reaplist",
            "structnfs4_layout",
            "lo_perstate"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "reaplist"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\nstatic void\nnfsd4_free_layouts(struct list_head *reaplist)\n{\n\twhile (!list_empty(reaplist)) {\n\t\tstruct nfs4_layout *lp = list_first_entry(reaplist,\n\t\t\t\tstruct nfs4_layout, lo_perstate);\n\n\t\tlist_del(&lp->lo_perstate);\n\t\tnfs4_put_stid(&lp->lo_state->ls_stid);\n\t\tkmem_cache_free(nfs4_layout_cache, lp);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_insert_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "392-439",
    "snippet": "__be32\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\n{\n\tstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout *lp, *new = NULL;\n\t__be32 nfserr;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\tspin_unlock(&fp->fi_lock);\n\n\tnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\n\tif (!new)\n\t\treturn nfserr_jukebox;\n\tmemcpy(&new->lo_seg, seg, sizeof(lp->lo_seg));\n\tnew->lo_state = ls;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\n\tnew = NULL;\ndone:\n\tnfs4_inc_and_copy_stateid(&lgp->lg_sid, &ls->ls_stid);\n\tspin_unlock(&ls->ls_lock);\nout:\n\tspin_unlock(&fp->fi_lock);\n\tif (new)\n\t\tkmem_cache_free(nfs4_layout_cache, new);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_cache",
            "new"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&lgp->lg_sid",
            "&ls->ls_stid"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new->lo_perstate",
            "&ls->ls_layouts"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ls->ls_stid.sc_count"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layouts_try_merge",
          "args": [
            "&lp->lo_seg",
            "seg"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "layouts_try_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "358-371",
          "snippet": "static bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lp",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_recall_conflict",
          "args": [
            "ls"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recall_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "373-390",
          "snippet": "static __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->lo_seg",
            "seg",
            "sizeof(lp->lo_seg)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "nfs4_layout_cache",
            "GFP_KERNEL"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lp",
            "&ls->ls_layouts",
            "lo_perstate"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_cache;\n\n__be32\nnfsd4_insert_layout(struct nfsd4_layoutget *lgp, struct nfs4_layout_stateid *ls)\n{\n\tstruct nfsd4_layout_seg *seg = &lgp->lg_seg;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout *lp, *new = NULL;\n\t__be32 nfserr;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\tspin_unlock(&ls->ls_lock);\n\tspin_unlock(&fp->fi_lock);\n\n\tnew = kmem_cache_alloc(nfs4_layout_cache, GFP_KERNEL);\n\tif (!new)\n\t\treturn nfserr_jukebox;\n\tmemcpy(&new->lo_seg, seg, sizeof(lp->lo_seg));\n\tnew->lo_state = ls;\n\n\tspin_lock(&fp->fi_lock);\n\tnfserr = nfsd4_recall_conflict(ls);\n\tif (nfserr)\n\t\tgoto out;\n\tspin_lock(&ls->ls_lock);\n\tlist_for_each_entry(lp, &ls->ls_layouts, lo_perstate) {\n\t\tif (layouts_try_merge(&lp->lo_seg, seg))\n\t\t\tgoto done;\n\t}\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tlist_add_tail(&new->lo_perstate, &ls->ls_layouts);\n\tnew = NULL;\ndone:\n\tnfs4_inc_and_copy_stateid(&lgp->lg_sid, &ls->ls_stid);\n\tspin_unlock(&ls->ls_lock);\nout:\n\tspin_unlock(&fp->fi_lock);\n\tif (new)\n\t\tkmem_cache_free(nfs4_layout_cache, new);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd4_recall_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "373-390",
    "snippet": "static __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_recall_file_layout",
          "args": [
            "l"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recall_file_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "309-328",
          "snippet": "static void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "l",
            "n",
            "&fp->fi_lo_states",
            "ls_perfile"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic __be32\nnfsd4_recall_conflict(struct nfs4_layout_stateid *ls)\n{\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\tstruct nfs4_layout_stateid *l, *n;\n\t__be32 nfserr = nfs_ok;\n\n\tassert_spin_locked(&fp->fi_lock);\n\n\tlist_for_each_entry_safe(l, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (l != ls) {\n\t\t\tnfsd4_recall_file_layout(l);\n\t\t\tnfserr = nfserr_recallconflict;\n\t\t}\n\t}\n\n\treturn nfserr;\n}"
  },
  {
    "function_name": "layouts_try_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "358-371",
    "snippet": "static bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "layout_update_len",
          "args": [
            "lo",
            "max(layout_end(lo), layout_end(new))"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "layout_update_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "337-344",
          "snippet": "static void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "layout_end(lo)",
            "layout_end(new)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_max_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4proc.c",
          "lines": "2338-2348",
          "snippet": "int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"trace.h\"",
            "#include \"pnfs.h\"",
            "#include \"acl.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"cache.h\"",
            "#include \"idmap.h\"",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define op_encode_hdr_size\t\t(2)"
          ],
          "globals_used": [
            "static const char *nfsd4_op_name(unsigned opnum);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"trace.h\"\n#include \"pnfs.h\"\n#include \"acl.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"cache.h\"\n#include \"idmap.h\"\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/file.h>\n\n#define op_encode_hdr_size\t\t(2)\n\nstatic const char *nfsd4_op_name(unsigned opnum);\n\nint nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\tstruct nfsd4_operation *opdesc;\n\tnfsd4op_rsize estimator;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\treturn op_encode_hdr_size * sizeof(__be32);\n\topdesc = OPDESC(op);\n\testimator = opdesc->op_rsize_bop;\n\treturn estimator ? estimator(rqstp, op) : PAGE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "layout_end",
          "args": [
            "new"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "layout_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "330-335",
          "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "lo->offset",
            "new->offset"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic bool\nlayouts_try_merge(struct nfsd4_layout_seg *lo, struct nfsd4_layout_seg *new)\n{\n\tif (lo->iomode != new->iomode)\n\t\treturn false;\n\tif (layout_end(new) < lo->offset)\n\t\treturn false;\n\tif (layout_end(lo) < new->offset)\n\t\treturn false;\n\n\tlo->offset = min(lo->offset, new->offset);\n\tlayout_update_len(lo, max(layout_end(lo), layout_end(new)));\n\treturn true;\n}"
  },
  {
    "function_name": "layouts_overlapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "346-356",
    "snippet": "static bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "layout_end",
          "args": [
            "s"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "layout_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "330-335",
          "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic bool\nlayouts_overlapping(struct nfs4_layout *lo, struct nfsd4_layout_seg *s)\n{\n\tif (s->iomode != IOMODE_ANY && s->iomode != lo->lo_seg.iomode)\n\t\treturn false;\n\tif (layout_end(&lo->lo_seg) <= s->offset)\n\t\treturn false;\n\tif (layout_end(s) <= lo->lo_seg.offset)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "layout_update_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "337-344",
    "snippet": "static void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nlayout_update_len(struct nfsd4_layout_seg *lo, u64 end)\n{\n\tif (end == NFS4_MAX_UINT64)\n\t\tlo->length = NFS4_MAX_UINT64;\n\telse\n\t\tlo->length = end - lo->offset;\n}"
  },
  {
    "function_name": "layout_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "330-335",
    "snippet": "static inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic inline u64\nlayout_end(struct nfsd4_layout_seg *seg)\n{\n\tu64 end = seg->offset + seg->length;\n\treturn end >= seg->offset ? end : NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "nfsd4_recall_file_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "309-328",
    "snippet": "static void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_run_cb",
          "args": [
            "&ls->ls_recall"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_run_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1147-1150",
          "snippet": "void nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ls->ls_stid.sc_count"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layout_recall",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ls->ls_layouts"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ls->ls_stid.sc_file->fi_lo_recalls"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic void\nnfsd4_recall_file_layout(struct nfs4_layout_stateid *ls)\n{\n\tspin_lock(&ls->ls_lock);\n\tif (ls->ls_recalled)\n\t\tgoto out_unlock;\n\n\tls->ls_recalled = true;\n\tatomic_inc(&ls->ls_stid.sc_file->fi_lo_recalls);\n\tif (list_empty(&ls->ls_layouts))\n\t\tgoto out_unlock;\n\n\ttrace_layout_recall(&ls->ls_stid.sc_stateid);\n\n\tatomic_inc(&ls->ls_stid.sc_count);\n\tnfsd4_run_cb(&ls->ls_recall);\n\nout_unlock:\n\tspin_unlock(&ls->ls_lock);\n}"
  },
  {
    "function_name": "nfsd4_preprocess_layout_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "255-307",
    "snippet": "__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t\tmutex_lock(&ls->ls_mutex);\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tmutex_lock(&ls->ls_mutex);\n\t\tif (nfsd4_stateid_generation_after(stateid, &stid->sc_stateid))\n\t\t\tgoto out_unlock_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_unlock_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_unlock_stid:\n\tmutex_unlock(&ls->ls_mutex);\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "stid"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_mutex"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_stateid_generation_after",
          "args": [
            "stateid",
            "&stid->sc_stateid"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_stateid_generation_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "577-580",
          "snippet": "static inline bool nfsd4_stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline bool nfsd4_stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_mutex"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "stid",
            "structnfs4_layout_stateid",
            "ls_stid"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_mutex"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_alloc_layout_stateid",
          "args": [
            "cstate",
            "stid",
            "layout_type"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_alloc_layout_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "203-253",
          "snippet": "static struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tmutex_init(&ls->ls_mutex);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tfput(ls->ls_file);\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *nfs4_layout_stateid_cache;",
            "static const struct nfsd4_callback_ops nfsd4_cb_layout_ops;",
            "static const struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.prepare\t= nfsd4_cb_layout_prepare,\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic const struct nfsd4_callback_ops nfsd4_cb_layout_ops;\nstatic const struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.prepare\t= nfsd4_cb_layout_prepare,\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};\n\nstatic struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tmutex_init(&ls->ls_mutex);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tfput(ls->ls_file);\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_match",
          "args": [
            "&cstate->current_fh.fh_handle",
            "&stid->sc_file->fi_fhandle"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "fh_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "191-198",
          "snippet": "static inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "typemask",
            "&stid",
            "net_generic(SVC_NET(rqstp), nfsd_net_id)"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4743-4764",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n__be32\nnfsd4_preprocess_layout_stateid(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, stateid_t *stateid,\n\t\tbool create, u32 layout_type, struct nfs4_layout_stateid **lsp)\n{\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stid;\n\tunsigned char typemask = NFS4_LAYOUT_STID;\n\t__be32 status;\n\n\tif (create)\n\t\ttypemask |= (NFS4_OPEN_STID | NFS4_LOCK_STID | NFS4_DELEG_STID);\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &stid,\n\t\t\tnet_generic(SVC_NET(rqstp), nfsd_net_id));\n\tif (status)\n\t\tgoto out;\n\n\tif (!fh_match(&cstate->current_fh.fh_handle,\n\t\t      &stid->sc_file->fi_fhandle)) {\n\t\tstatus = nfserr_bad_stateid;\n\t\tgoto out_put_stid;\n\t}\n\n\tif (stid->sc_type != NFS4_LAYOUT_STID) {\n\t\tls = nfsd4_alloc_layout_stateid(cstate, stid, layout_type);\n\t\tnfs4_put_stid(stid);\n\n\t\tstatus = nfserr_jukebox;\n\t\tif (!ls)\n\t\t\tgoto out;\n\t\tmutex_lock(&ls->ls_mutex);\n\t} else {\n\t\tls = container_of(stid, struct nfs4_layout_stateid, ls_stid);\n\n\t\tstatus = nfserr_bad_stateid;\n\t\tmutex_lock(&ls->ls_mutex);\n\t\tif (nfsd4_stateid_generation_after(stateid, &stid->sc_stateid))\n\t\t\tgoto out_unlock_stid;\n\t\tif (layout_type != ls->ls_layout_type)\n\t\t\tgoto out_unlock_stid;\n\t}\n\n\t*lsp = ls;\n\treturn 0;\n\nout_unlock_stid:\n\tmutex_unlock(&ls->ls_mutex);\nout_put_stid:\n\tnfs4_put_stid(stid);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_alloc_layout_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "203-253",
    "snippet": "static struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tmutex_init(&ls->ls_mutex);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tfput(ls->ls_file);\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_stateid_cache;",
      "static const struct nfsd4_callback_ops nfsd4_cb_layout_ops;",
      "static const struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.prepare\t= nfsd4_cb_layout_prepare,\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_layoutstate_alloc",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ls->ls_perfile",
            "&fp->fi_lo_states"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ls->ls_perclnt",
            "&clp->cl_lo_states"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_stateid_cache",
            "ls"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "277-289",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "ls->ls_file"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_layout_setlease",
          "args": [
            "ls"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_layout_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "176-201",
          "snippet": "static int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd4_layouts_lm_ops;",
            "static const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops;\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};\n\nstatic int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ls->ls_file"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "fp"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "348-362",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "fp->fi_deleg_file"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_init_cb",
          "args": [
            "&ls->ls_recall",
            "clp",
            "&nfsd4_cb_layout_ops",
            "NFSPROC4_CLNT_CB_LAYOUT"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1133-1145",
          "snippet": "void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tcb->cb_need_restart = false;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tcb->cb_need_restart = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ls->ls_mutex"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_layouts"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_lock"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_perfile"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ls->ls_perclnt"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutstateid",
          "args": [
            "stp"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "layoutstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "560-563",
          "snippet": "static inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "619-622",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "cstate->clp",
            "nfs4_layout_stateid_cache"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "556-593",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\nstatic const struct nfsd4_callback_ops nfsd4_cb_layout_ops;\nstatic const struct nfsd4_callback_ops nfsd4_cb_layout_ops = {\n\t.prepare\t= nfsd4_cb_layout_prepare,\n\t.done\t\t= nfsd4_cb_layout_done,\n\t.release\t= nfsd4_cb_layout_release,\n};\n\nstatic struct nfs4_layout_stateid *\nnfsd4_alloc_layout_stateid(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stid *parent, u32 layout_type)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_file *fp = parent->sc_file;\n\tstruct nfs4_layout_stateid *ls;\n\tstruct nfs4_stid *stp;\n\n\tstp = nfs4_alloc_stid(cstate->clp, nfs4_layout_stateid_cache);\n\tif (!stp)\n\t\treturn NULL;\n\tstp->sc_free = nfsd4_free_layout_stateid;\n\tget_nfs4_file(fp);\n\tstp->sc_file = fp;\n\n\tls = layoutstateid(stp);\n\tINIT_LIST_HEAD(&ls->ls_perclnt);\n\tINIT_LIST_HEAD(&ls->ls_perfile);\n\tspin_lock_init(&ls->ls_lock);\n\tINIT_LIST_HEAD(&ls->ls_layouts);\n\tmutex_init(&ls->ls_mutex);\n\tls->ls_layout_type = layout_type;\n\tnfsd4_init_cb(&ls->ls_recall, clp, &nfsd4_cb_layout_ops,\n\t\t\tNFSPROC4_CLNT_CB_LAYOUT);\n\n\tif (parent->sc_type == NFS4_DELEG_STID)\n\t\tls->ls_file = get_file(fp->fi_deleg_file);\n\telse\n\t\tls->ls_file = find_any_file(fp);\n\tBUG_ON(!ls->ls_file);\n\n\tif (nfsd4_layout_setlease(ls)) {\n\t\tfput(ls->ls_file);\n\t\tput_nfs4_file(fp);\n\t\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n\t\treturn NULL;\n\t}\n\n\tspin_lock(&clp->cl_lock);\n\tstp->sc_type = NFS4_LAYOUT_STID;\n\tlist_add(&ls->ls_perclnt, &clp->cl_lo_states);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&ls->ls_perfile, &fp->fi_lo_states);\n\tspin_unlock(&fp->fi_lock);\n\n\ttrace_layoutstate_alloc(&ls->ls_stid.sc_stateid);\n\treturn ls;\n}"
  },
  {
    "function_name": "nfsd4_layout_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "176-201",
    "snippet": "static int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd4_layouts_lm_ops;",
      "static const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fl != NULL"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "fl->fl_file",
            "fl->fl_type",
            "&fl",
            "NULL"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_init_lock",
          "args": [
            "fl"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops;\nstatic const struct lock_manager_operations nfsd4_layouts_lm_ops = {\n\t.lm_break\t= nfsd4_layout_lm_break,\n\t.lm_change\t= nfsd4_layout_lm_change,\n};\n\nstatic int\nnfsd4_layout_setlease(struct nfs4_layout_stateid *ls)\n{\n\tstruct file_lock *fl;\n\tint status;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tlocks_init_lock(fl);\n\tfl->fl_lmops = &nfsd4_layouts_lm_ops;\n\tfl->fl_flags = FL_LAYOUT;\n\tfl->fl_type = F_RDLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = ls;\n\tfl->fl_pid = current->tgid;\n\tfl->fl_file = ls->ls_file;\n\n\tstatus = vfs_setlease(fl->fl_file, fl->fl_type, &fl, NULL);\n\tif (status) {\n\t\tlocks_free_lock(fl);\n\t\treturn status;\n\t}\n\tBUG_ON(fl != NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_free_layout_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "150-174",
    "snippet": "static void\nnfsd4_free_layout_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_layout_stateid *ls = layoutstateid(stid);\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\n\ttrace_layoutstate_free(&ls->ls_stid.sc_stateid);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_del_init(&ls->ls_perclnt);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&ls->ls_perfile);\n\tspin_unlock(&fp->fi_lock);\n\n\tvfs_setlease(ls->ls_file, F_UNLCK, NULL, (void **)&ls);\n\tfput(ls->ls_file);\n\n\tif (ls->ls_recalled)\n\t\tatomic_dec(&ls->ls_stid.sc_file->fi_lo_recalls);\n\n\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *nfs4_layout_stateid_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "nfs4_layout_stateid_cache",
            "ls"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ls->ls_stid.sc_file->fi_lo_recalls"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "ls->ls_file"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "ls->ls_file",
            "F_UNLCK",
            "NULL",
            "(void **)&ls"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ls->ls_perfile"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ls->ls_perclnt"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_layoutstate_free",
          "args": [
            "&ls->ls_stid.sc_stateid"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "layoutstateid",
          "args": [
            "stid"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "layoutstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "560-563",
          "snippet": "static inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_layout_stateid *layoutstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_layout_stateid, ls_stid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct kmem_cache *nfs4_layout_stateid_cache;\n\nstatic void\nnfsd4_free_layout_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_layout_stateid *ls = layoutstateid(stid);\n\tstruct nfs4_client *clp = ls->ls_stid.sc_client;\n\tstruct nfs4_file *fp = ls->ls_stid.sc_file;\n\n\ttrace_layoutstate_free(&ls->ls_stid.sc_stateid);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_del_init(&ls->ls_perclnt);\n\tspin_unlock(&clp->cl_lock);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&ls->ls_perfile);\n\tspin_unlock(&fp->fi_lock);\n\n\tvfs_setlease(ls->ls_file, F_UNLCK, NULL, (void **)&ls);\n\tfput(ls->ls_file);\n\n\tif (ls->ls_recalled)\n\t\tatomic_dec(&ls->ls_stid.sc_file->fi_lo_recalls);\n\n\tkmem_cache_free(nfs4_layout_stateid_cache, ls);\n}"
  },
  {
    "function_name": "nfsd4_setup_layout_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "123-148",
    "snippet": "void nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (!(exp->ex_flags & NFSEXP_PNFS))\n\t\treturn;\n\n\t/*\n\t * Check if the file system supports exporting a block-like layout.\n\t * If the block device supports reservations prefer the SCSI layout,\n\t * otherwise advertise the block layout.\n\t */\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\t/* overwrite block layout selection if needed */\n\tif (sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks &&\n\t    sb->s_bdev && sb->s_bdev->bd_disk->fops->pr_ops)\n\t\texp->ex_layout_type = LAYOUT_SCSI;\n#endif\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nvoid nfsd4_setup_layout_type(struct svc_export *exp)\n{\n\tstruct super_block *sb = exp->ex_path.mnt->mnt_sb;\n\n\tif (!(exp->ex_flags & NFSEXP_PNFS))\n\t\treturn;\n\n\t/*\n\t * Check if the file system supports exporting a block-like layout.\n\t * If the block device supports reservations prefer the SCSI layout,\n\t * otherwise advertise the block layout.\n\t */\n#ifdef CONFIG_NFSD_BLOCKLAYOUT\n\tif (sb->s_export_op->get_uuid &&\n\t    sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks)\n\t\texp->ex_layout_type = LAYOUT_BLOCK_VOLUME;\n#endif\n#ifdef CONFIG_NFSD_SCSILAYOUT\n\t/* overwrite block layout selection if needed */\n\tif (sb->s_export_op->map_blocks &&\n\t    sb->s_export_op->commit_blocks &&\n\t    sb->s_bdev && sb->s_bdev->bd_disk->fops->pr_ops)\n\t\texp->ex_layout_type = LAYOUT_SCSI;\n#endif\n}"
  },
  {
    "function_name": "nfsd4_set_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "107-121",
    "snippet": "int\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_alloc_devid_map",
          "args": [
            "fhp"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_alloc_devid_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "51-91",
          "snippet": "static void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
          ],
          "globals_used": [
            "static u64 nfsd_devid_seq = 1;",
            "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];",
            "static DEFINE_SPINLOCK(nfsd_devid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic u64 nfsd_devid_seq = 1;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfsd_devid_lock);\n\nstatic void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nint\nnfsd4_set_deviceid(struct nfsd4_deviceid *id, const struct svc_fh *fhp,\n\t\tu32 device_generation)\n{\n\tif (!fhp->fh_export->ex_devid_map) {\n\t\tnfsd4_alloc_devid_map(fhp);\n\t\tif (!fhp->fh_export->ex_devid_map)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tid->fsid_idx = fhp->fh_export->ex_devid_map->idx;\n\tid->generation = device_generation;\n\tid->pad = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_find_devid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "93-105",
    "snippet": "struct nfsd4_deviceid_map *\nnfsd4_find_devid_map(int idx)\n{\n\tstruct nfsd4_deviceid_map *map, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\n\t\tif (map->idx == idx)\n\t\t\tret = map;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "map",
            "&nfsd_devid_hash[devid_hashfn(idx)]",
            "hash"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devid_hashfn",
          "args": [
            "idx"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "devid_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "46-49",
          "snippet": "static inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)\n\nstatic inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\n\nstruct nfsd4_deviceid_map *\nnfsd4_find_devid_map(int idx)\n{\n\tstruct nfsd4_deviceid_map *map, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(map, &nfsd_devid_hash[devid_hashfn(idx)], hash)\n\t\tif (map->idx == idx)\n\t\t\tret = map;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_alloc_devid_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "51-91",
    "snippet": "static void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)"
    ],
    "globals_used": [
      "static u64 nfsd_devid_seq = 1;",
      "static struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];",
      "static DEFINE_SPINLOCK(nfsd_devid_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "map"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfsd_devid_lock"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&map->hash",
            "&nfsd_devid_hash[devid_hashfn(map->idx)]"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devid_hashfn",
          "args": [
            "map->idx"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "devid_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "46-49",
          "snippet": "static inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [
            "#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)\n\nstatic inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "old->fsid",
            "fh->fh_fsid",
            "key_len(old->fsid_type)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "old->fsid_type"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "old",
            "&nfsd_devid_hash[i]",
            "hash"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfsd_devid_lock"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&map->fsid",
            "fh->fh_fsid",
            "fsid_len"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*map) + fsid_len",
            "GFP_KERNEL"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_SIZE\t(1 << DEVID_HASH_BITS)\n\nstatic u64 nfsd_devid_seq = 1;\nstatic struct list_head nfsd_devid_hash[DEVID_HASH_SIZE];\nstatic DEFINE_SPINLOCK(nfsd_devid_lock);\n\nstatic void\nnfsd4_alloc_devid_map(const struct svc_fh *fhp)\n{\n\tconst struct knfsd_fh *fh = &fhp->fh_handle;\n\tsize_t fsid_len = key_len(fh->fh_fsid_type);\n\tstruct nfsd4_deviceid_map *map, *old;\n\tint i;\n\n\tmap = kzalloc(sizeof(*map) + fsid_len, GFP_KERNEL);\n\tif (!map)\n\t\treturn;\n\n\tmap->fsid_type = fh->fh_fsid_type;\n\tmemcpy(&map->fsid, fh->fh_fsid, fsid_len);\n\n\tspin_lock(&nfsd_devid_lock);\n\tif (fhp->fh_export->ex_devid_map)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < DEVID_HASH_SIZE; i++) {\n\t\tlist_for_each_entry(old, &nfsd_devid_hash[i], hash) {\n\t\t\tif (old->fsid_type != fh->fh_fsid_type)\n\t\t\t\tcontinue;\n\t\t\tif (memcmp(old->fsid, fh->fh_fsid,\n\t\t\t\t\tkey_len(old->fsid_type)))\n\t\t\t\tcontinue;\n\n\t\t\tfhp->fh_export->ex_devid_map = old;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tmap->idx = nfsd_devid_seq++;\n\tlist_add_tail_rcu(&map->hash, &nfsd_devid_hash[devid_hashfn(map->idx)]);\n\tfhp->fh_export->ex_devid_map = map;\n\tmap = NULL;\n\nout_unlock:\n\tspin_unlock(&nfsd_devid_lock);\n\tkfree(map);\n}"
  },
  {
    "function_name": "devid_hashfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
    "lines": "46-49",
    "snippet": "static inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"netns.h\"",
      "#include \"pnfs.h\"",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sched.h>",
      "#include <linux/jhash.h>",
      "#include <linux/file.h>",
      "#include <linux/kmod.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [
      "#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash_2words",
          "args": [
            "idx",
            "idx >> 32",
            "0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\n#define DEVID_HASH_MASK\t(DEVID_HASH_SIZE - 1)\n\nstatic inline u32 devid_hashfn(u64 idx)\n{\n\treturn jhash_2words(idx, idx >> 32, 0) & DEVID_HASH_MASK;\n}"
  }
]