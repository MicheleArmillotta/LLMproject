[
  {
    "function_name": "nfserrno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "756-806",
    "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"nfsd: non-standard errno: %d\\n\"",
            "errno"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "nfs_errtbl"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
  },
  {
    "function_name": "nfsd_proc_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "551-563",
    "snippet": "static __be32\nnfsd_proc_statfs(struct svc_rqst * rqstp, struct nfsd_fhandle   *argp,\n\t\t\t\t\t  struct nfsd_statfsres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: STATFS   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tnfserr = nfsd_statfs(rqstp, &argp->fh, &resp->stats,\n\t\t\tNFSD_MAY_BYPASS_GSS_ON_ROOT);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_statfs",
          "args": [
            "rqstp",
            "&argp->fh",
            "&resp->stats",
            "NFSD_MAY_BYPASS_GSS_ON_ROOT"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1927-1942",
          "snippet": "__be32\nnfsd_statfs(struct svc_rqst *rqstp, struct svc_fh *fhp, struct kstatfs *stat, int access)\n{\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP | access);\n\tif (!err) {\n\t\tstruct path path = {\n\t\t\t.mnt\t= fhp->fh_export->ex_path.mnt,\n\t\t\t.dentry\t= fhp->fh_dentry,\n\t\t};\n\t\tif (vfs_statfs(&path, stat))\n\t\t\terr = nfserr_io;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_statfs(struct svc_rqst *rqstp, struct svc_fh *fhp, struct kstatfs *stat, int access)\n{\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP | access);\n\tif (!err) {\n\t\tstruct path path = {\n\t\t\t.mnt\t= fhp->fh_export->ex_path.mnt,\n\t\t\t.dentry\t= fhp->fh_dentry,\n\t\t};\n\t\tif (vfs_statfs(&path, stat))\n\t\t\terr = nfserr_io;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: STATFS   %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_statfs(struct svc_rqst * rqstp, struct nfsd_fhandle   *argp,\n\t\t\t\t\t  struct nfsd_statfsres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: STATFS   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tnfserr = nfsd_statfs(rqstp, &argp->fh, &resp->stats,\n\t\t\tNFSD_MAY_BYPASS_GSS_ON_ROOT);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "511-546",
    "snippet": "static __be32\nnfsd_proc_readdir(struct svc_rqst *rqstp, struct nfsd_readdirargs *argp,\n\t\t\t\t\t  struct nfsd_readdirres  *resp)\n{\n\tint\t\tcount;\n\t__be32\t\tnfserr;\n\tloff_t\t\toffset;\n\n\tdprintk(\"nfsd: READDIR  %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\t\t\n\t\targp->count, argp->cookie);\n\n\t/* Shrink to the client read size */\n\tcount = (argp->count >> 2) - 2;\n\n\t/* Make sure we've room for the NULL ptr & eof flag */\n\tcount -= 2;\n\tif (count < 0)\n\t\tcount = 0;\n\n\tresp->buffer = argp->buffer;\n\tresp->offset = NULL;\n\tresp->buflen = count;\n\tresp->common.err = nfs_ok;\n\t/* Read directory and encode entries on the fly */\n\toffset = argp->cookie;\n\tnfserr = nfsd_readdir(rqstp, &argp->fh, &offset, \n\t\t\t      &resp->common, nfssvc_encode_entry);\n\n\tresp->count = resp->buffer - argp->buffer;\n\tif (resp->offset)\n\t\t*resp->offset = htonl(offset);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "offset"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_readdir",
          "args": [
            "rqstp",
            "&argp->fh",
            "&offset",
            "&resp->common",
            "nfssvc_encode_entry"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1890-1921",
          "snippet": "__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tfput(file);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readdir(struct svc_rqst *rqstp, struct svc_fh *fhp, loff_t *offsetp, \n\t     struct readdir_cd *cdp, nfsd_filldir_t func)\n{\n\t__be32\t\terr;\n\tstruct file\t*file;\n\tloff_t\t\toffset = *offsetp;\n\tint             may_flags = NFSD_MAY_READ;\n\n\t/* NFSv2 only supports 32 bit cookies */\n\tif (rqstp->rq_vers > 2)\n\t\tmay_flags |= NFSD_MAY_64BIT_COOKIE;\n\n\terr = nfsd_open(rqstp, fhp, S_IFDIR, may_flags, &file);\n\tif (err)\n\t\tgoto out;\n\n\toffset = vfs_llseek(file, offset, SEEK_SET);\n\tif (offset < 0) {\n\t\terr = nfserrno((int)offset);\n\t\tgoto out_close;\n\t}\n\n\terr = nfsd_buffered_readdir(file, func, cdp, offsetp);\n\n\tif (err == nfserr_eof || err == nfserr_toosmall)\n\t\terr = nfs_ok; /* can still be found in ->err */\nout_close:\n\tfput(file);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: READDIR  %s %d bytes at %d\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->count",
            "argp->cookie"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_readdir(struct svc_rqst *rqstp, struct nfsd_readdirargs *argp,\n\t\t\t\t\t  struct nfsd_readdirres  *resp)\n{\n\tint\t\tcount;\n\t__be32\t\tnfserr;\n\tloff_t\t\toffset;\n\n\tdprintk(\"nfsd: READDIR  %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\t\t\n\t\targp->count, argp->cookie);\n\n\t/* Shrink to the client read size */\n\tcount = (argp->count >> 2) - 2;\n\n\t/* Make sure we've room for the NULL ptr & eof flag */\n\tcount -= 2;\n\tif (count < 0)\n\t\tcount = 0;\n\n\tresp->buffer = argp->buffer;\n\tresp->offset = NULL;\n\tresp->buflen = count;\n\tresp->common.err = nfs_ok;\n\t/* Read directory and encode entries on the fly */\n\toffset = argp->cookie;\n\tnfserr = nfsd_readdir(rqstp, &argp->fh, &offset, \n\t\t\t      &resp->common, nfssvc_encode_entry);\n\n\tresp->count = resp->buffer - argp->buffer;\n\tif (resp->offset)\n\t\t*resp->offset = htonl(offset);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "495-506",
    "snippet": "static __be32\nnfsd_proc_rmdir(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t \tvoid\t\t      *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RMDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_unlink",
          "args": [
            "rqstp",
            "&argp->fh",
            "S_IFDIR",
            "argp->name",
            "argp->len"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1720-1770",
          "snippet": "__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (d_really_is_negative(rdentry)) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = d_inode(rdentry)->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (d_really_is_negative(rdentry)) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = d_inode(rdentry)->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: RMDIR    %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_rmdir(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t \tvoid\t\t      *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RMDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "471-490",
    "snippet": "static __be32\nnfsd_proc_mkdir(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\tstruct nfsd_diropres   *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: MKDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tif (resp->fh.fh_dentry) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"nfsd_proc_mkdir: response already verified??\\n\");\n\t}\n\n\targp->attrs.ia_valid &= ~ATTR_SIZE;\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t    &argp->attrs, S_IFDIR, 0, &resp->fh);\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_dirop",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_dirop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "31-36",
          "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_create",
          "args": [
            "rqstp",
            "&argp->fh",
            "argp->name",
            "argp->len",
            "&argp->attrs",
            "S_IFDIR",
            "0",
            "&resp->fh"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1146-1273",
          "snippet": "__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (d_really_is_positive(dchild)) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (d_really_is_positive(dchild)) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&resp->fh",
            "NFS_FHSIZE"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\"nfsd_proc_mkdir: response already verified??\\n\""
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: MKDIR    %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_mkdir(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\tstruct nfsd_diropres   *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: MKDIR    %s %.*s\\n\", SVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tif (resp->fh.fh_dentry) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"nfsd_proc_mkdir: response already verified??\\n\");\n\t}\n\n\targp->attrs.ia_valid &= ~ATTR_SIZE;\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_create(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t    &argp->attrs, S_IFDIR, 0, &resp->fh);\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "441-465",
    "snippet": "static __be32\nnfsd_proc_symlink(struct svc_rqst *rqstp, struct nfsd_symlinkargs *argp,\n\t\t\t\t          void\t\t\t  *resp)\n{\n\tstruct svc_fh\tnewfh;\n\t__be32\t\tnfserr;\n\n\tdprintk(\"nfsd: SYMLINK  %s %.*s -> %.*s\\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname,\n\t\targp->tlen, argp->tname);\n\n\tfh_init(&newfh, NFS_FHSIZE);\n\t/*\n\t * Crazy hack: the request fits in a page, and already-decoded\n\t * attributes follow argp->tname, so it's safe to just write a\n\t * null to ensure it's null-terminated:\n\t */\n\targp->tname[argp->tlen] = '\\0';\n\tnfserr = nfsd_symlink(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t\t\t argp->tname, &newfh);\n\n\tfh_put(&argp->ffh);\n\tfh_put(&newfh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&newfh"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_symlink",
          "args": [
            "rqstp",
            "&argp->ffh",
            "argp->fname",
            "argp->flen",
            "argp->tname",
            "&newfh"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1496-1545",
          "snippet": "__be32\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tchar *fname, int flen,\n\t\t\t\tchar *path,\n\t\t\t\tstruct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dnew;\n\t__be32\t\terr, cerr;\n\tint\t\thost_err;\n\n\terr = nfserr_noent;\n\tif (!flen || path[0] == '\\0')\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\tdentry = fhp->fh_dentry;\n\tdnew = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\thost_err = vfs_symlink(d_inode(dentry), dnew, path);\n\terr = nfserrno(host_err);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\tfh_unlock(fhp);\n\n\tfh_drop_write(fhp);\n\n\tcerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\n\tdput(dnew);\n\tif (err==0) err = cerr;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_symlink(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\t\t\tchar *fname, int flen,\n\t\t\t\tchar *path,\n\t\t\t\tstruct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dnew;\n\t__be32\t\terr, cerr;\n\tint\t\thost_err;\n\n\terr = nfserr_noent;\n\tif (!flen || path[0] == '\\0')\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\tdentry = fhp->fh_dentry;\n\tdnew = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\thost_err = vfs_symlink(d_inode(dentry), dnew, path);\n\terr = nfserrno(host_err);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\tfh_unlock(fhp);\n\n\tfh_drop_write(fhp);\n\n\tcerr = fh_compose(resfhp, fhp->fh_export, dnew, fhp);\n\tdput(dnew);\n\tif (err==0) err = cerr;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&newfh",
            "NFS_FHSIZE"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: SYMLINK  %s %.*s -> %.*s\\n\"",
            "SVCFH_fmt(&argp->ffh)",
            "argp->flen",
            "argp->fname",
            "argp->tlen",
            "argp->tname"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->ffh"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_symlink(struct svc_rqst *rqstp, struct nfsd_symlinkargs *argp,\n\t\t\t\t          void\t\t\t  *resp)\n{\n\tstruct svc_fh\tnewfh;\n\t__be32\t\tnfserr;\n\n\tdprintk(\"nfsd: SYMLINK  %s %.*s -> %.*s\\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname,\n\t\targp->tlen, argp->tname);\n\n\tfh_init(&newfh, NFS_FHSIZE);\n\t/*\n\t * Crazy hack: the request fits in a page, and already-decoded\n\t * attributes follow argp->tname, so it's safe to just write a\n\t * null to ensure it's null-terminated:\n\t */\n\targp->tname[argp->tlen] = '\\0';\n\tnfserr = nfsd_symlink(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t\t\t argp->tname, &newfh);\n\n\tfh_put(&argp->ffh);\n\tfh_put(&newfh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "421-439",
    "snippet": "static __be32\nnfsd_proc_link(struct svc_rqst *rqstp, struct nfsd_linkargs *argp,\n\t\t\t\tvoid\t\t\t    *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LINK     %s ->\\n\",\n\t\tSVCFH_fmt(&argp->ffh));\n\tdprintk(\"nfsd:    %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh),\n\t\targp->tlen,\n\t\targp->tname);\n\n\tnfserr = nfsd_link(rqstp, &argp->tfh, argp->tname, argp->tlen,\n\t\t\t\t  &argp->ffh);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->tfh"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_link",
          "args": [
            "rqstp",
            "&argp->tfh",
            "argp->tname",
            "argp->tlen",
            "&argp->ffh"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1551-1618",
          "snippet": "__be32\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\n\t\t\t\tchar *name, int len, struct svc_fh *tfhp)\n{\n\tstruct dentry\t*ddir, *dnew, *dold;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\terr = nfserr_isdir;\n\tif (d_is_dir(tfhp->fh_dentry))\n\t\tgoto out;\n\terr = nfserr_perm;\n\tif (!len)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(name, len))\n\t\tgoto out;\n\n\thost_err = fh_want_write(tfhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tfh_lock_nested(ffhp, I_MUTEX_PARENT);\n\tddir = ffhp->fh_dentry;\n\tdirp = d_inode(ddir);\n\n\tdnew = lookup_one_len(name, ddir, len);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\tdold = tfhp->fh_dentry;\n\n\terr = nfserr_noent;\n\tif (d_really_is_negative(dold))\n\t\tgoto out_dput;\n\thost_err = vfs_link(dold, dirp, dnew, NULL);\n\tif (!host_err) {\n\t\terr = nfserrno(commit_metadata(ffhp));\n\t\tif (!err)\n\t\t\terr = nfserrno(commit_metadata(tfhp));\n\t} else {\n\t\tif (host_err == -EXDEV && rqstp->rq_vers == 2)\n\t\t\terr = nfserr_acces;\n\t\telse\n\t\t\terr = nfserrno(host_err);\n\t}\nout_dput:\n\tdput(dnew);\nout_unlock:\n\tfh_unlock(ffhp);\n\tfh_drop_write(tfhp);\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_link(struct svc_rqst *rqstp, struct svc_fh *ffhp,\n\t\t\t\tchar *name, int len, struct svc_fh *tfhp)\n{\n\tstruct dentry\t*ddir, *dnew, *dold;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, 0, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\terr = nfserr_isdir;\n\tif (d_is_dir(tfhp->fh_dentry))\n\t\tgoto out;\n\terr = nfserr_perm;\n\tif (!len)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(name, len))\n\t\tgoto out;\n\n\thost_err = fh_want_write(tfhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\tfh_lock_nested(ffhp, I_MUTEX_PARENT);\n\tddir = ffhp->fh_dentry;\n\tdirp = d_inode(ddir);\n\n\tdnew = lookup_one_len(name, ddir, len);\n\thost_err = PTR_ERR(dnew);\n\tif (IS_ERR(dnew))\n\t\tgoto out_nfserr;\n\n\tdold = tfhp->fh_dentry;\n\n\terr = nfserr_noent;\n\tif (d_really_is_negative(dold))\n\t\tgoto out_dput;\n\thost_err = vfs_link(dold, dirp, dnew, NULL);\n\tif (!host_err) {\n\t\terr = nfserrno(commit_metadata(ffhp));\n\t\tif (!err)\n\t\t\terr = nfserrno(commit_metadata(tfhp));\n\t} else {\n\t\tif (host_err == -EXDEV && rqstp->rq_vers == 2)\n\t\t\terr = nfserr_acces;\n\t\telse\n\t\t\terr = nfserrno(host_err);\n\t}\nout_dput:\n\tdput(dnew);\nout_unlock:\n\tfh_unlock(ffhp);\n\tfh_drop_write(tfhp);\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd:    %s %.*s\\n\"",
            "SVCFH_fmt(&argp->tfh)",
            "argp->tlen",
            "argp->tname"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->tfh"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: LINK     %s ->\\n\"",
            "SVCFH_fmt(&argp->ffh)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_link(struct svc_rqst *rqstp, struct nfsd_linkargs *argp,\n\t\t\t\tvoid\t\t\t    *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LINK     %s ->\\n\",\n\t\tSVCFH_fmt(&argp->ffh));\n\tdprintk(\"nfsd:    %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh),\n\t\targp->tlen,\n\t\targp->tname);\n\n\tnfserr = nfsd_link(rqstp, &argp->tfh, argp->tname, argp->tlen,\n\t\t\t\t  &argp->ffh);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "403-419",
    "snippet": "static __be32\nnfsd_proc_rename(struct svc_rqst *rqstp, struct nfsd_renameargs *argp,\n\t\t\t\t  \t void\t\t        *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RENAME   %s %.*s -> \\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname);\n\tdprintk(\"nfsd:        ->  %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh), argp->tlen, argp->tname);\n\n\tnfserr = nfsd_rename(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t    &argp->tfh, argp->tname, argp->tlen);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->tfh"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_rename",
          "args": [
            "rqstp",
            "&argp->ffh",
            "argp->fname",
            "argp->flen",
            "&argp->tfh",
            "argp->tname",
            "argp->tlen"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1624-1714",
          "snippet": "__be32\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\n\t\t\t    struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry, *trap;\n\tstruct inode\t*fdir, *tdir;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tfdentry = ffhp->fh_dentry;\n\tfdir = d_inode(fdentry);\n\n\ttdentry = tfhp->fh_dentry;\n\ttdir = d_inode(tdentry);\n\n\terr = nfserr_perm;\n\tif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\n\t\tgoto out;\n\n\thost_err = fh_want_write(ffhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\t/* cannot use fh_lock as we need deadlock protective ordering\n\t * so do it by hand */\n\ttrap = lock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = true;\n\tfill_pre_wcc(ffhp);\n\tfill_pre_wcc(tfhp);\n\n\todentry = lookup_one_len(fname, fdentry, flen);\n\thost_err = PTR_ERR(odentry);\n\tif (IS_ERR(odentry))\n\t\tgoto out_nfserr;\n\n\thost_err = -ENOENT;\n\tif (d_really_is_negative(odentry))\n\t\tgoto out_dput_old;\n\thost_err = -EINVAL;\n\tif (odentry == trap)\n\t\tgoto out_dput_old;\n\n\tndentry = lookup_one_len(tname, tdentry, tlen);\n\thost_err = PTR_ERR(ndentry);\n\tif (IS_ERR(ndentry))\n\t\tgoto out_dput_old;\n\thost_err = -ENOTEMPTY;\n\tif (ndentry == trap)\n\t\tgoto out_dput_new;\n\n\thost_err = -EXDEV;\n\tif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\n\t\tgoto out_dput_new;\n\tif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\n\t\tgoto out_dput_new;\n\n\thost_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);\n\tif (!host_err) {\n\t\thost_err = commit_metadata(tfhp);\n\t\tif (!host_err)\n\t\t\thost_err = commit_metadata(ffhp);\n\t}\n out_dput_new:\n\tdput(ndentry);\n out_dput_old:\n\tdput(odentry);\n out_nfserr:\n\terr = nfserrno(host_err);\n\t/*\n\t * We cannot rely on fh_unlock on the two filehandles,\n\t * as that would do the wrong thing if the two directories\n\t * were the same, so again we do it by hand.\n\t */\n\tfill_post_wcc(ffhp);\n\tfill_post_wcc(tfhp);\n\tunlock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = false;\n\tfh_drop_write(ffhp);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,\n\t\t\t    struct svc_fh *tfhp, char *tname, int tlen)\n{\n\tstruct dentry\t*fdentry, *tdentry, *odentry, *ndentry, *trap;\n\tstruct inode\t*fdir, *tdir;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = fh_verify(rqstp, ffhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\terr = fh_verify(rqstp, tfhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tfdentry = ffhp->fh_dentry;\n\tfdir = d_inode(fdentry);\n\n\ttdentry = tfhp->fh_dentry;\n\ttdir = d_inode(tdentry);\n\n\terr = nfserr_perm;\n\tif (!flen || isdotent(fname, flen) || !tlen || isdotent(tname, tlen))\n\t\tgoto out;\n\n\thost_err = fh_want_write(ffhp);\n\tif (host_err) {\n\t\terr = nfserrno(host_err);\n\t\tgoto out;\n\t}\n\n\t/* cannot use fh_lock as we need deadlock protective ordering\n\t * so do it by hand */\n\ttrap = lock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = true;\n\tfill_pre_wcc(ffhp);\n\tfill_pre_wcc(tfhp);\n\n\todentry = lookup_one_len(fname, fdentry, flen);\n\thost_err = PTR_ERR(odentry);\n\tif (IS_ERR(odentry))\n\t\tgoto out_nfserr;\n\n\thost_err = -ENOENT;\n\tif (d_really_is_negative(odentry))\n\t\tgoto out_dput_old;\n\thost_err = -EINVAL;\n\tif (odentry == trap)\n\t\tgoto out_dput_old;\n\n\tndentry = lookup_one_len(tname, tdentry, tlen);\n\thost_err = PTR_ERR(ndentry);\n\tif (IS_ERR(ndentry))\n\t\tgoto out_dput_old;\n\thost_err = -ENOTEMPTY;\n\tif (ndentry == trap)\n\t\tgoto out_dput_new;\n\n\thost_err = -EXDEV;\n\tif (ffhp->fh_export->ex_path.mnt != tfhp->fh_export->ex_path.mnt)\n\t\tgoto out_dput_new;\n\tif (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)\n\t\tgoto out_dput_new;\n\n\thost_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);\n\tif (!host_err) {\n\t\thost_err = commit_metadata(tfhp);\n\t\tif (!host_err)\n\t\t\thost_err = commit_metadata(ffhp);\n\t}\n out_dput_new:\n\tdput(ndentry);\n out_dput_old:\n\tdput(odentry);\n out_nfserr:\n\terr = nfserrno(host_err);\n\t/*\n\t * We cannot rely on fh_unlock on the two filehandles,\n\t * as that would do the wrong thing if the two directories\n\t * were the same, so again we do it by hand.\n\t */\n\tfill_post_wcc(ffhp);\n\tfill_post_wcc(tfhp);\n\tunlock_rename(tdentry, fdentry);\n\tffhp->fh_locked = tfhp->fh_locked = false;\n\tfh_drop_write(ffhp);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd:        ->  %s %.*s\\n\"",
            "SVCFH_fmt(&argp->tfh)",
            "argp->tlen",
            "argp->tname"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->tfh"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: RENAME   %s %.*s -> \\n\"",
            "SVCFH_fmt(&argp->ffh)",
            "argp->flen",
            "argp->fname"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_rename(struct svc_rqst *rqstp, struct nfsd_renameargs *argp,\n\t\t\t\t  \t void\t\t        *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: RENAME   %s %.*s -> \\n\",\n\t\tSVCFH_fmt(&argp->ffh), argp->flen, argp->fname);\n\tdprintk(\"nfsd:        ->  %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->tfh), argp->tlen, argp->tname);\n\n\tnfserr = nfsd_rename(rqstp, &argp->ffh, argp->fname, argp->flen,\n\t\t\t\t    &argp->tfh, argp->tname, argp->tlen);\n\tfh_put(&argp->ffh);\n\tfh_put(&argp->tfh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "388-401",
    "snippet": "static __be32\nnfsd_proc_remove(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t void\t\t       *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: REMOVE   %s %.*s\\n\", SVCFH_fmt(&argp->fh),\n\t\targp->len, argp->name);\n\n\t/* Unlink. -SIFDIR means file must not be a directory */\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, -S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_unlink",
          "args": [
            "rqstp",
            "&argp->fh",
            "-S_IFDIR",
            "argp->name",
            "argp->len"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1720-1770",
          "snippet": "__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (d_really_is_negative(rdentry)) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = d_inode(rdentry)->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_unlink(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,\n\t\t\t\tchar *fname, int flen)\n{\n\tstruct dentry\t*dentry, *rdentry;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\n\terr = nfserr_acces;\n\tif (!flen || isdotent(fname, flen))\n\t\tgoto out;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_REMOVE);\n\tif (err)\n\t\tgoto out;\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\trdentry = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(rdentry);\n\tif (IS_ERR(rdentry))\n\t\tgoto out_nfserr;\n\n\tif (d_really_is_negative(rdentry)) {\n\t\tdput(rdentry);\n\t\terr = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tif (!type)\n\t\ttype = d_inode(rdentry)->i_mode & S_IFMT;\n\n\tif (type != S_IFDIR)\n\t\thost_err = vfs_unlink(dirp, rdentry, NULL);\n\telse\n\t\thost_err = vfs_rmdir(dirp, rdentry);\n\tif (!host_err)\n\t\thost_err = commit_metadata(fhp);\n\tdput(rdentry);\n\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: REMOVE   %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_remove(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t void\t\t       *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: REMOVE   %s %.*s\\n\", SVCFH_fmt(&argp->fh),\n\t\targp->len, argp->name);\n\n\t/* Unlink. -SIFDIR means file must not be a directory */\n\tnfserr = nfsd_unlink(rqstp, &argp->fh, -S_IFDIR, argp->name, argp->len);\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "230-386",
    "snippet": "static __be32\nnfsd_proc_create(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\t struct nfsd_diropres   *resp)\n{\n\tsvc_fh\t\t*dirfhp = &argp->fh;\n\tsvc_fh\t\t*newfhp = &resp->fh;\n\tstruct iattr\t*attr = &argp->attrs;\n\tstruct inode\t*inode;\n\tstruct dentry\t*dchild;\n\tint\t\ttype, mode;\n\t__be32\t\tnfserr;\n\tint\t\thosterr;\n\tdev_t\t\trdev = 0, wanted = new_decode_dev(attr->ia_size);\n\n\tdprintk(\"nfsd: CREATE   %s %.*s\\n\",\n\t\tSVCFH_fmt(dirfhp), argp->len, argp->name);\n\n\t/* First verify the parent file handle */\n\tnfserr = fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (nfserr)\n\t\tgoto done; /* must fh_put dirfhp even on error */\n\n\t/* Check for NFSD_MAY_WRITE in nfsd_create if necessary */\n\n\tnfserr = nfserr_acces;\n\tif (!argp->len)\n\t\tgoto done;\n\tnfserr = nfserr_exist;\n\tif (isdotent(argp->name, argp->len))\n\t\tgoto done;\n\thosterr = fh_want_write(dirfhp);\n\tif (hosterr) {\n\t\tnfserr = nfserrno(hosterr);\n\t\tgoto done;\n\t}\n\n\tfh_lock_nested(dirfhp, I_MUTEX_PARENT);\n\tdchild = lookup_one_len(argp->name, dirfhp->fh_dentry, argp->len);\n\tif (IS_ERR(dchild)) {\n\t\tnfserr = nfserrno(PTR_ERR(dchild));\n\t\tgoto out_unlock;\n\t}\n\tfh_init(newfhp, NFS_FHSIZE);\n\tnfserr = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);\n\tif (!nfserr && d_really_is_negative(dchild))\n\t\tnfserr = nfserr_noent;\n\tdput(dchild);\n\tif (nfserr) {\n\t\tif (nfserr != nfserr_noent)\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If the new file handle wasn't verified, we can't tell\n\t\t * whether the file exists or not. Time to bail ...\n\t\t */\n\t\tnfserr = nfserr_acces;\n\t\tif (!newfhp->fh_dentry) {\n\t\t\tprintk(KERN_WARNING \n\t\t\t\t\"nfsd_proc_create: file handle not verified\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tinode = d_inode(newfhp->fh_dentry);\n\n\t/* Unfudge the mode bits */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\ttype = attr->ia_mode & S_IFMT;\n\t\tmode = attr->ia_mode & ~S_IFMT;\n\t\tif (!type) {\n\t\t\t/* no type, so if target exists, assume same as that,\n\t\t\t * else assume a file */\n\t\t\tif (inode) {\n\t\t\t\ttype = inode->i_mode & S_IFMT;\n\t\t\t\tswitch(type) {\n\t\t\t\tcase S_IFCHR:\n\t\t\t\tcase S_IFBLK:\n\t\t\t\t\t/* reserve rdev for later checking */\n\t\t\t\t\trdev = inode->i_rdev;\n\t\t\t\t\tattr->ia_valid |= ATTR_SIZE;\n\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase S_IFIFO:\n\t\t\t\t\t/* this is probably a permission check..\n\t\t\t\t\t * at least IRIX implements perm checking on\n\t\t\t\t\t *   echo thing > device-special-file-or-pipe\n\t\t\t\t\t * by doing a CREATE with type==0\n\t\t\t\t\t */\n\t\t\t\t\tnfserr = nfsd_permission(rqstp,\n\t\t\t\t\t\t\t\t newfhp->fh_export,\n\t\t\t\t\t\t\t\t newfhp->fh_dentry,\n\t\t\t\t\t\t\t\t NFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS);\n\t\t\t\t\tif (nfserr && nfserr != nfserr_rofs)\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttype = S_IFREG;\n\t\t}\n\t} else if (inode) {\n\t\ttype = inode->i_mode & S_IFMT;\n\t\tmode = inode->i_mode & ~S_IFMT;\n\t} else {\n\t\ttype = S_IFREG;\n\t\tmode = 0;\t/* ??? */\n\t}\n\n\tattr->ia_valid |= ATTR_MODE;\n\tattr->ia_mode = mode;\n\n\t/* Special treatment for non-regular files according to the\n\t * gospel of sun micro\n\t */\n\tif (type != S_IFREG) {\n\t\tif (type != S_IFBLK && type != S_IFCHR) {\n\t\t\trdev = 0;\n\t\t} else if (type == S_IFCHR && !(attr->ia_valid & ATTR_SIZE)) {\n\t\t\t/* If you think you've seen the worst, grok this. */\n\t\t\ttype = S_IFIFO;\n\t\t} else {\n\t\t\t/* Okay, char or block special */\n\t\t\tif (!rdev)\n\t\t\t\trdev = wanted;\n\t\t}\n\n\t\t/* we've used the SIZE information, so discard it */\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\t\t/* Make sure the type and device matches */\n\t\tnfserr = nfserr_exist;\n\t\tif (inode && type != (inode->i_mode & S_IFMT))\n\t\t\tgoto out_unlock;\n\t}\n\n\tnfserr = 0;\n\tif (!inode) {\n\t\t/* File doesn't exist. Create it and set attrs */\n\t\tnfserr = nfsd_create(rqstp, dirfhp, argp->name, argp->len,\n\t\t\t\t\tattr, type, rdev, newfhp);\n\t} else if (type == S_IFREG) {\n\t\tdprintk(\"nfsd:   existing %s, valid=%x, size=%ld\\n\",\n\t\t\targp->name, attr->ia_valid, (long) attr->ia_size);\n\t\t/* File already exists. We ignore all attributes except\n\t\t * size, so that creat() behaves exactly like\n\t\t * open(..., O_CREAT|O_TRUNC|O_WRONLY).\n\t\t */\n\t\tattr->ia_valid &= ATTR_SIZE;\n\t\tif (attr->ia_valid)\n\t\t\tnfserr = nfsd_setattr(rqstp, newfhp, attr, 0, (time_t)0);\n\t}\n\nout_unlock:\n\t/* We don't really need to unlock, as fh_put does it. */\n\tfh_unlock(dirfhp);\n\tfh_drop_write(dirfhp);\ndone:\n\tfh_put(dirfhp);\n\treturn nfsd_return_dirop(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_dirop",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_dirop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "31-36",
          "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "dirfhp"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_drop_write",
          "args": [
            "dirfhp"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "fh_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "121-127",
          "snippet": "static inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_unlock",
          "args": [
            "dirfhp"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "fh_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "305-313",
          "snippet": "static inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tinode_unlock(d_inode(fhp->fh_dentry));\n\t\tfhp->fh_locked = false;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tinode_unlock(d_inode(fhp->fh_dentry));\n\t\tfhp->fh_locked = false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setattr",
          "args": [
            "rqstp",
            "newfhp",
            "attr",
            "0",
            "(time_t)0"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "369-452",
          "snippet": "__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd:   existing %s, valid=%x, size=%ld\\n\"",
            "argp->name",
            "attr->ia_valid",
            "(long) attr->ia_size"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_create",
          "args": [
            "rqstp",
            "dirfhp",
            "argp->name",
            "argp->len",
            "attr",
            "type",
            "rdev",
            "newfhp"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1146-1273",
          "snippet": "__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (d_really_is_positive(dchild)) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\terr = nfserr_notdir;\n\tif (!dirp->i_op->lookup)\n\t\tgoto out;\n\t/*\n\t * Check whether the response file handle has been verified yet.\n\t * If it has, the parent directory should already be locked.\n\t */\n\tif (!resfhp->fh_dentry) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\tgoto out_nfserr;\n\n\t\t/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */\n\t\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\t\tdchild = lookup_one_len(fname, dentry, flen);\n\t\thost_err = PTR_ERR(dchild);\n\t\tif (IS_ERR(dchild))\n\t\t\tgoto out_nfserr;\n\t\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\t/* called from nfsd_proc_create */\n\t\tdchild = dget(resfhp->fh_dentry);\n\t\tif (!fhp->fh_locked) {\n\t\t\t/* not actually possible */\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\t\terr = nfserr_io;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/*\n\t * Make sure the child dentry is still negative ...\n\t */\n\terr = nfserr_exist;\n\tif (d_really_is_positive(dchild)) {\n\t\tdprintk(\"nfsd_create: dentry %pd/%pd not negative!\\n\",\n\t\t\tdentry, dchild);\n\t\tgoto out; \n\t}\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = nfserr_inval;\n\tif (!S_ISREG(type) && !S_ISDIR(type) && !special_file(type)) {\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Get the dir op function pointer.\n\t */\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child * simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_permission",
          "args": [
            "rqstp",
            "newfhp->fh_export",
            "newfhp->fh_dentry",
            "NFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1952-2032",
          "snippet": "__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "newfhp->fh_dentry"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \n\t\t\t\t\"nfsd_proc_create: file handle not verified\\n\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dchild"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_negative",
          "args": [
            "dchild"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_compose",
          "args": [
            "newfhp",
            "dirfhp->fh_export",
            "dchild",
            "dirfhp"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "fh_compose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "511-585",
          "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "newfhp",
            "NFS_FHSIZE"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(dchild)"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dchild"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dchild"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "argp->name",
            "dirfhp->fh_dentry",
            "argp->len"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_lock_nested",
          "args": [
            "dirfhp",
            "I_MUTEX_PARENT"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "fh_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "276-294",
          "snippet": "static inline void\nfh_lock_nested(struct svc_fh *fhp, unsigned int subclass)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tstruct inode\t*inode;\n\n\tBUG_ON(!dentry);\n\n\tif (fhp->fh_locked) {\n\t\tprintk(KERN_WARNING \"fh_lock: %pd2 already locked!\\n\",\n\t\t\tdentry);\n\t\treturn;\n\t}\n\n\tinode = d_inode(dentry);\n\tinode_lock_nested(inode, subclass);\n\tfill_pre_wcc(fhp);\n\tfhp->fh_locked = true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_lock_nested(struct svc_fh *fhp, unsigned int subclass)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tstruct inode\t*inode;\n\n\tBUG_ON(!dentry);\n\n\tif (fhp->fh_locked) {\n\t\tprintk(KERN_WARNING \"fh_lock: %pd2 already locked!\\n\",\n\t\t\tdentry);\n\t\treturn;\n\t}\n\n\tinode = d_inode(dentry);\n\tinode_lock_nested(inode, subclass);\n\tfill_pre_wcc(fhp);\n\tfhp->fh_locked = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_want_write",
          "args": [
            "dirfhp"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "fh_want_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "112-119",
          "snippet": "static inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = true;\n\treturn ret;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = true;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdotent",
          "args": [
            "argp->name",
            "argp->len"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "dirfhp",
            "S_IFDIR",
            "NFSD_MAY_EXEC"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: CREATE   %s %.*s\\n\"",
            "SVCFH_fmt(dirfhp)",
            "argp->len",
            "argp->name"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "dirfhp"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "attr->ia_size"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_create(struct svc_rqst *rqstp, struct nfsd_createargs *argp,\n\t\t\t\t\t struct nfsd_diropres   *resp)\n{\n\tsvc_fh\t\t*dirfhp = &argp->fh;\n\tsvc_fh\t\t*newfhp = &resp->fh;\n\tstruct iattr\t*attr = &argp->attrs;\n\tstruct inode\t*inode;\n\tstruct dentry\t*dchild;\n\tint\t\ttype, mode;\n\t__be32\t\tnfserr;\n\tint\t\thosterr;\n\tdev_t\t\trdev = 0, wanted = new_decode_dev(attr->ia_size);\n\n\tdprintk(\"nfsd: CREATE   %s %.*s\\n\",\n\t\tSVCFH_fmt(dirfhp), argp->len, argp->name);\n\n\t/* First verify the parent file handle */\n\tnfserr = fh_verify(rqstp, dirfhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (nfserr)\n\t\tgoto done; /* must fh_put dirfhp even on error */\n\n\t/* Check for NFSD_MAY_WRITE in nfsd_create if necessary */\n\n\tnfserr = nfserr_acces;\n\tif (!argp->len)\n\t\tgoto done;\n\tnfserr = nfserr_exist;\n\tif (isdotent(argp->name, argp->len))\n\t\tgoto done;\n\thosterr = fh_want_write(dirfhp);\n\tif (hosterr) {\n\t\tnfserr = nfserrno(hosterr);\n\t\tgoto done;\n\t}\n\n\tfh_lock_nested(dirfhp, I_MUTEX_PARENT);\n\tdchild = lookup_one_len(argp->name, dirfhp->fh_dentry, argp->len);\n\tif (IS_ERR(dchild)) {\n\t\tnfserr = nfserrno(PTR_ERR(dchild));\n\t\tgoto out_unlock;\n\t}\n\tfh_init(newfhp, NFS_FHSIZE);\n\tnfserr = fh_compose(newfhp, dirfhp->fh_export, dchild, dirfhp);\n\tif (!nfserr && d_really_is_negative(dchild))\n\t\tnfserr = nfserr_noent;\n\tdput(dchild);\n\tif (nfserr) {\n\t\tif (nfserr != nfserr_noent)\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * If the new file handle wasn't verified, we can't tell\n\t\t * whether the file exists or not. Time to bail ...\n\t\t */\n\t\tnfserr = nfserr_acces;\n\t\tif (!newfhp->fh_dentry) {\n\t\t\tprintk(KERN_WARNING \n\t\t\t\t\"nfsd_proc_create: file handle not verified\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tinode = d_inode(newfhp->fh_dentry);\n\n\t/* Unfudge the mode bits */\n\tif (attr->ia_valid & ATTR_MODE) {\n\t\ttype = attr->ia_mode & S_IFMT;\n\t\tmode = attr->ia_mode & ~S_IFMT;\n\t\tif (!type) {\n\t\t\t/* no type, so if target exists, assume same as that,\n\t\t\t * else assume a file */\n\t\t\tif (inode) {\n\t\t\t\ttype = inode->i_mode & S_IFMT;\n\t\t\t\tswitch(type) {\n\t\t\t\tcase S_IFCHR:\n\t\t\t\tcase S_IFBLK:\n\t\t\t\t\t/* reserve rdev for later checking */\n\t\t\t\t\trdev = inode->i_rdev;\n\t\t\t\t\tattr->ia_valid |= ATTR_SIZE;\n\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase S_IFIFO:\n\t\t\t\t\t/* this is probably a permission check..\n\t\t\t\t\t * at least IRIX implements perm checking on\n\t\t\t\t\t *   echo thing > device-special-file-or-pipe\n\t\t\t\t\t * by doing a CREATE with type==0\n\t\t\t\t\t */\n\t\t\t\t\tnfserr = nfsd_permission(rqstp,\n\t\t\t\t\t\t\t\t newfhp->fh_export,\n\t\t\t\t\t\t\t\t newfhp->fh_dentry,\n\t\t\t\t\t\t\t\t NFSD_MAY_WRITE|NFSD_MAY_LOCAL_ACCESS);\n\t\t\t\t\tif (nfserr && nfserr != nfserr_rofs)\n\t\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttype = S_IFREG;\n\t\t}\n\t} else if (inode) {\n\t\ttype = inode->i_mode & S_IFMT;\n\t\tmode = inode->i_mode & ~S_IFMT;\n\t} else {\n\t\ttype = S_IFREG;\n\t\tmode = 0;\t/* ??? */\n\t}\n\n\tattr->ia_valid |= ATTR_MODE;\n\tattr->ia_mode = mode;\n\n\t/* Special treatment for non-regular files according to the\n\t * gospel of sun micro\n\t */\n\tif (type != S_IFREG) {\n\t\tif (type != S_IFBLK && type != S_IFCHR) {\n\t\t\trdev = 0;\n\t\t} else if (type == S_IFCHR && !(attr->ia_valid & ATTR_SIZE)) {\n\t\t\t/* If you think you've seen the worst, grok this. */\n\t\t\ttype = S_IFIFO;\n\t\t} else {\n\t\t\t/* Okay, char or block special */\n\t\t\tif (!rdev)\n\t\t\t\trdev = wanted;\n\t\t}\n\n\t\t/* we've used the SIZE information, so discard it */\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n\t\t/* Make sure the type and device matches */\n\t\tnfserr = nfserr_exist;\n\t\tif (inode && type != (inode->i_mode & S_IFMT))\n\t\t\tgoto out_unlock;\n\t}\n\n\tnfserr = 0;\n\tif (!inode) {\n\t\t/* File doesn't exist. Create it and set attrs */\n\t\tnfserr = nfsd_create(rqstp, dirfhp, argp->name, argp->len,\n\t\t\t\t\tattr, type, rdev, newfhp);\n\t} else if (type == S_IFREG) {\n\t\tdprintk(\"nfsd:   existing %s, valid=%x, size=%ld\\n\",\n\t\t\targp->name, attr->ia_valid, (long) attr->ia_size);\n\t\t/* File already exists. We ignore all attributes except\n\t\t * size, so that creat() behaves exactly like\n\t\t * open(..., O_CREAT|O_TRUNC|O_WRONLY).\n\t\t */\n\t\tattr->ia_valid &= ATTR_SIZE;\n\t\tif (attr->ia_valid)\n\t\t\tnfserr = nfsd_setattr(rqstp, newfhp, attr, 0, (time_t)0);\n\t}\n\nout_unlock:\n\t/* We don't really need to unlock, as fh_put does it. */\n\tfh_unlock(dirfhp);\n\tfh_drop_write(dirfhp);\ndone:\n\tfh_put(dirfhp);\n\treturn nfsd_return_dirop(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "204-222",
    "snippet": "static __be32\nnfsd_proc_write(struct svc_rqst *rqstp, struct nfsd_writeargs *argp,\n\t\t\t\t\tstruct nfsd_attrstat  *resp)\n{\n\t__be32\tnfserr;\n\tint\tstable = 1;\n\tunsigned long cnt = argp->len;\n\n\tdprintk(\"nfsd: WRITE    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->len, argp->offset);\n\n\tnfserr = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh), NULL,\n\t\t\t\t   argp->offset,\n\t\t\t\t   rqstp->rq_vec, argp->vlen,\n\t\t\t           &cnt,\n\t\t\t\t   &stable);\n\treturn nfsd_return_attrs(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_attrs",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "25-30",
          "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_write",
          "args": [
            "rqstp",
            "fh_copy(&resp->fh, &argp->fh)",
            "NULL",
            "argp->offset",
            "rqstp->rq_vec",
            "argp->vlen",
            "&cnt",
            "&stable"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1022-1055",
          "snippet": "__be32\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\n\t\tloff_t offset, struct kvec *vec, int vlen, unsigned long *cnt,\n\t\tint *stablep)\n{\n\t__be32\t\t\terr = 0;\n\n\ttrace_write_start(rqstp, fhp, offset, vlen);\n\n\tif (file) {\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\tgoto out;\n\t\ttrace_write_opened(rqstp, fhp, offset, vlen);\n\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,\n\t\t\t\tstablep);\n\t\ttrace_write_io_done(rqstp, fhp, offset, vlen);\n\t} else {\n\t\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_WRITE, &file);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttrace_write_opened(rqstp, fhp, offset, vlen);\n\t\tif (cnt)\n\t\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,\n\t\t\t\t\t     cnt, stablep);\n\t\ttrace_write_io_done(rqstp, fhp, offset, vlen);\n\t\tfput(file);\n\t}\nout:\n\ttrace_write_done(rqstp, fhp, offset, vlen);\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,\n\t\tloff_t offset, struct kvec *vec, int vlen, unsigned long *cnt,\n\t\tint *stablep)\n{\n\t__be32\t\t\terr = 0;\n\n\ttrace_write_start(rqstp, fhp, offset, vlen);\n\n\tif (file) {\n\t\terr = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tNFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (err)\n\t\t\tgoto out;\n\t\ttrace_write_opened(rqstp, fhp, offset, vlen);\n\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen, cnt,\n\t\t\t\tstablep);\n\t\ttrace_write_io_done(rqstp, fhp, offset, vlen);\n\t} else {\n\t\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_WRITE, &file);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\ttrace_write_opened(rqstp, fhp, offset, vlen);\n\t\tif (cnt)\n\t\t\terr = nfsd_vfs_write(rqstp, fhp, file, offset, vec, vlen,\n\t\t\t\t\t     cnt, stablep);\n\t\ttrace_write_io_done(rqstp, fhp, offset, vlen);\n\t\tfput(file);\n\t}\nout:\n\ttrace_write_done(rqstp, fhp, offset, vlen);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: WRITE    %s %d bytes at %d\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->offset"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_write(struct svc_rqst *rqstp, struct nfsd_writeargs *argp,\n\t\t\t\t\tstruct nfsd_attrstat  *resp)\n{\n\t__be32\tnfserr;\n\tint\tstable = 1;\n\tunsigned long cnt = argp->len;\n\n\tdprintk(\"nfsd: WRITE    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->len, argp->offset);\n\n\tnfserr = nfsd_write(rqstp, fh_copy(&resp->fh, &argp->fh), NULL,\n\t\t\t\t   argp->offset,\n\t\t\t\t   rqstp->rq_vec, argp->vlen,\n\t\t\t           &cnt,\n\t\t\t\t   &stable);\n\treturn nfsd_return_attrs(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "166-198",
    "snippet": "static __be32\nnfsd_proc_read(struct svc_rqst *rqstp, struct nfsd_readargs *argp,\n\t\t\t\t       struct nfsd_readres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READ    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->count, argp->offset);\n\n\t/* Obtain buffer pointer for payload. 19 is 1 word for\n\t * status, 17 words for fattr, and 1 word for the byte count.\n\t */\n\n\tif (NFSSVC_MAXBLKSIZE_V2 < argp->count) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_NOTICE\n\t\t\t\"oversized read request from %s (%d bytes)\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)),\n\t\t\t\targp->count);\n\t\targp->count = NFSSVC_MAXBLKSIZE_V2;\n\t}\n\tsvc_reserve_auth(rqstp, (19<<2) + argp->count + 4);\n\n\tresp->count = argp->count;\n\tnfserr = nfsd_read(rqstp, fh_copy(&resp->fh, &argp->fh),\n\t\t\t\t  argp->offset,\n\t\t\t   \t  rqstp->rq_vec, argp->vlen,\n\t\t\t\t  &resp->count);\n\n\tif (nfserr) return nfserr;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_read",
          "args": [
            "rqstp",
            "fh_copy(&resp->fh, &argp->fh)",
            "argp->offset",
            "rqstp->rq_vec",
            "argp->vlen",
            "&resp->count"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "990-1015",
          "snippet": "__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\tloff_t offset, struct kvec *vec, int vlen, unsigned long *count)\n{\n\tstruct file *file;\n\tstruct raparms\t*ra;\n\t__be32 err;\n\n\ttrace_read_start(rqstp, fhp, offset, vlen);\n\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (err)\n\t\treturn err;\n\n\tra = nfsd_init_raparms(file);\n\n\ttrace_read_opened(rqstp, fhp, offset, vlen);\n\terr = nfsd_vfs_read(rqstp, file, offset, vec, vlen, count);\n\ttrace_read_io_done(rqstp, fhp, offset, vlen);\n\n\tif (ra)\n\t\tnfsd_put_raparams(file, ra);\n\tfput(file);\n\n\ttrace_read_done(rqstp, fhp, offset, vlen);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32 nfsd_read(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\tloff_t offset, struct kvec *vec, int vlen, unsigned long *count)\n{\n\tstruct file *file;\n\tstruct raparms\t*ra;\n\t__be32 err;\n\n\ttrace_read_start(rqstp, fhp, offset, vlen);\n\terr = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (err)\n\t\treturn err;\n\n\tra = nfsd_init_raparms(file);\n\n\ttrace_read_opened(rqstp, fhp, offset, vlen);\n\terr = nfsd_vfs_read(rqstp, file, offset, vec, vlen, count);\n\ttrace_read_io_done(rqstp, fhp, offset, vlen);\n\n\tif (ra)\n\t\tnfsd_put_raparams(file, ra);\n\tfput(file);\n\n\ttrace_read_done(rqstp, fhp, offset, vlen);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_reserve_auth",
          "args": [
            "rqstp",
            "(19<<2) + argp->count + 4"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE\n\t\t\t\"oversized read request from %s (%d bytes)\\n\"",
            "svc_print_addr(rqstp, buf, sizeof(buf))",
            "argp->count"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_print_addr",
          "args": [
            "rqstp",
            "buf",
            "sizeof(buf)"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: READ    %s %d bytes at %d\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->count",
            "argp->offset"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_read(struct svc_rqst *rqstp, struct nfsd_readargs *argp,\n\t\t\t\t       struct nfsd_readres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READ    %s %d bytes at %d\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->count, argp->offset);\n\n\t/* Obtain buffer pointer for payload. 19 is 1 word for\n\t * status, 17 words for fattr, and 1 word for the byte count.\n\t */\n\n\tif (NFSSVC_MAXBLKSIZE_V2 < argp->count) {\n\t\tchar buf[RPC_MAX_ADDRBUFLEN];\n\t\tprintk(KERN_NOTICE\n\t\t\t\"oversized read request from %s (%d bytes)\\n\",\n\t\t\t\tsvc_print_addr(rqstp, buf, sizeof(buf)),\n\t\t\t\targp->count);\n\t\targp->count = NFSSVC_MAXBLKSIZE_V2;\n\t}\n\tsvc_reserve_auth(rqstp, (19<<2) + argp->count + 4);\n\n\tresp->count = argp->count;\n\tnfserr = nfsd_read(rqstp, fh_copy(&resp->fh, &argp->fh),\n\t\t\t\t  argp->offset,\n\t\t\t   \t  rqstp->rq_vec, argp->vlen,\n\t\t\t\t  &resp->count);\n\n\tif (nfserr) return nfserr;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
  },
  {
    "function_name": "nfsd_proc_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "146-160",
    "snippet": "static __be32\nnfsd_proc_readlink(struct svc_rqst *rqstp, struct nfsd_readlinkargs *argp,\n\t\t\t\t\t   struct nfsd_readlinkres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READLINK %s\\n\", SVCFH_fmt(&argp->fh));\n\n\t/* Read the symlink. */\n\tresp->len = NFS_MAXPATHLEN;\n\tnfserr = nfsd_readlink(rqstp, &argp->fh, argp->buffer, &resp->len);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_readlink",
          "args": [
            "rqstp",
            "&argp->fh",
            "argp->buffer",
            "&resp->len"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1450-1490",
          "snippet": "__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_readlink(struct svc_rqst *rqstp, struct svc_fh *fhp, char *buf, int *lenp)\n{\n\tstruct inode\t*inode;\n\tmm_segment_t\toldfs;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tstruct path path;\n\n\terr = fh_verify(rqstp, fhp, S_IFLNK, NFSD_MAY_NOP);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\terr = nfserr_inval;\n\tif (!inode->i_op->readlink)\n\t\tgoto out;\n\n\ttouch_atime(&path);\n\t/* N.B. Why does this call need a get_fs()??\n\t * Remove the set_fs and watch the fireworks:-) --okir\n\t */\n\n\toldfs = get_fs(); set_fs(KERNEL_DS);\n\thost_err = inode->i_op->readlink(path.dentry, (char __user *)buf, *lenp);\n\tset_fs(oldfs);\n\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\t*lenp = host_err;\n\terr = 0;\nout:\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: READLINK %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_readlink(struct svc_rqst *rqstp, struct nfsd_readlinkargs *argp,\n\t\t\t\t\t   struct nfsd_readlinkres *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: READLINK %s\\n\", SVCFH_fmt(&argp->fh));\n\n\t/* Read the symlink. */\n\tresp->len = NFS_MAXPATHLEN;\n\tnfserr = nfsd_readlink(rqstp, &argp->fh, argp->buffer, &resp->len);\n\n\tfh_put(&argp->fh);\n\treturn nfserr;\n}"
  },
  {
    "function_name": "nfsd_proc_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "126-141",
    "snippet": "static __be32\nnfsd_proc_lookup(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t struct nfsd_diropres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LOOKUP   %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t &resp->fh);\n\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_dirop",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_dirop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "31-36",
          "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "&argp->fh"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_lookup",
          "args": [
            "rqstp",
            "&argp->fh",
            "argp->name",
            "argp->len",
            "&resp->fh"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "259-287",
          "snippet": "__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && d_really_is_negative(dentry))\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,\n\t\t\t\tunsigned int len, struct svc_fh *resfh)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dentry;\n\t__be32 err;\n\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\treturn err;\n\terr = nfsd_lookup_dentry(rqstp, fhp, name, len, &exp, &dentry);\n\tif (err)\n\t\treturn err;\n\terr = check_nfsd_access(exp, rqstp);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * Note: we compose the file handle now, but as the\n\t * dentry may be negative, it may need to be updated.\n\t */\n\terr = fh_compose(resfh, exp, dentry, fhp);\n\tif (!err && d_really_is_negative(dentry))\n\t\terr = nfserr_noent;\nout:\n\tdput(dentry);\n\texp_put(exp);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_init",
          "args": [
            "&resp->fh",
            "NFS_FHSIZE"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "fh_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "183-189",
          "snippet": "static __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic __inline__ struct svc_fh *\nfh_init(struct svc_fh *fhp, int maxsize)\n{\n\tmemset(fhp, 0, sizeof(*fhp));\n\tfhp->fh_maxsize = maxsize;\n\treturn fhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: LOOKUP   %s %.*s\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->len",
            "argp->name"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_lookup(struct svc_rqst *rqstp, struct nfsd_diropargs *argp,\n\t\t\t\t\t struct nfsd_diropres  *resp)\n{\n\t__be32\tnfserr;\n\n\tdprintk(\"nfsd: LOOKUP   %s %.*s\\n\",\n\t\tSVCFH_fmt(&argp->fh), argp->len, argp->name);\n\n\tfh_init(&resp->fh, NFS_FHSIZE);\n\tnfserr = nfsd_lookup(rqstp, &argp->fh, argp->name, argp->len,\n\t\t\t\t &resp->fh);\n\n\tfh_put(&argp->fh);\n\treturn nfsd_return_dirop(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "58-118",
    "snippet": "static __be32\nnfsd_proc_setattr(struct svc_rqst *rqstp, struct nfsd_sattrargs *argp,\n\t\t\t\t\t  struct nfsd_attrstat  *resp)\n{\n\tstruct iattr *iap = &argp->attrs;\n\tstruct svc_fh *fhp;\n\t__be32 nfserr;\n\n\tdprintk(\"nfsd: SETATTR  %s, valid=%x, size=%ld\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->attrs.ia_valid, (long) argp->attrs.ia_size);\n\n\tfhp = fh_copy(&resp->fh, &argp->fh);\n\n\t/*\n\t * NFSv2 does not differentiate between \"set-[ac]time-to-now\"\n\t * which only requires access, and \"set-[ac]time-to-X\" which\n\t * requires ownership.\n\t * So if it looks like it might be \"set both to the same time which\n\t * is close to now\", and if inode_change_ok fails, then we\n\t * convert to \"set to now\" instead of \"set to explicit time\"\n\t *\n\t * We only call inode_change_ok as the last test as technically\n\t * it is not an interface that we should be using.\n\t */\n#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)\n#define\tMAX_TOUCH_TIME_ERROR (30*60)\n\tif ((iap->ia_valid & BOTH_TIME_SET) == BOTH_TIME_SET &&\n\t    iap->ia_mtime.tv_sec == iap->ia_atime.tv_sec) {\n\t\t/*\n\t\t * Looks probable.\n\t\t *\n\t\t * Now just make sure time is in the right ballpark.\n\t\t * Solaris, at least, doesn't seem to care what the time\n\t\t * request is.  We require it be within 30 minutes of now.\n\t\t */\n\t\ttime_t delta = iap->ia_atime.tv_sec - get_seconds();\n\t\tstruct inode *inode;\n\n\t\tnfserr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\t\tif (nfserr)\n\t\t\tgoto done;\n\t\tinode = d_inode(fhp->fh_dentry);\n\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < MAX_TOUCH_TIME_ERROR &&\n\t\t    inode_change_ok(inode, iap) != 0) {\n\t\t\t/*\n\t\t\t * Turn off ATTR_[AM]TIME_SET but leave ATTR_[AM]TIME.\n\t\t\t * This will cause notify_change to set these times\n\t\t\t * to \"now\"\n\t\t\t */\n\t\t\tiap->ia_valid &= ~BOTH_TIME_SET;\n\t\t}\n\t}\n\n\tnfserr = nfsd_setattr(rqstp, fhp, iap, 0, (time_t)0);\ndone:\n\treturn nfsd_return_attrs(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [
      "#define\tMAX_TOUCH_TIME_ERROR (30*60)",
      "#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_attrs",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "25-30",
          "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setattr",
          "args": [
            "rqstp",
            "fhp",
            "iap",
            "0",
            "(time_t)0"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "369-452",
          "snippet": "__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iap"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "fhp->fh_dentry"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "fhp",
            "0",
            "NFSD_MAY_NOP"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: SETATTR  %s, valid=%x, size=%ld\\n\"",
            "SVCFH_fmt(&argp->fh)",
            "argp->attrs.ia_valid",
            "(long) argp->attrs.ia_size"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n#define\tMAX_TOUCH_TIME_ERROR (30*60)\n#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)\n\nstatic __be32\nnfsd_proc_setattr(struct svc_rqst *rqstp, struct nfsd_sattrargs *argp,\n\t\t\t\t\t  struct nfsd_attrstat  *resp)\n{\n\tstruct iattr *iap = &argp->attrs;\n\tstruct svc_fh *fhp;\n\t__be32 nfserr;\n\n\tdprintk(\"nfsd: SETATTR  %s, valid=%x, size=%ld\\n\",\n\t\tSVCFH_fmt(&argp->fh),\n\t\targp->attrs.ia_valid, (long) argp->attrs.ia_size);\n\n\tfhp = fh_copy(&resp->fh, &argp->fh);\n\n\t/*\n\t * NFSv2 does not differentiate between \"set-[ac]time-to-now\"\n\t * which only requires access, and \"set-[ac]time-to-X\" which\n\t * requires ownership.\n\t * So if it looks like it might be \"set both to the same time which\n\t * is close to now\", and if inode_change_ok fails, then we\n\t * convert to \"set to now\" instead of \"set to explicit time\"\n\t *\n\t * We only call inode_change_ok as the last test as technically\n\t * it is not an interface that we should be using.\n\t */\n#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)\n#define\tMAX_TOUCH_TIME_ERROR (30*60)\n\tif ((iap->ia_valid & BOTH_TIME_SET) == BOTH_TIME_SET &&\n\t    iap->ia_mtime.tv_sec == iap->ia_atime.tv_sec) {\n\t\t/*\n\t\t * Looks probable.\n\t\t *\n\t\t * Now just make sure time is in the right ballpark.\n\t\t * Solaris, at least, doesn't seem to care what the time\n\t\t * request is.  We require it be within 30 minutes of now.\n\t\t */\n\t\ttime_t delta = iap->ia_atime.tv_sec - get_seconds();\n\t\tstruct inode *inode;\n\n\t\tnfserr = fh_verify(rqstp, fhp, 0, NFSD_MAY_NOP);\n\t\tif (nfserr)\n\t\t\tgoto done;\n\t\tinode = d_inode(fhp->fh_dentry);\n\n\t\tif (delta < 0)\n\t\t\tdelta = -delta;\n\t\tif (delta < MAX_TOUCH_TIME_ERROR &&\n\t\t    inode_change_ok(inode, iap) != 0) {\n\t\t\t/*\n\t\t\t * Turn off ATTR_[AM]TIME_SET but leave ATTR_[AM]TIME.\n\t\t\t * This will cause notify_change to set these times\n\t\t\t * to \"now\"\n\t\t\t */\n\t\t\tiap->ia_valid &= ~BOTH_TIME_SET;\n\t\t}\n\t}\n\n\tnfserr = nfsd_setattr(rqstp, fhp, iap, 0, (time_t)0);\ndone:\n\treturn nfsd_return_attrs(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_proc_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "41-52",
    "snippet": "static __be32\nnfsd_proc_getattr(struct svc_rqst *rqstp, struct nfsd_fhandle  *argp,\n\t\t\t\t\t  struct nfsd_attrstat *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0,\n\t\t\tNFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\treturn nfsd_return_attrs(nfserr, resp);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_return_attrs",
          "args": [
            "nfserr",
            "resp"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_return_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "25-30",
          "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&resp->fh",
            "0",
            "NFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_copy",
          "args": [
            "&resp->fh",
            "&argp->fh"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: GETATTR  %s\\n\"",
            "SVCFH_fmt(&argp->fh)"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "&argp->fh"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_getattr(struct svc_rqst *rqstp, struct nfsd_fhandle  *argp,\n\t\t\t\t\t  struct nfsd_attrstat *resp)\n{\n\t__be32 nfserr;\n\tdprintk(\"nfsd: GETATTR  %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0,\n\t\t\tNFSD_MAY_NOP | NFSD_MAY_BYPASS_GSS_ON_ROOT);\n\treturn nfsd_return_attrs(nfserr, resp);\n}"
  },
  {
    "function_name": "nfsd_return_dirop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "31-36",
    "snippet": "static __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_dirop(__be32 err, struct nfsd_diropres *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
  },
  {
    "function_name": "nfsd_return_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "25-30",
    "snippet": "static __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_getattr",
          "args": [
            "&resp->fh",
            "&resp->stat"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "fh_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "129-134",
          "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_return_attrs(__be32 err, struct nfsd_attrstat *resp)\n{\n\tif (err) return err;\n\treturn fh_getattr(&resp->fh, &resp->stat);\n}"
  },
  {
    "function_name": "nfsd_proc_null",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
    "lines": "19-23",
    "snippet": "static __be32\nnfsd_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"vfs.h\"",
      "#include \"xdr.h\"",
      "#include \"cache.h\"",
      "#include <linux/namei.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\nstatic __be32\nnfsd_proc_null(struct svc_rqst *rqstp, void *argp, void *resp)\n{\n\treturn nfs_ok;\n}"
  }
]