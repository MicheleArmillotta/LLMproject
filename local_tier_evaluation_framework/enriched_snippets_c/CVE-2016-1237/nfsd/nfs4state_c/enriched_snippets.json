[
  {
    "function_name": "nfsd4_get_writestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6951-6955",
    "snippet": "void\nnfsd4_get_writestateid(struct nfsd4_compound_state *cstate, struct nfsd4_write *write)\n{\n\tget_stateid(cstate, &write->wr_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&write->wr_stateid"
          ],
          "line": 6954
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_writestateid(struct nfsd4_compound_state *cstate, struct nfsd4_write *write)\n{\n\tget_stateid(cstate, &write->wr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_readstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6945-6949",
    "snippet": "void\nnfsd4_get_readstateid(struct nfsd4_compound_state *cstate, struct nfsd4_read *read)\n{\n\tget_stateid(cstate, &read->rd_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&read->rd_stateid"
          ],
          "line": 6948
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_readstateid(struct nfsd4_compound_state *cstate, struct nfsd4_read *read)\n{\n\tget_stateid(cstate, &read->rd_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_lockustateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6939-6943",
    "snippet": "void\nnfsd4_get_lockustateid(struct nfsd4_compound_state *cstate, struct nfsd4_locku *locku)\n{\n\tget_stateid(cstate, &locku->lu_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&locku->lu_stateid"
          ],
          "line": 6942
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_lockustateid(struct nfsd4_compound_state *cstate, struct nfsd4_locku *locku)\n{\n\tget_stateid(cstate, &locku->lu_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_closestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6933-6937",
    "snippet": "void\nnfsd4_get_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tget_stateid(cstate, &close->cl_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&close->cl_stateid"
          ],
          "line": 6936
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tget_stateid(cstate, &close->cl_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_setattrstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6927-6931",
    "snippet": "void\nnfsd4_get_setattrstateid(struct nfsd4_compound_state *cstate, struct nfsd4_setattr *setattr)\n{\n\tget_stateid(cstate, &setattr->sa_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&setattr->sa_stateid"
          ],
          "line": 6930
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_setattrstateid(struct nfsd4_compound_state *cstate, struct nfsd4_setattr *setattr)\n{\n\tget_stateid(cstate, &setattr->sa_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_freestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6921-6925",
    "snippet": "void\nnfsd4_get_freestateid(struct nfsd4_compound_state *cstate, struct nfsd4_free_stateid *fsp)\n{\n\tget_stateid(cstate, &fsp->fr_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&fsp->fr_stateid"
          ],
          "line": 6924
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_freestateid(struct nfsd4_compound_state *cstate, struct nfsd4_free_stateid *fsp)\n{\n\tget_stateid(cstate, &fsp->fr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_delegreturnstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6915-6919",
    "snippet": "void\nnfsd4_get_delegreturnstateid(struct nfsd4_compound_state *cstate, struct nfsd4_delegreturn *drp)\n{\n\tget_stateid(cstate, &drp->dr_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&drp->dr_stateid"
          ],
          "line": 6918
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_delegreturnstateid(struct nfsd4_compound_state *cstate, struct nfsd4_delegreturn *drp)\n{\n\tget_stateid(cstate, &drp->dr_stateid);\n}"
  },
  {
    "function_name": "nfsd4_get_opendowngradestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6909-6913",
    "snippet": "void\nnfsd4_get_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tget_stateid(cstate, &odp->od_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stateid",
          "args": [
            "cstate",
            "&odp->od_stateid"
          ],
          "line": 6912
        },
        "resolved": true,
        "details": {
          "function_name": "get_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6856-6861",
          "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_get_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tget_stateid(cstate, &odp->od_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_lockstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6899-6903",
    "snippet": "void\nnfsd4_set_lockstateid(struct nfsd4_compound_state *cstate, struct nfsd4_lock *lock)\n{\n\tput_stateid(cstate, &lock->lk_resp_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&lock->lk_resp_stateid"
          ],
          "line": 6902
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6863-6870",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_lockstateid(struct nfsd4_compound_state *cstate, struct nfsd4_lock *lock)\n{\n\tput_stateid(cstate, &lock->lk_resp_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_closestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6893-6897",
    "snippet": "void\nnfsd4_set_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tput_stateid(cstate, &close->cl_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&close->cl_stateid"
          ],
          "line": 6896
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6863-6870",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_closestateid(struct nfsd4_compound_state *cstate, struct nfsd4_close *close)\n{\n\tput_stateid(cstate, &close->cl_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_openstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6887-6891",
    "snippet": "void\nnfsd4_set_openstateid(struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tput_stateid(cstate, &open->op_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&open->op_stateid"
          ],
          "line": 6890
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6863-6870",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_openstateid(struct nfsd4_compound_state *cstate, struct nfsd4_open *open)\n{\n\tput_stateid(cstate, &open->op_stateid);\n}"
  },
  {
    "function_name": "nfsd4_set_opendowngradestateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6881-6885",
    "snippet": "void\nnfsd4_set_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tput_stateid(cstate, &odp->od_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_stateid",
          "args": [
            "cstate",
            "&odp->od_stateid"
          ],
          "line": 6884
        },
        "resolved": true,
        "details": {
          "function_name": "put_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6863-6870",
          "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_set_opendowngradestateid(struct nfsd4_compound_state *cstate, struct nfsd4_open_downgrade *odp)\n{\n\tput_stateid(cstate, &odp->od_stateid);\n}"
  },
  {
    "function_name": "clear_current_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6872-6876",
    "snippet": "void\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CLEAR_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 6875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nclear_current_stateid(struct nfsd4_compound_state *cstate)\n{\n\tCLEAR_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n}"
  },
  {
    "function_name": "put_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6863-6870",
    "snippet": "static void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 6868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&cstate->current_stateid",
            "stateid",
            "sizeof(stateid_t)"
          ],
          "line": 6867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nput_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (cstate->minorversion) {\n\t\tmemcpy(&cstate->current_stateid, stateid, sizeof(stateid_t));\n\t\tSET_STATE_ID(cstate, CURRENT_STATE_ID_FLAG);\n\t}\n}"
  },
  {
    "function_name": "get_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6856-6861",
    "snippet": "static void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stateid",
            "&cstate->current_stateid",
            "sizeof(stateid_t)"
          ],
          "line": 6860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CURRENT_STATEID",
          "args": [
            "stateid"
          ],
          "line": 6859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_STATE_ID",
          "args": [
            "cstate",
            "CURRENT_STATE_ID_FLAG"
          ],
          "line": 6859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nget_stateid(struct nfsd4_compound_state *cstate, stateid_t *stateid)\n{\n\tif (HAS_STATE_ID(cstate, CURRENT_STATE_ID_FLAG) && CURRENT_STATEID(stateid))\n\t\tmemcpy(stateid, &cstate->current_stateid, sizeof(stateid_t));\n}"
  },
  {
    "function_name": "nfs4_state_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6849-6854",
    "snippet": "void\nnfs4_state_shutdown(void)\n{\n\tdestroy_workqueue(laundry_wq);\n\tnfsd4_destroy_callback_queue();\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_destroy_callback_queue",
          "args": [],
          "line": 6853
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_destroy_callback_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1014-1017",
          "snippet": "void nfsd4_destroy_callback_queue(void)\n{\n\tdestroy_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_destroy_callback_queue(void)\n{\n\tdestroy_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "laundry_wq"
          ],
          "line": 6852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\n\nvoid\nnfs4_state_shutdown(void)\n{\n\tdestroy_workqueue(laundry_wq);\n\tnfsd4_destroy_callback_queue();\n}"
  },
  {
    "function_name": "nfs4_state_shutdown_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6819-6847",
    "snippet": "void\nnfs4_state_shutdown_net(struct net *net)\n{\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct list_head *pos, *next, reaplist;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcancel_delayed_work_sync(&nn->laundromat_work);\n\tlocks_end_grace(&nn->nfsd4_manager);\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\n\tnfsd4_client_tracking_exit(net);\n\tnfs4_state_destroy_net(net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_state_destroy_net",
          "args": [
            "net"
          ],
          "line": 6846
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_destroy_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6743-6768",
          "snippet": "static void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_client_tracking_exit",
          "args": [
            "net"
          ],
          "line": 6845
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_tracking_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1461-1471",
          "snippet": "void\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 6842
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 6841
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "761-774",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_clnt_odstate",
          "args": [
            "dp->dl_clnt_odstate"
          ],
          "line": 6840
        },
        "resolved": true,
        "details": {
          "function_name": "put_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "512-528",
          "snippet": "static void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *odstate_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 6839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 6838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&reaplist"
          ],
          "line": 6837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 6836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&reaplist"
          ],
          "line": 6834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!unhash_delegation_locked(dp)"
          ],
          "line": 6833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 6833
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "845-864",
          "snippet": "static bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 6832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&nn->del_recall_lru"
          ],
          "line": 6831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 6830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 6829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_end_grace",
          "args": [
            "&nn->nfsd4_manager"
          ],
          "line": 6827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&nn->laundromat_work"
          ],
          "line": 6826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nnfs4_state_shutdown_net(struct net *net)\n{\n\tstruct nfs4_delegation *dp = NULL;\n\tstruct list_head *pos, *next, reaplist;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tcancel_delayed_work_sync(&nn->laundromat_work);\n\tlocks_end_grace(&nn->nfsd4_manager);\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\n\tnfsd4_client_tracking_exit(net);\n\tnfs4_state_destroy_net(net);\n}"
  },
  {
    "function_name": "nfs4_state_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6792-6817",
    "snippet": "int\nnfs4_state_start(void)\n{\n\tint ret;\n\n\tret = set_callback_cred();\n\tif (ret)\n\t\treturn -ENOMEM;\n\tlaundry_wq = alloc_workqueue(\"%s\", WQ_UNBOUND, 0, \"nfsd4\");\n\tif (laundry_wq == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_recovery;\n\t}\n\tret = nfsd4_create_callback_queue();\n\tif (ret)\n\t\tgoto out_free_laundry;\n\n\tset_max_delegations();\n\n\treturn 0;\n\nout_free_laundry:\n\tdestroy_workqueue(laundry_wq);\nout_recovery:\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "laundry_wq"
          ],
          "line": 6814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_max_delegations",
          "args": [],
          "line": 6809
        },
        "resolved": true,
        "details": {
          "function_name": "set_max_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6687-6697",
          "snippet": "static void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long max_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nunsigned long max_delegations;\n\nstatic void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_create_callback_queue",
          "args": [],
          "line": 6805
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_create_callback_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1006-1012",
          "snippet": "int nfsd4_create_callback_queue(void)\n{\n\tcallback_wq = create_singlethread_workqueue(\"nfsd4_callbacks\");\n\tif (!callback_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nint nfsd4_create_callback_queue(void)\n{\n\tcallback_wq = create_singlethread_workqueue(\"nfsd4_callbacks\");\n\tif (!callback_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"%s\"",
            "WQ_UNBOUND",
            "0",
            "\"nfsd4\""
          ],
          "line": 6800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_callback_cred",
          "args": [],
          "line": 6797
        },
        "resolved": true,
        "details": {
          "function_name": "set_callback_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "689-697",
          "snippet": "int set_callback_cred(void)\n{\n\tif (callback_cred)\n\t\treturn 0;\n\tcallback_cred = rpc_lookup_machine_cred(\"nfs\");\n\tif (!callback_cred)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_cred *callback_cred;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_cred *callback_cred;\n\nint set_callback_cred(void)\n{\n\tif (callback_cred)\n\t\treturn 0;\n\tcallback_cred = rpc_lookup_machine_cred(\"nfs\");\n\tif (!callback_cred)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\n\nint\nnfs4_state_start(void)\n{\n\tint ret;\n\n\tret = set_callback_cred();\n\tif (ret)\n\t\treturn -ENOMEM;\n\tlaundry_wq = alloc_workqueue(\"%s\", WQ_UNBOUND, 0, \"nfsd4\");\n\tif (laundry_wq == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out_recovery;\n\t}\n\tret = nfsd4_create_callback_queue();\n\tif (ret)\n\t\tgoto out_free_laundry;\n\n\tset_max_delegations();\n\n\treturn 0;\n\nout_free_laundry:\n\tdestroy_workqueue(laundry_wq);\nout_recovery:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_state_start_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6770-6788",
    "snippet": "int\nnfs4_state_start_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tret = nfs4_state_create_net(net);\n\tif (ret)\n\t\treturn ret;\n\tnn->boot_time = get_seconds();\n\tnn->grace_ended = false;\n\tnn->nfsd4_manager.block_opens = true;\n\tlocks_start_grace(net, &nn->nfsd4_manager);\n\tnfsd4_client_tracking_init(net);\n\tprintk(KERN_INFO \"NFSD: starting %ld-second grace period (net %p)\\n\",\n\t       nn->nfsd4_grace, net);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_grace * HZ);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "laundry_wq",
            "&nn->laundromat_work",
            "nn->nfsd4_grace * HZ"
          ],
          "line": 6786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NFSD: starting %ld-second grace period (net %p)\\n\"",
            "nn->nfsd4_grace",
            "net"
          ],
          "line": 6784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_client_tracking_init",
          "args": [
            "net"
          ],
          "line": 6783
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_tracking_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1413-1459",
          "snippet": "int\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};",
            "static const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};",
            "static const struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic const struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};\nstatic const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};\nstatic const struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};\n\nint\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_start_grace",
          "args": [
            "net",
            "&nn->nfsd4_manager"
          ],
          "line": 6782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 6779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_state_create_net",
          "args": [
            "net"
          ],
          "line": 6776
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_state_create_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6699-6741",
          "snippet": "static int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\n\nint\nnfs4_state_start_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint ret;\n\n\tret = nfs4_state_create_net(net);\n\tif (ret)\n\t\treturn ret;\n\tnn->boot_time = get_seconds();\n\tnn->grace_ended = false;\n\tnn->nfsd4_manager.block_opens = true;\n\tlocks_start_grace(net, &nn->nfsd4_manager);\n\tnfsd4_client_tracking_init(net);\n\tprintk(KERN_INFO \"NFSD: starting %ld-second grace period (net %p)\\n\",\n\t       nn->nfsd4_grace, net);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, nn->nfsd4_grace * HZ);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_state_destroy_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6743-6768",
    "snippet": "static void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_net",
          "args": [
            "net"
          ],
          "line": 6767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->conf_id_hashtbl"
          ],
          "line": 6766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->unconf_id_hashtbl"
          ],
          "line": 6765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->sessionid_hashtbl"
          ],
          "line": 6764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_client",
          "args": [
            "clp"
          ],
          "line": 6760
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1834-1839",
          "snippet": "static void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nn->unconf_id_hashtbl[i].next",
            "structnfs4_client",
            "cl_idhash"
          ],
          "line": 6759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->unconf_id_hashtbl[i]"
          ],
          "line": 6758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nn->conf_id_hashtbl[i].next",
            "structnfs4_client",
            "cl_idhash"
          ],
          "line": 6752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->conf_id_hashtbl[i]"
          ],
          "line": 6751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_state_destroy_net(struct net *net)\n{\n\tint i;\n\tstruct nfs4_client *clp = NULL;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->conf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->conf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->unconf_id_hashtbl[i])) {\n\t\t\tclp = list_entry(nn->unconf_id_hashtbl[i].next, struct nfs4_client, cl_idhash);\n\t\t\tdestroy_client(clp);\n\t\t}\n\t}\n\n\tkfree(nn->sessionid_hashtbl);\n\tkfree(nn->unconf_id_hashtbl);\n\tkfree(nn->conf_id_hashtbl);\n\tput_net(net);\n}"
  },
  {
    "function_name": "nfs4_state_create_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6699-6741",
    "snippet": "static int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->conf_id_hashtbl"
          ],
          "line": 6738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->unconf_id_hashtbl"
          ],
          "line": 6736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_net",
          "args": [
            "net"
          ],
          "line": 6731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&nn->laundromat_work",
            "laundromat_main"
          ],
          "line": 6730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->del_recall_lru"
          ],
          "line": 6727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->close_lru"
          ],
          "line": 6726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->client_lru"
          ],
          "line": 6725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->sessionid_hashtbl[i]"
          ],
          "line": 6722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->unconf_id_hashtbl[i]"
          ],
          "line": 6719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->conf_id_hashtbl[i]"
          ],
          "line": 6718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 6712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 6708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 6704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 6701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_state_create_net(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->conf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->conf_id_hashtbl)\n\t\tgoto err;\n\tnn->unconf_id_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tCLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->unconf_id_hashtbl)\n\t\tgoto err_unconf_id;\n\tnn->sessionid_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tSESSION_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->sessionid_hashtbl)\n\t\tgoto err_sessionid;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\tINIT_LIST_HEAD(&nn->conf_id_hashtbl[i]);\n\t\tINIT_LIST_HEAD(&nn->unconf_id_hashtbl[i]);\n\t}\n\tfor (i = 0; i < SESSION_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->sessionid_hashtbl[i]);\n\tnn->conf_name_tree = RB_ROOT;\n\tnn->unconf_name_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&nn->client_lru);\n\tINIT_LIST_HEAD(&nn->close_lru);\n\tINIT_LIST_HEAD(&nn->del_recall_lru);\n\tspin_lock_init(&nn->client_lock);\n\n\tINIT_DELAYED_WORK(&nn->laundromat_work, laundromat_main);\n\tget_net(net);\n\n\treturn 0;\n\nerr_sessionid:\n\tkfree(nn->unconf_id_hashtbl);\nerr_unconf_id:\n\tkfree(nn->conf_id_hashtbl);\nerr:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "set_max_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6687-6697",
    "snippet": "static void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long max_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nr_free_buffer_pages",
          "args": [],
          "line": 6696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nunsigned long max_delegations;\n\nstatic void\nset_max_delegations(void)\n{\n\t/*\n\t * Allow at most 4 delegations per megabyte of RAM.  Quick\n\t * estimates suggest that in the worst case (where every delegation\n\t * is for a different inode), a delegation could take about 1.5K,\n\t * giving a worst case usage of about 6% of memory.\n\t */\n\tmax_delegations = nr_free_buffer_pages() >> (20 - 2 - PAGE_SHIFT);\n}"
  },
  {
    "function_name": "nfsd_inject_recall_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6654-6675",
    "snippet": "u64\nnfsd_inject_recall_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && ++count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_recall_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6673
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_recall_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6608-6629",
          "snippet": "static void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "max - count",
            "&reaplist"
          ],
          "line": 6668
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6479-6518",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "clp",
            "next",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_recall_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && ++count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_recall_client_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6631-6652",
    "snippet": "u64\nnfsd_inject_recall_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_recall_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6650
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_recall_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6608-6629",
          "snippet": "static void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "0",
            "&reaplist"
          ],
          "line": 6647
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6479-6518",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6645
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6095-6110",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_recall_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_recall_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_recall_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6608-6629",
    "snippet": "static void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 6627
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6089-6093",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_break_one_deleg",
          "args": [
            "dp"
          ],
          "line": 6626
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_break_one_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3704-3715",
          "snippet": "static void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 6625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 6623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 6615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dp",
            "next",
            "reaplist",
            "dl_recall_lru"
          ],
          "line": 6614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\nnfsd_recall_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\t/*\n\t\t * We skipped all entries that had a zero dl_time before,\n\t\t * so we can now reset the dl_time back to 0. If a delegation\n\t\t * break comes in now, then it won't make any difference since\n\t\t * we're recalling it either way.\n\t\t */\n\t\tspin_lock(&state_lock);\n\t\tdp->dl_time = 0;\n\t\tspin_unlock(&state_lock);\n\t\tnfsd_break_one_deleg(dp);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_forget_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6585-6606",
    "snippet": "u64\nnfsd_inject_forget_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_forget_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6604
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_forget_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6548-6560",
          "snippet": "static void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "max - count",
            "&reaplist"
          ],
          "line": 6599
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6479-6518",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_delegations(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_find_all_delegations(clp, max - count, &reaplist);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6562-6583",
    "snippet": "u64\nnfsd_inject_forget_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_forget_delegations",
          "args": [
            "&reaplist"
          ],
          "line": 6581
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_forget_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6548-6560",
          "snippet": "static void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "0",
            "&reaplist"
          ],
          "line": 6578
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6479-6518",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6576
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6095-6110",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client_delegations(struct sockaddr_storage *addr,\n\t\t\t\t      size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_find_all_delegations(clp, 0, &reaplist);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd_forget_delegations(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_forget_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6548-6560",
    "snippet": "static void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 6558
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6089-6093",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "revoke_delegation",
          "args": [
            "dp"
          ],
          "line": 6557
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "880-897",
          "snippet": "static void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 6555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dp",
            "next",
            "reaplist",
            "dl_recall_lru"
          ],
          "line": 6554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_forget_delegations(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_delegation *dp, *next;\n\n\tlist_for_each_entry_safe(dp, next, reaplist, dl_recall_lru) {\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tclp = dp->dl_stid.sc_client;\n\t\trevoke_delegation(dp);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_print_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6529-6546",
    "snippet": "u64\nnfsd_inject_print_delegations(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_delegations(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_print_client_delegations",
          "args": [
            "clp"
          ],
          "line": 6542
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_client_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6520-6527",
          "snippet": "static u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_delegations(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_delegations(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_print_client_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6520-6527",
    "snippet": "static u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_print_count",
          "args": [
            "clp",
            "count",
            "\"delegations\""
          ],
          "line": 6525
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6190-6196",
          "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_all_delegations",
          "args": [
            "clp",
            "0",
            "NULL"
          ],
          "line": 6523
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_all_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6479-6518",
          "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_delegations(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_find_all_delegations(clp, 0, NULL);\n\n\tnfsd_print_count(clp, count, \"delegations\");\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_find_all_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6479-6518",
    "snippet": "static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 6516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == (INT_MAX / 2)"
          ],
          "line": 6512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "victims"
          ],
          "line": 6503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!unhash_delegation_locked(dp)"
          ],
          "line": 6502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 6502
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "845-864",
          "snippet": "static bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 6501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dp",
            "next",
            "&clp->cl_delegations",
            "dl_perclnt"
          ],
          "line": 6490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 6489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,\n\t\t\t\t     struct list_head *victims)\n{\n\tstruct nfs4_delegation *dp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&state_lock);\n\tlist_for_each_entry_safe(dp, next, &clp->cl_delegations, dl_perclnt) {\n\t\tif (victims) {\n\t\t\t/*\n\t\t\t * It's not safe to mess with delegations that have a\n\t\t\t * non-zero dl_time. They might have already been broken\n\t\t\t * and could be processed by the laundromat outside of\n\t\t\t * the state_lock. Just leave them be.\n\t\t\t */\n\t\t\tif (dp->dl_time != 0)\n\t\t\t\tcontinue;\n\n\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\t\tlist_add(&dp->dl_recall_lru, victims);\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&state_lock);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6455-6477",
    "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_openowners",
          "args": [
            "&reaplist"
          ],
          "line": 6475
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6419-6431",
          "snippet": "static void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_openowners",
          "args": [
            "clp",
            "&reaplist",
            "max - count"
          ],
          "line": 6469
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6392-6398",
          "snippet": "static u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6433-6453",
    "snippet": "u64\nnfsd_inject_forget_client_openowners(struct sockaddr_storage *addr,\n\t\t\t\t     size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_openowners(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_openowners",
          "args": [
            "&reaplist"
          ],
          "line": 6451
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6419-6431",
          "snippet": "static void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_openowners",
          "args": [
            "clp",
            "&reaplist",
            "0"
          ],
          "line": 6449
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6392-6398",
          "snippet": "static u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6447
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6095-6110",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client_openowners(struct sockaddr_storage *addr,\n\t\t\t\t     size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_openowners(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_reap_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6419-6431",
    "snippet": "static void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 6429
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6089-6093",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_openowner",
          "args": [
            "oop"
          ],
          "line": 6428
        },
        "resolved": true,
        "details": {
          "function_name": "release_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1289-1309",
          "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oop->oo_perclient"
          ],
          "line": 6426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "oop",
            "next",
            "reaplist",
            "oo_perclient"
          ],
          "line": 6425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_openowners(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oop, *next;\n\n\tlist_for_each_entry_safe(oop, next, reaplist, oo_perclient) {\n\t\tlist_del_init(&oop->oo_perclient);\n\t\tclp = oop->oo_owner.so_client;\n\t\trelease_openowner(oop);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_print_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6400-6417",
    "snippet": "u64\nnfsd_inject_print_openowners(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_openowners(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_print_client_openowners",
          "args": [
            "clp"
          ],
          "line": 6413
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_client_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6383-6390",
          "snippet": "static u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_openowners(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_openowners(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_collect_client_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6392-6398",
    "snippet": "static u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_foreach_client_openowner",
          "args": [
            "clp",
            "max",
            "collect",
            "unhash_openowner_locked"
          ],
          "line": 6396
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6346-6381",
          "snippet": "static u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_openowners(struct nfs4_client *clp,\n\t\t\t       struct list_head *collect, u64 max)\n{\n\treturn nfsd_foreach_client_openowner(clp, max, collect,\n\t\t\t\t\t\tunhash_openowner_locked);\n}"
  },
  {
    "function_name": "nfsd_print_client_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6383-6390",
    "snippet": "static u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_print_count",
          "args": [
            "clp",
            "count",
            "\"openowners\""
          ],
          "line": 6388
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6190-6196",
          "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_foreach_client_openowner",
          "args": [
            "clp",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 6386
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6346-6381",
          "snippet": "static u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_openowners(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_openowner(clp, 0, NULL, NULL);\n\n\tnfsd_print_count(clp, count, \"openowners\");\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_foreach_client_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6346-6381",
    "snippet": "static u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 6378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == (INT_MAX / 2)"
          ],
          "line": 6374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&oop->oo_perclient",
            "collect"
          ],
          "line": 6364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 6363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "oop"
          ],
          "line": 6361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "oop",
            "next",
            "&clp->cl_openowners",
            "oo_perclient"
          ],
          "line": 6359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 6358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_foreach_client_openowner(struct nfs4_client *clp, u64 max,\n\t\t\t      struct list_head *collect,\n\t\t\t      void (*func)(struct nfs4_openowner *))\n{\n\tstruct nfs4_openowner *oop, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tu64 count = 0;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(oop, next, &clp->cl_openowners, oo_perclient) {\n\t\tif (func) {\n\t\t\tfunc(oop);\n\t\t\tif (collect) {\n\t\t\t\tatomic_inc(&clp->cl_refcount);\n\t\t\t\tlist_add(&oop->oo_perclient, collect);\n\t\t\t}\n\t\t}\n\t\t++count;\n\t\t/*\n\t\t * Despite the fact that these functions deal with\n\t\t * 64-bit integers for \"count\", we must ensure that\n\t\t * it doesn't blow up the clp->cl_refcount. Throw a\n\t\t * warning if we start to approach INT_MAX here.\n\t\t */\n\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\tif (count == max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6323-6344",
    "snippet": "u64\nnfsd_inject_forget_locks(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_locks(clp, &reaplist, max - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_locks",
          "args": [
            "&reaplist"
          ],
          "line": 6342
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6288-6300",
          "snippet": "static void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_locks",
          "args": [
            "clp",
            "&reaplist",
            "max - count"
          ],
          "line": 6337
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6254-6259",
          "snippet": "static u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_locks(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_locks(clp, &reaplist, max - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6302-6321",
    "snippet": "u64\nnfsd_inject_forget_client_locks(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_locks(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_reap_locks",
          "args": [
            "&reaplist"
          ],
          "line": 6319
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_reap_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6288-6300",
          "snippet": "static void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_collect_client_locks",
          "args": [
            "clp",
            "&reaplist",
            "0"
          ],
          "line": 6317
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_collect_client_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6254-6259",
          "snippet": "static u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6315
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6095-6110",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client_locks(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tunsigned int count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp)\n\t\tcount = nfsd_collect_client_locks(clp, &reaplist, 0);\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_locks(&reaplist);\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_reap_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6288-6300",
    "snippet": "static void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client",
          "args": [
            "clp"
          ],
          "line": 6298
        },
        "resolved": true,
        "details": {
          "function_name": "put_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6089-6093",
          "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 6297
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&stp->st_locks"
          ],
          "line": 6295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stp",
            "next",
            "reaplist",
            "st_locks"
          ],
          "line": 6294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_reap_locks(struct list_head *reaplist)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_ol_stateid *stp, *next;\n\n\tlist_for_each_entry_safe(stp, next, reaplist, st_locks) {\n\t\tlist_del_init(&stp->st_locks);\n\t\tclp = stp->st_stid.sc_client;\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tput_client(clp);\n\t}\n}"
  },
  {
    "function_name": "nfsd_inject_print_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6269-6286",
    "snippet": "u64\nnfsd_inject_print_locks(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_locks(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_print_client_locks",
          "args": [
            "clp"
          ],
          "line": 6282
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_client_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6261-6267",
          "snippet": "static u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_locks(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru)\n\t\tcount += nfsd_print_client_locks(clp);\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_print_client_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6261-6267",
    "snippet": "static u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_print_count",
          "args": [
            "clp",
            "count",
            "\"locked files\""
          ],
          "line": 6265
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_print_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6190-6196",
          "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_foreach_client_lock",
          "args": [
            "clp",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 6264
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6214-6252",
          "snippet": "static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    bool (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tif (func(lst))\n\t\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    bool (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tif (func(lst))\n\t\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_print_client_locks(struct nfs4_client *clp)\n{\n\tu64 count = nfsd_foreach_client_lock(clp, 0, NULL, NULL);\n\tnfsd_print_count(clp, count, \"locked files\");\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_collect_client_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6254-6259",
    "snippet": "static u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_foreach_client_lock",
          "args": [
            "clp",
            "max",
            "collect",
            "unhash_lock_stateid"
          ],
          "line": 6258
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_foreach_client_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6214-6252",
          "snippet": "static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    bool (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tif (func(lst))\n\t\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    bool (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tif (func(lst))\n\t\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64\nnfsd_collect_client_locks(struct nfs4_client *clp, struct list_head *collect,\n\t\t\t  u64 max)\n{\n\treturn nfsd_foreach_client_lock(clp, max, collect, unhash_lock_stateid);\n}"
  },
  {
    "function_name": "nfsd_foreach_client_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6214-6252",
    "snippet": "static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    bool (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tif (func(lst))\n\t\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 6249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "count == (INT_MAX / 2)"
          ],
          "line": 6242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_inject_add_lock_to_list",
          "args": [
            "lst",
            "collect"
          ],
          "line": 6231
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_add_lock_to_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6198-6212",
          "snippet": "static void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}"
        }
      },
      {
        "call_info": {
          "callee": "func",
          "args": [
            "lst"
          ],
          "line": 6230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lst",
            "lst_next",
            "&stp->st_locks",
            "st_locks"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "stp",
            "st_next",
            "&oop->oo_owner.so_stateids",
            "st_perstateowner"
          ],
          "line": 6225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "oop",
            "&clp->cl_openowners",
            "oo_perclient"
          ],
          "line": 6224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 6223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,\n\t\t\t\t    struct list_head *collect,\n\t\t\t\t    bool (*func)(struct nfs4_ol_stateid *))\n{\n\tstruct nfs4_openowner *oop;\n\tstruct nfs4_ol_stateid *stp, *st_next;\n\tstruct nfs4_ol_stateid *lst, *lst_next;\n\tu64 count = 0;\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(oop, &clp->cl_openowners, oo_perclient) {\n\t\tlist_for_each_entry_safe(stp, st_next,\n\t\t\t\t&oop->oo_owner.so_stateids, st_perstateowner) {\n\t\t\tlist_for_each_entry_safe(lst, lst_next,\n\t\t\t\t\t&stp->st_locks, st_locks) {\n\t\t\t\tif (func) {\n\t\t\t\t\tif (func(lst))\n\t\t\t\t\t\tnfsd_inject_add_lock_to_list(lst,\n\t\t\t\t\t\t\t\t\tcollect);\n\t\t\t\t}\n\t\t\t\t++count;\n\t\t\t\t/*\n\t\t\t\t * Despite the fact that these functions deal\n\t\t\t\t * with 64-bit integers for \"count\", we must\n\t\t\t\t * ensure that it doesn't blow up the\n\t\t\t\t * clp->cl_refcount. Throw a warning if we\n\t\t\t\t * start to approach INT_MAX here.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(count == (INT_MAX / 2));\n\t\t\t\tif (count == max)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\nout:\n\tspin_unlock(&clp->cl_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_add_lock_to_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6198-6212",
    "snippet": "static void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lst->st_locks",
            "collect"
          ],
          "line": 6211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,\n\t\t\t     struct list_head *collect)\n{\n\tstruct nfs4_client *clp = lst->st_stid.sc_client;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!collect)\n\t\treturn;\n\n\tlockdep_assert_held(&nn->client_lock);\n\tatomic_inc(&clp->cl_refcount);\n\tlist_add(&lst->st_locks, collect);\n}"
  },
  {
    "function_name": "nfsd_print_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6190-6196",
    "snippet": "static void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"NFS Client: %s has %u %s\\n\"",
            "buf",
            "count",
            "type"
          ],
          "line": 6195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&clp->cl_addr",
            "buf",
            "sizeof(buf)"
          ],
          "line": 6194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_print_count(struct nfs4_client *clp, unsigned int count,\n\t\t\t     const char *type)\n{\n\tchar buf[INET6_ADDRSTRLEN];\n\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\tprintk(KERN_INFO \"NFS Client: %s has %u %s\\n\", buf, count, type);\n}"
  },
  {
    "function_name": "nfsd_inject_forget_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6162-6188",
    "snippet": "u64\nnfsd_inject_forget_clients(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok) {\n\t\t\tlist_add(&clp->cl_lru, &reaplist);\n\t\t\tif (max != 0 && ++count >= max)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tlist_for_each_entry_safe(clp, next, &reaplist, cl_lru)\n\t\texpire_client(clp);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 6185
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "clp",
            "next",
            "&reaplist",
            "cl_lru"
          ],
          "line": 6184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&clp->cl_lru",
            "&reaplist"
          ],
          "line": 6177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "clp"
          ],
          "line": 6176
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1787-1793",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "clp",
            "next",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 6169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_clients(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp, *next;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry_safe(clp, next, &nn->client_lru, cl_lru) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok) {\n\t\t\tlist_add(&clp->cl_lru, &reaplist);\n\t\t\tif (max != 0 && ++count >= max)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tlist_for_each_entry_safe(clp, next, &reaplist, cl_lru)\n\t\texpire_client(clp);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_forget_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6135-6160",
    "snippet": "u64\nnfsd_inject_forget_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok)\n\t\t\t++count;\n\t\telse\n\t\t\tclp = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tif (clp)\n\t\texpire_client(clp);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 6157
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "clp"
          ],
          "line": 6149
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1787-1793",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_find_client",
          "args": [
            "addr",
            "addr_size"
          ],
          "line": 6147
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_find_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6095-6110",
          "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tclp = nfsd_find_client(addr, addr_size);\n\tif (clp) {\n\t\tif (mark_client_expired_locked(clp) == nfs_ok)\n\t\t\t++count;\n\t\telse\n\t\t\tclp = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tif (clp)\n\t\texpire_client(clp);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_inject_print_clients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6112-6133",
    "snippet": "u64\nnfsd_inject_print_clients(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\tchar buf[INET6_ADDRSTRLEN];\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\t\tpr_info(\"NFS Client: %s\\n\", buf);\n\t\t++count;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"NFS Client: %s\\n\"",
            "buf"
          ],
          "line": 6127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&clp->cl_addr",
            "buf",
            "sizeof(buf)"
          ],
          "line": 6126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 6124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_print_clients(void)\n{\n\tstruct nfs4_client *clp;\n\tu64 count = 0;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\tchar buf[INET6_ADDRSTRLEN];\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn 0;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\trpc_ntop((struct sockaddr *)&clp->cl_addr, buf, sizeof(buf));\n\t\tpr_info(\"NFS Client: %s\\n\", buf);\n\t\t++count;\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\treturn count;\n}"
  },
  {
    "function_name": "nfsd_find_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6095-6110",
    "snippet": "static struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&clp->cl_addr",
            "addr",
            "addr_size"
          ],
          "line": 6106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&nn->client_lru",
            "cl_lru"
          ],
          "line": 6105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_netns_ready",
          "args": [
            "nn"
          ],
          "line": 6102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "current->nsproxy->net_ns",
            "nfsd_net_id"
          ],
          "line": 6099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nnfsd_find_client(struct sockaddr_storage *addr, size_t addr_size)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t  nfsd_net_id);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn NULL;\n\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tif (memcmp(&clp->cl_addr, addr, addr_size) == 0)\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "put_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6089-6093",
    "snippet": "static inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 6092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nput_client(struct nfs4_client *clp)\n{\n\tatomic_dec(&clp->cl_refcount);\n}"
  },
  {
    "function_name": "nfs4_check_open_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6067-6086",
    "snippet": "__be32\nnfs4_check_open_reclaim(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\t__be32 status;\n\n\t/* find clientid in conf_id_hashtbl */\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn nfserr_reclaim_bad;\n\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(cstate->clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_client_record_check",
          "args": [
            "cstate->clp"
          ],
          "line": 6082
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1491-1500",
          "snippet": "int\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nint\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_RECLAIM_COMPLETE",
            "&cstate->clp->cl_flags"
          ],
          "line": 6079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clid",
            "cstate",
            "nn"
          ],
          "line": 6075
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3781-3815",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_check_open_reclaim(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\t__be32 status;\n\n\t/* find clientid in conf_id_hashtbl */\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn nfserr_reclaim_bad;\n\n\tif (test_bit(NFSD4_CLIENT_RECLAIM_COMPLETE, &cstate->clp->cl_flags))\n\t\treturn nfserr_no_grace;\n\n\tif (nfsd4_client_record_check(cstate->clp))\n\t\treturn nfserr_reclaim_bad;\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_find_reclaim_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6047-6062",
    "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "same_name",
          "args": [
            "crp->cr_recdir",
            "recdir"
          ],
          "line": 6057
        },
        "resolved": true,
        "details": {
          "function_name": "same_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1903-1906",
          "snippet": "static int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "crp",
            "&nn->reclaim_str_hashtbl[strhashval]",
            "cr_strhash"
          ],
          "line": 6056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientstr_hashval",
          "args": [
            "recdir"
          ],
          "line": 6055
        },
        "resolved": true,
        "details": {
          "function_name": "clientstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "908-911",
          "snippet": "static unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\"",
            "recdir"
          ],
          "line": 6053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_release_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6029-6043",
    "snippet": "void\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nn->reclaim_str_hashtbl_size"
          ],
          "line": 6042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_remove_reclaim_record",
          "args": [
            "crp",
            "nn"
          ],
          "line": 6039
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_remove_reclaim_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6021-6027",
          "snippet": "void\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "nn->reclaim_str_hashtbl[i].next",
            "structnfs4_client_reclaim",
            "cr_strhash"
          ],
          "line": 6037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->reclaim_str_hashtbl[i]"
          ],
          "line": 6036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}"
  },
  {
    "function_name": "nfs4_remove_reclaim_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6021-6027",
    "snippet": "void\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "crp"
          ],
          "line": 6025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&crp->cr_strhash"
          ],
          "line": 6024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}"
  },
  {
    "function_name": "nfs4_client_to_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "6002-6019",
    "snippet": "struct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "crp->cr_recdir",
            "name",
            "HEXDIR_LEN"
          ],
          "line": 6014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&crp->cr_strhash",
            "&nn->reclaim_str_hashtbl[strhashval]"
          ],
          "line": 6013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&crp->cr_strhash"
          ],
          "line": 6012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientstr_hashval",
          "args": [
            "name"
          ],
          "line": 6011
        },
        "resolved": true,
        "details": {
          "function_name": "clientstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "908-911",
          "snippet": "static unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_reclaim",
          "args": [],
          "line": 6009
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5984-5988",
          "snippet": "static inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\"",
            "HEXDIR_LEN",
            "name"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}"
  },
  {
    "function_name": "nfs4_has_reclaimed_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5990-5997",
    "snippet": "bool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_find_reclaim_client",
          "args": [
            "name",
            "nn"
          ],
          "line": 5995
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_reclaim_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6047-6062",
          "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nbool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}"
  },
  {
    "function_name": "alloc_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5984-5988",
    "snippet": "static inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nfs4_client_reclaim)",
            "GFP_KERNEL"
          ],
          "line": 5987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_client_reclaim *\nalloc_reclaim(void)\n{\n\treturn kmalloc(sizeof(struct nfs4_client_reclaim), GFP_KERNEL);\n}"
  },
  {
    "function_name": "nfsd4_release_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5934-5982",
    "snippet": "__be32\nnfsd4_release_lockowner(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tstruct nfsd4_release_lockowner *rlockowner)\n{\n\tclientid_t *clid = &rlockowner->rl_clientid;\n\tstruct nfs4_stateowner *sop;\n\tstruct nfs4_lockowner *lo = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct xdr_netobj *owner = &rlockowner->rl_owner;\n\tunsigned int hashval = ownerstr_hashval(owner);\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct nfs4_client *clp;\n\n\tdprintk(\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\",\n\t\tclid->cl_boot, clid->cl_id);\n\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\n\tclp = cstate->clp;\n\t/* Find the matching lock stateowner */\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(sop, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\n\t\tif (sop->so_is_open_owner || !same_owner_str(sop, owner))\n\t\t\tcontinue;\n\n\t\t/* see if there are still any locks associated with it */\n\t\tlo = lockowner(sop);\n\t\tlist_for_each_entry(stp, &sop->so_stateids, st_perstateowner) {\n\t\t\tif (check_for_locks(stp->st_stid.sc_file, lo)) {\n\t\t\t\tstatus = nfserr_locks_held;\n\t\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tnfs4_get_stateowner(sop);\n\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (lo)\n\t\trelease_lockowner(lo);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_lockowner",
          "args": [
            "lo"
          ],
          "line": 5980
        },
        "resolved": true,
        "details": {
          "function_name": "release_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1203-1222",
          "snippet": "static void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "sop"
          ],
          "line": 5975
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_for_locks",
          "args": [
            "stp->st_stid.sc_file",
            "lo"
          ],
          "line": 5968
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5902-5932",
          "snippet": "static bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\n\nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "stp",
            "&sop->so_stateids",
            "st_perstateowner"
          ],
          "line": 5967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "sop"
          ],
          "line": 5966
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_owner_str",
          "args": [
            "sop",
            "owner"
          ],
          "line": 5962
        },
        "resolved": true,
        "details": {
          "function_name": "same_owner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "220-225",
          "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sop",
            "&clp->cl_ownerstr_hashtbl[hashval]",
            "so_strhash"
          ],
          "line": 5959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clid",
            "cstate",
            "nn"
          ],
          "line": 5952
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3781-3815",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\"",
            "clid->cl_boot",
            "clid->cl_id"
          ],
          "line": 5949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "owner"
          ],
          "line": 5944
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "376-382",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_release_lockowner(struct svc_rqst *rqstp,\n\t\t\tstruct nfsd4_compound_state *cstate,\n\t\t\tstruct nfsd4_release_lockowner *rlockowner)\n{\n\tclientid_t *clid = &rlockowner->rl_clientid;\n\tstruct nfs4_stateowner *sop;\n\tstruct nfs4_lockowner *lo = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct xdr_netobj *owner = &rlockowner->rl_owner;\n\tunsigned int hashval = ownerstr_hashval(owner);\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct nfs4_client *clp;\n\n\tdprintk(\"nfsd4_release_lockowner clientid: (%08x/%08x):\\n\",\n\t\tclid->cl_boot, clid->cl_id);\n\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\n\tclp = cstate->clp;\n\t/* Find the matching lock stateowner */\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(sop, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\n\t\tif (sop->so_is_open_owner || !same_owner_str(sop, owner))\n\t\t\tcontinue;\n\n\t\t/* see if there are still any locks associated with it */\n\t\tlo = lockowner(sop);\n\t\tlist_for_each_entry(stp, &sop->so_stateids, st_perstateowner) {\n\t\t\tif (check_for_locks(stp->st_stid.sc_file, lo)) {\n\t\t\t\tstatus = nfserr_locks_held;\n\t\t\t\tspin_unlock(&clp->cl_lock);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\tnfs4_get_stateowner(sop);\n\t\tbreak;\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (lo)\n\t\trelease_lockowner(lo);\n\treturn status;\n}"
  },
  {
    "function_name": "check_for_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5902-5932",
    "snippet": "static bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 5930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 5928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fl",
            "&flctx->flc_posix",
            "fl_list"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&flctx->flc_lock"
          ],
          "line": 5921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&flctx->flc_posix"
          ],
          "line": 5920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 5917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 5913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "fp"
          ],
          "line": 5907
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "348-362",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\n\nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_locku",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5828-5895",
    "snippet": "__be32\nnfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_locku *locku)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\t__be32 status;\n\tint err;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\",\n\t\t(long long) locku->lu_offset,\n\t\t(long long) locku->lu_length);\n\n\tif (check_lock_length(locku->lu_offset, locku->lu_length))\n\t\t return nfserr_inval;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, locku->lu_seqid,\n\t\t\t\t\t&locku->lu_stateid, NFS4_LOCK_STID,\n\t\t\t\t\t&stp, nn);\n\tif (status)\n\t\tgoto out;\n\tfilp = find_any_file(stp->st_stid.sc_file);\n\tif (!filp) {\n\t\tstatus = nfserr_lock_range;\n\t\tgoto put_stateid;\n\t}\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto fput;\n\t}\n\n\tfile_lock->fl_type = F_UNLCK;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(stp->st_stateowner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = locku->lu_offset;\n\n\tfile_lock->fl_end = last_byte_offset(locku->lu_offset,\n\t\t\t\t\t\tlocku->lu_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, NULL);\n\tif (err) {\n\t\tdprintk(\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\");\n\t\tgoto out_nfserr;\n\t}\n\tnfs4_inc_and_copy_stateid(&locku->lu_stateid, &stp->st_stid);\nfput:\n\tfput(filp);\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto fput;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 5893
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 5889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 5887
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1337-1354",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5885
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 5884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 5882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&locku->lu_stateid",
            "&stp->st_stid"
          ],
          "line": 5880
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\""
          ],
          "line": 5877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "F_SETLK",
            "file_lock",
            "NULL"
          ],
          "line": 5875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_transform_lock_offset",
          "args": [
            "file_lock"
          ],
          "line": 5873
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_transform_lock_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5272-5279",
          "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_byte_offset",
          "args": [
            "locku->lu_offset",
            "locku->lu_length"
          ],
          "line": 5871
        },
        "resolved": true,
        "details": {
          "function_name": "last_byte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5254-5262",
          "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "nfs4_get_stateowner(stp->st_stateowner)"
          ],
          "line": 5864
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 5864
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "stp->st_stid.sc_file"
          ],
          "line": 5851
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "348-362",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "locku->lu_seqid",
            "&locku->lu_stateid",
            "NFS4_LOCK_STID",
            "&stp",
            "nn"
          ],
          "line": 5846
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4999-5025",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_lock_length",
          "args": [
            "locku->lu_offset",
            "locku->lu_length"
          ],
          "line": 5843
        },
        "resolved": true,
        "details": {
          "function_name": "check_lock_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5490-5495",
          "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\"",
            "(long long) locku->lu_offset",
            "(long long) locku->lu_length"
          ],
          "line": 5839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\n__be32\nnfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_locku *locku)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\t__be32 status;\n\tint err;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_locku: start=%Ld length=%Ld\\n\",\n\t\t(long long) locku->lu_offset,\n\t\t(long long) locku->lu_length);\n\n\tif (check_lock_length(locku->lu_offset, locku->lu_length))\n\t\t return nfserr_inval;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, locku->lu_seqid,\n\t\t\t\t\t&locku->lu_stateid, NFS4_LOCK_STID,\n\t\t\t\t\t&stp, nn);\n\tif (status)\n\t\tgoto out;\n\tfilp = find_any_file(stp->st_stid.sc_file);\n\tif (!filp) {\n\t\tstatus = nfserr_lock_range;\n\t\tgoto put_stateid;\n\t}\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto fput;\n\t}\n\n\tfile_lock->fl_type = F_UNLCK;\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(stp->st_stateowner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = locku->lu_offset;\n\n\tfile_lock->fl_end = last_byte_offset(locku->lu_offset,\n\t\t\t\t\t\tlocku->lu_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, NULL);\n\tif (err) {\n\t\tdprintk(\"NFSD: nfs4_locku: vfs_lock_file failed!\\n\");\n\t\tgoto out_nfserr;\n\t}\n\tnfs4_inc_and_copy_stateid(&locku->lu_stateid, &stp->st_stid);\nfput:\n\tfput(filp);\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n\nout_nfserr:\n\tstatus = nfserrno(err);\n\tgoto fput;\n}"
  },
  {
    "function_name": "nfsd4_lockt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5755-5826",
    "snippet": "__be32\nnfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_lockt *lockt)\n{\n\tstruct file_lock *file_lock = NULL;\n\tstruct nfs4_lockowner *lo = NULL;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tif (check_lock_length(lockt->lt_offset, lockt->lt_length))\n\t\t return nfserr_inval;\n\n\tif (!nfsd4_has_session(cstate)) {\n\t\tstatus = lookup_clientid(&lockt->lt_clientid, cstate, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tswitch (lockt->lt_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: nfs4_lockt: bad lock type!\\n\");\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tlo = find_lockowner_str(cstate->clp, &lockt->lt_owner);\n\tif (lo)\n\t\tfile_lock->fl_owner = (fl_owner_t)lo;\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_flags = FL_POSIX;\n\n\tfile_lock->fl_start = lockt->lt_offset;\n\tfile_lock->fl_end = last_byte_offset(lockt->lt_offset, lockt->lt_length);\n\n\tnfs4_transform_lock_offset(file_lock);\n\n\tstatus = nfsd_test_lock(rqstp, &cstate->current_fh, file_lock);\n\tif (status)\n\t\tgoto out;\n\n\tif (file_lock->fl_type != F_UNLCK) {\n\t\tstatus = nfserr_denied;\n\t\tnfs4_set_lock_denied(file_lock, &lockt->lt_denied);\n\t}\nout:\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 5824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5822
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_set_lock_denied",
          "args": [
            "file_lock",
            "&lockt->lt_denied"
          ],
          "line": 5818
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5304-5332",
          "snippet": "static inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_test_lock",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "file_lock"
          ],
          "line": 5812
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_test_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5741-5750",
          "snippet": "static __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tfput(file);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tfput(file);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_transform_lock_offset",
          "args": [
            "file_lock"
          ],
          "line": 5810
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_transform_lock_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5272-5279",
          "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_byte_offset",
          "args": [
            "lockt->lt_offset",
            "lockt->lt_length"
          ],
          "line": 5808
        },
        "resolved": true,
        "details": {
          "function_name": "last_byte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5254-5262",
          "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lockowner_str",
          "args": [
            "cstate->clp",
            "&lockt->lt_owner"
          ],
          "line": 5801
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5352-5361",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_lockt: bad lock type!\\n\""
          ],
          "line": 5796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "0"
          ],
          "line": 5776
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "&lockt->lt_clientid",
            "cstate",
            "nn"
          ],
          "line": 5771
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3781-3815",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 5770
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_lock_length",
          "args": [
            "lockt->lt_offset",
            "lockt->lt_length"
          ],
          "line": 5767
        },
        "resolved": true,
        "details": {
          "function_name": "check_lock_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5490-5495",
          "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "SVC_NET(rqstp)"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_lockt *lockt)\n{\n\tstruct file_lock *file_lock = NULL;\n\tstruct nfs4_lockowner *lo = NULL;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (locks_in_grace(SVC_NET(rqstp)))\n\t\treturn nfserr_grace;\n\n\tif (check_lock_length(lockt->lt_offset, lockt->lt_length))\n\t\t return nfserr_inval;\n\n\tif (!nfsd4_has_session(cstate)) {\n\t\tstatus = lookup_clientid(&lockt->lt_clientid, cstate, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tswitch (lockt->lt_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\tbreak;\n\t\tdefault:\n\t\t\tdprintk(\"NFSD: nfs4_lockt: bad lock type!\\n\");\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\n\tlo = find_lockowner_str(cstate->clp, &lockt->lt_owner);\n\tif (lo)\n\t\tfile_lock->fl_owner = (fl_owner_t)lo;\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_flags = FL_POSIX;\n\n\tfile_lock->fl_start = lockt->lt_offset;\n\tfile_lock->fl_end = last_byte_offset(lockt->lt_offset, lockt->lt_length);\n\n\tnfs4_transform_lock_offset(file_lock);\n\n\tstatus = nfsd_test_lock(rqstp, &cstate->current_fh, file_lock);\n\tif (status)\n\t\tgoto out;\n\n\tif (file_lock->fl_type != F_UNLCK) {\n\t\tstatus = nfserr_denied;\n\t\tnfs4_set_lock_denied(file_lock, &lockt->lt_denied);\n\t}\nout:\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd_test_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5741-5750",
    "snippet": "static __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tfput(file);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 5747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "vfs_test_lock(file, lock)"
          ],
          "line": 5746
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_test_lock",
          "args": [
            "file",
            "lock"
          ],
          "line": 5746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_open",
          "args": [
            "rqstp",
            "fhp",
            "S_IFREG",
            "NFSD_MAY_READ",
            "&file"
          ],
          "line": 5744
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "651-736",
          "snippet": "__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tfput(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tfput(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd_test_lock(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file_lock *lock)\n{\n\tstruct file *file;\n\t__be32 err = nfsd_open(rqstp, fhp, S_IFREG, NFSD_MAY_READ, &file);\n\tif (!err) {\n\t\terr = nfserrno(vfs_test_lock(file, lock));\n\t\tfput(file);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "nfsd4_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5551-5733",
    "snippet": "__be32\nnfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_openowner *open_sop = NULL;\n\tstruct nfs4_lockowner *lock_sop = NULL;\n\tstruct nfs4_ol_stateid *lock_stp = NULL;\n\tstruct nfs4_ol_stateid *open_stp = NULL;\n\tstruct nfs4_file *fp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\tstruct file_lock *conflock = NULL;\n\t__be32 status = 0;\n\tint lkflg;\n\tint err;\n\tbool new = false;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\",\n\t\t(long long) lock->lk_offset,\n\t\t(long long) lock->lk_length);\n\n\tif (check_lock_length(lock->lk_offset, lock->lk_length))\n\t\t return nfserr_inval;\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh,\n\t\t\t\tS_IFREG, NFSD_MAY_LOCK))) {\n\t\tdprintk(\"NFSD: nfsd4_lock: permission denied!\\n\");\n\t\treturn status;\n\t}\n\n\tif (lock->lk_is_new) {\n\t\tif (nfsd4_has_session(cstate))\n\t\t\t/* See rfc 5661 18.10.3: given clientid is ignored: */\n\t\t\tmemcpy(&lock->lk_new_clientid,\n\t\t\t\t&cstate->session->se_client->cl_clientid,\n\t\t\t\tsizeof(clientid_t));\n\n\t\tstatus = nfserr_stale_clientid;\n\t\tif (STALE_CLIENTID(&lock->lk_new_clientid, nn))\n\t\t\tgoto out;\n\n\t\t/* validate and update open stateid and open seqid */\n\t\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate,\n\t\t\t\t        lock->lk_new_open_seqid,\n\t\t                        &lock->lk_new_open_stateid,\n\t\t\t\t\t&open_stp, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tmutex_unlock(&open_stp->st_mutex);\n\t\topen_sop = openowner(open_stp->st_stateowner);\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (!same_clid(&open_sop->oo_owner.so_client->cl_clientid,\n\t\t\t\t\t\t&lock->lk_new_clientid))\n\t\t\tgoto out;\n\t\tstatus = lookup_or_create_lock_state(cstate, open_stp, lock,\n\t\t\t\t\t\t\t&lock_stp, &new);\n\t\tif (status == nfs_ok)\n\t\t\tmutex_lock(&lock_stp->st_mutex);\n\t} else {\n\t\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t       lock->lk_old_lock_seqid,\n\t\t\t\t       &lock->lk_old_lock_stateid,\n\t\t\t\t       NFS4_LOCK_STID, &lock_stp, nn);\n\t}\n\tif (status)\n\t\tgoto out;\n\tlock_sop = lockowner(lock_stp->st_stateowner);\n\n\tlkflg = setlkflg(lock->lk_type);\n\tstatus = nfs4_check_openmode(lock_stp, lkflg);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && !lock->lk_reclaim)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && lock->lk_reclaim)\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tfp = lock_stp->st_stid.sc_file;\n\tswitch (lock->lk_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_readable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_READ);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_writeable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_WRITE);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\tif (!filp) {\n\t\tstatus = nfserr_openmode;\n\t\tgoto out;\n\t}\n\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lock_sop->lo_owner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = lock->lk_offset;\n\tfile_lock->fl_end = last_byte_offset(lock->lk_offset, lock->lk_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\tconflock = locks_alloc_lock();\n\tif (!conflock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, conflock);\n\tswitch (-err) {\n\tcase 0: /* success! */\n\t\tnfs4_inc_and_copy_stateid(&lock->lk_resp_stateid, &lock_stp->st_stid);\n\t\tstatus = 0;\n\t\tbreak;\n\tcase (EAGAIN):\t\t/* conflock holds conflicting lock */\n\t\tstatus = nfserr_denied;\n\t\tdprintk(\"NFSD: nfsd4_lock: conflicting lock found!\\n\");\n\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);\n\t\tbreak;\n\tcase (EDEADLK):\n\t\tstatus = nfserr_deadlock;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);\n\t\tstatus = nfserrno(err);\n\t\tbreak;\n\t}\nout:\n\tif (filp)\n\t\tfput(filp);\n\tif (lock_stp) {\n\t\t/* Bump seqid manually if the 4.0 replay owner is openowner */\n\t\tif (cstate->replay_owner &&\n\t\t    cstate->replay_owner != &lock_sop->lo_owner &&\n\t\t    seqid_mutating_err(ntohl(status)))\n\t\t\tlock_sop->lo_owner.so_seqid++;\n\n\t\tmutex_unlock(&lock_stp->st_mutex);\n\n\t\t/*\n\t\t * If this is a new, never-before-used stateid, and we are\n\t\t * returning an error, then just go ahead and release it.\n\t\t */\n\t\tif (status && new)\n\t\t\trelease_lock_stateid(lock_stp);\n\n\t\tnfs4_put_stid(&lock_stp->st_stid);\n\t}\n\tif (open_stp)\n\t\tnfs4_put_stid(&open_stp->st_stid);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\tif (conflock)\n\t\tlocks_free_lock(conflock);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "conflock"
          ],
          "line": 5731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "file_lock"
          ],
          "line": 5729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 5727
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1337-1354",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&open_stp->st_stid"
          ],
          "line": 5726
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_lock_stateid",
          "args": [
            "lock_stp"
          ],
          "line": 5721
        },
        "resolved": true,
        "details": {
          "function_name": "release_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1159-1169",
          "snippet": "static void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\tbool unhashed;\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhashed = unhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (unhashed)\n\t\tnfs4_put_stid(&stp->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\tbool unhashed;\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhashed = unhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (unhashed)\n\t\tnfs4_put_stid(&stp->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&lock_stp->st_mutex"
          ],
          "line": 5714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seqid_mutating_err",
          "args": [
            "ntohl(status)"
          ],
          "line": 5711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "status"
          ],
          "line": 5711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 5706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "err"
          ],
          "line": 5701
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\"",
            "err"
          ],
          "line": 5700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_lock_denied",
          "args": [
            "conflock",
            "&lock->lk_denied"
          ],
          "line": 5694
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_lock_denied",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5304-5332",
          "snippet": "static inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: conflicting lock found!\\n\""
          ],
          "line": 5693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&lock->lk_resp_stateid",
            "&lock_stp->st_stid"
          ],
          "line": 5688
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_lock_file",
          "args": [
            "filp",
            "F_SETLK",
            "file_lock",
            "conflock"
          ],
          "line": 5685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 5678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_transform_lock_offset",
          "args": [
            "file_lock"
          ],
          "line": 5676
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_transform_lock_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5272-5279",
          "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "last_byte_offset",
          "args": [
            "lock->lk_offset",
            "lock->lk_length"
          ],
          "line": 5675
        },
        "resolved": true,
        "details": {
          "function_name": "last_byte_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5254-5262",
          "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "nfs4_get_stateowner(&lock_sop->lo_owner)"
          ],
          "line": 5669
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&lock_sop->lo_owner"
          ],
          "line": 5669
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_lock_access",
          "args": [
            "lock_stp",
            "NFS4_SHARE_ACCESS_WRITE"
          ],
          "line": 5656
        },
        "resolved": true,
        "details": {
          "function_name": "get_lock_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5497-5507",
          "snippet": "static void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_writeable_file_locked",
          "args": [
            "fp"
          ],
          "line": 5654
        },
        "resolved": true,
        "details": {
          "function_name": "find_writeable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "299-310",
          "snippet": "static struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_readable_file_locked",
          "args": [
            "fp"
          ],
          "line": 5645
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "324-334",
          "snippet": "static struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: unable to allocate lock!\\n\"",
            "__func__"
          ],
          "line": 5635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 5633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "net"
          ],
          "line": 5630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "net"
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_check_openmode",
          "args": [
            "lock_stp",
            "lkflg"
          ],
          "line": 5622
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_openmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4617-4632",
          "snippet": "static\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setlkflg",
          "args": [
            "lock->lk_type"
          ],
          "line": 5621
        },
        "resolved": true,
        "details": {
          "function_name": "setlkflg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4963-4968",
          "snippet": "static inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "lock->lk_old_lock_seqid",
            "&lock->lk_old_lock_stateid",
            "NFS4_LOCK_STID",
            "&lock_stp",
            "nn"
          ],
          "line": 5612
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4999-5025",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&lock_stp->st_mutex"
          ],
          "line": 5610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_or_create_lock_state",
          "args": [
            "cstate",
            "open_stp",
            "lock",
            "&lock_stp",
            "&new"
          ],
          "line": 5607
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_or_create_lock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5509-5546",
          "snippet": "static __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = d_inode(cstate->current_fh.fh_dentry);\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(cl, &lock->lk_new_owner);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->lk_new_owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = d_inode(cstate->current_fh.fh_dentry);\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(cl, &lock->lk_new_owner);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->lk_new_owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&open_sop->oo_owner.so_client->cl_clientid",
            "&lock->lk_new_clientid"
          ],
          "line": 5604
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1914-1918",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "open_stp->st_stateowner"
          ],
          "line": 5602
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&open_stp->st_mutex"
          ],
          "line": 5601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_confirmed_seqid_op",
          "args": [
            "cstate",
            "lock->lk_new_open_seqid",
            "&lock->lk_new_open_stateid",
            "&open_stp",
            "nn"
          ],
          "line": 5595
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_confirmed_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5027-5046",
          "snippet": "static __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "&lock->lk_new_clientid",
            "nn"
          ],
          "line": 5591
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1672-1685",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lock->lk_new_clientid",
            "&cstate->session->se_client->cl_clientid",
            "sizeof(clientid_t)"
          ],
          "line": 5586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 5584
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: permission denied!\\n\""
          ],
          "line": 5579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "NFSD_MAY_LOCK"
          ],
          "line": 5577
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_lock_length",
          "args": [
            "lock->lk_offset",
            "lock->lk_length"
          ],
          "line": 5574
        },
        "resolved": true,
        "details": {
          "function_name": "check_lock_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5490-5495",
          "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\"",
            "(long long) lock->lk_offset",
            "(long long) lock->lk_length"
          ],
          "line": 5570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\n__be32\nnfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_openowner *open_sop = NULL;\n\tstruct nfs4_lockowner *lock_sop = NULL;\n\tstruct nfs4_ol_stateid *lock_stp = NULL;\n\tstruct nfs4_ol_stateid *open_stp = NULL;\n\tstruct nfs4_file *fp;\n\tstruct file *filp = NULL;\n\tstruct file_lock *file_lock = NULL;\n\tstruct file_lock *conflock = NULL;\n\t__be32 status = 0;\n\tint lkflg;\n\tint err;\n\tbool new = false;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_lock: start=%Ld length=%Ld\\n\",\n\t\t(long long) lock->lk_offset,\n\t\t(long long) lock->lk_length);\n\n\tif (check_lock_length(lock->lk_offset, lock->lk_length))\n\t\t return nfserr_inval;\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh,\n\t\t\t\tS_IFREG, NFSD_MAY_LOCK))) {\n\t\tdprintk(\"NFSD: nfsd4_lock: permission denied!\\n\");\n\t\treturn status;\n\t}\n\n\tif (lock->lk_is_new) {\n\t\tif (nfsd4_has_session(cstate))\n\t\t\t/* See rfc 5661 18.10.3: given clientid is ignored: */\n\t\t\tmemcpy(&lock->lk_new_clientid,\n\t\t\t\t&cstate->session->se_client->cl_clientid,\n\t\t\t\tsizeof(clientid_t));\n\n\t\tstatus = nfserr_stale_clientid;\n\t\tif (STALE_CLIENTID(&lock->lk_new_clientid, nn))\n\t\t\tgoto out;\n\n\t\t/* validate and update open stateid and open seqid */\n\t\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate,\n\t\t\t\t        lock->lk_new_open_seqid,\n\t\t                        &lock->lk_new_open_stateid,\n\t\t\t\t\t&open_stp, nn);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tmutex_unlock(&open_stp->st_mutex);\n\t\topen_sop = openowner(open_stp->st_stateowner);\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (!same_clid(&open_sop->oo_owner.so_client->cl_clientid,\n\t\t\t\t\t\t&lock->lk_new_clientid))\n\t\t\tgoto out;\n\t\tstatus = lookup_or_create_lock_state(cstate, open_stp, lock,\n\t\t\t\t\t\t\t&lock_stp, &new);\n\t\tif (status == nfs_ok)\n\t\t\tmutex_lock(&lock_stp->st_mutex);\n\t} else {\n\t\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t       lock->lk_old_lock_seqid,\n\t\t\t\t       &lock->lk_old_lock_stateid,\n\t\t\t\t       NFS4_LOCK_STID, &lock_stp, nn);\n\t}\n\tif (status)\n\t\tgoto out;\n\tlock_sop = lockowner(lock_stp->st_stateowner);\n\n\tlkflg = setlkflg(lock->lk_type);\n\tstatus = nfs4_check_openmode(lock_stp, lkflg);\n\tif (status)\n\t\tgoto out;\n\n\tstatus = nfserr_grace;\n\tif (locks_in_grace(net) && !lock->lk_reclaim)\n\t\tgoto out;\n\tstatus = nfserr_no_grace;\n\tif (!locks_in_grace(net) && lock->lk_reclaim)\n\t\tgoto out;\n\n\tfile_lock = locks_alloc_lock();\n\tif (!file_lock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\tfp = lock_stp->st_stid.sc_file;\n\tswitch (lock->lk_type) {\n\t\tcase NFS4_READ_LT:\n\t\tcase NFS4_READW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_readable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_READ);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_RDLCK;\n\t\t\tbreak;\n\t\tcase NFS4_WRITE_LT:\n\t\tcase NFS4_WRITEW_LT:\n\t\t\tspin_lock(&fp->fi_lock);\n\t\t\tfilp = find_writeable_file_locked(fp);\n\t\t\tif (filp)\n\t\t\t\tget_lock_access(lock_stp, NFS4_SHARE_ACCESS_WRITE);\n\t\t\tspin_unlock(&fp->fi_lock);\n\t\t\tfile_lock->fl_type = F_WRLCK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = nfserr_inval;\n\t\tgoto out;\n\t}\n\tif (!filp) {\n\t\tstatus = nfserr_openmode;\n\t\tgoto out;\n\t}\n\n\tfile_lock->fl_owner = (fl_owner_t)lockowner(nfs4_get_stateowner(&lock_sop->lo_owner));\n\tfile_lock->fl_pid = current->tgid;\n\tfile_lock->fl_file = filp;\n\tfile_lock->fl_flags = FL_POSIX;\n\tfile_lock->fl_lmops = &nfsd_posix_mng_ops;\n\tfile_lock->fl_start = lock->lk_offset;\n\tfile_lock->fl_end = last_byte_offset(lock->lk_offset, lock->lk_length);\n\tnfs4_transform_lock_offset(file_lock);\n\n\tconflock = locks_alloc_lock();\n\tif (!conflock) {\n\t\tdprintk(\"NFSD: %s: unable to allocate lock!\\n\", __func__);\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\n\terr = vfs_lock_file(filp, F_SETLK, file_lock, conflock);\n\tswitch (-err) {\n\tcase 0: /* success! */\n\t\tnfs4_inc_and_copy_stateid(&lock->lk_resp_stateid, &lock_stp->st_stid);\n\t\tstatus = 0;\n\t\tbreak;\n\tcase (EAGAIN):\t\t/* conflock holds conflicting lock */\n\t\tstatus = nfserr_denied;\n\t\tdprintk(\"NFSD: nfsd4_lock: conflicting lock found!\\n\");\n\t\tnfs4_set_lock_denied(conflock, &lock->lk_denied);\n\t\tbreak;\n\tcase (EDEADLK):\n\t\tstatus = nfserr_deadlock;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"NFSD: nfsd4_lock: vfs_lock_file() failed! status %d\\n\",err);\n\t\tstatus = nfserrno(err);\n\t\tbreak;\n\t}\nout:\n\tif (filp)\n\t\tfput(filp);\n\tif (lock_stp) {\n\t\t/* Bump seqid manually if the 4.0 replay owner is openowner */\n\t\tif (cstate->replay_owner &&\n\t\t    cstate->replay_owner != &lock_sop->lo_owner &&\n\t\t    seqid_mutating_err(ntohl(status)))\n\t\t\tlock_sop->lo_owner.so_seqid++;\n\n\t\tmutex_unlock(&lock_stp->st_mutex);\n\n\t\t/*\n\t\t * If this is a new, never-before-used stateid, and we are\n\t\t * returning an error, then just go ahead and release it.\n\t\t */\n\t\tif (status && new)\n\t\t\trelease_lock_stateid(lock_stp);\n\n\t\tnfs4_put_stid(&lock_stp->st_stid);\n\t}\n\tif (open_stp)\n\t\tnfs4_put_stid(&open_stp->st_stid);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (file_lock)\n\t\tlocks_free_lock(file_lock);\n\tif (conflock)\n\t\tlocks_free_lock(conflock);\n\treturn status;\n}"
  },
  {
    "function_name": "lookup_or_create_lock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5509-5546",
    "snippet": "static __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = d_inode(cstate->current_fh.fh_dentry);\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(cl, &lock->lk_new_owner);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->lk_new_owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5544
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_create_lock_stateid",
          "args": [
            "lo",
            "fi",
            "inode",
            "ost",
            "new"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "find_or_create_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5457-5488",
          "snippet": "static struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *stateid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_init_lock_stateowner",
          "args": [
            "strhashval",
            "cl",
            "ost",
            "lock"
          ],
          "line": 5526
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_init_lock_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5387-5412",
          "snippet": "static struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(clp, &lock->lk_new_owner);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_stateowner(&lo->lo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;",
            "static const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\nstatic const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};\n\nstatic struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(clp, &lock->lk_new_owner);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_stateowner(&lo->lo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "&lock->lk_new_owner"
          ],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "376-382",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lockowner_str",
          "args": [
            "cl",
            "&lock->lk_new_owner"
          ],
          "line": 5523
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5352-5361",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "cstate->current_fh.fh_dentry"
          ],
          "line": 5519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "ost->st_stateowner"
          ],
          "line": 5517
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nlookup_or_create_lock_state(struct nfsd4_compound_state *cstate,\n\t\t\t    struct nfs4_ol_stateid *ost,\n\t\t\t    struct nfsd4_lock *lock,\n\t\t\t    struct nfs4_ol_stateid **lst, bool *new)\n{\n\t__be32 status;\n\tstruct nfs4_file *fi = ost->st_stid.sc_file;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *cl = oo->oo_owner.so_client;\n\tstruct inode *inode = d_inode(cstate->current_fh.fh_dentry);\n\tstruct nfs4_lockowner *lo;\n\tunsigned int strhashval;\n\n\tlo = find_lockowner_str(cl, &lock->lk_new_owner);\n\tif (!lo) {\n\t\tstrhashval = ownerstr_hashval(&lock->lk_new_owner);\n\t\tlo = alloc_init_lock_stateowner(strhashval, cl, ost, lock);\n\t\tif (lo == NULL)\n\t\t\treturn nfserr_jukebox;\n\t} else {\n\t\t/* with an existing lockowner, seqids must be the same */\n\t\tstatus = nfserr_bad_seqid;\n\t\tif (!cstate->minorversion &&\n\t\t    lock->lk_new_lock_seqid != lo->lo_owner.so_seqid)\n\t\t\tgoto out;\n\t}\n\n\t*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);\n\tif (*lst == NULL) {\n\t\tstatus = nfserr_jukebox;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\nout:\n\tnfs4_put_stateowner(&lo->lo_owner);\n\treturn status;\n}"
  },
  {
    "function_name": "get_lock_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5497-5507",
    "snippet": "static void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_access",
          "args": [
            "access",
            "lock_stp"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "set_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "944-951",
          "snippet": "static inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfs4_file_get_access",
          "args": [
            "fp",
            "access"
          ],
          "line": 5505
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_file_get_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "400-409",
          "snippet": "static void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "access",
            "lock_stp"
          ],
          "line": 5503
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "964-970",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void get_lock_access(struct nfs4_ol_stateid *lock_stp, u32 access)\n{\n\tstruct nfs4_file *fp = lock_stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (test_access(access, lock_stp))\n\t\treturn;\n\t__nfs4_file_get_access(fp, access);\n\tset_access(access, lock_stp);\n}"
  },
  {
    "function_name": "check_lock_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5490-5495",
    "snippet": "static int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncheck_lock_length(u64 offset, u64 length)\n{\n\treturn ((length == 0) || ((length != NFS4_MAX_UINT64) &&\n\t\t(length > ~offset)));\n}"
  },
  {
    "function_name": "find_or_create_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5457-5488",
    "snippet": "static struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *stateid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "ns"
          ],
          "line": 5486
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_lock_stateid",
          "args": [
            "lst",
            "lo",
            "fi",
            "inode",
            "ost"
          ],
          "line": 5479
        },
        "resolved": true,
        "details": {
          "function_name": "init_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5414-5438",
          "snippet": "static void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tmutex_init(&stp->st_mutex);\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tmutex_init(&stp->st_mutex);\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "ns"
          ],
          "line": 5478
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!lst"
          ],
          "line": 5477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_stateid",
          "args": [
            "lo",
            "fi"
          ],
          "line": 5476
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5440-5455",
          "snippet": "static struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "clp",
            "stateid_slab"
          ],
          "line": 5471
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "556-593",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "ost->st_stateowner"
          ],
          "line": 5464
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid *\nfind_or_create_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fi,\n\t\t\t    struct inode *inode, struct nfs4_ol_stateid *ost,\n\t\t\t    bool *new)\n{\n\tstruct nfs4_stid *ns = NULL;\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_openowner *oo = openowner(ost->st_stateowner);\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tspin_lock(&clp->cl_lock);\n\tlst = find_lock_stateid(lo, fi);\n\tif (lst == NULL) {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tns = nfs4_alloc_stid(clp, stateid_slab);\n\t\tif (ns == NULL)\n\t\t\treturn NULL;\n\n\t\tspin_lock(&clp->cl_lock);\n\t\tlst = find_lock_stateid(lo, fi);\n\t\tif (likely(!lst)) {\n\t\t\tlst = openlockstateid(ns);\n\t\t\tinit_lock_stateid(lst, lo, fi, inode, ost);\n\t\t\tns = NULL;\n\t\t\t*new = true;\n\t\t}\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tif (ns)\n\t\tnfs4_put_stid(ns);\n\treturn lst;\n}"
  },
  {
    "function_name": "find_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5440-5455",
    "snippet": "static struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lst->st_stid.sc_count"
          ],
          "line": 5450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lst",
            "&lo->lo_owner.so_stateids",
            "st_perstateowner"
          ],
          "line": 5448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nfind_lock_stateid(struct nfs4_lockowner *lo, struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *lst;\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(lst, &lo->lo_owner.so_stateids, st_perstateowner) {\n\t\tif (lst->st_stid.sc_file == fp) {\n\t\t\tatomic_inc(&lst->st_stid.sc_count);\n\t\t\treturn lst;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5414-5438",
    "snippet": "static void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tmutex_init(&stp->st_mutex);\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_perfile",
            "&fp->fi_stateids"
          ],
          "line": 5436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_perstateowner",
            "&lo->lo_owner.so_stateids"
          ],
          "line": 5434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_locks",
            "&open_stp->st_locks"
          ],
          "line": 5433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 5432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 5426
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "619-622",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5425
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&stp->st_stid.sc_count"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ninit_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,\n\t\t  struct nfs4_file *fp, struct inode *inode,\n\t\t  struct nfs4_ol_stateid *open_stp)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_LOCK_STID;\n\tstp->st_stateowner = nfs4_get_stateowner(&lo->lo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_stid.sc_free = nfs4_free_lock_stateid;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = open_stp->st_deny_bmap;\n\tstp->st_openstp = open_stp;\n\tmutex_init(&stp->st_mutex);\n\tlist_add(&stp->st_locks, &open_stp->st_locks);\n\tlist_add(&stp->st_perstateowner, &lo->lo_owner.so_stateids);\n\tspin_lock(&fp->fi_lock);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\tspin_unlock(&fp->fi_lock);\n}"
  },
  {
    "function_name": "alloc_init_lock_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5387-5412",
    "snippet": "static struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(clp, &lock->lk_new_owner);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_stateowner(&lo->lo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *lockowner_slab;",
      "static const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_free_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5408
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1066-1070",
          "snippet": "static inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&lo->lo_owner.so_strhash",
            "&clp->cl_ownerstr_hashtbl[strhashval]"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lockowner_str_locked",
          "args": [
            "clp",
            "&lock->lk_new_owner"
          ],
          "line": 5402
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5334-5350",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&lo->lo_owner.so_stateids"
          ],
          "line": 5397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_stateowner",
          "args": [
            "lockowner_slab",
            "&lock->lk_new_owner",
            "clp"
          ],
          "line": 5394
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3382-3402",
          "snippet": "static inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\nstatic const struct nfs4_stateowner_operations lockowner_ops = {\n\t.so_unhash =\tnfs4_unhash_lockowner,\n\t.so_free =\tnfs4_free_lockowner,\n};\n\nstatic struct nfs4_lockowner *\nalloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp,\n\t\t\t   struct nfs4_ol_stateid *open_stp,\n\t\t\t   struct nfsd4_lock *lock)\n{\n\tstruct nfs4_lockowner *lo, *ret;\n\n\tlo = alloc_stateowner(lockowner_slab, &lock->lk_new_owner, clp);\n\tif (!lo)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&lo->lo_owner.so_stateids);\n\tlo->lo_owner.so_is_open_owner = 0;\n\tlo->lo_owner.so_seqid = lock->lk_new_lock_seqid;\n\tlo->lo_owner.so_ops = &lockowner_ops;\n\tspin_lock(&clp->cl_lock);\n\tret = find_lockowner_str_locked(clp, &lock->lk_new_owner);\n\tif (ret == NULL) {\n\t\tlist_add(&lo->lo_owner.so_strhash,\n\t\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\t\tret = lo;\n\t} else\n\t\tnfs4_free_stateowner(&lo->lo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_free_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5368-5373",
    "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *lockowner_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "lockowner_slab",
            "lo"
          ],
          "line": 5372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "sop"
          ],
          "line": 5370
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
  },
  {
    "function_name": "nfs4_unhash_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5363-5366",
    "snippet": "static void nfs4_unhash_lockowner(struct nfs4_stateowner *sop)\n{\n\tunhash_lockowner_locked(lockowner(sop));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_lockowner_locked",
          "args": [
            "lockowner(sop)"
          ],
          "line": 5365
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lockowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1171-1178",
          "snippet": "static void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "sop"
          ],
          "line": 5365
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_unhash_lockowner(struct nfs4_stateowner *sop)\n{\n\tunhash_lockowner_locked(lockowner(sop));\n}"
  },
  {
    "function_name": "find_lockowner_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5352-5361",
    "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lockowner_str_locked",
          "args": [
            "clp",
            "owner"
          ],
          "line": 5358
        },
        "resolved": true,
        "details": {
          "function_name": "find_lockowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5334-5350",
          "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tspin_lock(&clp->cl_lock);\n\tlo = find_lockowner_str_locked(clp, owner);\n\tspin_unlock(&clp->cl_lock);\n\treturn lo;\n}"
  },
  {
    "function_name": "find_lockowner_str_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5334-5350",
    "snippet": "static struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "nfs4_get_stateowner(so)"
          ],
          "line": 5347
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "so"
          ],
          "line": 5347
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_owner_str",
          "args": [
            "so",
            "owner"
          ],
          "line": 5346
        },
        "resolved": true,
        "details": {
          "function_name": "same_owner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "220-225",
          "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "so",
            "&clp->cl_ownerstr_hashtbl[strhashval]",
            "so_strhash"
          ],
          "line": 5342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "owner"
          ],
          "line": 5337
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "376-382",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_lockowner *\nfind_lockowner_str_locked(struct nfs4_client *clp, struct xdr_netobj *owner)\n{\n\tunsigned int strhashval = ownerstr_hashval(owner);\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[strhashval],\n\t\t\t    so_strhash) {\n\t\tif (so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, owner))\n\t\t\treturn lockowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfs4_set_lock_denied",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5304-5332",
    "snippet": "static inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "lo->lo_owner.so_owner.data",
            "lo->lo_owner.so_owner.len",
            "GFP_KERNEL"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_posix_mng_ops  = {\n\t.lm_get_owner = nfsd4_fl_get_owner,\n\t.lm_put_owner = nfsd4_fl_put_owner,\n};\n\nstatic inline void\nnfs4_set_lock_denied(struct file_lock *fl, struct nfsd4_lock_denied *deny)\n{\n\tstruct nfs4_lockowner *lo;\n\n\tif (fl->fl_lmops == &nfsd_posix_mng_ops) {\n\t\tlo = (struct nfs4_lockowner *) fl->fl_owner;\n\t\tdeny->ld_owner.data = kmemdup(lo->lo_owner.so_owner.data,\n\t\t\t\t\tlo->lo_owner.so_owner.len, GFP_KERNEL);\n\t\tif (!deny->ld_owner.data)\n\t\t\t/* We just don't care that much */\n\t\t\tgoto nevermind;\n\t\tdeny->ld_owner.len = lo->lo_owner.so_owner.len;\n\t\tdeny->ld_clientid = lo->lo_owner.so_client->cl_clientid;\n\t} else {\nnevermind:\n\t\tdeny->ld_owner.len = 0;\n\t\tdeny->ld_owner.data = NULL;\n\t\tdeny->ld_clientid.cl_boot = 0;\n\t\tdeny->ld_clientid.cl_id = 0;\n\t}\n\tdeny->ld_start = fl->fl_start;\n\tdeny->ld_length = NFS4_MAX_UINT64;\n\tif (fl->fl_end != NFS4_MAX_UINT64)\n\t\tdeny->ld_length = fl->fl_end - fl->fl_start + 1;        \n\tdeny->ld_type = NFS4_READ_LT;\n\tif (fl->fl_type != F_RDLCK)\n\t\tdeny->ld_type = NFS4_WRITE_LT;\n}"
  },
  {
    "function_name": "nfsd4_fl_put_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5290-5297",
    "snippet": "static void\nnfsd4_fl_put_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5296
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_fl_put_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tif (lo)\n\t\tnfs4_put_stateowner(&lo->lo_owner);\n}"
  },
  {
    "function_name": "nfsd4_fl_get_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5281-5288",
    "snippet": "static fl_owner_t\nnfsd4_fl_get_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tnfs4_get_stateowner(&lo->lo_owner);\n\treturn owner;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 5286
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic fl_owner_t\nnfsd4_fl_get_owner(fl_owner_t owner)\n{\n\tstruct nfs4_lockowner *lo = (struct nfs4_lockowner *)owner;\n\n\tnfs4_get_stateowner(&lo->lo_owner);\n\treturn owner;\n}"
  },
  {
    "function_name": "nfs4_transform_lock_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5272-5279",
    "snippet": "static inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nnfs4_transform_lock_offset(struct file_lock *lock)\n{\n\tif (lock->fl_start < 0)\n\t\tlock->fl_start = OFFSET_MAX;\n\tif (lock->fl_end < 0)\n\t\tlock->fl_end = OFFSET_MAX;\n}"
  },
  {
    "function_name": "last_byte_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5254-5262",
    "snippet": "static inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!len"
          ],
          "line": 5259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nlast_byte_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tWARN_ON_ONCE(!len);\n\tend = start + len;\n\treturn end > start ? end - 1: NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "end_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5244-5251",
    "snippet": "static inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end: NFS4_MAX_UINT64;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u64\nend_offset(u64 start, u64 len)\n{\n\tu64 end;\n\n\tend = start + len;\n\treturn end >= start ? end: NFS4_MAX_UINT64;\n}"
  },
  {
    "function_name": "nfsd4_delegreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5216-5242",
    "snippet": "__be32\nnfsd4_delegreturn(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_delegreturn *dr)\n{\n\tstruct nfs4_delegation *dp;\n\tstateid_t *stateid = &dr->dr_stateid;\n\tstruct nfs4_stid *s;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\treturn status;\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, NFS4_DELEG_STID, &s, nn);\n\tif (status)\n\t\tgoto out;\n\tdp = delegstateid(s);\n\tstatus = check_stateid_generation(stateid, &dp->dl_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto put_stateid;\n\n\tdestroy_delegation(dp);\nput_stateid:\n\tnfs4_put_stid(&dp->dl_stid);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 5239
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_delegation",
          "args": [
            "dp"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "866-878",
          "snippet": "static void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tbool unhashed;\n\n\tspin_lock(&state_lock);\n\tunhashed = unhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tif (unhashed) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tbool unhashed;\n\n\tspin_lock(&state_lock);\n\tunhashed = unhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tif (unhashed) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&dp->dl_stid.sc_stateid",
            "nfsd4_has_session(cstate)"
          ],
          "line": 5233
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4661-4687",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 5233
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "s"
          ],
          "line": 5232
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "154-157",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "NFS4_DELEG_STID",
            "&s",
            "nn"
          ],
          "line": 5229
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4743-4764",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "0"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_delegreturn(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_delegreturn *dr)\n{\n\tstruct nfs4_delegation *dp;\n\tstateid_t *stateid = &dr->dr_stateid;\n\tstruct nfs4_stid *s;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif ((status = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0)))\n\t\treturn status;\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, NFS4_DELEG_STID, &s, nn);\n\tif (status)\n\t\tgoto out;\n\tdp = delegstateid(s);\n\tstatus = check_stateid_generation(stateid, &dp->dl_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto put_stateid;\n\n\tdestroy_delegation(dp);\nput_stateid:\n\tnfs4_put_stid(&dp->dl_stid);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5186-5214",
    "snippet": "__be32\nnfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_close *close)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\tnfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tnfsd4_close_open_stateid(stp);\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5211
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_close_open_stateid",
          "args": [
            "stp"
          ],
          "line": 5208
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_close_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5160-5181",
          "snippet": "static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tbool unhashed;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tif (unhashed)\n\t\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tif (unhashed)\n\t\t\tmove_to_close_lru(s, clp->net);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tbool unhashed;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tif (unhashed)\n\t\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tif (unhashed)\n\t\t\tmove_to_close_lru(s, clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 5206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&close->cl_stateid",
            "&stp->st_stid"
          ],
          "line": 5205
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 5202
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1337-1354",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "close->cl_seqid",
            "&close->cl_stateid",
            "NFS4_OPEN_STID|NFS4_CLOSED_STID",
            "&stp",
            "nn"
          ],
          "line": 5198
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4999-5025",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_close on file %pd\\n\"",
            "cstate->current_fh.fh_dentry"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_close *close)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\tnfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tnfsd4_close_open_stateid(stp);\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_close_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5160-5181",
    "snippet": "static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tbool unhashed;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tif (unhashed)\n\t\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tif (unhashed)\n\t\t\tmove_to_close_lru(s, clp->net);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_to_close_lru",
          "args": [
            "s",
            "clp->net"
          ],
          "line": 5179
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_close_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3532-3567",
          "snippet": "static void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 5177
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1184-1201",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "s",
            "&reaplist"
          ],
          "line": 5172
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1129-1146",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_open_stateid",
          "args": [
            "s",
            "&reaplist"
          ],
          "line": 5168
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1239-1249",
          "snippet": "static bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 5167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)\n{\n\tstruct nfs4_client *clp = s->st_stid.sc_client;\n\tbool unhashed;\n\tLIST_HEAD(reaplist);\n\n\ts->st_stid.sc_type = NFS4_CLOSED_STID;\n\tspin_lock(&clp->cl_lock);\n\tunhashed = unhash_open_stateid(s, &reaplist);\n\n\tif (clp->cl_minorversion) {\n\t\tif (unhashed)\n\t\t\tput_ol_stateid_locked(s, &reaplist);\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t} else {\n\t\tspin_unlock(&clp->cl_lock);\n\t\tfree_ol_stateid_reaplist(&reaplist);\n\t\tif (unhashed)\n\t\t\tmove_to_close_lru(s, clp->net);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_open_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5116-5158",
    "snippet": "__be32\nnfsd4_open_downgrade(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_open_downgrade *od)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_downgrade on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\t/* We don't yet support WANT bits: */\n\tif (od->od_deleg_want)\n\t\tdprintk(\"NFSD: %s: od_deleg_want=0x%x ignored\\n\", __func__,\n\t\t\tod->od_deleg_want);\n\n\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate, od->od_seqid,\n\t\t\t\t\t&od->od_stateid, &stp, nn);\n\tif (status)\n\t\tgoto out; \n\tstatus = nfserr_inval;\n\tif (!test_access(od->od_share_access, stp)) {\n\t\tdprintk(\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\",\n\t\t\tstp->st_access_bmap, od->od_share_access);\n\t\tgoto put_stateid;\n\t}\n\tif (!test_deny(od->od_share_deny, stp)) {\n\t\tdprintk(\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\",\n\t\t\tstp->st_deny_bmap, od->od_share_deny);\n\t\tgoto put_stateid;\n\t}\n\tnfs4_stateid_downgrade(stp, od->od_share_access);\n\treset_union_bmap_deny(od->od_share_deny, stp);\n\tnfs4_inc_and_copy_stateid(&od->od_stateid, &stp->st_stid);\n\tstatus = nfs_ok;\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 5156
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1337-1354",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5154
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 5153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&od->od_stateid",
            "&stp->st_stid"
          ],
          "line": 5150
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_union_bmap_deny",
          "args": [
            "od->od_share_deny",
            "stp"
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "reset_union_bmap_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1031-1047",
          "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_downgrade",
          "args": [
            "stp",
            "od->od_share_access"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_downgrade",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5098-5114",
          "snippet": "static inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\"",
            "stp->st_deny_bmap",
            "od->od_share_deny"
          ],
          "line": 5144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_deny",
          "args": [
            "od->od_share_deny",
            "stp"
          ],
          "line": 5143
        },
        "resolved": true,
        "details": {
          "function_name": "test_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "993-999",
          "snippet": "static inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\"",
            "stp->st_access_bmap",
            "od->od_share_access"
          ],
          "line": 5139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "od->od_share_access",
            "stp"
          ],
          "line": 5138
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "964-970",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_confirmed_seqid_op",
          "args": [
            "cstate",
            "od->od_seqid",
            "&od->od_stateid",
            "&stp",
            "nn"
          ],
          "line": 5133
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_confirmed_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5027-5046",
          "snippet": "static __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: od_deleg_want=0x%x ignored\\n\"",
            "__func__",
            "od->od_deleg_want"
          ],
          "line": 5130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_open_downgrade on file %pd\\n\"",
            "cstate->current_fh.fh_dentry"
          ],
          "line": 5125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_open_downgrade(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_open_downgrade *od)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_downgrade on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\t/* We don't yet support WANT bits: */\n\tif (od->od_deleg_want)\n\t\tdprintk(\"NFSD: %s: od_deleg_want=0x%x ignored\\n\", __func__,\n\t\t\tod->od_deleg_want);\n\n\tstatus = nfs4_preprocess_confirmed_seqid_op(cstate, od->od_seqid,\n\t\t\t\t\t&od->od_stateid, &stp, nn);\n\tif (status)\n\t\tgoto out; \n\tstatus = nfserr_inval;\n\tif (!test_access(od->od_share_access, stp)) {\n\t\tdprintk(\"NFSD: access not a subset of current bitmap: 0x%hhx, input access=%08x\\n\",\n\t\t\tstp->st_access_bmap, od->od_share_access);\n\t\tgoto put_stateid;\n\t}\n\tif (!test_deny(od->od_share_deny, stp)) {\n\t\tdprintk(\"NFSD: deny not a subset of current bitmap: 0x%hhx, input deny=%08x\\n\",\n\t\t\tstp->st_deny_bmap, od->od_share_deny);\n\t\tgoto put_stateid;\n\t}\n\tnfs4_stateid_downgrade(stp, od->od_share_access);\n\treset_union_bmap_deny(od->od_share_deny, stp);\n\tnfs4_inc_and_copy_stateid(&od->od_stateid, &stp->st_stid);\n\tstatus = nfs_ok;\nput_stateid:\n\tmutex_unlock(&stp->st_mutex);\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_stateid_downgrade",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5098-5114",
    "snippet": "static inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 5112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_stateid_downgrade_bit",
          "args": [
            "stp",
            "NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 5107
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_stateid_downgrade_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5090-5096",
          "snippet": "static inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade(struct nfs4_ol_stateid *stp, u32 to_access)\n{\n\tswitch (to_access) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_WRITE);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_READ);\n\t\tnfs4_stateid_downgrade_bit(stp, NFS4_SHARE_ACCESS_BOTH);\n\t\tbreak;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
  },
  {
    "function_name": "nfs4_stateid_downgrade_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5090-5096",
    "snippet": "static inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_access",
          "args": [
            "access",
            "stp"
          ],
          "line": 5095
        },
        "resolved": true,
        "details": {
          "function_name": "clear_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "954-961",
          "snippet": "static inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_put_access",
          "args": [
            "stp->st_stid.sc_file",
            "access"
          ],
          "line": 5094
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "466-474",
          "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "access",
            "stp"
          ],
          "line": 5092
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "964-970",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_stateid_downgrade_bit(struct nfs4_ol_stateid *stp, u32 access)\n{\n\tif (!test_access(access, stp))\n\t\treturn;\n\tnfs4_file_put_access(stp->st_stid.sc_file, access);\n\tclear_access(access, stp);\n}"
  },
  {
    "function_name": "nfsd4_open_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5048-5088",
    "snippet": "__be32\nnfsd4_open_confirm(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_open_confirm *oc)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_confirm on file %pd\\n\",\n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t\toc->oc_seqid, &oc->oc_req_stateid,\n\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\tgoto out;\n\too = openowner(stp->st_stateowner);\n\tstatus = nfserr_bad_stateid;\n\tif (oo->oo_flags & NFS4_OO_CONFIRMED) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tgoto put_stateid;\n\t}\n\too->oo_flags |= NFS4_OO_CONFIRMED;\n\tnfs4_inc_and_copy_stateid(&oc->oc_resp_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\tdprintk(\"NFSD: %s: success, seqid=%d stateid=\" STATEID_FMT \"\\n\",\n\t\t__func__, oc->oc_seqid, STATEID_VAL(&stp->st_stid.sc_stateid));\n\n\tnfsd4_client_record_create(oo->oo_owner.so_client);\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_bump_seqid",
          "args": [
            "cstate",
            "status"
          ],
          "line": 5086
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_bump_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1337-1354",
          "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5084
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_client_record_create",
          "args": [
            "oo->oo_owner.so_client"
          ],
          "line": 5081
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1473-1480",
          "snippet": "void\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: success, seqid=%d stateid=\" STATEID_FMT \"\\n\"",
            "__func__",
            "oc->oc_seqid",
            "STATEID_VAL(&stp->st_stid.sc_stateid)"
          ],
          "line": 5078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 5077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&oc->oc_resp_stateid",
            "&stp->st_stid"
          ],
          "line": 5076
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 5072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 5069
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "oc->oc_seqid",
            "&oc->oc_req_stateid",
            "NFS4_OPEN_STID",
            "&stp",
            "nn"
          ],
          "line": 5064
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4999-5025",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_verify",
          "args": [
            "rqstp",
            "&cstate->current_fh",
            "S_IFREG",
            "0"
          ],
          "line": 5060
        },
        "resolved": true,
        "details": {
          "function_name": "fh_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "303-381",
          "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_open_confirm on file %pd\\n\"",
            "cstate->current_fh.fh_dentry"
          ],
          "line": 5057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 5055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 5055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_open_confirm(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_open_confirm *oc)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_open_confirm on file %pd\\n\",\n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = fh_verify(rqstp, &cstate->current_fh, S_IFREG, 0);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate,\n\t\t\t\t\toc->oc_seqid, &oc->oc_req_stateid,\n\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\tgoto out;\n\too = openowner(stp->st_stateowner);\n\tstatus = nfserr_bad_stateid;\n\tif (oo->oo_flags & NFS4_OO_CONFIRMED) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tgoto put_stateid;\n\t}\n\too->oo_flags |= NFS4_OO_CONFIRMED;\n\tnfs4_inc_and_copy_stateid(&oc->oc_resp_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\tdprintk(\"NFSD: %s: success, seqid=%d stateid=\" STATEID_FMT \"\\n\",\n\t\t__func__, oc->oc_seqid, STATEID_VAL(&stp->st_stid.sc_stateid));\n\n\tnfsd4_client_record_create(oo->oo_owner.so_client);\n\tstatus = nfs_ok;\nput_stateid:\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\tnfsd4_bump_seqid(cstate, status);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_preprocess_confirmed_seqid_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "5027-5046",
    "snippet": "static __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5041
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 5040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 5038
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_preprocess_seqid_op",
          "args": [
            "cstate",
            "seqid",
            "stateid",
            "NFS4_OPEN_STID",
            "&stp",
            "nn"
          ],
          "line": 5034
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_preprocess_seqid_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4999-5025",
          "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_preprocess_confirmed_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t\t\t\t stateid_t *stateid, struct nfs4_ol_stateid **stpp, struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, seqid, stateid,\n\t\t\t\t\t\tNFS4_OPEN_STID, &stp, nn);\n\tif (status)\n\t\treturn status;\n\too = openowner(stp->st_stateowner);\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\treturn nfserr_bad_stateid;\n\t}\n\t*stpp = stp;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfs4_preprocess_seqid_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4999-5025",
    "snippet": "static __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 5023
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_seqid_op_checks",
          "args": [
            "cstate",
            "stateid",
            "seqid",
            "stp"
          ],
          "line": 5019
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_seqid_op_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4970-4994",
          "snippet": "static __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tmutex_lock(&stp->st_mutex);\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status == nfs_ok)\n\t\tstatus = nfs4_check_fh(current_fh, &stp->st_stid);\n\tif (status != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tmutex_lock(&stp->st_mutex);\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status == nfs_ok)\n\t\tstatus = nfs4_check_fh(current_fh, &stp->st_stid);\n\tif (status != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cstate_assign_replay",
          "args": [
            "cstate",
            "stp->st_stateowner"
          ],
          "line": 5017
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cstate_assign_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3362-3369",
          "snippet": "static void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "typemask",
            "&s",
            "nn"
          ],
          "line": 5013
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4743-4764",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\"",
            "__func__",
            "seqid",
            "STATEID_VAL(stateid)"
          ],
          "line": 5009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "stateid"
          ],
          "line": 5010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_preprocess_seqid_op(struct nfsd4_compound_state *cstate, u32 seqid,\n\t\t\t stateid_t *stateid, char typemask,\n\t\t\t struct nfs4_ol_stateid **stpp,\n\t\t\t struct nfsd_net *nn)\n{\n\t__be32 status;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\n\tdprintk(\"NFSD: %s: seqid=%d stateid = \" STATEID_FMT \"\\n\", __func__,\n\t\tseqid, STATEID_VAL(stateid));\n\n\t*stpp = NULL;\n\tstatus = nfsd4_lookup_stateid(cstate, stateid, typemask, &s, nn);\n\tif (status)\n\t\treturn status;\n\tstp = openlockstateid(s);\n\tnfsd4_cstate_assign_replay(cstate, stp->st_stateowner);\n\n\tstatus = nfs4_seqid_op_checks(cstate, stateid, seqid, stp);\n\tif (!status)\n\t\t*stpp = stp;\n\telse\n\t\tnfs4_put_stid(&stp->st_stid);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_seqid_op_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4970-4994",
    "snippet": "static __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tmutex_lock(&stp->st_mutex);\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status == nfs_ok)\n\t\tstatus = nfs4_check_fh(current_fh, &stp->st_stid);\n\tif (status != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 4992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_check_fh",
          "args": [
            "current_fh",
            "&stp->st_stid"
          ],
          "line": 4990
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4595-4600",
          "snippet": "static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&stp->st_stid.sc_stateid",
            "nfsd4_has_session(cstate)"
          ],
          "line": 4988
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4661-4687",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 4988
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 4987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_check_seqid",
          "args": [
            "cstate",
            "sop",
            "seqid"
          ],
          "line": 4976
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3770-3779",
          "snippet": "static __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_seqid_op_checks(struct nfsd4_compound_state *cstate, stateid_t *stateid, u32 seqid, struct nfs4_ol_stateid *stp)\n{\n\tstruct svc_fh *current_fh = &cstate->current_fh;\n\tstruct nfs4_stateowner *sop = stp->st_stateowner;\n\t__be32 status;\n\n\tstatus = nfsd4_check_seqid(cstate, sop, seqid);\n\tif (status)\n\t\treturn status;\n\tif (stp->st_stid.sc_type == NFS4_CLOSED_STID\n\t\t|| stp->st_stid.sc_type == NFS4_REVOKED_DELEG_STID)\n\t\t/*\n\t\t * \"Closed\" stateid's exist *only* to return\n\t\t * nfserr_replay_me from the previous step, and\n\t\t * revoked delegations are kept only for free_stateid.\n\t\t */\n\t\treturn nfserr_bad_stateid;\n\tmutex_lock(&stp->st_mutex);\n\tstatus = check_stateid_generation(stateid, &stp->st_stid.sc_stateid, nfsd4_has_session(cstate));\n\tif (status == nfs_ok)\n\t\tstatus = nfs4_check_fh(current_fh, &stp->st_stid);\n\tif (status != nfs_ok)\n\t\tmutex_unlock(&stp->st_mutex);\n\treturn status;\n}"
  },
  {
    "function_name": "setlkflg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4963-4968",
    "snippet": "static inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nsetlkflg (int type)\n{\n\treturn (type == NFS4_READW_LT || type == NFS4_READ_LT) ?\n\t\tRD_STATE : WR_STATE;\n}"
  },
  {
    "function_name": "nfsd4_free_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4909-4961",
    "snippet": "__be32\nnfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_free_stateid *free_stateid)\n{\n\tstateid_t *stateid = &free_stateid->fr_stateid;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\t__be32 ret = nfserr_bad_stateid;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_LOCK_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstp = openlockstateid(s);\n\t\tret = nfserr_locks_held;\n\t\tif (check_for_locks(stp->st_stid.sc_file,\n\t\t\t\t    lockowner(stp->st_stateowner)))\n\t\t\tbreak;\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\t/* Default falls through and returns nfserr_bad_stateid */\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "s"
          ],
          "line": 4952
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 4950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "s"
          ],
          "line": 4949
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "154-157",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!unhash_lock_stateid(stp)"
          ],
          "line": 4943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1148-1157",
          "snippet": "static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_for_locks",
          "args": [
            "stp->st_stid.sc_file",
            "lockowner(stp->st_stateowner)"
          ],
          "line": 4940
        },
        "resolved": true,
        "details": {
          "function_name": "check_for_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5902-5932",
          "snippet": "static bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);\n\nstatic bool\ncheck_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner)\n{\n\tstruct file_lock *fl;\n\tint status = false;\n\tstruct file *filp = find_any_file(fp);\n\tstruct inode *inode;\n\tstruct file_lock_context *flctx;\n\n\tif (!filp) {\n\t\t/* Any valid lock stateid should have some sort of access */\n\t\tWARN_ON_ONCE(1);\n\t\treturn status;\n\t}\n\n\tinode = file_inode(filp);\n\tflctx = inode->i_flctx;\n\n\tif (flctx && !list_empty_careful(&flctx->flc_posix)) {\n\t\tspin_lock(&flctx->flc_lock);\n\t\tlist_for_each_entry(fl, &flctx->flc_posix, fl_list) {\n\t\t\tif (fl->fl_owner == (fl_owner_t)lowner) {\n\t\t\t\tstatus = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&flctx->flc_lock);\n\t}\n\tfput(filp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 4941
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&s->sc_stateid",
            "1"
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4661-4687",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_stateid_locked",
          "args": [
            "cl",
            "stateid"
          ],
          "line": 4921
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2013-2022",
          "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_free_stateid *free_stateid)\n{\n\tstateid_t *stateid = &free_stateid->fr_stateid;\n\tstruct nfs4_stid *s;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\t__be32 ret = nfserr_bad_stateid;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = nfserr_locks_held;\n\t\tbreak;\n\tcase NFS4_LOCK_STID:\n\t\tret = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tstp = openlockstateid(s);\n\t\tret = nfserr_locks_held;\n\t\tif (check_for_locks(stp->st_stid.sc_file,\n\t\t\t\t    lockowner(stp->st_stateowner)))\n\t\t\tbreak;\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tdp = delegstateid(s);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tspin_unlock(&cl->cl_lock);\n\t\tnfs4_put_stid(s);\n\t\tret = nfs_ok;\n\t\tgoto out;\n\t/* Default falls through and returns nfserr_bad_stateid */\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_test_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4895-4907",
    "snippet": "__be32\nnfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct nfsd4_test_stateid_id *stateid;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\n\tlist_for_each_entry(stateid, &test_stateid->ts_stateid_list, ts_id_list)\n\t\tstateid->ts_id_status =\n\t\t\tnfsd4_validate_stateid(cl, &stateid->ts_id_stateid);\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_validate_stateid",
          "args": [
            "cl",
            "&stateid->ts_id_stateid"
          ],
          "line": 4904
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_validate_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4697-4741",
          "snippet": "static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfsd4_check_openowner_confirmed(openlockstateid(s));\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfsd4_check_openowner_confirmed(openlockstateid(s));\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "stateid",
            "&test_stateid->ts_stateid_list",
            "ts_id_list"
          ],
          "line": 4902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t   struct nfsd4_test_stateid *test_stateid)\n{\n\tstruct nfsd4_test_stateid_id *stateid;\n\tstruct nfs4_client *cl = cstate->session->se_client;\n\n\tlist_for_each_entry(stateid, &test_stateid->ts_stateid_list, ts_id_list)\n\t\tstateid->ts_id_status =\n\t\t\tnfsd4_validate_stateid(cl, &stateid->ts_id_stateid);\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfs4_preprocess_stateid_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4833-4890",
    "snippet": "__be32\nnfs4_preprocess_stateid_op(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, struct svc_fh *fhp,\n\t\tstateid_t *stateid, int flags, struct file **filpp, bool *tmp_file)\n{\n\tstruct inode *ino = d_inode(fhp->fh_dentry);\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct nfs4_stid *s = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\tif (tmp_file)\n\t\t*tmp_file = false;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid)) {\n\t\tstatus = check_special_stateids(net, fhp, stateid, flags);\n\t\tgoto done;\n\t}\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid,\n\t\t\tnfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs4_check_delegmode(delegstateid(s), flags);\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfs4_check_olstateid(fhp, openlockstateid(s), flags);\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tbreak;\n\t}\n\tif (status)\n\t\tgoto out;\n\tstatus = nfs4_check_fh(fhp, s);\n\ndone:\n\tif (!status && filpp)\n\t\tstatus = nfs4_check_file(rqstp, fhp, s, filpp, tmp_file, flags);\nout:\n\tif (s)\n\t\tnfs4_put_stid(s);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "s"
          ],
          "line": 4888
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_file",
          "args": [
            "rqstp",
            "fhp",
            "s",
            "filpp",
            "tmp_file",
            "flags"
          ],
          "line": 4885
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4800-4828",
          "snippet": "static __be32\nnfs4_check_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfs4_stid *s,\n\t\tstruct file **filpp, bool *tmp_file, int flags)\n{\n\tint acc = (flags & RD_STATE) ? NFSD_MAY_READ : NFSD_MAY_WRITE;\n\tstruct file *file;\n\t__be32 status;\n\n\tfile = nfs4_find_file(s, flags);\n\tif (file) {\n\t\tstatus = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tacc | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (status) {\n\t\t\tfput(file);\n\t\t\treturn status;\n\t\t}\n\n\t\t*filpp = file;\n\t} else {\n\t\tstatus = nfsd_open(rqstp, fhp, S_IFREG, acc, filpp);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (tmp_file)\n\t\t\t*tmp_file = true;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfs4_stid *s,\n\t\tstruct file **filpp, bool *tmp_file, int flags)\n{\n\tint acc = (flags & RD_STATE) ? NFSD_MAY_READ : NFSD_MAY_WRITE;\n\tstruct file *file;\n\t__be32 status;\n\n\tfile = nfs4_find_file(s, flags);\n\tif (file) {\n\t\tstatus = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tacc | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (status) {\n\t\t\tfput(file);\n\t\t\treturn status;\n\t\t}\n\n\t\t*filpp = file;\n\t} else {\n\t\tstatus = nfsd_open(rqstp, fhp, S_IFREG, acc, filpp);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (tmp_file)\n\t\t\t*tmp_file = true;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_fh",
          "args": [
            "fhp",
            "s"
          ],
          "line": 4881
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_fh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4595-4600",
          "snippet": "static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_olstateid",
          "args": [
            "fhp",
            "openlockstateid(s)",
            "flags"
          ],
          "line": 4873
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_olstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4789-4798",
          "snippet": "static __be32\nnfs4_check_olstateid(struct svc_fh *fhp, struct nfs4_ol_stateid *ols, int flags)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_check_openowner_confirmed(ols);\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_openmode(ols, flags);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_olstateid(struct svc_fh *fhp, struct nfs4_ol_stateid *ols, int flags)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_check_openowner_confirmed(ols);\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_openmode(ols, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 4873
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_delegmode",
          "args": [
            "delegstateid(s)",
            "flags"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_delegmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3878-3885",
          "snippet": "static inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "s"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "154-157",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&s->sc_stateid",
            "nfsd4_has_session(cstate)"
          ],
          "line": 4862
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4661-4687",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 4863
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_lookup_stateid",
          "args": [
            "cstate",
            "stateid",
            "NFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID",
            "&s",
            "nn"
          ],
          "line": 4857
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_lookup_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4743-4764",
          "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_special_stateids",
          "args": [
            "net",
            "fhp",
            "stateid",
            "flags"
          ],
          "line": 4853
        },
        "resolved": true,
        "details": {
          "function_name": "check_special_stateids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4634-4649",
          "snippet": "static inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (opens_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (opens_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grace_disallows_io",
          "args": [
            "net",
            "ino"
          ],
          "line": 4849
        },
        "resolved": true,
        "details": {
          "function_name": "grace_disallows_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4655-4659",
          "snippet": "static inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn opens_in_grace(net) && mandatory_lock(inode);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn opens_in_grace(net) && mandatory_lock(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 4839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "fhp->fh_dentry"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfs4_preprocess_stateid_op(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, struct svc_fh *fhp,\n\t\tstateid_t *stateid, int flags, struct file **filpp, bool *tmp_file)\n{\n\tstruct inode *ino = d_inode(fhp->fh_dentry);\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct nfs4_stid *s = NULL;\n\t__be32 status;\n\n\tif (filpp)\n\t\t*filpp = NULL;\n\tif (tmp_file)\n\t\t*tmp_file = false;\n\n\tif (grace_disallows_io(net, ino))\n\t\treturn nfserr_grace;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid)) {\n\t\tstatus = check_special_stateids(net, fhp, stateid, flags);\n\t\tgoto done;\n\t}\n\n\tstatus = nfsd4_lookup_stateid(cstate, stateid,\n\t\t\t\tNFS4_DELEG_STID|NFS4_OPEN_STID|NFS4_LOCK_STID,\n\t\t\t\t&s, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid,\n\t\t\tnfsd4_has_session(cstate));\n\tif (status)\n\t\tgoto out;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs4_check_delegmode(delegstateid(s), flags);\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfs4_check_olstateid(fhp, openlockstateid(s), flags);\n\t\tbreak;\n\tdefault:\n\t\tstatus = nfserr_bad_stateid;\n\t\tbreak;\n\t}\n\tif (status)\n\t\tgoto out;\n\tstatus = nfs4_check_fh(fhp, s);\n\ndone:\n\tif (!status && filpp)\n\t\tstatus = nfs4_check_file(rqstp, fhp, s, filpp, tmp_file, flags);\nout:\n\tif (s)\n\t\tnfs4_put_stid(s);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_check_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4800-4828",
    "snippet": "static __be32\nnfs4_check_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfs4_stid *s,\n\t\tstruct file **filpp, bool *tmp_file, int flags)\n{\n\tint acc = (flags & RD_STATE) ? NFSD_MAY_READ : NFSD_MAY_WRITE;\n\tstruct file *file;\n\t__be32 status;\n\n\tfile = nfs4_find_file(s, flags);\n\tif (file) {\n\t\tstatus = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tacc | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (status) {\n\t\t\tfput(file);\n\t\t\treturn status;\n\t\t}\n\n\t\t*filpp = file;\n\t} else {\n\t\tstatus = nfsd_open(rqstp, fhp, S_IFREG, acc, filpp);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (tmp_file)\n\t\t\t*tmp_file = true;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_open",
          "args": [
            "rqstp",
            "fhp",
            "S_IFREG",
            "acc",
            "filpp"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "651-736",
          "snippet": "__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tfput(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tfput(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_permission",
          "args": [
            "rqstp",
            "fhp->fh_export",
            "fhp->fh_dentry",
            "acc | NFSD_MAY_OWNER_OVERRIDE"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1952-2032",
          "snippet": "__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_find_file",
          "args": [
            "s",
            "flags"
          ],
          "line": 4808
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_find_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4766-4787",
          "snippet": "static struct file *\nnfs4_find_file(struct nfs4_stid *s, int flags)\n{\n\tif (!s)\n\t\treturn NULL;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tif (WARN_ON_ONCE(!s->sc_file->fi_deleg_file))\n\t\t\treturn NULL;\n\t\treturn get_file(s->sc_file->fi_deleg_file);\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tif (flags & RD_STATE)\n\t\t\treturn find_readable_file(s->sc_file);\n\t\telse\n\t\t\treturn find_writeable_file(s->sc_file);\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nnfs4_find_file(struct nfs4_stid *s, int flags)\n{\n\tif (!s)\n\t\treturn NULL;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tif (WARN_ON_ONCE(!s->sc_file->fi_deleg_file))\n\t\t\treturn NULL;\n\t\treturn get_file(s->sc_file->fi_deleg_file);\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tif (flags & RD_STATE)\n\t\t\treturn find_readable_file(s->sc_file);\n\t\telse\n\t\t\treturn find_writeable_file(s->sc_file);\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_file(struct svc_rqst *rqstp, struct svc_fh *fhp, struct nfs4_stid *s,\n\t\tstruct file **filpp, bool *tmp_file, int flags)\n{\n\tint acc = (flags & RD_STATE) ? NFSD_MAY_READ : NFSD_MAY_WRITE;\n\tstruct file *file;\n\t__be32 status;\n\n\tfile = nfs4_find_file(s, flags);\n\tif (file) {\n\t\tstatus = nfsd_permission(rqstp, fhp->fh_export, fhp->fh_dentry,\n\t\t\t\tacc | NFSD_MAY_OWNER_OVERRIDE);\n\t\tif (status) {\n\t\t\tfput(file);\n\t\t\treturn status;\n\t\t}\n\n\t\t*filpp = file;\n\t} else {\n\t\tstatus = nfsd_open(rqstp, fhp, S_IFREG, acc, filpp);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (tmp_file)\n\t\t\t*tmp_file = true;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_check_olstateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4789-4798",
    "snippet": "static __be32\nnfs4_check_olstateid(struct svc_fh *fhp, struct nfs4_ol_stateid *ols, int flags)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_check_openowner_confirmed(ols);\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_openmode(ols, flags);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_check_openmode",
          "args": [
            "ols",
            "flags"
          ],
          "line": 4797
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_openmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4617-4632",
          "snippet": "static\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_openowner_confirmed",
          "args": [
            "ols"
          ],
          "line": 4794
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_openowner_confirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4689-4695",
          "snippet": "static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_olstateid(struct svc_fh *fhp, struct nfs4_ol_stateid *ols, int flags)\n{\n\t__be32 status;\n\n\tstatus = nfsd4_check_openowner_confirmed(ols);\n\tif (status)\n\t\treturn status;\n\treturn nfs4_check_openmode(ols, flags);\n}"
  },
  {
    "function_name": "nfs4_find_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4766-4787",
    "snippet": "static struct file *\nnfs4_find_file(struct nfs4_stid *s, int flags)\n{\n\tif (!s)\n\t\treturn NULL;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tif (WARN_ON_ONCE(!s->sc_file->fi_deleg_file))\n\t\t\treturn NULL;\n\t\treturn get_file(s->sc_file->fi_deleg_file);\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tif (flags & RD_STATE)\n\t\t\treturn find_readable_file(s->sc_file);\n\t\telse\n\t\t\treturn find_writeable_file(s->sc_file);\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_writeable_file",
          "args": [
            "s->sc_file"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "find_writeable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "312-322",
          "snippet": "static struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_readable_file",
          "args": [
            "s->sc_file"
          ],
          "line": 4780
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "336-346",
          "snippet": "static struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "s->sc_file->fi_deleg_file"
          ],
          "line": 4776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!s->sc_file->fi_deleg_file"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nnfs4_find_file(struct nfs4_stid *s, int flags)\n{\n\tif (!s)\n\t\treturn NULL;\n\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tif (WARN_ON_ONCE(!s->sc_file->fi_deleg_file))\n\t\t\treturn NULL;\n\t\treturn get_file(s->sc_file->fi_deleg_file);\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tif (flags & RD_STATE)\n\t\t\treturn find_readable_file(s->sc_file);\n\t\telse\n\t\t\treturn find_writeable_file(s->sc_file);\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfsd4_lookup_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4743-4764",
    "snippet": "__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_stateid_by_type",
          "args": [
            "cstate->clp",
            "stateid",
            "typemask"
          ],
          "line": 4760
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2024-2039",
          "snippet": "static struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "&stateid->si_opaque.so_clid",
            "cstate",
            "nn"
          ],
          "line": 4752
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3781-3815",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,\n\t\t     stateid_t *stateid, unsigned char typemask,\n\t\t     struct nfs4_stid **s, struct nfsd_net *nn)\n{\n\t__be32 status;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn nfserr_bad_stateid;\n\tstatus = lookup_clientid(&stateid->si_opaque.so_clid, cstate, nn);\n\tif (status == nfserr_stale_clientid) {\n\t\tif (cstate->session)\n\t\t\treturn nfserr_bad_stateid;\n\t\treturn nfserr_stale_stateid;\n\t}\n\tif (status)\n\t\treturn status;\n\t*s = find_stateid_by_type(cstate->clp, stateid, typemask);\n\tif (!*s)\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_validate_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4697-4741",
    "snippet": "static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfsd4_check_openowner_confirmed(openlockstateid(s));\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"unknown stateid type %x\\n\"",
            "s->sc_type"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_check_openowner_confirmed",
          "args": [
            "openlockstateid(s)"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_openowner_confirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4689-4695",
          "snippet": "static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "s"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_stateid_generation",
          "args": [
            "stateid",
            "&s->sc_stateid",
            "1"
          ],
          "line": 4717
        },
        "resolved": true,
        "details": {
          "function_name": "check_stateid_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4661-4687",
          "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_stateid_locked",
          "args": [
            "cl",
            "stateid"
          ],
          "line": 4714
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2013-2022",
          "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\"",
            "addr_str"
          ],
          "line": 4709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *)&cl->cl_addr",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&stateid->si_opaque.so_clid",
            "&cl->cl_clientid"
          ],
          "line": 4705
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1914-1918",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)\n{\n\tstruct nfs4_stid *s;\n\t__be32 status = nfserr_bad_stateid;\n\n\tif (ZERO_STATEID(stateid) || ONE_STATEID(stateid))\n\t\treturn status;\n\t/* Client debugging aid. */\n\tif (!same_clid(&stateid->si_opaque.so_clid, &cl->cl_clientid)) {\n\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\trpc_ntop((struct sockaddr *)&cl->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\tpr_warn_ratelimited(\"NFSD: client %s testing state ID \"\n\t\t\t\t\t\"with incorrect client ID\\n\", addr_str);\n\t\treturn status;\n\t}\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, stateid);\n\tif (!s)\n\t\tgoto out_unlock;\n\tstatus = check_stateid_generation(stateid, &s->sc_stateid, 1);\n\tif (status)\n\t\tgoto out_unlock;\n\tswitch (s->sc_type) {\n\tcase NFS4_DELEG_STID:\n\t\tstatus = nfs_ok;\n\t\tbreak;\n\tcase NFS4_REVOKED_DELEG_STID:\n\t\tstatus = nfserr_deleg_revoked;\n\t\tbreak;\n\tcase NFS4_OPEN_STID:\n\tcase NFS4_LOCK_STID:\n\t\tstatus = nfsd4_check_openowner_confirmed(openlockstateid(s));\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"unknown stateid type %x\\n\", s->sc_type);\n\t\t/* Fallthrough */\n\tcase NFS4_CLOSED_STID:\n\tcase NFS4_CLOSED_DELEG_STID:\n\t\tstatus = nfserr_bad_stateid;\n\t}\nout_unlock:\n\tspin_unlock(&cl->cl_lock);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_check_openowner_confirmed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4689-4695",
    "snippet": "static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "ols->st_stateowner"
          ],
          "line": 4692
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)\n{\n\tif (ols->st_stateowner->so_is_open_owner &&\n\t    !(openowner(ols->st_stateowner)->oo_flags & NFS4_OO_CONFIRMED))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "check_stateid_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4661-4687",
    "snippet": "static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_stateid_generation_after",
          "args": [
            "in",
            "ref"
          ],
          "line": 4674
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_stateid_generation_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "577-580",
          "snippet": "static inline bool nfsd4_stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline bool nfsd4_stateid_generation_after(stateid_t *a, stateid_t *b)\n{\n\treturn (s32)(a->si_generation - b->si_generation) > 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_session)\n{\n\t/*\n\t * When sessions are used the stateid generation number is ignored\n\t * when it is zero.\n\t */\n\tif (has_session && in->si_generation == 0)\n\t\treturn nfs_ok;\n\n\tif (in->si_generation == ref->si_generation)\n\t\treturn nfs_ok;\n\n\t/* If the client sends us a stateid from the future, it's buggy: */\n\tif (nfsd4_stateid_generation_after(in, ref))\n\t\treturn nfserr_bad_stateid;\n\t/*\n\t * However, we could see a stateid from the past, even from a\n\t * non-buggy client.  For example, if the client sends a lock\n\t * while some IO is outstanding, the lock may bump si_generation\n\t * while the IO is still in flight.  The client could avoid that\n\t * situation by waiting for responses on all the IO requests,\n\t * but better performance may result in retrying IO that\n\t * receives an old_stateid error if requests are rarely\n\t * reordered in flight:\n\t */\n\treturn nfserr_old_stateid;\n}"
  },
  {
    "function_name": "grace_disallows_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4655-4659",
    "snippet": "static inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn opens_in_grace(net) && mandatory_lock(inode);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mandatory_lock",
          "args": [
            "inode"
          ],
          "line": 4658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opens_in_grace",
          "args": [
            "net"
          ],
          "line": 4658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\ngrace_disallows_io(struct net *net, struct inode *inode)\n{\n\treturn opens_in_grace(net) && mandatory_lock(inode);\n}"
  },
  {
    "function_name": "check_special_stateids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4634-4649",
    "snippet": "static inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (opens_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_share_conflict",
          "args": [
            "current_fh",
            "NFS4_SHARE_DENY_READ"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_share_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3623-3639",
          "snippet": "static __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opens_in_grace",
          "args": [
            "net"
          ],
          "line": 4639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ONE_STATEID",
          "args": [
            "stateid"
          ],
          "line": 4637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\ncheck_special_stateids(struct net *net, svc_fh *current_fh, stateid_t *stateid, int flags)\n{\n\tif (ONE_STATEID(stateid) && (flags & RD_STATE))\n\t\treturn nfs_ok;\n\telse if (opens_in_grace(net)) {\n\t\t/* Answer in remaining cases depends on existence of\n\t\t * conflicting state; so we must wait out the grace period. */\n\t\treturn nfserr_grace;\n\t} else if (flags & WR_STATE)\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_WRITE);\n\telse /* (flags & RD_STATE) && ZERO_STATEID(stateid) */\n\t\treturn nfs4_share_conflict(current_fh,\n\t\t\t\tNFS4_SHARE_DENY_READ);\n}"
  },
  {
    "function_name": "nfs4_check_openmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4617-4632",
    "snippet": "static\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "access_permit_read",
          "args": [
            "stp"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "access_permit_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4602-4608",
          "snippet": "static inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_permit_write",
          "args": [
            "stp"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "access_permit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4610-4615",
          "snippet": "static inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic\n__be32 nfs4_check_openmode(struct nfs4_ol_stateid *stp, int flags)\n{\n        __be32 status = nfserr_openmode;\n\n\t/* For lock stateid's, we test the parent open, not the lock: */\n\tif (stp->st_openstp)\n\t\tstp = stp->st_openstp;\n\tif ((flags & WR_STATE) && !access_permit_write(stp))\n                goto out;\n\tif ((flags & RD_STATE) && !access_permit_read(stp))\n                goto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "access_permit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4610-4615",
    "snippet": "static inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "NFS4_SHARE_ACCESS_BOTH",
            "stp"
          ],
          "line": 4614
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "964-970",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_write(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_WRITE, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp);\n}"
  },
  {
    "function_name": "access_permit_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4602-4608",
    "snippet": "static inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "NFS4_SHARE_ACCESS_WRITE",
            "stp"
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "964-970",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\naccess_permit_read(struct nfs4_ol_stateid *stp)\n{\n\treturn test_access(NFS4_SHARE_ACCESS_READ, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_BOTH, stp) ||\n\t\ttest_access(NFS4_SHARE_ACCESS_WRITE, stp);\n}"
  },
  {
    "function_name": "nfs4_check_fh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4595-4600",
    "snippet": "static inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_match",
          "args": [
            "&fhp->fh_handle",
            "&stp->sc_file->fi_fhandle"
          ],
          "line": 4597
        },
        "resolved": true,
        "details": {
          "function_name": "fh_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "191-198",
          "snippet": "static inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stid *stp)\n{\n\tif (!fh_match(&fhp->fh_handle, &stp->sc_file->fi_fhandle))\n\t\treturn nfserr_bad_stateid;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "laundromat_main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4582-4593",
    "snippet": "static void\nlaundromat_main(struct work_struct *laundry)\n{\n\ttime_t t;\n\tstruct delayed_work *dwork = to_delayed_work(laundry);\n\tstruct nfsd_net *nn = container_of(dwork, struct nfsd_net,\n\t\t\t\t\t   laundromat_work);\n\n\tt = nfs4_laundromat(nn);\n\tdprintk(\"NFSD: laundromat_main - sleeping for %ld seconds\\n\", t);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, t*HZ);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *laundry_wq;",
      "static void laundromat_main(struct work_struct *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "laundry_wq",
            "&nn->laundromat_work",
            "t*HZ"
          ],
          "line": 4592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: laundromat_main - sleeping for %ld seconds\\n\"",
            "t"
          ],
          "line": 4591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_laundromat",
          "args": [
            "nn"
          ],
          "line": 4590
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_laundromat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4500-4577",
          "snippet": "static time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dwork",
            "structnfsd_net",
            "laundromat_work"
          ],
          "line": 4587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "laundry"
          ],
          "line": 4586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct workqueue_struct *laundry_wq;\nstatic void laundromat_main(struct work_struct *);\n\nstatic void\nlaundromat_main(struct work_struct *laundry)\n{\n\ttime_t t;\n\tstruct delayed_work *dwork = to_delayed_work(laundry);\n\tstruct nfsd_net *nn = container_of(dwork, struct nfsd_net,\n\t\t\t\t\t   laundromat_work);\n\n\tt = nfs4_laundromat(nn);\n\tdprintk(\"NFSD: laundromat_main - sleeping for %ld seconds\\n\", t);\n\tqueue_delayed_work(laundry_wq, &nn->laundromat_work, t*HZ);\n}"
  },
  {
    "function_name": "nfs4_laundromat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4500-4577",
    "snippet": "static time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "time_t",
            "new_timeo",
            "NFSD_LAUNDROMAT_MINTIMEOUT"
          ],
          "line": 4575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4570
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_close_lru"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "new_timeo",
            "t"
          ],
          "line": 4563
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "(unsigned long)oo->oo_time",
            "(unsigned long)cutoff"
          ],
          "line": 4560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&nn->close_lru",
            "structnfs4_openowner",
            "oo_close_lru"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&nn->close_lru"
          ],
          "line": 4557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revoke_delegation",
          "args": [
            "dp"
          ],
          "line": 4553
        },
        "resolved": true,
        "details": {
          "function_name": "revoke_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "880-897",
          "snippet": "static void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 4552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&reaplist",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&reaplist"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 4548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&reaplist"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!unhash_delegation_locked(dp)"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 4545
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "845-864",
          "snippet": "static bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "(unsigned long)dp->dl_time",
            "(unsigned long)cutoff"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 4539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&nn->del_recall_lru"
          ],
          "line": 4538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 4535
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&clp->cl_lru"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: purging unused client (clientid %08x)\\n\"",
            "clp->cl_clientid.cl_id"
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_client",
            "cl_lru"
          ],
          "line": 4531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&reaplist"
          ],
          "line": 4530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&clp->cl_lru",
            "&reaplist"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: client in use (clientid %08x)\\n\"",
            "clp->cl_clientid.cl_id"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "clp"
          ],
          "line": 4522
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1787-1793",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "(unsigned long)clp->cl_time",
            "(unsigned long)cutoff"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structnfs4_client",
            "cl_lru"
          ],
          "line": 4516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "next",
            "&nn->client_lru"
          ],
          "line": 4515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 4514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 4513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_end_grace",
          "args": [
            "nn"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_end_grace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4467-4498",
          "snippet": "void\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: laundromat service - starting\\n\""
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic time_t\nnfs4_laundromat(struct nfsd_net *nn)\n{\n\tstruct nfs4_client *clp;\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head *pos, *next, reaplist;\n\ttime_t cutoff = get_seconds() - nn->nfsd4_lease;\n\ttime_t t, new_timeo = nn->nfsd4_lease;\n\n\tdprintk(\"NFSD: laundromat service - starting\\n\");\n\tnfsd4_end_grace(nn);\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &nn->client_lru) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tif (time_after((unsigned long)clp->cl_time, (unsigned long)cutoff)) {\n\t\t\tt = clp->cl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tif (mark_client_expired_locked(clp)) {\n\t\t\tdprintk(\"NFSD: client in use (clientid %08x)\\n\",\n\t\t\t\tclp->cl_clientid.cl_id);\n\t\t\tcontinue;\n\t\t}\n\t\tlist_add(&clp->cl_lru, &reaplist);\n\t}\n\tspin_unlock(&nn->client_lock);\n\tlist_for_each_safe(pos, next, &reaplist) {\n\t\tclp = list_entry(pos, struct nfs4_client, cl_lru);\n\t\tdprintk(\"NFSD: purging unused client (clientid %08x)\\n\",\n\t\t\tclp->cl_clientid.cl_id);\n\t\tlist_del_init(&clp->cl_lru);\n\t\texpire_client(clp);\n\t}\n\tspin_lock(&state_lock);\n\tlist_for_each_safe(pos, next, &nn->del_recall_lru) {\n\t\tdp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);\n\t\tif (time_after((unsigned long)dp->dl_time, (unsigned long)cutoff)) {\n\t\t\tt = dp->dl_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_first_entry(&reaplist, struct nfs4_delegation,\n\t\t\t\t\tdl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\trevoke_delegation(dp);\n\t}\n\n\tspin_lock(&nn->client_lock);\n\twhile (!list_empty(&nn->close_lru)) {\n\t\too = list_first_entry(&nn->close_lru, struct nfs4_openowner,\n\t\t\t\t\too_close_lru);\n\t\tif (time_after((unsigned long)oo->oo_time,\n\t\t\t       (unsigned long)cutoff)) {\n\t\t\tt = oo->oo_time - cutoff;\n\t\t\tnew_timeo = min(new_timeo, t);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\tstp = oo->oo_last_closed_stid;\n\t\too->oo_last_closed_stid = NULL;\n\t\tspin_unlock(&nn->client_lock);\n\t\tnfs4_put_stid(&stp->st_stid);\n\t\tspin_lock(&nn->client_lock);\n\t}\n\tspin_unlock(&nn->client_lock);\n\n\tnew_timeo = max_t(time_t, new_timeo, NFSD_LAUNDROMAT_MINTIMEOUT);\n\treturn new_timeo;\n}"
  },
  {
    "function_name": "nfsd4_end_grace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4467-4498",
    "snippet": "void\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_end_grace",
          "args": [
            "&nn->nfsd4_manager"
          ],
          "line": 4492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_record_grace_done",
          "args": [
            "nn"
          ],
          "line": 4482
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_record_grace_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1502-1507",
          "snippet": "void\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: end of grace period\\n\""
          ],
          "line": 4474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_end_grace(struct nfsd_net *nn)\n{\n\t/* do nothing if grace period already ended */\n\tif (nn->grace_ended)\n\t\treturn;\n\n\tdprintk(\"NFSD: end of grace period\\n\");\n\tnn->grace_ended = true;\n\t/*\n\t * If the server goes down again right now, an NFSv4\n\t * client will still be allowed to reclaim after it comes back up,\n\t * even if it hasn't yet had a chance to reclaim state this time.\n\t *\n\t */\n\tnfsd4_record_grace_done(nn);\n\t/*\n\t * At this point, NFSv4 clients can still reclaim.  But if the\n\t * server crashes, any that have not yet reclaimed will be out\n\t * of luck on the next boot.\n\t *\n\t * (NFSv4.1+ clients are considered to have reclaimed once they\n\t * call RECLAIM_COMPLETE.  NFSv4.0 clients are considered to\n\t * have reclaimed after their first OPEN.)\n\t */\n\tlocks_end_grace(&nn->nfsd4_manager);\n\t/*\n\t * At this point, and once lockd and/or any other containers\n\t * exit their grace period, further reclaims will fail and\n\t * regular locking can resume.\n\t */\n}"
  },
  {
    "function_name": "nfsd4_renew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4444-4465",
    "snippet": "__be32\nnfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    clientid_t *clid)\n{\n\tstruct nfs4_client *clp;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"process_renew(%08x/%08x): starting\\n\", \n\t\t\tclid->cl_boot, clid->cl_id);\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\tgoto out;\n\tclp = cstate->clp;\n\tstatus = nfserr_cb_path_down;\n\tif (!list_empty(&clp->cl_delegations)\n\t\t\t&& clp->cl_cb_state != NFSD4_CB_UP)\n\t\tgoto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_delegations"
          ],
          "line": 4459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clid",
            "cstate",
            "nn"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3781-3815",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"process_renew(%08x/%08x): starting\\n\"",
            "clid->cl_boot",
            "clid->cl_id"
          ],
          "line": 4452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    clientid_t *clid)\n{\n\tstruct nfs4_client *clp;\n\t__be32 status;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tdprintk(\"process_renew(%08x/%08x): starting\\n\", \n\t\t\tclid->cl_boot, clid->cl_id);\n\tstatus = lookup_clientid(clid, cstate, nn);\n\tif (status)\n\t\tgoto out;\n\tclp = cstate->clp;\n\tstatus = nfserr_cb_path_down;\n\tif (!list_empty(&clp->cl_delegations)\n\t\t\t&& clp->cl_cb_state != NFSD4_CB_UP)\n\t\tgoto out;\n\tstatus = nfs_ok;\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_cleanup_open_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4427-4442",
    "snippet": "void nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n\tif (open->op_odstate)\n\t\tkmem_cache_free(odstate_slab, open->op_odstate);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_slab;",
      "static struct kmem_cache *odstate_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "odstate_slab",
            "open->op_odstate"
          ],
          "line": 4441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&open->op_stp->st_stid"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "file_slab",
            "open->op_file"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "so"
          ],
          "line": 4434
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cstate_assign_replay",
          "args": [
            "cstate",
            "so"
          ],
          "line": 4433
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cstate_assign_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3362-3369",
          "snippet": "static void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\nstatic struct kmem_cache *odstate_slab;\n\nvoid nfsd4_cleanup_open_state(struct nfsd4_compound_state *cstate,\n\t\t\t      struct nfsd4_open *open)\n{\n\tif (open->op_openowner) {\n\t\tstruct nfs4_stateowner *so = &open->op_openowner->oo_owner;\n\n\t\tnfsd4_cstate_assign_replay(cstate, so);\n\t\tnfs4_put_stateowner(so);\n\t}\n\tif (open->op_file)\n\t\tkmem_cache_free(file_slab, open->op_file);\n\tif (open->op_stp)\n\t\tnfs4_put_stid(&open->op_stp->st_stid);\n\tif (open->op_odstate)\n\t\tkmem_cache_free(odstate_slab, open->op_odstate);\n}"
  },
  {
    "function_name": "nfsd4_process_open2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4313-4425",
    "snippet": "__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\n\t/*\n\t * Lookup file; if found, lookup stateid and check open request,\n\t * and check for delegations in the process of being recalled.\n\t * If not found, create the nfs4_file struct\n\t */\n\tfp = find_or_add_file(open->op_file, &current_fh->fh_handle);\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tspin_lock(&fp->fi_lock);\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t\tspin_unlock(&fp->fi_lock);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * OPEN the file, or upgrade an existing OPEN.\n\t * If truncate fails, the OPEN fails.\n\t */\n\tif (stp) {\n\t\t/* Stateid was found, this is an OPEN upgrade */\n\t\tmutex_lock(&stp->st_mutex);\n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* stp is returned locked. */\n\t\tstp = init_open_stateid(fp, open);\n\t\t/* See if we lost the race to some other thread */\n\t\tif (stp->st_access_bmap != 0) {\n\t\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh,\n\t\t\t\t\t\tstp, open);\n\t\t\tif (status) {\n\t\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto upgrade_out;\n\t\t}\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\trelease_open_stateid(stp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstp->st_clnt_odstate = find_or_hash_clnt_odstate(fp,\n\t\t\t\t\t\t\topen->op_odstate);\n\t\tif (stp->st_clnt_odstate == open->op_odstate)\n\t\t\topen->op_odstate = NULL;\n\t}\nupgrade_out:\n\tnfs4_inc_and_copy_stateid(&open->op_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t/*\n\t* Attempt to hand out a delegation. No error return, because the\n\t* OPEN succeeds even if we fail.\n\t*/\n\tnfs4_open_delegation(current_fh, open, stp);\nnodeleg:\n\tstatus = nfs_ok;\n\n\tdprintk(\"%s: stateid=\" STATEID_FMT \"\\n\", __func__,\n\t\tSTATEID_VAL(&stp->st_stid.sc_stateid));\nout:\n\t/* 4.1 client trying to upgrade/downgrade delegation? */\n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t/*\n\t* To finish the open response, we just need to set the rflags.\n\t*/\n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED) &&\n\t    !nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 4422
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "&resp->cstate"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "277-289",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_deleg_xgrade_none_ext",
          "args": [
            "open",
            "dp"
          ],
          "line": 4406
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_deleg_xgrade_none_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4295-4311",
          "snippet": "static void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: stateid=\" STATEID_FMT \"\\n\"",
            "__func__",
            "STATEID_VAL(&stp->st_stid.sc_stateid)"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "&stp->st_stid.sc_stateid"
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_open_delegation",
          "args": [
            "current_fh",
            "open",
            "stp"
          ],
          "line": 4396
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_open_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4225-4293",
          "snippet": "static void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs, *and* until\n\t\t\t * NLM locks have all been reclaimed:\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file, stp->st_clnt_odstate);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs, *and* until\n\t\t\t * NLM locks have all been reclaimed:\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file, stp->st_clnt_odstate);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 4382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_inc_and_copy_stateid",
          "args": [
            "&open->op_stateid",
            "&stp->st_stid"
          ],
          "line": 4381
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_inc_and_copy_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "749-759",
          "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_hash_clnt_odstate",
          "args": [
            "fp",
            "open->op_odstate"
          ],
          "line": 4375
        },
        "resolved": true,
        "details": {
          "function_name": "find_or_hash_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "530-554",
          "snippet": "static struct nfs4_clnt_odstate *\nfind_or_hash_clnt_odstate(struct nfs4_file *fp, struct nfs4_clnt_odstate *new)\n{\n\tstruct nfs4_clnt_odstate *co;\n\tstruct nfs4_client *cl;\n\n\tif (!new)\n\t\treturn NULL;\n\n\tcl = new->co_client;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(co, &fp->fi_clnt_odstate, co_perfile) {\n\t\tif (co->co_client == cl) {\n\t\t\tget_clnt_odstate(co);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tco = new;\n\tco->co_file = fp;\n\thash_clnt_odstate_locked(new);\nout:\n\tspin_unlock(&fp->fi_lock);\n\treturn co;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_clnt_odstate *\nfind_or_hash_clnt_odstate(struct nfs4_file *fp, struct nfs4_clnt_odstate *new)\n{\n\tstruct nfs4_clnt_odstate *co;\n\tstruct nfs4_client *cl;\n\n\tif (!new)\n\t\treturn NULL;\n\n\tcl = new->co_client;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(co, &fp->fi_clnt_odstate, co_perfile) {\n\t\tif (co->co_client == cl) {\n\t\t\tget_clnt_odstate(co);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tco = new;\n\tco->co_file = fp;\n\thash_clnt_odstate_locked(new);\nout:\n\tspin_unlock(&fp->fi_lock);\n\treturn co;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_open_stateid",
          "args": [
            "stp"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "release_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1251-1260",
          "snippet": "static void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tif (unhash_open_stateid(stp, &reaplist))\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tif (unhash_open_stateid(stp, &reaplist))\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_vfs_file",
          "args": [
            "rqstp",
            "fp",
            "current_fh",
            "stp",
            "open"
          ],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_vfs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3961-4024",
          "snippet": "static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_upgrade_open",
          "args": [
            "rqstp",
            "fp",
            "current_fh",
            "stp",
            "open"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_upgrade_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4026-4052",
          "snippet": "static __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap = stp->st_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap = stp->st_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_open_stateid",
          "args": [
            "fp",
            "open"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "init_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3482-3525",
          "snippet": "static struct nfs4_ol_stateid *\ninit_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\tstruct nfs4_ol_stateid *retstp = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstp = open->op_stp;\n\t/* We are moving these outside of the spinlocks to avoid the warnings */\n\tmutex_init(&stp->st_mutex);\n\tmutex_lock(&stp->st_mutex);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tspin_lock(&fp->fi_lock);\n\n\tretstp = nfsd4_find_existing_open(fp, open);\n\tif (retstp)\n\t\tgoto out_unlock;\n\n\topen->op_stp = NULL;\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (retstp) {\n\t\tmutex_lock(&retstp->st_mutex);\n\t\t/* To keep mutex tracking happy */\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tstp = retstp;\n\t}\n\treturn stp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\ninit_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\tstruct nfs4_ol_stateid *retstp = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstp = open->op_stp;\n\t/* We are moving these outside of the spinlocks to avoid the warnings */\n\tmutex_init(&stp->st_mutex);\n\tmutex_lock(&stp->st_mutex);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tspin_lock(&fp->fi_lock);\n\n\tretstp = nfsd4_find_existing_open(fp, open);\n\tif (retstp)\n\t\tgoto out_unlock;\n\n\topen->op_stp = NULL;\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (retstp) {\n\t\tmutex_lock(&retstp->st_mutex);\n\t\t/* To keep mutex tracking happy */\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tstp = retstp;\n\t}\n\treturn stp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 4352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 4349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_is_deleg_cur",
          "args": [
            "open"
          ],
          "line": 4339
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_is_deleg_cur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3902-3906",
          "snippet": "static bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_find_existing_open",
          "args": [
            "fp",
            "open"
          ],
          "line": 4334
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_existing_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3430-3449",
          "snippet": "static struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_check_deleg",
          "args": [
            "cl",
            "open",
            "&dp"
          ],
          "line": 4330
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3908-3933",
          "snippet": "static __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_or_add_file",
          "args": [
            "open->op_file",
            "&current_fh->fh_handle"
          ],
          "line": 4328
        },
        "resolved": true,
        "details": {
          "function_name": "find_or_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3596-3617",
          "snippet": "static struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\n__be32\nnfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open *open)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfs4_client *cl = open->op_openowner->oo_owner.so_client;\n\tstruct nfs4_file *fp = NULL;\n\tstruct nfs4_ol_stateid *stp = NULL;\n\tstruct nfs4_delegation *dp = NULL;\n\t__be32 status;\n\n\t/*\n\t * Lookup file; if found, lookup stateid and check open request,\n\t * and check for delegations in the process of being recalled.\n\t * If not found, create the nfs4_file struct\n\t */\n\tfp = find_or_add_file(open->op_file, &current_fh->fh_handle);\n\tif (fp != open->op_file) {\n\t\tstatus = nfs4_check_deleg(cl, open, &dp);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tspin_lock(&fp->fi_lock);\n\t\tstp = nfsd4_find_existing_open(fp, open);\n\t\tspin_unlock(&fp->fi_lock);\n\t} else {\n\t\topen->op_file = NULL;\n\t\tstatus = nfserr_bad_stateid;\n\t\tif (nfsd4_is_deleg_cur(open))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * OPEN the file, or upgrade an existing OPEN.\n\t * If truncate fails, the OPEN fails.\n\t */\n\tif (stp) {\n\t\t/* Stateid was found, this is an OPEN upgrade */\n\t\tmutex_lock(&stp->st_mutex);\n\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/* stp is returned locked. */\n\t\tstp = init_open_stateid(fp, open);\n\t\t/* See if we lost the race to some other thread */\n\t\tif (stp->st_access_bmap != 0) {\n\t\t\tstatus = nfs4_upgrade_open(rqstp, fp, current_fh,\n\t\t\t\t\t\tstp, open);\n\t\t\tif (status) {\n\t\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto upgrade_out;\n\t\t}\n\t\tstatus = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);\n\t\tif (status) {\n\t\t\tmutex_unlock(&stp->st_mutex);\n\t\t\trelease_open_stateid(stp);\n\t\t\tgoto out;\n\t\t}\n\n\t\tstp->st_clnt_odstate = find_or_hash_clnt_odstate(fp,\n\t\t\t\t\t\t\topen->op_odstate);\n\t\tif (stp->st_clnt_odstate == open->op_odstate)\n\t\t\topen->op_odstate = NULL;\n\t}\nupgrade_out:\n\tnfs4_inc_and_copy_stateid(&open->op_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tif (nfsd4_has_session(&resp->cstate)) {\n\t\tif (open->op_deleg_want & NFS4_SHARE_WANT_NO_DELEG) {\n\t\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\t\topen->op_why_no_deleg = WND4_NOT_WANTED;\n\t\t\tgoto nodeleg;\n\t\t}\n\t}\n\n\t/*\n\t* Attempt to hand out a delegation. No error return, because the\n\t* OPEN succeeds even if we fail.\n\t*/\n\tnfs4_open_delegation(current_fh, open, stp);\nnodeleg:\n\tstatus = nfs_ok;\n\n\tdprintk(\"%s: stateid=\" STATEID_FMT \"\\n\", __func__,\n\t\tSTATEID_VAL(&stp->st_stid.sc_stateid));\nout:\n\t/* 4.1 client trying to upgrade/downgrade delegation? */\n\tif (open->op_delegate_type == NFS4_OPEN_DELEGATE_NONE && dp &&\n\t    open->op_deleg_want)\n\t\tnfsd4_deleg_xgrade_none_ext(open, dp);\n\n\tif (fp)\n\t\tput_nfs4_file(fp);\n\tif (status == 0 && open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)\n\t\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\t/*\n\t* To finish the open response, we just need to set the rflags.\n\t*/\n\topen->op_rflags = NFS4_OPEN_RESULT_LOCKTYPE_POSIX;\n\tif (!(open->op_openowner->oo_flags & NFS4_OO_CONFIRMED) &&\n\t    !nfsd4_has_session(&resp->cstate))\n\t\topen->op_rflags |= NFS4_OPEN_RESULT_CONFIRM;\n\tif (dp)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\tif (stp)\n\t\tnfs4_put_stid(&stp->st_stid);\n\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_deleg_xgrade_none_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4295-4311",
    "snippet": "static void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_deleg_xgrade_none_ext(struct nfsd4_open *open,\n\t\t\t\t\tstruct nfs4_delegation *dp)\n{\n\tif (open->op_deleg_want == NFS4_SHARE_WANT_READ_DELEG &&\n\t    dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_DOWNGRADE;\n\t} else if (open->op_deleg_want == NFS4_SHARE_WANT_WRITE_DELEG &&\n\t\t   dp->dl_type == NFS4_OPEN_DELEGATE_WRITE) {\n\t\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\t\topen->op_why_no_deleg = WND4_NOT_SUPP_UPGRADE;\n\t}\n\t/* Otherwise the client must be confused wanting a delegation\n\t * it already has, therefore we don't return\n\t * NFS4_OPEN_DELEGATE_NONE_EXT and reason.\n\t */\n}"
  },
  {
    "function_name": "nfs4_open_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4225-4293",
    "snippet": "static void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs, *and* until\n\t\t\t * NLM locks have all been reclaimed:\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file, stp->st_clnt_odstate);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_open_deleg_none_ext",
          "args": [
            "open",
            "status"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_open_deleg_none_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4198-4217",
          "snippet": "static void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: WARNING: refusing delegation reclaim\\n\""
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 4279
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\"",
            "STATEID_VAL(&dp->dl_stid.sc_stateid)"
          ],
          "line": 4276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATEID_VAL",
          "args": [
            "&dp->dl_stid.sc_stateid"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&open->op_delegate_stateid",
            "&dp->dl_stid.sc_stateid",
            "sizeof(dp->dl_stid.sc_stateid)"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dp"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_set_delegation",
          "args": [
            "clp",
            "fh",
            "stp->st_stid.sc_file",
            "stp->st_clnt_odstate"
          ],
          "line": 4270
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_set_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4148-4196",
          "snippet": "static struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp, struct nfs4_clnt_odstate *odstate)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tdp = alloc_init_deleg(clp, fh, odstate);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\tstatus = hash_delegation_locked(dp, fp);\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp, struct nfs4_clnt_odstate *odstate)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tdp = alloc_init_deleg(clp, fh, odstate);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\tstatus = hash_delegation_locked(dp, fp);\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "locks_in_grace",
          "args": [
            "clp->net"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cb_channel_good",
          "args": [
            "oo->oo_owner.so_client"
          ],
          "line": 4235
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cb_channel_good",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4055-4065",
          "snippet": "static bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 4230
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open,\n\t\t\tstruct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_delegation *dp;\n\tstruct nfs4_openowner *oo = openowner(stp->st_stateowner);\n\tstruct nfs4_client *clp = stp->st_stid.sc_client;\n\tint cb_up;\n\tint status = 0;\n\n\tcb_up = nfsd4_cb_channel_good(oo->oo_owner.so_client);\n\topen->op_recall = 0;\n\tswitch (open->op_claim_type) {\n\t\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\t\tif (!cb_up)\n\t\t\t\topen->op_recall = 1;\n\t\t\tif (open->op_delegate_type != NFS4_OPEN_DELEGATE_READ)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tcase NFS4_OPEN_CLAIM_FH:\n\t\t\t/*\n\t\t\t * Let's not give out any delegations till everyone's\n\t\t\t * had the chance to reclaim theirs, *and* until\n\t\t\t * NLM locks have all been reclaimed:\n\t\t\t */\n\t\t\tif (locks_in_grace(clp->net))\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (!cb_up || !(oo->oo_flags & NFS4_OO_CONFIRMED))\n\t\t\t\tgoto out_no_deleg;\n\t\t\t/*\n\t\t\t * Also, if the file was opened for write or\n\t\t\t * create, there's a good chance the client's\n\t\t\t * about to write to it, resulting in an\n\t\t\t * immediate recall (since we don't support\n\t\t\t * write delegations):\n\t\t\t */\n\t\t\tif (open->op_share_access & NFS4_SHARE_ACCESS_WRITE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tif (open->op_create == NFS4_OPEN_CREATE)\n\t\t\t\tgoto out_no_deleg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out_no_deleg;\n\t}\n\tdp = nfs4_set_delegation(clp, fh, stp->st_stid.sc_file, stp->st_clnt_odstate);\n\tif (IS_ERR(dp))\n\t\tgoto out_no_deleg;\n\n\tmemcpy(&open->op_delegate_stateid, &dp->dl_stid.sc_stateid, sizeof(dp->dl_stid.sc_stateid));\n\n\tdprintk(\"NFSD: delegation stateid=\" STATEID_FMT \"\\n\",\n\t\tSTATEID_VAL(&dp->dl_stid.sc_stateid));\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_READ;\n\tnfs4_put_stid(&dp->dl_stid);\n\treturn;\nout_no_deleg:\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE;\n\tif (open->op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS &&\n\t    open->op_delegate_type != NFS4_OPEN_DELEGATE_NONE) {\n\t\tdprintk(\"NFSD: WARNING: refusing delegation reclaim\\n\");\n\t\topen->op_recall = 1;\n\t}\n\n\t/* 4.1 client asking for a delegation? */\n\tif (open->op_deleg_want)\n\t\tnfsd4_open_deleg_none_ext(open, status);\n\treturn;\n}"
  },
  {
    "function_name": "nfsd4_open_deleg_none_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4198-4217",
    "snippet": "static void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_open_deleg_none_ext(struct nfsd4_open *open, int status)\n{\n\topen->op_delegate_type = NFS4_OPEN_DELEGATE_NONE_EXT;\n\tif (status == -EAGAIN)\n\t\topen->op_why_no_deleg = WND4_CONTENTION;\n\telse {\n\t\topen->op_why_no_deleg = WND4_RESOURCE;\n\t\tswitch (open->op_deleg_want) {\n\t\tcase NFS4_SHARE_WANT_READ_DELEG:\n\t\tcase NFS4_SHARE_WANT_WRITE_DELEG:\n\t\tcase NFS4_SHARE_WANT_ANY_DELEG:\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_CANCEL:\n\t\t\topen->op_why_no_deleg = WND4_CANCELLED;\n\t\t\tbreak;\n\t\tcase NFS4_SHARE_WANT_NO_DELEG:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "nfs4_set_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4148-4196",
    "snippet": "static struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp, struct nfs4_clnt_odstate *odstate)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tdp = alloc_init_deleg(clp, fh, odstate);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\tstatus = hash_delegation_locked(dp, fp);\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 4193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 4192
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_clnt_odstate",
          "args": [
            "dp->dl_clnt_odstate"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "put_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "512-528",
          "snippet": "static void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *odstate_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 4188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_delegation_locked",
          "args": [
            "dp",
            "fp"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "hash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "825-843",
          "snippet": "static int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tif (status)\n\t\treturn status;\n\t++fp->fi_delegees;\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tif (status)\n\t\treturn status;\n\t++fp->fi_delegees;\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_setlease",
          "args": [
            "dp"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_setlease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4095-4146",
          "snippet": "static int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\tlocks_free_lock(fl);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = hash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 0;\n\tstatus = hash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\tif (status) {\n\t\t/* Should never happen, this is a new fi_deleg_file  */\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out_fput;\n\t}\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\tlocks_free_lock(fl);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = hash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 0;\n\tstatus = hash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\tif (status) {\n\t\t/* Should never happen, this is a new fi_deleg_file  */\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out_fput;\n\t}\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 4172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "619-622",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_init_deleg",
          "args": [
            "clp",
            "fh",
            "odstate"
          ],
          "line": 4167
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_init_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "691-728",
          "snippet": "static struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh,\n\t\t struct nfs4_clnt_odstate *odstate)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_clnt_odstate = odstate;\n\tget_clnt_odstate(odstate);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *deleg_slab;",
            "static const struct nfsd4_callback_ops nfsd4_cb_recall_ops;",
            "static atomic_long_t num_delegations;",
            "unsigned long max_delegations;",
            "static const struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *deleg_slab;\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops;\nstatic atomic_long_t num_delegations;\nunsigned long max_delegations;\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};\n\nstatic struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh,\n\t\t struct nfs4_clnt_odstate *odstate)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_clnt_odstate = odstate;\n\tget_clnt_odstate(odstate);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "status"
          ],
          "line": 4165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_existing_delegation",
          "args": [
            "clp",
            "fp"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_existing_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "794-810",
          "snippet": "static int\nnfs4_get_existing_delegation(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int\nnfs4_get_existing_delegation(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 4158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_delegation *\nnfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,\n\t\t    struct nfs4_file *fp, struct nfs4_clnt_odstate *odstate)\n{\n\tint status;\n\tstruct nfs4_delegation *dp;\n\n\tif (fp->fi_had_conflict)\n\t\treturn ERR_PTR(-EAGAIN);\n\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\n\tif (status)\n\t\treturn ERR_PTR(status);\n\n\tdp = alloc_init_deleg(clp, fh, odstate);\n\tif (!dp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tget_nfs4_file(fp);\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\tdp->dl_stid.sc_file = fp;\n\tif (!fp->fi_deleg_file) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tspin_unlock(&state_lock);\n\t\tstatus = nfs4_setlease(dp);\n\t\tgoto out;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\tstatus = hash_delegation_locked(dp, fp);\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout:\n\tif (status) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn dp;\n}"
  },
  {
    "function_name": "nfs4_setlease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4095-4146",
    "snippet": "static int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\tlocks_free_lock(fl);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = hash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 0;\n\tstatus = hash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\tif (status) {\n\t\t/* Should never happen, this is a new fi_deleg_file  */\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out_fput;\n\t}\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 4142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_delegation_locked",
          "args": [
            "dp",
            "fp"
          ],
          "line": 4131
        },
        "resolved": true,
        "details": {
          "function_name": "hash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "825-843",
          "snippet": "static int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tif (status)\n\t\treturn status;\n\t++fp->fi_delegees;\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tif (status)\n\t\treturn status;\n\t++fp->fi_delegees;\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "fl->fl_type",
            "&fl",
            "NULL"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock",
          "args": [
            "fl"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 4108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_readable_file",
          "args": [
            "fp"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "336-346",
          "snippet": "static struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_init_lease",
          "args": [
            "fp",
            "NFS4_OPEN_DELEGATE_READ"
          ],
          "line": 4102
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_init_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "4067-4081",
          "snippet": "static struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};\n\nstatic struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int nfs4_setlease(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\tstruct file_lock *fl;\n\tstruct file *filp;\n\tint status = 0;\n\n\tfl = nfs4_alloc_init_lease(fp, NFS4_OPEN_DELEGATE_READ);\n\tif (!fl)\n\t\treturn -ENOMEM;\n\tfilp = find_readable_file(fp);\n\tif (!filp) {\n\t\t/* We should always have a readable file here */\n\t\tWARN_ON_ONCE(1);\n\t\tlocks_free_lock(fl);\n\t\treturn -EBADF;\n\t}\n\tfl->fl_file = filp;\n\tstatus = vfs_setlease(filp, fl->fl_type, &fl, NULL);\n\tif (fl)\n\t\tlocks_free_lock(fl);\n\tif (status)\n\t\tgoto out_fput;\n\tspin_lock(&state_lock);\n\tspin_lock(&fp->fi_lock);\n\t/* Did the lease get broken before we took the lock? */\n\tstatus = -EAGAIN;\n\tif (fp->fi_had_conflict)\n\t\tgoto out_unlock;\n\t/* Race breaker */\n\tif (fp->fi_deleg_file) {\n\t\tstatus = hash_delegation_locked(dp, fp);\n\t\tgoto out_unlock;\n\t}\n\tfp->fi_deleg_file = filp;\n\tfp->fi_delegees = 0;\n\tstatus = hash_delegation_locked(dp, fp);\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\n\tif (status) {\n\t\t/* Should never happen, this is a new fi_deleg_file  */\n\t\tWARN_ON_ONCE(1);\n\t\tgoto out_fput;\n\t}\n\treturn 0;\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&state_lock);\nout_fput:\n\tfput(filp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_alloc_init_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4067-4081",
    "snippet": "static struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "locks_alloc_lock",
          "args": [],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic const struct lock_manager_operations nfsd_lease_mng_ops = {\n\t.lm_break = nfsd_break_deleg_cb,\n\t.lm_change = nfsd_change_deleg_cb,\n};\n\nstatic struct file_lock *nfs4_alloc_init_lease(struct nfs4_file *fp, int flag)\n{\n\tstruct file_lock *fl;\n\n\tfl = locks_alloc_lock();\n\tif (!fl)\n\t\treturn NULL;\n\tfl->fl_lmops = &nfsd_lease_mng_ops;\n\tfl->fl_flags = FL_DELEG;\n\tfl->fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;\n\tfl->fl_end = OFFSET_MAX;\n\tfl->fl_owner = (fl_owner_t)fp;\n\tfl->fl_pid = current->tgid;\n\treturn fl;\n}"
  },
  {
    "function_name": "nfsd4_cb_channel_good",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4055-4065",
    "snippet": "static bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_cb_channel_good(struct nfs4_client *clp)\n{\n\tif (clp->cl_cb_state == NFSD4_CB_UP)\n\t\treturn true;\n\t/*\n\t * In the sessions case, since we don't have to establish a\n\t * separate connection for callbacks, we assume it's OK\n\t * until we hear otherwise:\n\t */\n\treturn clp->cl_minorversion && clp->cl_cb_state == NFSD4_CB_UNKNOWN;\n}"
  },
  {
    "function_name": "nfs4_upgrade_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "4026-4052",
    "snippet": "static __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap = stp->st_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_union_bmap_deny",
          "args": [
            "old_deny_bmap",
            "stp"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "reset_union_bmap_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1031-1047",
          "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_truncate",
          "args": [
            "rqstp",
            "cur_fh",
            "open"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3946-3959",
          "snippet": "static inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_deny",
          "args": [
            "open->op_share_deny",
            "stp"
          ],
          "line": 4039
        },
        "resolved": true,
        "details": {
          "function_name": "set_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "973-980",
          "snippet": "static inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_check_deny",
          "args": [
            "fp",
            "open->op_share_deny"
          ],
          "line": 4037
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_check_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "428-445",
          "snippet": "static __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_vfs_file",
          "args": [
            "rqstp",
            "fp",
            "cur_fh",
            "stp",
            "open"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_vfs_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3961-4024",
          "snippet": "static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "open->op_share_access",
            "stp"
          ],
          "line": 4032
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "964-970",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_ol_stateid *stp, struct nfsd4_open *open)\n{\n\t__be32 status;\n\tunsigned char old_deny_bmap = stp->st_deny_bmap;\n\n\tif (!test_access(open->op_share_access, stp))\n\t\treturn nfs4_get_vfs_file(rqstp, fp, cur_fh, stp, open);\n\n\t/* test and set deny mode */\n\tspin_lock(&fp->fi_lock);\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status == nfs_ok) {\n\t\tset_deny(open->op_share_deny, stp);\n\t\tfp->fi_share_deny |=\n\t\t\t\t(open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tif (status != nfs_ok)\n\t\treturn status;\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status != nfs_ok)\n\t\treset_union_bmap_deny(old_deny_bmap, stp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_get_vfs_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3961-4024",
    "snippet": "static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_union_bmap_deny",
          "args": [
            "bmap_to_share_mode(old_deny_bmap)",
            "stp"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "reset_union_bmap_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1031-1047",
          "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bmap_to_share_mode",
          "args": [
            "old_deny_bmap"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_to_share_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "931-941",
          "snippet": "static unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_put_access",
          "args": [
            "fp",
            "open->op_share_access"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "466-474",
          "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_truncate",
          "args": [
            "rqstp",
            "cur_fh",
            "open"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3946-3959",
          "snippet": "static inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_open",
          "args": [
            "rqstp",
            "cur_fh",
            "S_IFREG",
            "access",
            "&filp"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "651-736",
          "snippet": "__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tfput(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,\n\t\t\tint may_flags, struct file **filp)\n{\n\tstruct path\tpath;\n\tstruct inode\t*inode;\n\tstruct file\t*file;\n\tint\t\tflags = O_RDONLY|O_LARGEFILE;\n\t__be32\t\terr;\n\tint\t\thost_err = 0;\n\n\tvalidate_process_creds();\n\n\t/*\n\t * If we get here, then the client has already done an \"open\",\n\t * and (hopefully) checked permission - so allow OWNER_OVERRIDE\n\t * in case a chmod has now revoked permission.\n\t *\n\t * Arguably we should also allow the owner override for\n\t * directories, but we never have and it doesn't seem to have\n\t * caused anyone a problem.  If we were to change this, note\n\t * also that our filldir callbacks would need a variant of\n\t * lookup_one_len that doesn't check permissions.\n\t */\n\tif (type == S_IFREG)\n\t\tmay_flags |= NFSD_MAY_OWNER_OVERRIDE;\n\terr = fh_verify(rqstp, fhp, type, may_flags);\n\tif (err)\n\t\tgoto out;\n\n\tpath.mnt = fhp->fh_export->ex_path.mnt;\n\tpath.dentry = fhp->fh_dentry;\n\tinode = d_inode(path.dentry);\n\n\t/* Disallow write access to files with the append-only bit set\n\t * or any access when mandatory locking enabled\n\t */\n\terr = nfserr_perm;\n\tif (IS_APPEND(inode) && (may_flags & NFSD_MAY_WRITE))\n\t\tgoto out;\n\t/*\n\t * We must ignore files (but only files) which might have mandatory\n\t * locks on them because there is no way to know if the accesser has\n\t * the lock.\n\t */\n\tif (S_ISREG((inode)->i_mode) && mandatory_lock(inode))\n\t\tgoto out;\n\n\tif (!inode->i_fop)\n\t\tgoto out;\n\n\thost_err = nfsd_open_break_lease(inode, may_flags);\n\tif (host_err) /* NOMEM or WOULDBLOCK */\n\t\tgoto out_nfserr;\n\n\tif (may_flags & NFSD_MAY_WRITE) {\n\t\tif (may_flags & NFSD_MAY_READ)\n\t\t\tflags = O_RDWR|O_LARGEFILE;\n\t\telse\n\t\t\tflags = O_WRONLY|O_LARGEFILE;\n\t}\n\n\tfile = dentry_open(&path, flags, current_cred());\n\tif (IS_ERR(file)) {\n\t\thost_err = PTR_ERR(file);\n\t\tgoto out_nfserr;\n\t}\n\n\thost_err = ima_file_check(file, may_flags, 0);\n\tif (host_err) {\n\t\tfput(file);\n\t\tgoto out_nfserr;\n\t}\n\n\tif (may_flags & NFSD_MAY_64BIT_COOKIE)\n\t\tfile->f_mode |= FMODE_64BITHASH;\n\telse\n\t\tfile->f_mode |= FMODE_32BITHASH;\n\n\t*filp = file;\nout_nfserr:\n\terr = nfserrno(host_err);\nout:\n\tvalidate_process_creds();\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 4000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_deny",
          "args": [
            "open->op_share_deny",
            "stp"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "set_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "973-980",
          "snippet": "static inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_access",
          "args": [
            "open->op_share_access",
            "stp"
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "set_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "944-951",
          "snippet": "static inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_file_get_access",
          "args": [
            "fp",
            "open->op_share_access"
          ],
          "line": 3984
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_get_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "411-426",
          "snippet": "static __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_file_check_deny",
          "args": [
            "fp",
            "open->op_share_deny"
          ],
          "line": 3977
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_check_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "428-445",
          "snippet": "static __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_access_to_access",
          "args": [
            "open->op_share_access"
          ],
          "line": 3968
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_access_to_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3935-3944",
          "snippet": "static inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_access_to_omode",
          "args": [
            "open->op_share_access"
          ],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_access_to_omode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1001-1013",
          "snippet": "static int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file *fp,\n\t\tstruct svc_fh *cur_fh, struct nfs4_ol_stateid *stp,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct file *filp = NULL;\n\t__be32 status;\n\tint oflag = nfs4_access_to_omode(open->op_share_access);\n\tint access = nfs4_access_to_access(open->op_share_access);\n\tunsigned char old_access_bmap, old_deny_bmap;\n\n\tspin_lock(&fp->fi_lock);\n\n\t/*\n\t * Are we trying to set a deny mode that would conflict with\n\t * current access?\n\t */\n\tstatus = nfs4_file_check_deny(fp, open->op_share_deny);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* set access to the file */\n\tstatus = nfs4_file_get_access(fp, open->op_share_access);\n\tif (status != nfs_ok) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tgoto out;\n\t}\n\n\t/* Set access bits in stateid */\n\told_access_bmap = stp->st_access_bmap;\n\tset_access(open->op_share_access, stp);\n\n\t/* Set new deny mask */\n\told_deny_bmap = stp->st_deny_bmap;\n\tset_deny(open->op_share_deny, stp);\n\tfp->fi_share_deny |= (open->op_share_deny & NFS4_SHARE_DENY_BOTH);\n\n\tif (!fp->fi_fds[oflag]) {\n\t\tspin_unlock(&fp->fi_lock);\n\t\tstatus = nfsd_open(rqstp, cur_fh, S_IFREG, access, &filp);\n\t\tif (status)\n\t\t\tgoto out_put_access;\n\t\tspin_lock(&fp->fi_lock);\n\t\tif (!fp->fi_fds[oflag]) {\n\t\t\tfp->fi_fds[oflag] = filp;\n\t\t\tfilp = NULL;\n\t\t}\n\t}\n\tspin_unlock(&fp->fi_lock);\n\tif (filp)\n\t\tfput(filp);\n\n\tstatus = nfsd4_truncate(rqstp, cur_fh, open);\n\tif (status)\n\t\tgoto out_put_access;\nout:\n\treturn status;\nout_put_access:\n\tstp->st_access_bmap = old_access_bmap;\n\tnfs4_file_put_access(fp, open->op_share_access);\n\treset_union_bmap_deny(bmap_to_share_mode(old_deny_bmap), stp);\n\tgoto out;\n}"
  },
  {
    "function_name": "nfsd4_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3946-3959",
    "snippet": "static inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_setattr",
          "args": [
            "rqstp",
            "fh",
            "&iattr",
            "0",
            "(time_t)0"
          ],
          "line": 3958
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "369-452",
          "snippet": "__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,\n\t     int check_guard, time_t guardtime)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\tint\t\taccmode = NFSD_MAY_SATTR;\n\tumode_t\t\tftype = 0;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\tbool\t\tget_write_count;\n\tint\t\tsize_change = 0;\n\n\tif (iap->ia_valid & (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))\n\t\taccmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;\n\tif (iap->ia_valid & ATTR_SIZE)\n\t\tftype = S_IFREG;\n\n\t/* Callers that do fh_verify should do the fh_want_write: */\n\tget_write_count = !fhp->fh_dentry;\n\n\t/* Get inode */\n\terr = fh_verify(rqstp, fhp, ftype, accmode);\n\tif (err)\n\t\tgoto out;\n\tif (get_write_count) {\n\t\thost_err = fh_want_write(fhp);\n\t\tif (host_err)\n\t\t\treturn nfserrno(host_err);\n\t}\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\t/* Ignore any mode updates on symlinks */\n\tif (S_ISLNK(inode->i_mode))\n\t\tiap->ia_valid &= ~ATTR_MODE;\n\n\tif (!iap->ia_valid)\n\t\tgoto out;\n\n\tnfsd_sanitize_attrs(inode, iap);\n\n\t/*\n\t * The size case is special, it changes the file in addition to the\n\t * attributes.\n\t */\n\tif (iap->ia_valid & ATTR_SIZE) {\n\t\terr = nfsd_get_write_access(rqstp, fhp, iap);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tsize_change = 1;\n\n\t\t/*\n\t\t * RFC5661, Section 18.30.4:\n\t\t *   Changing the size of a file with SETATTR indirectly\n\t\t *   changes the time_modify and change attributes.\n\t\t *\n\t\t * (and similar for the older RFCs)\n\t\t */\n\t\tif (iap->ia_size != i_size_read(inode))\n\t\t\tiap->ia_valid |= ATTR_MTIME;\n\t}\n\n\tiap->ia_valid |= ATTR_CTIME;\n\n\tif (check_guard && guardtime != inode->i_ctime.tv_sec) {\n\t\terr = nfserr_notsync;\n\t\tgoto out_put_write_access;\n\t}\n\n\tfh_lock(fhp);\n\thost_err = notify_change(dentry, iap, NULL);\n\tfh_unlock(fhp);\n\terr = nfserrno(host_err);\n\nout_put_write_access:\n\tif (size_change)\n\t\tput_write_access(inode);\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\nout:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,\n\t\tstruct nfsd4_open *open)\n{\n\tstruct iattr iattr = {\n\t\t.ia_valid = ATTR_SIZE,\n\t\t.ia_size = 0,\n\t};\n\tif (!open->op_truncate)\n\t\treturn 0;\n\tif (!(open->op_share_access & NFS4_SHARE_ACCESS_WRITE))\n\t\treturn nfserr_inval;\n\treturn nfsd_setattr(rqstp, fh, &iattr, 0, (time_t)0);\n}"
  },
  {
    "function_name": "nfs4_access_to_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3935-3944",
    "snippet": "static inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int nfs4_access_to_access(u32 nfs4_access)\n{\n\tint flags = 0;\n\n\tif (nfs4_access & NFS4_SHARE_ACCESS_READ)\n\t\tflags |= NFSD_MAY_READ;\n\tif (nfs4_access & NFS4_SHARE_ACCESS_WRITE)\n\t\tflags |= NFSD_MAY_WRITE;\n\treturn flags;\n}"
  },
  {
    "function_name": "nfs4_check_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3908-3933",
    "snippet": "static __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_is_deleg_cur",
          "args": [
            "open"
          ],
          "line": 3927
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_is_deleg_cur",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3902-3906",
          "snippet": "static bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&deleg->dl_stid"
          ],
          "line": 3922
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_check_delegmode",
          "args": [
            "deleg",
            "flags"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_check_delegmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3878-3885",
          "snippet": "static inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "share_access_to_flags",
          "args": [
            "open->op_share_access"
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "share_access_to_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3887-3890",
          "snippet": "static int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_deleg_stateid",
          "args": [
            "cl",
            "&open->op_delegate_stateid"
          ],
          "line": 3916
        },
        "resolved": true,
        "details": {
          "function_name": "find_deleg_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3892-3900",
          "snippet": "static struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,\n\t\tstruct nfs4_delegation **dp)\n{\n\tint flags;\n\t__be32 status = nfserr_bad_stateid;\n\tstruct nfs4_delegation *deleg;\n\n\tdeleg = find_deleg_stateid(cl, &open->op_delegate_stateid);\n\tif (deleg == NULL)\n\t\tgoto out;\n\tflags = share_access_to_flags(open->op_share_access);\n\tstatus = nfs4_check_delegmode(deleg, flags);\n\tif (status) {\n\t\tnfs4_put_stid(&deleg->dl_stid);\n\t\tgoto out;\n\t}\n\t*dp = deleg;\nout:\n\tif (!nfsd4_is_deleg_cur(open))\n\t\treturn nfs_ok;\n\tif (status)\n\t\treturn status;\n\topen->op_openowner->oo_flags |= NFS4_OO_CONFIRMED;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_is_deleg_cur",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3902-3906",
    "snippet": "static bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool nfsd4_is_deleg_cur(struct nfsd4_open *open)\n{\n\treturn open->op_claim_type == NFS4_OPEN_CLAIM_DELEGATE_CUR ||\n\t       open->op_claim_type == NFS4_OPEN_CLAIM_DELEG_CUR_FH;\n}"
  },
  {
    "function_name": "find_deleg_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3892-3900",
    "snippet": "static struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "ret"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "154-157",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_stateid_by_type",
          "args": [
            "cl",
            "s",
            "NFS4_DELEG_STID"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_by_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2024-2039",
          "snippet": "static struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, stateid_t *s)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);\n\tif (!ret)\n\t\treturn NULL;\n\treturn delegstateid(ret);\n}"
  },
  {
    "function_name": "share_access_to_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3887-3890",
    "snippet": "static int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int share_access_to_flags(u32 share_access)\n{\n\treturn share_access == NFS4_SHARE_ACCESS_READ ? RD_STATE : WR_STATE;\n}"
  },
  {
    "function_name": "nfs4_check_delegmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3878-3885",
    "snippet": "static inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline __be32\nnfs4_check_delegmode(struct nfs4_delegation *dp, int flags)\n{\n\tif ((flags & WR_STATE) && (dp->dl_type == NFS4_OPEN_DELEGATE_READ))\n\t\treturn nfserr_openmode;\n\telse\n\t\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_process_open1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3817-3876",
    "snippet": "__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\n\tif (nfsd4_has_session(cstate) &&\n\t    (cstate->current_fh.fh_export->ex_flags & NFSEXP_PNFS)) {\n\t\topen->op_odstate = alloc_clnt_odstate(clp);\n\t\tif (!open->op_odstate)\n\t\t\treturn nfserr_jukebox;\n\t}\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_clnt_odstate",
          "args": [
            "clp"
          ],
          "line": 3870
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "483-494",
          "snippet": "static struct nfs4_clnt_odstate *\nalloc_clnt_odstate(struct nfs4_client *clp)\n{\n\tstruct nfs4_clnt_odstate *co;\n\n\tco = kmem_cache_zalloc(odstate_slab, GFP_KERNEL);\n\tif (co) {\n\t\tco->co_client = clp;\n\t\tatomic_set(&co->co_odcount, 1);\n\t}\n\treturn co;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *odstate_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic struct nfs4_clnt_odstate *\nalloc_clnt_odstate(struct nfs4_client *clp)\n{\n\tstruct nfs4_clnt_odstate *co;\n\n\tco = kmem_cache_zalloc(odstate_slab, GFP_KERNEL);\n\tif (co) {\n\t\tco->co_client = clp;\n\t\tatomic_set(&co->co_odcount, 1);\n\t}\n\treturn co;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 3868
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_open_stateid",
          "args": [
            "clp"
          ],
          "line": 3864
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "595-607",
          "snippet": "static struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
            "static struct kmem_cache *stateid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_init_open_stateowner",
          "args": [
            "strhashval",
            "open",
            "cstate"
          ],
          "line": 3859
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_init_open_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3451-3480",
          "snippet": "static struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_stateowner(&oo->oo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *openowner_slab;",
            "static const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};\n\nstatic struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_stateowner(&oo->oo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_seqid",
          "args": [
            "cstate",
            "&oo->oo_owner",
            "open->op_seqid"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3770-3779",
          "snippet": "static __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_openowner",
          "args": [
            "oo"
          ],
          "line": 3850
        },
        "resolved": true,
        "details": {
          "function_name": "release_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1289-1309",
          "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openstateowner_str",
          "args": [
            "strhashval",
            "open",
            "clp"
          ],
          "line": 3843
        },
        "resolved": true,
        "details": {
          "function_name": "find_openstateowner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "245-255",
          "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ownerstr_hashval",
          "args": [
            "&open->op_owner"
          ],
          "line": 3842
        },
        "resolved": true,
        "details": {
          "function_name": "ownerstr_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "376-382",
          "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_clientid",
          "args": [
            "clientid",
            "cstate",
            "nn"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_clientid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3781-3815",
          "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_alloc_file",
          "args": [],
          "line": 3833
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_alloc_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3270-3273",
          "snippet": "static struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *file_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nstatic struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "&open->op_clientid",
            "nn"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1672-1685",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_process_open1(struct nfsd4_compound_state *cstate,\n\t\t    struct nfsd4_open *open, struct nfsd_net *nn)\n{\n\tclientid_t *clientid = &open->op_clientid;\n\tstruct nfs4_client *clp = NULL;\n\tunsigned int strhashval;\n\tstruct nfs4_openowner *oo = NULL;\n\t__be32 status;\n\n\tif (STALE_CLIENTID(&open->op_clientid, nn))\n\t\treturn nfserr_stale_clientid;\n\t/*\n\t * In case we need it later, after we've already created the\n\t * file and don't want to risk a further failure:\n\t */\n\topen->op_file = nfsd4_alloc_file();\n\tif (open->op_file == NULL)\n\t\treturn nfserr_jukebox;\n\n\tstatus = lookup_clientid(clientid, cstate, nn);\n\tif (status)\n\t\treturn status;\n\tclp = cstate->clp;\n\n\tstrhashval = ownerstr_hashval(&open->op_owner);\n\too = find_openstateowner_str(strhashval, open, clp);\n\topen->op_openowner = oo;\n\tif (!oo) {\n\t\tgoto new_owner;\n\t}\n\tif (!(oo->oo_flags & NFS4_OO_CONFIRMED)) {\n\t\t/* Replace unconfirmed owners without checking for replay. */\n\t\trelease_openowner(oo);\n\t\topen->op_openowner = NULL;\n\t\tgoto new_owner;\n\t}\n\tstatus = nfsd4_check_seqid(cstate, &oo->oo_owner, open->op_seqid);\n\tif (status)\n\t\treturn status;\n\tgoto alloc_stateid;\nnew_owner:\n\too = alloc_init_open_stateowner(strhashval, open, cstate);\n\tif (oo == NULL)\n\t\treturn nfserr_jukebox;\n\topen->op_openowner = oo;\nalloc_stateid:\n\topen->op_stp = nfs4_alloc_open_stateid(clp);\n\tif (!open->op_stp)\n\t\treturn nfserr_jukebox;\n\n\tif (nfsd4_has_session(cstate) &&\n\t    (cstate->current_fh.fh_export->ex_flags & NFSEXP_PNFS)) {\n\t\topen->op_odstate = alloc_clnt_odstate(clp);\n\t\tif (!open->op_odstate)\n\t\t\treturn nfserr_jukebox;\n\t}\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "lookup_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3781-3815",
    "snippet": "static __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&found->cl_refcount"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "clid",
            "false",
            "nn"
          ],
          "line": 3804
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2156-2163",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cstate->session"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "clid",
            "nn"
          ],
          "line": 3794
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1672-1685",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&found->cl_clientid",
            "clid"
          ],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1914-1918",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 lookup_clientid(clientid_t *clid,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd_net *nn)\n{\n\tstruct nfs4_client *found;\n\n\tif (cstate->clp) {\n\t\tfound = cstate->clp;\n\t\tif (!same_clid(&found->cl_clientid, clid))\n\t\t\treturn nfserr_stale_clientid;\n\t\treturn nfs_ok;\n\t}\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\t/*\n\t * For v4.1+ we get the client in the SEQUENCE op. If we don't have one\n\t * cached already then we know this is for is for v4.0 and \"sessions\"\n\t * will be false.\n\t */\n\tWARN_ON_ONCE(cstate->session);\n\tspin_lock(&nn->client_lock);\n\tfound = find_confirmed_client(clid, false, nn);\n\tif (!found) {\n\t\tspin_unlock(&nn->client_lock);\n\t\treturn nfserr_expired;\n\t}\n\tatomic_inc(&found->cl_refcount);\n\tspin_unlock(&nn->client_lock);\n\n\t/* Cache the nfs4_client in cstate! */\n\tcstate->clp = found;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_check_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3770-3779",
    "snippet": "static __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 3772
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n\tif (nfsd4_has_session(cstate))\n\t\treturn nfs_ok;\n\tif (seqid == so->so_seqid - 1)\n\t\treturn nfserr_replay_me;\n\tif (seqid == so->so_seqid)\n\t\treturn nfs_ok;\n\treturn nfserr_bad_seqid;\n}"
  },
  {
    "function_name": "nfsd_change_deleg_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3755-3763",
    "snippet": "static int\nnfsd_change_deleg_cb(struct file_lock *onlist, int arg,\n\t\t     struct list_head *dispose)\n{\n\tif (arg & F_UNLCK)\n\t\treturn lease_modify(onlist, arg, dispose);\n\telse\n\t\treturn -EAGAIN;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lease_modify",
          "args": [
            "onlist",
            "arg",
            "dispose"
          ],
          "line": 3760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nnfsd_change_deleg_cb(struct file_lock *onlist, int arg,\n\t\t     struct list_head *dispose)\n{\n\tif (arg & F_UNLCK)\n\t\treturn lease_modify(onlist, arg, dispose);\n\telse\n\t\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "nfsd_break_deleg_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3718-3753",
    "snippet": "static bool\nnfsd_break_deleg_cb(struct file_lock *fl)\n{\n\tbool ret = false;\n\tstruct nfs4_file *fp = (struct nfs4_file *)fl->fl_owner;\n\tstruct nfs4_delegation *dp;\n\n\tif (!fp) {\n\t\tWARN(1, \"(%p)->fl_owner NULL\\n\", fl);\n\t\treturn ret;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tWARN(1, \"duplicate break on %p\\n\", fp);\n\t\treturn ret;\n\t}\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a delegation isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_had_conflict = true;\n\t/*\n\t * If there are no delegations on the list, then return true\n\t * so that the lease code will go ahead and delete it.\n\t */\n\tif (list_empty(&fp->fi_delegations))\n\t\tret = true;\n\telse\n\t\tlist_for_each_entry(dp, &fp->fi_delegations, dl_perfile)\n\t\t\tnfsd_break_one_deleg(dp);\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_break_one_deleg",
          "args": [
            "dp"
          ],
          "line": 3750
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_break_one_deleg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3704-3715",
          "snippet": "static void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dp",
            "&fp->fi_delegations",
            "dl_perfile"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fp->fi_delegations"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"duplicate break on %p\\n\"",
            "fp"
          ],
          "line": 3730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"(%p)->fl_owner NULL\\n\"",
            "fl"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nnfsd_break_deleg_cb(struct file_lock *fl)\n{\n\tbool ret = false;\n\tstruct nfs4_file *fp = (struct nfs4_file *)fl->fl_owner;\n\tstruct nfs4_delegation *dp;\n\n\tif (!fp) {\n\t\tWARN(1, \"(%p)->fl_owner NULL\\n\", fl);\n\t\treturn ret;\n\t}\n\tif (fp->fi_had_conflict) {\n\t\tWARN(1, \"duplicate break on %p\\n\", fp);\n\t\treturn ret;\n\t}\n\t/*\n\t * We don't want the locks code to timeout the lease for us;\n\t * we'll remove it ourself if a delegation isn't returned\n\t * in time:\n\t */\n\tfl->fl_break_time = 0;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_had_conflict = true;\n\t/*\n\t * If there are no delegations on the list, then return true\n\t * so that the lease code will go ahead and delete it.\n\t */\n\tif (list_empty(&fp->fi_delegations))\n\t\tret = true;\n\telse\n\t\tlist_for_each_entry(dp, &fp->fi_delegations, dl_perfile)\n\t\t\tnfsd_break_one_deleg(dp);\n\tspin_unlock(&fp->fi_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd_break_one_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3704-3715",
    "snippet": "static void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_run_cb",
          "args": [
            "&dp->dl_recall"
          ],
          "line": 3714
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_run_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1147-1150",
          "snippet": "void nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_run_cb(struct nfsd4_callback *cb)\n{\n\tqueue_work(callback_wq, &cb->cb_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dp->dl_stid.sc_count"
          ],
          "line": 3713
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd_break_one_deleg(struct nfs4_delegation *dp)\n{\n\t/*\n\t * We're assuming the state code never drops its reference\n\t * without first removing the lease.  Since we're in this lease\n\t * callback (and since the lease code is serialized by the kernel\n\t * lock) we know the server hasn't removed the lease yet, we know\n\t * it's safe to take a reference.\n\t */\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tnfsd4_run_cb(&dp->dl_recall);\n}"
  },
  {
    "function_name": "nfsd4_cb_recall_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3691-3696",
    "snippet": "static void nfsd4_cb_recall_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tnfs4_put_stid(&dp->dl_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 3695
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cb_to_delegation",
          "args": [
            "cb"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cb_recall_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tnfs4_put_stid(&dp->dl_stid);\n}"
  },
  {
    "function_name": "nfsd4_cb_recall_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3664-3689",
    "snippet": "static int nfsd4_cb_recall_done(struct nfsd4_callback *cb,\n\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tif (dp->dl_stid.sc_type == NFS4_CLOSED_DELEG_STID)\n\t        return 1;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -EBADHANDLE:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\t/*\n\t\t * Race: client probably got cb_recall before open reply\n\t\t * granting delegation.\n\t\t */\n\t\tif (dp->dl_retries--) {\n\t\t\trpc_delay(task, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\treturn -1;\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_delay",
          "args": [
            "task",
            "2 * HZ"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb_to_delegation",
          "args": [
            "cb"
          ],
          "line": 3667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_cb_recall_done(struct nfsd4_callback *cb,\n\t\tstruct rpc_task *task)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\n\tif (dp->dl_stid.sc_type == NFS4_CLOSED_DELEG_STID)\n\t        return 1;\n\n\tswitch (task->tk_status) {\n\tcase 0:\n\t\treturn 1;\n\tcase -EBADHANDLE:\n\tcase -NFS4ERR_BAD_STATEID:\n\t\t/*\n\t\t * Race: client probably got cb_recall before open reply\n\t\t * granting delegation.\n\t\t */\n\t\tif (dp->dl_retries--) {\n\t\t\trpc_delay(task, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\t\t/*FALLTHRU*/\n\tdefault:\n\t\treturn -1;\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cb_recall_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3641-3662",
    "snippet": "static void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfsd_net *nn = net_generic(dp->dl_stid.sc_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\n\tblock_delegations(&dp->dl_stid.sc_file->fi_fhandle);\n\n\t/*\n\t * We can't do this in nfsd_break_deleg_cb because it is\n\t * already holding inode->i_lock.\n\t *\n\t * If the dl_time != 0, then we know that it has already been\n\t * queued for a lease break. Don't queue it again.\n\t */\n\tspin_lock(&state_lock);\n\tif (dp->dl_time == 0) {\n\t\tdp->dl_time = get_seconds();\n\t\tlist_add_tail(&dp->dl_recall_lru, &nn->del_recall_lru);\n\t}\n\tspin_unlock(&state_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&dp->dl_recall_lru",
            "&nn->del_recall_lru"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_delegations",
          "args": [
            "&dp->dl_stid.sc_file->fi_fhandle"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "block_delegations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "674-689",
          "snippet": "static void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_delegations_lock);",
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "dp->dl_stid.sc_client->net",
            "nfsd_net_id"
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cb_to_delegation",
          "args": [
            "cb"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void nfsd4_cb_recall_prepare(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_delegation *dp = cb_to_delegation(cb);\n\tstruct nfsd_net *nn = net_generic(dp->dl_stid.sc_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\n\tblock_delegations(&dp->dl_stid.sc_file->fi_fhandle);\n\n\t/*\n\t * We can't do this in nfsd_break_deleg_cb because it is\n\t * already holding inode->i_lock.\n\t *\n\t * If the dl_time != 0, then we know that it has already been\n\t * queued for a lease break. Don't queue it again.\n\t */\n\tspin_lock(&state_lock);\n\tif (dp->dl_time == 0) {\n\t\tdp->dl_time = get_seconds();\n\t\tlist_add_tail(&dp->dl_recall_lru, &nn->del_recall_lru);\n\t}\n\tspin_unlock(&state_lock);\n}"
  },
  {
    "function_name": "nfs4_share_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3623-3639",
    "snippet": "static __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "277-289",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_file",
          "args": [
            "&current_fh->fh_handle"
          ],
          "line": 3629
        },
        "resolved": true,
        "details": {
          "function_name": "find_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3584-3594",
          "snippet": "struct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)\n{\n\tstruct nfs4_file *fp;\n\t__be32 ret = nfs_ok;\n\n\tfp = find_file(&current_fh->fh_handle);\n\tif (!fp)\n\t\treturn ret;\n\t/* Check for conflicting share reservations */\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_share_deny & deny_type)\n\t\tret = nfserr_locked;\n\tspin_unlock(&fp->fi_lock);\n\tput_nfs4_file(fp);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_or_add_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3596-3617",
    "snippet": "static struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_init_file",
          "args": [
            "fh",
            "hashval",
            "new"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3276-3297",
          "snippet": "static void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tINIT_LIST_HEAD(&fp->fi_clnt_odstate);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);",
            "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tINIT_LIST_HEAD(&fp->fi_clnt_odstate);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fp == NULL"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_file_locked",
          "args": [
            "fh",
            "hashval"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3570-3582",
          "snippet": "static struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 3608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_hashval",
          "args": [
            "fh"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "file_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "393-396",
          "snippet": "static unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)\n\nstatic unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic struct nfs4_file *\nfind_or_add_file(struct nfs4_file *new, struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\tif (fp)\n\t\treturn fp;\n\n\tspin_lock(&state_lock);\n\tfp = find_file_locked(fh, hashval);\n\tif (likely(fp == NULL)) {\n\t\tnfsd4_init_file(fh, hashval, new);\n\t\tfp = new;\n\t}\n\tspin_unlock(&state_lock);\n\n\treturn fp;\n}"
  },
  {
    "function_name": "find_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3584-3594",
    "snippet": "struct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_file_locked",
          "args": [
            "fh",
            "hashval"
          ],
          "line": 3591
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3570-3582",
          "snippet": "static struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_hashval",
          "args": [
            "fh"
          ],
          "line": 3588
        },
        "resolved": true,
        "details": {
          "function_name": "file_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "393-396",
          "snippet": "static unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)\n\nstatic unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_file *\nfind_file(struct knfsd_fh *fh)\n{\n\tstruct nfs4_file *fp;\n\tunsigned int hashval = file_hashval(fh);\n\n\trcu_read_lock();\n\tfp = find_file_locked(fh, hashval);\n\trcu_read_unlock();\n\treturn fp;\n}"
  },
  {
    "function_name": "find_file_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3570-3582",
    "snippet": "static struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&fp->fi_ref"
          ],
          "line": 3577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_match",
          "args": [
            "&fp->fi_fhandle",
            "fh"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "fh_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "191-198",
          "snippet": "static inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline bool fh_match(struct knfsd_fh *fh1, struct knfsd_fh *fh2)\n{\n\tif (fh1->fh_size != fh2->fh_size)\n\t\treturn false;\n\tif (memcmp(fh1->fh_base.fh_pad, fh2->fh_base.fh_pad, fh1->fh_size) != 0)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "fp",
            "&file_hashtbl[hashval]",
            "fi_hash"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic struct nfs4_file *\nfind_file_locked(struct knfsd_fh *fh, unsigned int hashval)\n{\n\tstruct nfs4_file *fp;\n\n\thlist_for_each_entry_rcu(fp, &file_hashtbl[hashval], fi_hash) {\n\t\tif (fh_match(&fp->fi_fhandle, fh)) {\n\t\t\tif (atomic_inc_not_zero(&fp->fi_ref))\n\t\t\t\treturn fp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "move_to_close_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3532-3567",
    "snippet": "static void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&last->st_stid"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&oo->oo_close_lru",
            "&nn->close_lru"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "s->st_stid.sc_file"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "277-289",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_all_access",
          "args": [
            "s"
          ],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "release_all_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1050-1064",
          "snippet": "static void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "close_wq",
            "atomic_read(&s->st_stid.sc_count) == 2"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&s->st_stid.sc_count"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: move_to_close_lru nfs4_openowner %p\\n\"",
            "oo"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "s->st_stid.sc_client->net",
            "nfsd_net_id"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "s->st_stateowner"
          ],
          "line": 3536
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void\nmove_to_close_lru(struct nfs4_ol_stateid *s, struct net *net)\n{\n\tstruct nfs4_ol_stateid *last;\n\tstruct nfs4_openowner *oo = openowner(s->st_stateowner);\n\tstruct nfsd_net *nn = net_generic(s->st_stid.sc_client->net,\n\t\t\t\t\t\tnfsd_net_id);\n\n\tdprintk(\"NFSD: move_to_close_lru nfs4_openowner %p\\n\", oo);\n\n\t/*\n\t * We know that we hold one reference via nfsd4_close, and another\n\t * \"persistent\" reference for the client. If the refcount is higher\n\t * than 2, then there are still calls in progress that are using this\n\t * stateid. We can't put the sc_file reference until they are finished.\n\t * Wait for the refcount to drop to 2. Since it has been unhashed,\n\t * there should be no danger of the refcount going back up again at\n\t * this point.\n\t */\n\twait_event(close_wq, atomic_read(&s->st_stid.sc_count) == 2);\n\n\trelease_all_access(s);\n\tif (s->st_stid.sc_file) {\n\t\tput_nfs4_file(s->st_stid.sc_file);\n\t\ts->st_stid.sc_file = NULL;\n\t}\n\n\tspin_lock(&nn->client_lock);\n\tlast = oo->oo_last_closed_stid;\n\too->oo_last_closed_stid = s;\n\tlist_move_tail(&oo->oo_close_lru, &nn->close_lru);\n\too->oo_time = get_seconds();\n\tspin_unlock(&nn->client_lock);\n\tif (last)\n\t\tnfs4_put_stid(&last->st_stid);\n}"
  },
  {
    "function_name": "init_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3482-3525",
    "snippet": "static struct nfs4_ol_stateid *\ninit_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\tstruct nfs4_ol_stateid *retstp = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstp = open->op_stp;\n\t/* We are moving these outside of the spinlocks to avoid the warnings */\n\tmutex_init(&stp->st_mutex);\n\tmutex_lock(&stp->st_mutex);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tspin_lock(&fp->fi_lock);\n\n\tretstp = nfsd4_find_existing_open(fp, open);\n\tif (retstp)\n\t\tgoto out_unlock;\n\n\topen->op_stp = NULL;\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (retstp) {\n\t\tmutex_lock(&retstp->st_mutex);\n\t\t/* To keep mutex tracking happy */\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tstp = retstp;\n\t}\n\treturn stp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&retstp->st_mutex"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_perfile",
            "&fp->fi_stateids"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_perstateowner",
            "&oo->oo_owner.so_stateids"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "get_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "619-622",
          "snippet": "static inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline void get_nfs4_file(struct nfs4_file *fi)\n{\n\tatomic_inc(&fi->fi_ref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 3506
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&stp->st_locks"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&stp->st_stid.sc_count"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_find_existing_open",
          "args": [
            "fp",
            "open"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_existing_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3430-3449",
          "snippet": "static struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&stp->st_mutex"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\ninit_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\tstruct nfs4_ol_stateid *retstp = NULL;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstp = open->op_stp;\n\t/* We are moving these outside of the spinlocks to avoid the warnings */\n\tmutex_init(&stp->st_mutex);\n\tmutex_lock(&stp->st_mutex);\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tspin_lock(&fp->fi_lock);\n\n\tretstp = nfsd4_find_existing_open(fp, open);\n\tif (retstp)\n\t\tgoto out_unlock;\n\n\topen->op_stp = NULL;\n\tatomic_inc(&stp->st_stid.sc_count);\n\tstp->st_stid.sc_type = NFS4_OPEN_STID;\n\tINIT_LIST_HEAD(&stp->st_locks);\n\tstp->st_stateowner = nfs4_get_stateowner(&oo->oo_owner);\n\tget_nfs4_file(fp);\n\tstp->st_stid.sc_file = fp;\n\tstp->st_access_bmap = 0;\n\tstp->st_deny_bmap = 0;\n\tstp->st_openstp = NULL;\n\tlist_add(&stp->st_perstateowner, &oo->oo_owner.so_stateids);\n\tlist_add(&stp->st_perfile, &fp->fi_stateids);\n\nout_unlock:\n\tspin_unlock(&fp->fi_lock);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (retstp) {\n\t\tmutex_lock(&retstp->st_mutex);\n\t\t/* To keep mutex tracking happy */\n\t\tmutex_unlock(&stp->st_mutex);\n\t\tstp = retstp;\n\t}\n\treturn stp;\n}"
  },
  {
    "function_name": "alloc_init_open_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3451-3480",
    "snippet": "static struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_stateowner(&oo->oo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;",
      "static const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_free_stateowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1066-1070",
          "snippet": "static inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_openowner",
          "args": [
            "oo",
            "clp",
            "strhashval"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "hash_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3404-3411",
          "snippet": "static void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_openstateowner_str_locked",
          "args": [
            "strhashval",
            "open",
            "clp"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "find_openstateowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "227-243",
          "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&oo->oo_close_lru"
          ],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 3465
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_stateowner",
          "args": [
            "openowner_slab",
            "&open->op_owner",
            "clp"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3382-3402",
          "snippet": "static inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic const struct nfs4_stateowner_operations openowner_ops = {\n\t.so_unhash =\tnfs4_unhash_openowner,\n\t.so_free =\tnfs4_free_openowner,\n};\n\nstatic struct nfs4_openowner *\nalloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,\n\t\t\t   struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_client *clp = cstate->clp;\n\tstruct nfs4_openowner *oo, *ret;\n\n\too = alloc_stateowner(openowner_slab, &open->op_owner, clp);\n\tif (!oo)\n\t\treturn NULL;\n\too->oo_owner.so_ops = &openowner_ops;\n\too->oo_owner.so_is_open_owner = 1;\n\too->oo_owner.so_seqid = open->op_seqid;\n\too->oo_flags = 0;\n\tif (nfsd4_has_session(cstate))\n\t\too->oo_flags |= NFS4_OO_CONFIRMED;\n\too->oo_time = 0;\n\too->oo_last_closed_stid = NULL;\n\tINIT_LIST_HEAD(&oo->oo_close_lru);\n\tspin_lock(&clp->cl_lock);\n\tret = find_openstateowner_str_locked(strhashval, open, clp);\n\tif (ret == NULL) {\n\t\thash_openowner(oo, clp, strhashval);\n\t\tret = oo;\n\t} else\n\t\tnfs4_free_stateowner(&oo->oo_owner);\n\n\tspin_unlock(&clp->cl_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_find_existing_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3430-3449",
    "snippet": "static struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ret->st_stid.sc_count"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "local",
            "&fp->fi_stateids",
            "st_perfile"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_ol_stateid *\nnfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)\n{\n\tstruct nfs4_ol_stateid *local, *ret = NULL;\n\tstruct nfs4_openowner *oo = open->op_openowner;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(local, &fp->fi_stateids, st_perfile) {\n\t\t/* ignore lock owners */\n\t\tif (local->st_stateowner->so_is_open_owner == 0)\n\t\t\tcontinue;\n\t\tif (local->st_stateowner == &oo->oo_owner) {\n\t\t\tret = local;\n\t\t\tatomic_inc(&ret->st_stid.sc_count);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "nfs4_free_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3418-3423",
    "snippet": "static void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "openowner_slab",
            "oo"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "so"
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\n\nstatic void nfs4_free_openowner(struct nfs4_stateowner *so)\n{\n\tstruct nfs4_openowner *oo = openowner(so);\n\n\tkmem_cache_free(openowner_slab, oo);\n}"
  },
  {
    "function_name": "nfs4_unhash_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3413-3416",
    "snippet": "static void nfs4_unhash_openowner(struct nfs4_stateowner *so)\n{\n\tunhash_openowner_locked(openowner(so));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_openowner_locked",
          "args": [
            "openowner(so)"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_openowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1262-1270",
          "snippet": "static void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "so"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_unhash_openowner(struct nfs4_stateowner *so)\n{\n\tunhash_openowner_locked(openowner(so));\n}"
  },
  {
    "function_name": "hash_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3404-3411",
    "snippet": "static void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&oo->oo_perclient",
            "&clp->cl_openowners"
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&oo->oo_owner.so_strhash",
            "&clp->cl_ownerstr_hashtbl[strhashval]"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void hash_openowner(struct nfs4_openowner *oo, struct nfs4_client *clp, unsigned int strhashval)\n{\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_add(&oo->oo_owner.so_strhash,\n\t\t &clp->cl_ownerstr_hashtbl[strhashval]);\n\tlist_add(&oo->oo_perclient, &clp->cl_openowners);\n}"
  },
  {
    "function_name": "alloc_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3382-3402",
    "snippet": "static inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sop->so_count",
            "1"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_nfs4_replay",
          "args": [
            "&sop->so_replay"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "init_nfs4_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3354-3360",
          "snippet": "static void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sop->so_stateids"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "slab",
            "sop"
          ],
          "line": 3392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "owner->data",
            "owner->len",
            "GFP_KERNEL"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "slab",
            "GFP_KERNEL"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void *alloc_stateowner(struct kmem_cache *slab, struct xdr_netobj *owner, struct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *sop;\n\n\tsop = kmem_cache_alloc(slab, GFP_KERNEL);\n\tif (!sop)\n\t\treturn NULL;\n\n\tsop->so_owner.data = kmemdup(owner->data, owner->len, GFP_KERNEL);\n\tif (!sop->so_owner.data) {\n\t\tkmem_cache_free(slab, sop);\n\t\treturn NULL;\n\t}\n\tsop->so_owner.len = owner->len;\n\n\tINIT_LIST_HEAD(&sop->so_stateids);\n\tsop->so_client = clp;\n\tinit_nfs4_replay(&sop->so_replay);\n\tatomic_set(&sop->so_count, 1);\n\treturn sop;\n}"
  },
  {
    "function_name": "nfsd4_cstate_clear_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3371-3380",
    "snippet": "void nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "so"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&so->so_replay.rp_mutex"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cstate_assign_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3362-3369",
    "snippet": "static void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "so"
          ],
          "line": 3367
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&so->so_replay.rp_mutex"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cstate"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_cstate_assign_replay(struct nfsd4_compound_state *cstate,\n\t\tstruct nfs4_stateowner *so)\n{\n\tif (!nfsd4_has_session(cstate)) {\n\t\tmutex_lock(&so->so_replay.rp_mutex);\n\t\tcstate->replay_owner = nfs4_get_stateowner(so);\n\t}\n}"
  },
  {
    "function_name": "init_nfs4_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3354-3360",
    "snippet": "static void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&rp->rp_mutex"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void init_nfs4_replay(struct nfs4_replay *rp)\n{\n\trp->rp_status = nfserr_serverfault;\n\trp->rp_buflen = 0;\n\trp->rp_buf = rp->rp_ibuf;\n\tmutex_init(&rp->rp_mutex);\n}"
  },
  {
    "function_name": "nfsd4_init_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3310-3352",
    "snippet": "int\nnfsd4_init_slabs(void)\n{\n\topenowner_slab = kmem_cache_create(\"nfsd4_openowners\",\n\t\t\tsizeof(struct nfs4_openowner), 0, 0, NULL);\n\tif (openowner_slab == NULL)\n\t\tgoto out;\n\tlockowner_slab = kmem_cache_create(\"nfsd4_lockowners\",\n\t\t\tsizeof(struct nfs4_lockowner), 0, 0, NULL);\n\tif (lockowner_slab == NULL)\n\t\tgoto out_free_openowner_slab;\n\tfile_slab = kmem_cache_create(\"nfsd4_files\",\n\t\t\tsizeof(struct nfs4_file), 0, 0, NULL);\n\tif (file_slab == NULL)\n\t\tgoto out_free_lockowner_slab;\n\tstateid_slab = kmem_cache_create(\"nfsd4_stateids\",\n\t\t\tsizeof(struct nfs4_ol_stateid), 0, 0, NULL);\n\tif (stateid_slab == NULL)\n\t\tgoto out_free_file_slab;\n\tdeleg_slab = kmem_cache_create(\"nfsd4_delegations\",\n\t\t\tsizeof(struct nfs4_delegation), 0, 0, NULL);\n\tif (deleg_slab == NULL)\n\t\tgoto out_free_stateid_slab;\n\todstate_slab = kmem_cache_create(\"nfsd4_odstate\",\n\t\t\tsizeof(struct nfs4_clnt_odstate), 0, 0, NULL);\n\tif (odstate_slab == NULL)\n\t\tgoto out_free_deleg_slab;\n\treturn 0;\n\nout_free_deleg_slab:\n\tkmem_cache_destroy(deleg_slab);\nout_free_stateid_slab:\n\tkmem_cache_destroy(stateid_slab);\nout_free_file_slab:\n\tkmem_cache_destroy(file_slab);\nout_free_lockowner_slab:\n\tkmem_cache_destroy(lockowner_slab);\nout_free_openowner_slab:\n\tkmem_cache_destroy(openowner_slab);\nout:\n\tdprintk(\"nfsd4: out of memory while initializing nfsv4\\n\");\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;",
      "static struct kmem_cache *lockowner_slab;",
      "static struct kmem_cache *file_slab;",
      "static struct kmem_cache *stateid_slab;",
      "static struct kmem_cache *deleg_slab;",
      "static struct kmem_cache *odstate_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4: out of memory while initializing nfsv4\\n\""
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "openowner_slab"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "lockowner_slab"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "file_slab"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "stateid_slab"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "deleg_slab"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_odstate\"",
            "sizeof(struct nfs4_clnt_odstate)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_delegations\"",
            "sizeof(struct nfs4_delegation)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_stateids\"",
            "sizeof(struct nfs4_ol_stateid)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_files\"",
            "sizeof(struct nfs4_file)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_lockowners\"",
            "sizeof(struct nfs4_lockowner)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"nfsd4_openowners\"",
            "sizeof(struct nfs4_openowner)",
            "0",
            "0",
            "NULL"
          ],
          "line": 3313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic struct kmem_cache *lockowner_slab;\nstatic struct kmem_cache *file_slab;\nstatic struct kmem_cache *stateid_slab;\nstatic struct kmem_cache *deleg_slab;\nstatic struct kmem_cache *odstate_slab;\n\nint\nnfsd4_init_slabs(void)\n{\n\topenowner_slab = kmem_cache_create(\"nfsd4_openowners\",\n\t\t\tsizeof(struct nfs4_openowner), 0, 0, NULL);\n\tif (openowner_slab == NULL)\n\t\tgoto out;\n\tlockowner_slab = kmem_cache_create(\"nfsd4_lockowners\",\n\t\t\tsizeof(struct nfs4_lockowner), 0, 0, NULL);\n\tif (lockowner_slab == NULL)\n\t\tgoto out_free_openowner_slab;\n\tfile_slab = kmem_cache_create(\"nfsd4_files\",\n\t\t\tsizeof(struct nfs4_file), 0, 0, NULL);\n\tif (file_slab == NULL)\n\t\tgoto out_free_lockowner_slab;\n\tstateid_slab = kmem_cache_create(\"nfsd4_stateids\",\n\t\t\tsizeof(struct nfs4_ol_stateid), 0, 0, NULL);\n\tif (stateid_slab == NULL)\n\t\tgoto out_free_file_slab;\n\tdeleg_slab = kmem_cache_create(\"nfsd4_delegations\",\n\t\t\tsizeof(struct nfs4_delegation), 0, 0, NULL);\n\tif (deleg_slab == NULL)\n\t\tgoto out_free_stateid_slab;\n\todstate_slab = kmem_cache_create(\"nfsd4_odstate\",\n\t\t\tsizeof(struct nfs4_clnt_odstate), 0, 0, NULL);\n\tif (odstate_slab == NULL)\n\t\tgoto out_free_deleg_slab;\n\treturn 0;\n\nout_free_deleg_slab:\n\tkmem_cache_destroy(deleg_slab);\nout_free_stateid_slab:\n\tkmem_cache_destroy(stateid_slab);\nout_free_file_slab:\n\tkmem_cache_destroy(file_slab);\nout_free_lockowner_slab:\n\tkmem_cache_destroy(lockowner_slab);\nout_free_openowner_slab:\n\tkmem_cache_destroy(openowner_slab);\nout:\n\tdprintk(\"nfsd4: out of memory while initializing nfsv4\\n\");\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "nfsd4_free_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3299-3308",
    "snippet": "void\nnfsd4_free_slabs(void)\n{\n\tkmem_cache_destroy(odstate_slab);\n\tkmem_cache_destroy(openowner_slab);\n\tkmem_cache_destroy(lockowner_slab);\n\tkmem_cache_destroy(file_slab);\n\tkmem_cache_destroy(stateid_slab);\n\tkmem_cache_destroy(deleg_slab);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *openowner_slab;",
      "static struct kmem_cache *lockowner_slab;",
      "static struct kmem_cache *file_slab;",
      "static struct kmem_cache *stateid_slab;",
      "static struct kmem_cache *deleg_slab;",
      "static struct kmem_cache *odstate_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "deleg_slab"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "stateid_slab"
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "file_slab"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "lockowner_slab"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "openowner_slab"
          ],
          "line": 3303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "odstate_slab"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *openowner_slab;\nstatic struct kmem_cache *lockowner_slab;\nstatic struct kmem_cache *file_slab;\nstatic struct kmem_cache *stateid_slab;\nstatic struct kmem_cache *deleg_slab;\nstatic struct kmem_cache *odstate_slab;\n\nvoid\nnfsd4_free_slabs(void)\n{\n\tkmem_cache_destroy(odstate_slab);\n\tkmem_cache_destroy(openowner_slab);\n\tkmem_cache_destroy(lockowner_slab);\n\tkmem_cache_destroy(file_slab);\n\tkmem_cache_destroy(stateid_slab);\n\tkmem_cache_destroy(deleg_slab);\n}"
  },
  {
    "function_name": "nfsd4_init_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3276-3297",
    "snippet": "static void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tINIT_LIST_HEAD(&fp->fi_clnt_odstate);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);",
      "static struct hlist_head file_hashtbl[FILE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&fp->fi_hash",
            "&file_hashtbl[hashval]"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fp->fi_lo_recalls",
            "0"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fp->fi_lo_states"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fp->fi_access",
            "0",
            "sizeof(fp->fi_access)"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fp->fi_fds",
            "0",
            "sizeof(fp->fi_fds)"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_copy_shallow",
          "args": [
            "&fp->fi_fhandle",
            "fh"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "fh_copy_shallow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "176-181",
          "snippet": "static inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_copy_shallow(struct knfsd_fh *dst, struct knfsd_fh *src)\n{\n\tdst->fh_size = src->fh_size;\n\tmemcpy(&dst->fh_base, &src->fh_base, src->fh_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fp->fi_clnt_odstate"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fp->fi_delegations"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&fp->fi_stateids"
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&fp->fi_ref",
            "1"
          ],
          "line": 3281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&state_lock"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\nstatic struct hlist_head file_hashtbl[FILE_HASH_SIZE];\n\nstatic void nfsd4_init_file(struct knfsd_fh *fh, unsigned int hashval,\n\t\t\t\tstruct nfs4_file *fp)\n{\n\tlockdep_assert_held(&state_lock);\n\n\tatomic_set(&fp->fi_ref, 1);\n\tspin_lock_init(&fp->fi_lock);\n\tINIT_LIST_HEAD(&fp->fi_stateids);\n\tINIT_LIST_HEAD(&fp->fi_delegations);\n\tINIT_LIST_HEAD(&fp->fi_clnt_odstate);\n\tfh_copy_shallow(&fp->fi_fhandle, fh);\n\tfp->fi_deleg_file = NULL;\n\tfp->fi_had_conflict = false;\n\tfp->fi_share_deny = 0;\n\tmemset(fp->fi_fds, 0, sizeof(fp->fi_fds));\n\tmemset(fp->fi_access, 0, sizeof(fp->fi_access));\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&fp->fi_lo_states);\n\tatomic_set(&fp->fi_lo_recalls, 0);\n#endif\n\thlist_add_head_rcu(&fp->fi_hash, &file_hashtbl[hashval]);\n}"
  },
  {
    "function_name": "nfsd4_alloc_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3270-3273",
    "snippet": "static struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "file_slab",
            "GFP_KERNEL"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nstatic struct nfs4_file *nfsd4_alloc_file(void)\n{\n\treturn kmem_cache_alloc(file_slab, GFP_KERNEL);\n}"
  },
  {
    "function_name": "nfsd4_setclientid_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3198-3268",
    "snippet": "__be32\nnfsd4_setclientid_confirm(struct svc_rqst *rqstp,\n\t\t\t struct nfsd4_compound_state *cstate,\n\t\t\t struct nfsd4_setclientid_confirm *setclientid_confirm)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tnfs4_verifier confirm = setclientid_confirm->sc_confirm; \n\tclientid_t * clid = &setclientid_confirm->sc_clientid;\n\t__be32 status;\n\tstruct nfsd_net\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client(clid, false, nn);\n\tunconf = find_unconfirmed_client(clid, false, nn);\n\t/*\n\t * We try hard to give out unique clientid's, so if we get an\n\t * attempt to confirm the same clientid with a different cred,\n\t * the client may be buggy; this should never happen.\n\t *\n\t * Nevertheless, RFC 7530 recommends INUSE for this case:\n\t */\n\tstatus = nfserr_clid_inuse;\n\tif (unconf && !same_creds(&unconf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\tif (conf && !same_creds(&conf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\t/* cases below refer to rfc 3530 section 14.2.34: */\n\tif (!unconf || !same_verf(&confirm, &unconf->cl_confirm)) {\n\t\tif (conf && !unconf) /* case 2: probable retransmit */\n\t\t\tstatus = nfs_ok;\n\t\telse /* case 4: client hasn't noticed we rebooted yet? */\n\t\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (conf) { /* case 1: callback update */\n\t\told = unconf;\n\t\tunhash_client_locked(old);\n\t\tnfsd4_change_callback(conf, &unconf->cl_cb_conn);\n\t} else { /* case 3: normal case; new or rebooted client */\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tif (client_has_state(old)\n\t\t\t\t\t&& !same_creds(&unconf->cl_cred,\n\t\t\t\t\t\t\t&old->cl_cred))\n\t\t\t\tgoto out;\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t}\n\tget_client_locked(conf);\n\tspin_unlock(&nn->client_lock);\n\tnfsd4_probe_callback(conf);\n\tspin_lock(&nn->client_lock);\n\tput_client_renew_locked(conf);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "old"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_client_renew_locked",
          "args": [
            "conf"
          ],
          "line": 3262
        },
        "resolved": true,
        "details": {
          "function_name": "put_client_renew_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "155-165",
          "snippet": "static void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_probe_callback",
          "args": [
            "conf"
          ],
          "line": 3260
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "822-826",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_client_locked",
          "args": [
            "conf"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "121-131",
          "snippet": "static __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_to_confirmed",
          "args": [
            "unconf"
          ],
          "line": 3255
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_confirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2123-2137",
          "snippet": "static void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "old"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1787-1793",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&unconf->cl_cred",
            "&old->cl_cred"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1948-1961",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_has_state",
          "args": [
            "old"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "client_has_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2352-2360",
          "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&unconf->cl_name",
            "nn"
          ],
          "line": 3242
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2179-2184",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_change_callback",
          "args": [
            "conf",
            "&unconf->cl_cb_conn"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_change_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "828-834",
          "snippet": "void nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tspin_lock(&clp->cl_lock);\n\tmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nvoid nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\n{\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tspin_lock(&clp->cl_lock);\n\tmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "old"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1752-1775",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_verf",
          "args": [
            "&confirm",
            "&unconf->cl_confirm"
          ],
          "line": 3229
        },
        "resolved": true,
        "details": {
          "function_name": "same_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1908-1912",
          "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client",
          "args": [
            "clid",
            "false",
            "nn"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2165-2172",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "clid",
            "false",
            "nn"
          ],
          "line": 3214
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2156-2163",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STALE_CLIENTID",
          "args": [
            "clid",
            "nn"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "STALE_CLIENTID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1672-1685",
          "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 3208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_setclientid_confirm(struct svc_rqst *rqstp,\n\t\t\t struct nfsd4_compound_state *cstate,\n\t\t\t struct nfsd4_setclientid_confirm *setclientid_confirm)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tnfs4_verifier confirm = setclientid_confirm->sc_confirm; \n\tclientid_t * clid = &setclientid_confirm->sc_clientid;\n\t__be32 status;\n\tstruct nfsd_net\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (STALE_CLIENTID(clid, nn))\n\t\treturn nfserr_stale_clientid;\n\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client(clid, false, nn);\n\tunconf = find_unconfirmed_client(clid, false, nn);\n\t/*\n\t * We try hard to give out unique clientid's, so if we get an\n\t * attempt to confirm the same clientid with a different cred,\n\t * the client may be buggy; this should never happen.\n\t *\n\t * Nevertheless, RFC 7530 recommends INUSE for this case:\n\t */\n\tstatus = nfserr_clid_inuse;\n\tif (unconf && !same_creds(&unconf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\tif (conf && !same_creds(&conf->cl_cred, &rqstp->rq_cred))\n\t\tgoto out;\n\t/* cases below refer to rfc 3530 section 14.2.34: */\n\tif (!unconf || !same_verf(&confirm, &unconf->cl_confirm)) {\n\t\tif (conf && !unconf) /* case 2: probable retransmit */\n\t\t\tstatus = nfs_ok;\n\t\telse /* case 4: client hasn't noticed we rebooted yet? */\n\t\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tstatus = nfs_ok;\n\tif (conf) { /* case 1: callback update */\n\t\told = unconf;\n\t\tunhash_client_locked(old);\n\t\tnfsd4_change_callback(conf, &unconf->cl_cb_conn);\n\t} else { /* case 3: normal case; new or rebooted client */\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tif (client_has_state(old)\n\t\t\t\t\t&& !same_creds(&unconf->cl_cred,\n\t\t\t\t\t\t\t&old->cl_cred))\n\t\t\t\tgoto out;\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t}\n\tget_client_locked(conf);\n\tspin_unlock(&nn->client_lock);\n\tnfsd4_probe_callback(conf);\n\tspin_lock(&nn->client_lock);\n\tput_client_renew_locked(conf);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_setclientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3140-3195",
    "snippet": "__be32\nnfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_setclientid *setclid)\n{\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\t/* Cases below refer to rfc 3530 section 14.2.33: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf && client_has_state(conf)) {\n\t\t/* case 0: */\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\t\trpc_ntop((struct sockaddr *) &conf->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\t\tdprintk(\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\", addr_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\tif (conf && same_verf(&conf->cl_verifier, &clverifier)) {\n\t\t/* case 1: probable callback update */\n\t\tcopy_clid(new, conf);\n\t\tgen_confirm(new, nn);\n\t} else /* case 4 (new client) or cases 2, 3 (client reboot): */\n\t\tgen_clid(new, nn);\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "unconf"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_client",
          "args": [
            "new"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "free_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1732-1749",
          "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "setclid->se_confirm.data",
            "new->cl_confirm.data",
            "sizeof(setclid->se_confirm.data)"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_unconfirmed",
          "args": [
            "new"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_unconfirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2108-2121",
          "snippet": "static void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_callback",
          "args": [
            "new",
            "setclid",
            "rqstp"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "gen_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2193-2234",
          "snippet": "static void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_clid",
          "args": [
            "new",
            "nn"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "gen_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2006-2011",
          "snippet": "static void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_confirm",
          "args": [
            "new",
            "nn"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "gen_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1993-2004",
          "snippet": "static void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_clid",
          "args": [
            "new",
            "conf"
          ],
          "line": 3176
        },
        "resolved": true,
        "details": {
          "function_name": "copy_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1854-1858",
          "snippet": "static void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}"
        }
      },
      {
        "call_info": {
          "callee": "same_verf",
          "args": [
            "&conf->cl_verifier",
            "&clverifier"
          ],
          "line": 3174
        },
        "resolved": true,
        "details": {
          "function_name": "same_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1908-1912",
          "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "unconf"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1752-1775",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client_by_name",
          "args": [
            "&clname",
            "nn"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2186-2191",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\"",
            "addr_str"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "(struct sockaddr *) &conf->cl_addr",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&conf->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 3162
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1948-1961",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clp_used_exchangeid",
          "args": [
            "conf"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "clp_used_exchangeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2174-2177",
          "snippet": "static bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_has_state",
          "args": [
            "conf"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "client_has_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2352-2360",
          "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&clname",
            "nn"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2179-2184",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_client",
          "args": [
            "clname",
            "rqstp",
            "&clverifier"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "create_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2041-2066",
          "snippet": "static struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 3149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_setclientid *setclid)\n{\n\tstruct xdr_netobj \tclname = setclid->se_name;\n\tnfs4_verifier\t\tclverifier = setclid->se_verf;\n\tstruct nfs4_client\t*conf, *new;\n\tstruct nfs4_client\t*unconf = NULL;\n\t__be32 \t\t\tstatus;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew = create_client(clname, rqstp, &clverifier);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\t/* Cases below refer to rfc 3530 section 14.2.33: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&clname, nn);\n\tif (conf && client_has_state(conf)) {\n\t\t/* case 0: */\n\t\tstatus = nfserr_clid_inuse;\n\t\tif (clp_used_exchangeid(conf))\n\t\t\tgoto out;\n\t\tif (!same_creds(&conf->cl_cred, &rqstp->rq_cred)) {\n\t\t\tchar addr_str[INET6_ADDRSTRLEN];\n\t\t\trpc_ntop((struct sockaddr *) &conf->cl_addr, addr_str,\n\t\t\t\t sizeof(addr_str));\n\t\t\tdprintk(\"NFSD: setclientid: string in use by client \"\n\t\t\t\t\"at %s\\n\", addr_str);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunconf = find_unconfirmed_client_by_name(&clname, nn);\n\tif (unconf)\n\t\tunhash_client_locked(unconf);\n\tif (conf && same_verf(&conf->cl_verifier, &clverifier)) {\n\t\t/* case 1: probable callback update */\n\t\tcopy_clid(new, conf);\n\t\tgen_confirm(new, nn);\n\t} else /* case 4 (new client) or cases 2, 3 (client reboot): */\n\t\tgen_clid(new, nn);\n\tnew->cl_minorversion = 0;\n\tgen_callback(new, setclid, rqstp);\n\tadd_to_unconfirmed(new);\n\tsetclid->se_clientid.cl_boot = new->cl_clientid.cl_boot;\n\tsetclid->se_clientid.cl_id = new->cl_clientid.cl_id;\n\tmemcpy(setclid->se_confirm.data, new->cl_confirm.data, sizeof(setclid->se_confirm.data));\n\tnew = NULL;\n\tstatus = nfs_ok;\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (new)\n\t\tfree_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_reclaim_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3103-3138",
    "snippet": "__be32\nnfsd4_reclaim_complete(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_reclaim_complete *rc)\n{\n\t__be32 status = 0;\n\n\tif (rc->rca_one_fs) {\n\t\tif (!cstate->current_fh.fh_dentry)\n\t\t\treturn nfserr_nofilehandle;\n\t\t/*\n\t\t * We don't take advantage of the rca_one_fs case.\n\t\t * That's OK, it's optional, we can safely ignore it.\n\t\t */\n\t\t return nfs_ok;\n\t}\n\n\tstatus = nfserr_complete_already;\n\tif (test_and_set_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t\t     &cstate->session->se_client->cl_flags))\n\t\tgoto out;\n\n\tstatus = nfserr_stale_clientid;\n\tif (is_client_expired(cstate->session->se_client))\n\t\t/*\n\t\t * The following error isn't really legal.\n\t\t * But we only get here if the client just explicitly\n\t\t * destroyed the client.  Surely it no longer cares what\n\t\t * error it gets back on an operation for the dead\n\t\t * client.\n\t\t */\n\t\tgoto out;\n\n\tstatus = nfs_ok;\n\tnfsd4_client_record_create(cstate->session->se_client);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_client_record_create",
          "args": [
            "cstate->session->se_client"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1473-1480",
          "snippet": "void\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "cstate->session->se_client"
          ],
          "line": 3124
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "116-119",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFSD4_CLIENT_RECLAIM_COMPLETE",
            "&cstate->session->se_client->cl_flags"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_reclaim_complete(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_reclaim_complete *rc)\n{\n\t__be32 status = 0;\n\n\tif (rc->rca_one_fs) {\n\t\tif (!cstate->current_fh.fh_dentry)\n\t\t\treturn nfserr_nofilehandle;\n\t\t/*\n\t\t * We don't take advantage of the rca_one_fs case.\n\t\t * That's OK, it's optional, we can safely ignore it.\n\t\t */\n\t\t return nfs_ok;\n\t}\n\n\tstatus = nfserr_complete_already;\n\tif (test_and_set_bit(NFSD4_CLIENT_RECLAIM_COMPLETE,\n\t\t\t     &cstate->session->se_client->cl_flags))\n\t\tgoto out;\n\n\tstatus = nfserr_stale_clientid;\n\tif (is_client_expired(cstate->session->se_client))\n\t\t/*\n\t\t * The following error isn't really legal.\n\t\t * But we only get here if the client just explicitly\n\t\t * destroyed the client.  Surely it no longer cares what\n\t\t * error it gets back on an operation for the dead\n\t\t * client.\n\t\t */\n\t\tgoto out;\n\n\tstatus = nfs_ok;\n\tnfsd4_client_record_create(cstate->session->se_client);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_destroy_clientid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3062-3101",
    "snippet": "__be32\nnfsd4_destroy_clientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_destroy_clientid *dc)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *clp = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&dc->clientid, true, nn);\n\tconf = find_confirmed_client(&dc->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tif (client_has_state(conf)) {\n\t\t\tstatus = nfserr_clientid_busy;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tclp = conf;\n\t} else if (unconf)\n\t\tclp = unconf;\n\telse {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tif (!mach_creds_match(clp, rqstp)) {\n\t\tclp = NULL;\n\t\tstatus = nfserr_wrong_cred;\n\t\tgoto out;\n\t}\n\tunhash_client_locked(clp);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (clp)\n\t\texpire_client(clp);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "clp"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "clp"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1752-1775",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "clp",
            "rqstp"
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1975-1991",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "conf"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1787-1793",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_has_state",
          "args": [
            "conf"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "client_has_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2352-2360",
          "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "conf && unconf"
          ],
          "line": 3073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "&dc->clientid",
            "true",
            "nn"
          ],
          "line": 3072
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2156-2163",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client",
          "args": [
            "&dc->clientid",
            "true",
            "nn"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2165-2172",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_destroy_clientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_destroy_clientid *dc)\n{\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *clp = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&dc->clientid, true, nn);\n\tconf = find_confirmed_client(&dc->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tif (client_has_state(conf)) {\n\t\t\tstatus = nfserr_clientid_busy;\n\t\t\tgoto out;\n\t\t}\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t\tclp = conf;\n\t} else if (unconf)\n\t\tclp = unconf;\n\telse {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out;\n\t}\n\tif (!mach_creds_match(clp, rqstp)) {\n\t\tclp = NULL;\n\t\tstatus = nfserr_wrong_cred;\n\t\tgoto out;\n\t}\n\tunhash_client_locked(clp);\nout:\n\tspin_unlock(&nn->client_lock);\n\tif (clp)\n\t\texpire_client(clp);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_sequence_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "3046-3060",
    "snippet": "void\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client_renew",
          "args": [
            "cs->clp"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "put_client_renew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "167-176",
          "snippet": "static void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session",
          "args": [
            "cs->session"
          ],
          "line": 3057
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "203-211",
          "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_store_cache_entry",
          "args": [
            "resp"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_store_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2239-2262",
          "snippet": "static void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(1, \"%s: sessions DRC could not cache compound\\n\",\n\t\t     __func__);\n\treturn;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(1, \"%s: sessions DRC could not cache compound\\n\",\n\t\t     __func__);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_has_session",
          "args": [
            "cs"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "71-74",
          "snippet": "static inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_has_session(struct nfsd4_compound_state *cs)\n{\n\treturn cs->slot != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_sequence_done(struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_compound_state *cs = &resp->cstate;\n\n\tif (nfsd4_has_session(cs)) {\n\t\tif (cs->status != nfserr_replay_cache) {\n\t\t\tnfsd4_store_cache_entry(resp);\n\t\t\tcs->slot->sl_flags &= ~NFSD4_SLOT_INUSE;\n\t\t}\n\t\t/* Drop session reference that was taken in nfsd4_sequence() */\n\t\tnfsd4_put_session(cs->session);\n\t} else if (cs->clp)\n\t\tput_client_renew(cs->clp);\n}"
  },
  {
    "function_name": "nfsd4_sequence",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2925-3044",
    "snippet": "__be32\nnfsd4_sequence(struct svc_rqst *rqstp,\n\t       struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_session *session;\n\tstruct nfs4_client *clp;\n\tstruct nfsd4_slot *slot;\n\tstruct nfsd4_conn *conn;\n\t__be32 status;\n\tint buflen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (resp->opcnt != 1)\n\t\treturn nfserr_sequence_pos;\n\n\t/*\n\t * Will be either used or freed by nfsd4_sequence_check_conn\n\t * below.\n\t */\n\tconn = alloc_conn(rqstp, NFS4_CDFC4_FORE);\n\tif (!conn)\n\t\treturn nfserr_jukebox;\n\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&seq->sessionid, net, &status);\n\tif (!session)\n\t\tgoto out_no_session;\n\tclp = session->se_client;\n\n\tstatus = nfserr_too_many_ops;\n\tif (nfsd4_session_too_many_ops(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_req_too_big;\n\tif (nfsd4_request_too_big(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_badslot;\n\tif (seq->slotid >= session->se_fchannel.maxreqs)\n\t\tgoto out_put_session;\n\n\tslot = session->se_slots[seq->slotid];\n\tdprintk(\"%s: slotid %d\\n\", __func__, seq->slotid);\n\n\t/* We do not negotiate the number of slots yet, so set the\n\t * maxslots to the session maxreqs which is used to encode\n\t * sr_highest_slotid and the sr_target_slot id to maxslots */\n\tseq->maxslots = session->se_fchannel.maxreqs;\n\n\tstatus = check_slot_seqid(seq->seqid, slot->sl_seqid,\n\t\t\t\t\tslot->sl_flags & NFSD4_SLOT_INUSE);\n\tif (status == nfserr_replay_cache) {\n\t\tstatus = nfserr_seq_misordered;\n\t\tif (!(slot->sl_flags & NFSD4_SLOT_INITIALIZED))\n\t\t\tgoto out_put_session;\n\t\tcstate->slot = slot;\n\t\tcstate->session = session;\n\t\tcstate->clp = clp;\n\t\t/* Return the cached reply status and set cstate->status\n\t\t * for nfsd4_proc_compound processing */\n\t\tstatus = nfsd4_replay_cache_entry(resp, seq);\n\t\tcstate->status = nfserr_replay_cache;\n\t\tgoto out;\n\t}\n\tif (status)\n\t\tgoto out_put_session;\n\n\tstatus = nfsd4_sequence_check_conn(conn, session);\n\tconn = NULL;\n\tif (status)\n\t\tgoto out_put_session;\n\n\tbuflen = (seq->cachethis) ?\n\t\t\tsession->se_fchannel.maxresp_cached :\n\t\t\tsession->se_fchannel.maxresp_sz;\n\tstatus = (seq->cachethis) ? nfserr_rep_too_big_to_cache :\n\t\t\t\t    nfserr_rep_too_big;\n\tif (xdr_restrict_buflen(xdr, buflen - rqstp->rq_auth_slack))\n\t\tgoto out_put_session;\n\tsvc_reserve(rqstp, buflen);\n\n\tstatus = nfs_ok;\n\t/* Success! bump slot seqid */\n\tslot->sl_seqid = seq->seqid;\n\tslot->sl_flags |= NFSD4_SLOT_INUSE;\n\tif (seq->cachethis)\n\t\tslot->sl_flags |= NFSD4_SLOT_CACHETHIS;\n\telse\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHETHIS;\n\n\tcstate->slot = slot;\n\tcstate->session = session;\n\tcstate->clp = clp;\n\nout:\n\tswitch (clp->cl_cb_state) {\n\tcase NFSD4_CB_DOWN:\n\t\tseq->status_flags = SEQ4_STATUS_CB_PATH_DOWN;\n\t\tbreak;\n\tcase NFSD4_CB_FAULT:\n\t\tseq->status_flags = SEQ4_STATUS_BACKCHANNEL_FAULT;\n\t\tbreak;\n\tdefault:\n\t\tseq->status_flags = 0;\n\t}\n\tif (!list_empty(&clp->cl_revoked))\n\t\tseq->status_flags |= SEQ4_STATUS_RECALLABLE_STATE_REVOKED;\nout_no_session:\n\tif (conn)\n\t\tfree_conn(conn);\n\tspin_unlock(&nn->client_lock);\n\treturn status;\nout_put_session:\n\tnfsd4_put_session_locked(session);\n\tgoto out_no_session;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);",
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_put_session_locked",
          "args": [
            "session"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "191-201",
          "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "conn"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1469-1473",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_revoked"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_reserve",
          "args": [
            "rqstp",
            "buflen"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_restrict_buflen",
          "args": [
            "xdr",
            "buflen - rqstp->rq_auth_slack"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_sequence_check_conn",
          "args": [
            "conn",
            "session"
          ],
          "line": 2996
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_sequence_check_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2883-2908",
          "snippet": "static __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_replay_cache_entry",
          "args": [
            "resp",
            "seq"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_replay_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2295-2320",
          "snippet": "static __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_slot_seqid",
          "args": [
            "seq->seqid",
            "slot->sl_seqid",
            "slot->sl_flags & NFSD4_SLOT_INUSE"
          ],
          "line": 2978
        },
        "resolved": true,
        "details": {
          "function_name": "check_slot_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2501-2520",
          "snippet": "static __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: slotid %d\\n\"",
            "__func__",
            "seq->slotid"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_request_too_big",
          "args": [
            "rqstp",
            "session"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_request_too_big",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2917-2923",
          "snippet": "static bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_session_too_many_ops",
          "args": [
            "rqstp",
            "session"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_session_too_many_ops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2910-2915",
          "snippet": "static bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_sessionid_hashtbl",
          "args": [
            "&seq->sessionid",
            "net",
            "&status"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1638-1654",
          "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_conn",
          "args": [
            "rqstp",
            "NFS4_CDFC4_FORE"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1537-1544",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\n__be32\nnfsd4_sequence(struct svc_rqst *rqstp,\n\t       struct nfsd4_compound_state *cstate,\n\t       struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfsd4_session *session;\n\tstruct nfs4_client *clp;\n\tstruct nfsd4_slot *slot;\n\tstruct nfsd4_conn *conn;\n\t__be32 status;\n\tint buflen;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (resp->opcnt != 1)\n\t\treturn nfserr_sequence_pos;\n\n\t/*\n\t * Will be either used or freed by nfsd4_sequence_check_conn\n\t * below.\n\t */\n\tconn = alloc_conn(rqstp, NFS4_CDFC4_FORE);\n\tif (!conn)\n\t\treturn nfserr_jukebox;\n\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&seq->sessionid, net, &status);\n\tif (!session)\n\t\tgoto out_no_session;\n\tclp = session->se_client;\n\n\tstatus = nfserr_too_many_ops;\n\tif (nfsd4_session_too_many_ops(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_req_too_big;\n\tif (nfsd4_request_too_big(rqstp, session))\n\t\tgoto out_put_session;\n\n\tstatus = nfserr_badslot;\n\tif (seq->slotid >= session->se_fchannel.maxreqs)\n\t\tgoto out_put_session;\n\n\tslot = session->se_slots[seq->slotid];\n\tdprintk(\"%s: slotid %d\\n\", __func__, seq->slotid);\n\n\t/* We do not negotiate the number of slots yet, so set the\n\t * maxslots to the session maxreqs which is used to encode\n\t * sr_highest_slotid and the sr_target_slot id to maxslots */\n\tseq->maxslots = session->se_fchannel.maxreqs;\n\n\tstatus = check_slot_seqid(seq->seqid, slot->sl_seqid,\n\t\t\t\t\tslot->sl_flags & NFSD4_SLOT_INUSE);\n\tif (status == nfserr_replay_cache) {\n\t\tstatus = nfserr_seq_misordered;\n\t\tif (!(slot->sl_flags & NFSD4_SLOT_INITIALIZED))\n\t\t\tgoto out_put_session;\n\t\tcstate->slot = slot;\n\t\tcstate->session = session;\n\t\tcstate->clp = clp;\n\t\t/* Return the cached reply status and set cstate->status\n\t\t * for nfsd4_proc_compound processing */\n\t\tstatus = nfsd4_replay_cache_entry(resp, seq);\n\t\tcstate->status = nfserr_replay_cache;\n\t\tgoto out;\n\t}\n\tif (status)\n\t\tgoto out_put_session;\n\n\tstatus = nfsd4_sequence_check_conn(conn, session);\n\tconn = NULL;\n\tif (status)\n\t\tgoto out_put_session;\n\n\tbuflen = (seq->cachethis) ?\n\t\t\tsession->se_fchannel.maxresp_cached :\n\t\t\tsession->se_fchannel.maxresp_sz;\n\tstatus = (seq->cachethis) ? nfserr_rep_too_big_to_cache :\n\t\t\t\t    nfserr_rep_too_big;\n\tif (xdr_restrict_buflen(xdr, buflen - rqstp->rq_auth_slack))\n\t\tgoto out_put_session;\n\tsvc_reserve(rqstp, buflen);\n\n\tstatus = nfs_ok;\n\t/* Success! bump slot seqid */\n\tslot->sl_seqid = seq->seqid;\n\tslot->sl_flags |= NFSD4_SLOT_INUSE;\n\tif (seq->cachethis)\n\t\tslot->sl_flags |= NFSD4_SLOT_CACHETHIS;\n\telse\n\t\tslot->sl_flags &= ~NFSD4_SLOT_CACHETHIS;\n\n\tcstate->slot = slot;\n\tcstate->session = session;\n\tcstate->clp = clp;\n\nout:\n\tswitch (clp->cl_cb_state) {\n\tcase NFSD4_CB_DOWN:\n\t\tseq->status_flags = SEQ4_STATUS_CB_PATH_DOWN;\n\t\tbreak;\n\tcase NFSD4_CB_FAULT:\n\t\tseq->status_flags = SEQ4_STATUS_BACKCHANNEL_FAULT;\n\t\tbreak;\n\tdefault:\n\t\tseq->status_flags = 0;\n\t}\n\tif (!list_empty(&clp->cl_revoked))\n\t\tseq->status_flags |= SEQ4_STATUS_RECALLABLE_STATE_REVOKED;\nout_no_session:\n\tif (conn)\n\t\tfree_conn(conn);\n\tspin_unlock(&nn->client_lock);\n\treturn status;\nout_put_session:\n\tnfsd4_put_session_locked(session);\n\tgoto out_no_session;\n}"
  },
  {
    "function_name": "nfsd4_request_too_big",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2917-2923",
    "snippet": "static bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\t  struct nfsd4_session *session)\n{\n\tstruct xdr_buf *xb = &rqstp->rq_arg;\n\n\treturn xb->len > session->se_fchannel.maxreq_sz;\n}"
  },
  {
    "function_name": "nfsd4_session_too_many_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2910-2915",
    "snippet": "static bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_session_too_many_ops(struct svc_rqst *rqstp, struct nfsd4_session *session)\n{\n\tstruct nfsd4_compoundargs *args = rqstp->rq_argp;\n\n\treturn args->opcnt > session->se_fchannel.maxops;\n}"
  },
  {
    "function_name": "nfsd4_sequence_check_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2883-2908",
    "snippet": "static __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "new"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1469-1473",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 2905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_conn_lost",
          "args": [
            "&new->cn_xpt_user"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_conn_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1475-1487",
          "snippet": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_register_conn",
          "args": [
            "new"
          ],
          "line": 2899
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_register_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1518-1522",
          "snippet": "static int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfsd4_hash_conn",
          "args": [
            "new",
            "ses"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_hash_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1503-1507",
          "snippet": "static void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__nfsd4_find_conn",
          "args": [
            "new->cn_xprt",
            "ses"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_find_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2871-2881",
          "snippet": "static struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_sequence_check_conn(struct nfsd4_conn *new, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_conn *c;\n\t__be32 status = nfs_ok;\n\tint ret;\n\n\tspin_lock(&clp->cl_lock);\n\tc = __nfsd4_find_conn(new->cn_xprt, ses);\n\tif (c)\n\t\tgoto out_free;\n\tstatus = nfserr_conn_not_bound_to_session;\n\tif (clp->cl_mach_cred)\n\t\tgoto out_free;\n\t__nfsd4_hash_conn(new, ses);\n\tspin_unlock(&clp->cl_lock);\n\tret = nfsd4_register_conn(new);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&new->cn_xpt_user);\n\treturn nfs_ok;\nout_free:\n\tspin_unlock(&clp->cl_lock);\n\tfree_conn(new);\n\treturn status;\n}"
  },
  {
    "function_name": "__nfsd4_find_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2871-2881",
    "snippet": "static struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "c",
            "&s->se_conns",
            "cn_persession"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_conn *__nfsd4_find_conn(struct svc_xprt *xpt, struct nfsd4_session *s)\n{\n\tstruct nfsd4_conn *c;\n\n\tlist_for_each_entry(c, &s->se_conns, cn_persession) {\n\t\tif (c->cn_xprt == xpt) {\n\t\t\treturn c;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfsd4_destroy_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2828-2869",
    "snippet": "__be32\nnfsd4_destroy_session(struct svc_rqst *r,\n\t\t      struct nfsd4_compound_state *cstate,\n\t\t      struct nfsd4_destroy_session *sessionid)\n{\n\tstruct nfsd4_session *ses;\n\t__be32 status;\n\tint ref_held_by_me = 0;\n\tstruct net *net = SVC_NET(r);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tstatus = nfserr_not_only_op;\n\tif (nfsd4_compound_in_session(cstate->session, &sessionid->sessionid)) {\n\t\tif (!nfsd4_last_compound_op(r))\n\t\t\tgoto out;\n\t\tref_held_by_me++;\n\t}\n\tdump_sessionid(__func__, &sessionid->sessionid);\n\tspin_lock(&nn->client_lock);\n\tses = find_in_sessionid_hashtbl(&sessionid->sessionid, net, &status);\n\tif (!ses)\n\t\tgoto out_client_lock;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(ses->se_client, r))\n\t\tgoto out_put_session;\n\tstatus = mark_session_dead_locked(ses, 1 + ref_held_by_me);\n\tif (status)\n\t\tgoto out_put_session;\n\tunhash_session(ses);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback_sync(ses->se_client);\n\n\tspin_lock(&nn->client_lock);\n\tstatus = nfs_ok;\nout_put_session:\n\tnfsd4_put_session_locked(ses);\nout_client_lock:\n\tspin_unlock(&nn->client_lock);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session_locked",
          "args": [
            "ses"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "191-201",
          "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_probe_callback_sync",
          "args": [
            "ses->se_client"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "822-826",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_session",
          "args": [
            "ses"
          ],
          "line": 2856
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1657-1669",
          "snippet": "static void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_session_dead_locked",
          "args": [
            "ses",
            "1 + ref_held_by_me"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "mark_session_dead_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "108-114",
          "snippet": "static __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "ses->se_client",
            "r"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1975-1991",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_in_sessionid_hashtbl",
          "args": [
            "&sessionid->sessionid",
            "net",
            "&status"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1638-1654",
          "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_sessionid",
          "args": [
            "__func__",
            "&sessionid->sessionid"
          ],
          "line": 2845
        },
        "resolved": true,
        "details": {
          "function_name": "dump_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1327-1330",
          "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_last_compound_op",
          "args": [
            "r"
          ],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_last_compound_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "628-634",
          "snippet": "static inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_compound_in_session",
          "args": [
            "cstate->session",
            "&sessionid->sessionid"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_compound_in_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2821-2826",
          "snippet": "static bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "r"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32\nnfsd4_destroy_session(struct svc_rqst *r,\n\t\t      struct nfsd4_compound_state *cstate,\n\t\t      struct nfsd4_destroy_session *sessionid)\n{\n\tstruct nfsd4_session *ses;\n\t__be32 status;\n\tint ref_held_by_me = 0;\n\tstruct net *net = SVC_NET(r);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tstatus = nfserr_not_only_op;\n\tif (nfsd4_compound_in_session(cstate->session, &sessionid->sessionid)) {\n\t\tif (!nfsd4_last_compound_op(r))\n\t\t\tgoto out;\n\t\tref_held_by_me++;\n\t}\n\tdump_sessionid(__func__, &sessionid->sessionid);\n\tspin_lock(&nn->client_lock);\n\tses = find_in_sessionid_hashtbl(&sessionid->sessionid, net, &status);\n\tif (!ses)\n\t\tgoto out_client_lock;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(ses->se_client, r))\n\t\tgoto out_put_session;\n\tstatus = mark_session_dead_locked(ses, 1 + ref_held_by_me);\n\tif (status)\n\t\tgoto out_put_session;\n\tunhash_session(ses);\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback_sync(ses->se_client);\n\n\tspin_lock(&nn->client_lock);\n\tstatus = nfs_ok;\nout_put_session:\n\tnfsd4_put_session_locked(ses);\nout_client_lock:\n\tspin_unlock(&nn->client_lock);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_compound_in_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2821-2826",
    "snippet": "static bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sid",
            "&session->se_sessionid",
            "sizeof(*sid)"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool nfsd4_compound_in_session(struct nfsd4_session *session, struct nfs4_sessionid *sid)\n{\n\tif (!session)\n\t\treturn 0;\n\treturn !memcmp(sid, &session->se_sessionid, sizeof(*sid));\n}"
  },
  {
    "function_name": "nfsd4_bind_conn_to_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2786-2819",
    "snippet": "__be32 nfsd4_bind_conn_to_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_bind_conn_to_session *bcts)\n{\n\t__be32 status;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_session *session;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\treturn nfserr_not_only_op;\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&bcts->sessionid, net, &status);\n\tspin_unlock(&nn->client_lock);\n\tif (!session)\n\t\tgoto out_no_session;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(session->se_client, rqstp))\n\t\tgoto out;\n\tstatus = nfsd4_map_bcts_dir(&bcts->dir);\n\tif (status)\n\t\tgoto out;\n\tconn = alloc_conn(rqstp, bcts->dir);\n\tstatus = nfserr_jukebox;\n\tif (!conn)\n\t\tgoto out;\n\tnfsd4_init_conn(rqstp, conn, session);\n\tstatus = nfs_ok;\nout:\n\tnfsd4_put_session(session);\nout_no_session:\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_put_session",
          "args": [
            "session"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "203-211",
          "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_conn",
          "args": [
            "rqstp",
            "conn",
            "session"
          ],
          "line": 2813
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1524-1535",
          "snippet": "static void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_conn",
          "args": [
            "rqstp",
            "bcts->dir"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1537-1544",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_map_bcts_dir",
          "args": [
            "&bcts->dir"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_map_bcts_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2753-2765",
          "snippet": "static __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "session->se_client",
            "rqstp"
          ],
          "line": 2804
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1975-1991",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_in_sessionid_hashtbl",
          "args": [
            "&bcts->sessionid",
            "net",
            "&status"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1638-1654",
          "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_last_compound_op",
          "args": [
            "rqstp"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_last_compound_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "628-634",
          "snippet": "static inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_last_compound_op(struct svc_rqst *rqstp)\n{\n\tstruct nfsd4_compoundres *resp = rqstp->rq_resp;\n\tstruct nfsd4_compoundargs *argp = rqstp->rq_argp;\n\n\treturn argp->opcnt == resp->opcnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32 nfsd4_bind_conn_to_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_bind_conn_to_session *bcts)\n{\n\t__be32 status;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_session *session;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nfsd4_last_compound_op(rqstp))\n\t\treturn nfserr_not_only_op;\n\tspin_lock(&nn->client_lock);\n\tsession = find_in_sessionid_hashtbl(&bcts->sessionid, net, &status);\n\tspin_unlock(&nn->client_lock);\n\tif (!session)\n\t\tgoto out_no_session;\n\tstatus = nfserr_wrong_cred;\n\tif (!mach_creds_match(session->se_client, rqstp))\n\t\tgoto out;\n\tstatus = nfsd4_map_bcts_dir(&bcts->dir);\n\tif (status)\n\t\tgoto out;\n\tconn = alloc_conn(rqstp, bcts->dir);\n\tstatus = nfserr_jukebox;\n\tif (!conn)\n\t\tgoto out;\n\tnfsd4_init_conn(rqstp, conn, session);\n\tstatus = nfs_ok;\nout:\n\tnfsd4_put_session(session);\nout_no_session:\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_backchannel_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2767-2784",
    "snippet": "__be32 nfsd4_backchannel_ctl(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_backchannel_ctl *bc)\n{\n\tstruct nfsd4_session *session = cstate->session;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\t__be32 status;\n\n\tstatus = nfsd4_check_cb_sec(&bc->bc_cb_sec);\n\tif (status)\n\t\treturn status;\n\tspin_lock(&nn->client_lock);\n\tsession->se_cb_prog = bc->bc_cb_program;\n\tsession->se_cb_sec = bc->bc_cb_sec;\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback(session->se_client);\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_probe_callback",
          "args": [
            "session->se_client"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "822-826",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_check_cb_sec",
          "args": [
            "&bc->bc_cb_sec"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2621-2637",
          "snippet": "static __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32 nfsd4_backchannel_ctl(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_backchannel_ctl *bc)\n{\n\tstruct nfsd4_session *session = cstate->session;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\t__be32 status;\n\n\tstatus = nfsd4_check_cb_sec(&bc->bc_cb_sec);\n\tif (status)\n\t\treturn status;\n\tspin_lock(&nn->client_lock);\n\tsession->se_cb_prog = bc->bc_cb_program;\n\tsession->se_cb_sec = bc->bc_cb_sec;\n\tspin_unlock(&nn->client_lock);\n\n\tnfsd4_probe_callback(session->se_client);\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_map_bcts_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2753-2765",
    "snippet": "static __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_map_bcts_dir(u32 *dir)\n{\n\tswitch (*dir) {\n\tcase NFS4_CDFC4_FORE:\n\tcase NFS4_CDFC4_BACK:\n\t\treturn nfs_ok;\n\tcase NFS4_CDFC4_FORE_OR_BOTH:\n\tcase NFS4_CDFC4_BACK_OR_BOTH:\n\t\t*dir = NFS4_CDFC4_BOTH;\n\t\treturn nfs_ok;\n\t};\n\treturn nfserr_inval;\n}"
  },
  {
    "function_name": "nfsd4_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2639-2751",
    "snippet": "__be32\nnfsd4_create_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_create_session *cr_ses)\n{\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tstruct nfsd4_session *new;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_clid_slot *cs_slot = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (cr_ses->flags & ~SESSION4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\tstatus = nfsd4_check_cb_sec(&cr_ses->cb_sec);\n\tif (status)\n\t\treturn status;\n\tstatus = check_forechannel_attrs(&cr_ses->fore_channel, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_backchannel_attrs(&cr_ses->back_channel);\n\tif (status)\n\t\tgoto out_release_drc_mem;\n\tstatus = nfserr_jukebox;\n\tnew = alloc_session(&cr_ses->fore_channel, &cr_ses->back_channel);\n\tif (!new)\n\t\tgoto out_release_drc_mem;\n\tconn = alloc_conn_from_crses(rqstp, cr_ses);\n\tif (!conn)\n\t\tgoto out_free_session;\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&cr_ses->clientid, true, nn);\n\tconf = find_confirmed_client(&cr_ses->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(conf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &conf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\tif (status == nfserr_replay_cache)\n\t\t\t\tstatus = nfsd4_replay_create_session(cr_ses, cs_slot);\n\t\t\tgoto out_free_conn;\n\t\t}\n\t} else if (unconf) {\n\t\tif (!same_creds(&unconf->cl_cred, &rqstp->rq_cred) ||\n\t\t    !rpc_cmp_addr(sa, (struct sockaddr *) &unconf->cl_addr)) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(unconf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &unconf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\t/* an unconfirmed replay returns misordered */\n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out_free_conn;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t} else {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out_free_conn;\n\t}\n\tstatus = nfs_ok;\n\t/* Persistent sessions are not supported */\n\tcr_ses->flags &= ~SESSION4_PERSIST;\n\t/* Upshifting from TCP to RDMA is not supported */\n\tcr_ses->flags &= ~SESSION4_RDMA;\n\n\tinit_session(rqstp, new, conf, cr_ses);\n\tnfsd4_get_session_locked(new);\n\n\tmemcpy(cr_ses->sessionid.data, new->se_sessionid.data,\n\t       NFS4_MAX_SESSIONID_LEN);\n\tcs_slot->sl_seqid++;\n\tcr_ses->seqid = cs_slot->sl_seqid;\n\n\t/* cache solo and embedded create sessions under the client_lock */\n\tnfsd4_cache_create_session(cr_ses, cs_slot, status);\n\tspin_unlock(&nn->client_lock);\n\t/* init connection and backchannel */\n\tnfsd4_init_conn(rqstp, conn, new);\n\tnfsd4_put_session(new);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\nout_free_conn:\n\tspin_unlock(&nn->client_lock);\n\tfree_conn(conn);\n\tif (old)\n\t\texpire_client(old);\nout_free_session:\n\t__free_session(new);\nout_release_drc_mem:\n\tnfsd4_put_drc_mem(&cr_ses->fore_channel);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_put_drc_mem",
          "args": [
            "&cr_ses->fore_channel"
          ],
          "line": 2749
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_drc_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1427-1434",
          "snippet": "static void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_session",
          "args": [
            "new"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "__free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1566-1570",
          "snippet": "static void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "old"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "conn"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1469-1473",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session",
          "args": [
            "new"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "203-211",
          "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_conn",
          "args": [
            "rqstp",
            "conn",
            "new"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1524-1535",
          "snippet": "static void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cache_create_session",
          "args": [
            "cr_ses",
            "cs_slot",
            "status"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cache_create_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2527-2533",
          "snippet": "static void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cr_ses->sessionid.data",
            "new->se_sessionid.data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_get_session_locked",
          "args": [
            "new"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "178-189",
          "snippet": "static __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_session",
          "args": [
            "rqstp",
            "new",
            "conf",
            "cr_ses"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "init_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1579-1612",
          "snippet": "static void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_to_confirmed",
          "args": [
            "unconf"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_confirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2123-2137",
          "snippet": "static void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "old"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1787-1793",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&unconf->cl_name",
            "nn"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2179-2184",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_slot_seqid",
          "args": [
            "cr_ses->seqid",
            "cs_slot->sl_seqid",
            "0"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "check_slot_seqid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2501-2520",
          "snippet": "static __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "unconf",
            "rqstp"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1975-1991",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_cmp_addr",
          "args": [
            "sa",
            "(struct sockaddr *) &unconf->cl_addr"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&unconf->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1948-1961",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_replay_create_session",
          "args": [
            "cr_ses",
            "cs_slot"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_replay_create_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2535-2541",
          "snippet": "static __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "conf && unconf"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_confirmed_client",
          "args": [
            "&cr_ses->clientid",
            "true",
            "nn"
          ],
          "line": 2674
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2156-2163",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client",
          "args": [
            "&cr_ses->clientid",
            "true",
            "nn"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2165-2172",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_conn_from_crses",
          "args": [
            "rqstp",
            "cr_ses"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1537-1544",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_session",
          "args": [
            "&cr_ses->fore_channel",
            "&cr_ses->back_channel"
          ],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1436-1467",
          "snippet": "static struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_backchannel_attrs",
          "args": [
            "&cr_ses->back_channel"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "check_backchannel_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2606-2619",
          "snippet": "static __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH_SYS) * \\\n\t\t\t\t sizeof(__be32))",
            "#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH_SYS) * sizeof(__be32))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH_SYS) * \\\n\t\t\t\t sizeof(__be32))\n#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH_SYS) * sizeof(__be32))\n\nstatic __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_forechannel_attrs",
          "args": [
            "&cr_ses->fore_channel",
            "nn"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "check_forechannel_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2560-2588",
          "snippet": "static __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */",
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_check_cb_sec",
          "args": [
            "&cr_ses->cb_sec"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_check_cb_sec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2621-2637",
          "snippet": "static __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\n__be32\nnfsd4_create_session(struct svc_rqst *rqstp,\n\t\t     struct nfsd4_compound_state *cstate,\n\t\t     struct nfsd4_create_session *cr_ses)\n{\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tstruct nfs4_client *conf, *unconf;\n\tstruct nfs4_client *old = NULL;\n\tstruct nfsd4_session *new;\n\tstruct nfsd4_conn *conn;\n\tstruct nfsd4_clid_slot *cs_slot = NULL;\n\t__be32 status = 0;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tif (cr_ses->flags & ~SESSION4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\tstatus = nfsd4_check_cb_sec(&cr_ses->cb_sec);\n\tif (status)\n\t\treturn status;\n\tstatus = check_forechannel_attrs(&cr_ses->fore_channel, nn);\n\tif (status)\n\t\treturn status;\n\tstatus = check_backchannel_attrs(&cr_ses->back_channel);\n\tif (status)\n\t\tgoto out_release_drc_mem;\n\tstatus = nfserr_jukebox;\n\tnew = alloc_session(&cr_ses->fore_channel, &cr_ses->back_channel);\n\tif (!new)\n\t\tgoto out_release_drc_mem;\n\tconn = alloc_conn_from_crses(rqstp, cr_ses);\n\tif (!conn)\n\t\tgoto out_free_session;\n\n\tspin_lock(&nn->client_lock);\n\tunconf = find_unconfirmed_client(&cr_ses->clientid, true, nn);\n\tconf = find_confirmed_client(&cr_ses->clientid, true, nn);\n\tWARN_ON_ONCE(conf && unconf);\n\n\tif (conf) {\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(conf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &conf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\tif (status == nfserr_replay_cache)\n\t\t\t\tstatus = nfsd4_replay_create_session(cr_ses, cs_slot);\n\t\t\tgoto out_free_conn;\n\t\t}\n\t} else if (unconf) {\n\t\tif (!same_creds(&unconf->cl_cred, &rqstp->rq_cred) ||\n\t\t    !rpc_cmp_addr(sa, (struct sockaddr *) &unconf->cl_addr)) {\n\t\t\tstatus = nfserr_clid_inuse;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\tstatus = nfserr_wrong_cred;\n\t\tif (!mach_creds_match(unconf, rqstp))\n\t\t\tgoto out_free_conn;\n\t\tcs_slot = &unconf->cl_cs_slot;\n\t\tstatus = check_slot_seqid(cr_ses->seqid, cs_slot->sl_seqid, 0);\n\t\tif (status) {\n\t\t\t/* an unconfirmed replay returns misordered */\n\t\t\tstatus = nfserr_seq_misordered;\n\t\t\tgoto out_free_conn;\n\t\t}\n\t\told = find_confirmed_client_by_name(&unconf->cl_name, nn);\n\t\tif (old) {\n\t\t\tstatus = mark_client_expired_locked(old);\n\t\t\tif (status) {\n\t\t\t\told = NULL;\n\t\t\t\tgoto out_free_conn;\n\t\t\t}\n\t\t}\n\t\tmove_to_confirmed(unconf);\n\t\tconf = unconf;\n\t} else {\n\t\tstatus = nfserr_stale_clientid;\n\t\tgoto out_free_conn;\n\t}\n\tstatus = nfs_ok;\n\t/* Persistent sessions are not supported */\n\tcr_ses->flags &= ~SESSION4_PERSIST;\n\t/* Upshifting from TCP to RDMA is not supported */\n\tcr_ses->flags &= ~SESSION4_RDMA;\n\n\tinit_session(rqstp, new, conf, cr_ses);\n\tnfsd4_get_session_locked(new);\n\n\tmemcpy(cr_ses->sessionid.data, new->se_sessionid.data,\n\t       NFS4_MAX_SESSIONID_LEN);\n\tcs_slot->sl_seqid++;\n\tcr_ses->seqid = cs_slot->sl_seqid;\n\n\t/* cache solo and embedded create sessions under the client_lock */\n\tnfsd4_cache_create_session(cr_ses, cs_slot, status);\n\tspin_unlock(&nn->client_lock);\n\t/* init connection and backchannel */\n\tnfsd4_init_conn(rqstp, conn, new);\n\tnfsd4_put_session(new);\n\tif (old)\n\t\texpire_client(old);\n\treturn status;\nout_free_conn:\n\tspin_unlock(&nn->client_lock);\n\tfree_conn(conn);\n\tif (old)\n\t\texpire_client(old);\nout_free_session:\n\t__free_session(new);\nout_release_drc_mem:\n\tnfsd4_put_drc_mem(&cr_ses->fore_channel);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_check_cb_sec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2621-2637",
    "snippet": "static __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfsd4_check_cb_sec(struct nfsd4_cb_sec *cbs)\n{\n\tswitch (cbs->flavor) {\n\tcase RPC_AUTH_NULL:\n\tcase RPC_AUTH_UNIX:\n\t\treturn nfs_ok;\n\tdefault:\n\t\t/*\n\t\t * GSS case: the spec doesn't allow us to return this\n\t\t * error.  But it also doesn't allow us not to support\n\t\t * GSS.\n\t\t * I'd rather this fail hard than return some error the\n\t\t * client might think it can already handle:\n\t\t */\n\t\treturn nfserr_encr_alg_unsupp;\n\t}\n}"
  },
  {
    "function_name": "check_backchannel_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2606-2619",
    "snippet": "static __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH_SYS) * \\\n\t\t\t\t sizeof(__be32))",
      "#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH_SYS) * sizeof(__be32))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_CB_MAX_RESP_SZ\t((NFS4_dec_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_REPHEADER_WITH_AUTH_SYS) * \\\n\t\t\t\t sizeof(__be32))\n#define NFSD_CB_MAX_REQ_SZ\t((NFS4_enc_cb_recall_sz + \\\n\t\t\t\t RPC_MAX_HEADER_WITH_AUTH_SYS) * sizeof(__be32))\n\nstatic __be32 check_backchannel_attrs(struct nfsd4_channel_attrs *ca)\n{\n\tca->headerpadsz = 0;\n\n\tif (ca->maxreq_sz < NFSD_CB_MAX_REQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_CB_MAX_RESP_SZ)\n\t\treturn nfserr_toosmall;\n\tca->maxresp_cached = 0;\n\tif (ca->maxops < 2)\n\t\treturn nfserr_toosmall;\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "check_forechannel_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2560-2588",
    "snippet": "static __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */",
      "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_get_drc_mem",
          "args": [
            "ca"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_drc_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1411-1425",
          "snippet": "static u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxreqs",
            "NFSD_MAX_SLOTS_PER_SESSION"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxresp_cached",
            "NFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxops",
            "NFSD_MAX_OPS_PER_COMPOUND"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxresp_sz",
            "maxrpc"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "ca->maxreq_sz",
            "maxrpc"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_REQ_HDR_SEQ_SZ\t((\\\n\t\t\t2 * 2 + /* credential,verifier: AUTH_NULL, length 0 */\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic __be32 check_forechannel_attrs(struct nfsd4_channel_attrs *ca, struct nfsd_net *nn)\n{\n\tu32 maxrpc = nn->nfsd_serv->sv_max_mesg;\n\n\tif (ca->maxreq_sz < NFSD_MIN_REQ_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tif (ca->maxresp_sz < NFSD_MIN_RESP_HDR_SEQ_SZ)\n\t\treturn nfserr_toosmall;\n\tca->headerpadsz = 0;\n\tca->maxreq_sz = min_t(u32, ca->maxreq_sz, maxrpc);\n\tca->maxresp_sz = min_t(u32, ca->maxresp_sz, maxrpc);\n\tca->maxops = min_t(u32, ca->maxops, NFSD_MAX_OPS_PER_COMPOUND);\n\tca->maxresp_cached = min_t(u32, ca->maxresp_cached,\n\t\t\tNFSD_SLOT_CACHE_SIZE + NFSD_MIN_HDR_SEQ_SZ);\n\tca->maxreqs = min_t(u32, ca->maxreqs, NFSD_MAX_SLOTS_PER_SESSION);\n\t/*\n\t * Note decreasing slot size below client's request may make it\n\t * difficult for client to function correctly, whereas\n\t * decreasing the number of slots will (just?) affect\n\t * performance.  When short on memory we therefore prefer to\n\t * decrease number of slots instead of their size.  Clients that\n\t * request larger slots than they need will get poor results:\n\t */\n\tca->maxreqs = nfsd4_get_drc_mem(ca);\n\tif (!ca->maxreqs)\n\t\treturn nfserr_jukebox;\n\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd4_replay_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2535-2541",
    "snippet": "static __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cr_ses",
            "&slot->sl_cr_ses",
            "sizeof(*cr_ses)"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t    struct nfsd4_clid_slot *slot)\n{\n\tmemcpy(cr_ses, &slot->sl_cr_ses, sizeof(*cr_ses));\n\treturn slot->sl_status;\n}"
  },
  {
    "function_name": "nfsd4_cache_create_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2527-2533",
    "snippet": "static void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&slot->sl_cr_ses",
            "cr_ses",
            "sizeof(*cr_ses)"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cache_create_session(struct nfsd4_create_session *cr_ses,\n\t\t\t   struct nfsd4_clid_slot *slot, __be32 nfserr)\n{\n\tslot->sl_status = nfserr;\n\tmemcpy(&slot->sl_cr_ses, cr_ses, sizeof(*cr_ses));\n}"
  },
  {
    "function_name": "check_slot_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2501-2520",
    "snippet": "static __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "seqid == slot_seqid + 1"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s enter. seqid %d slot_seqid %d\\n\"",
            "__func__",
            "seqid",
            "slot_seqid"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\ncheck_slot_seqid(u32 seqid, u32 slot_seqid, int slot_inuse)\n{\n\tdprintk(\"%s enter. seqid %d slot_seqid %d\\n\", __func__, seqid,\n\t\tslot_seqid);\n\n\t/* The slot is in use, and no response has been sent. */\n\tif (slot_inuse) {\n\t\tif (seqid == slot_seqid)\n\t\t\treturn nfserr_jukebox;\n\t\telse\n\t\t\treturn nfserr_seq_misordered;\n\t}\n\t/* Note unsigned 32-bit arithmetic handles wraparound: */\n\tif (likely(seqid == slot_seqid + 1))\n\t\treturn nfs_ok;\n\tif (seqid == slot_seqid)\n\t\treturn nfserr_replay_cache;\n\treturn nfserr_seq_misordered;\n}"
  },
  {
    "function_name": "nfsd4_exchange_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2362-2499",
    "snippet": "__be32\nnfsd4_exchange_id(struct svc_rqst *rqstp,\n\t\t  struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_exchange_id *exid)\n{\n\tstruct nfs4_client *conf, *new;\n\tstruct nfs4_client *unconf = NULL;\n\t__be32 status;\n\tchar\t\t\taddr_str[INET6_ADDRSTRLEN];\n\tnfs4_verifier\t\tverf = exid->verifier;\n\tstruct sockaddr\t\t*sa = svc_addr(rqstp);\n\tbool\tupdate = exid->flags & EXCHGID4_FLAG_UPD_CONFIRMED_REC_A;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\trpc_ntop(sa, addr_str, sizeof(addr_str));\n\tdprintk(\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %d\\n\",\n\t\t__func__, rqstp, exid, exid->clname.len, exid->clname.data,\n\t\taddr_str, exid->flags, exid->spa_how);\n\n\tif (exid->flags & ~EXCHGID4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\n\tnew = create_client(exid->clname, rqstp, &verf);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\n\tswitch (exid->spa_how) {\n\tcase SP4_MACH_CRED:\n\t\tif (!svc_rqst_integrity_protected(rqstp)) {\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\t/*\n\t\t * Sometimes userspace doesn't give us a principal.\n\t\t * Which is a bug, really.  Anyway, we can't enforce\n\t\t * MACH_CRED in that case, better to give up now:\n\t\t */\n\t\tif (!new->cl_cred.cr_principal &&\n\t\t\t\t\t!new->cl_cred.cr_raw_principal) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\tnew->cl_mach_cred = true;\n\tcase SP4_NONE:\n\t\tbreak;\n\tdefault:\t\t\t\t/* checked by xdr code */\n\t\tWARN_ON_ONCE(1);\n\tcase SP4_SSV:\n\t\tstatus = nfserr_encr_alg_unsupp;\n\t\tgoto out_nolock;\n\t}\n\n\t/* Cases below refer to rfc 5661 section 18.35.4: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&exid->clname, nn);\n\tif (conf) {\n\t\tbool creds_match = same_creds(&conf->cl_cred, &rqstp->rq_cred);\n\t\tbool verfs_match = same_verf(&verf, &conf->cl_verifier);\n\n\t\tif (update) {\n\t\t\tif (!clp_used_exchangeid(conf)) { /* buggy client */\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!mach_creds_match(conf, rqstp)) {\n\t\t\t\tstatus = nfserr_wrong_cred;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!creds_match) { /* case 9 */\n\t\t\t\tstatus = nfserr_perm;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!verfs_match) { /* case 8 */\n\t\t\t\tstatus = nfserr_not_same;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* case 6 */\n\t\t\texid->flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\tif (!creds_match) { /* case 3 */\n\t\t\tif (client_has_state(conf)) {\n\t\t\t\tstatus = nfserr_clid_inuse;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto out_new;\n\t\t}\n\t\tif (verfs_match) { /* case 2 */\n\t\t\tconf->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\t/* case 5, client reboot */\n\t\tconf = NULL;\n\t\tgoto out_new;\n\t}\n\n\tif (update) { /* case 7 */\n\t\tstatus = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tunconf  = find_unconfirmed_client_by_name(&exid->clname, nn);\n\tif (unconf) /* case 4, possible retry or client restart */\n\t\tunhash_client_locked(unconf);\n\n\t/* case 1 (normal case) */\nout_new:\n\tif (conf) {\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tnew->cl_minorversion = cstate->minorversion;\n\n\tgen_clid(new, nn);\n\tadd_to_unconfirmed(new);\n\tswap(new, conf);\nout_copy:\n\texid->clientid.cl_boot = conf->cl_clientid.cl_boot;\n\texid->clientid.cl_id = conf->cl_clientid.cl_id;\n\n\texid->seqid = conf->cl_cs_slot.sl_seqid + 1;\n\tnfsd4_set_ex_flags(conf, exid);\n\n\tdprintk(\"nfsd4_exchange_id seqid %d flags %x\\n\",\n\t\tconf->cl_cs_slot.sl_seqid, conf->cl_exchange_flags);\n\tstatus = nfs_ok;\n\nout:\n\tspin_unlock(&nn->client_lock);\nout_nolock:\n\tif (new)\n\t\texpire_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expire_client",
          "args": [
            "unconf"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "expire_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1841-1846",
          "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd4_exchange_id seqid %d flags %x\\n\"",
            "conf->cl_cs_slot.sl_seqid",
            "conf->cl_exchange_flags"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_set_ex_flags",
          "args": [
            "conf",
            "exid"
          ],
          "line": 2485
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_set_ex_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2325-2339",
          "snippet": "static void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "new",
            "conf"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_unconfirmed",
          "args": [
            "new"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_unconfirmed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2108-2121",
          "snippet": "static void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_clid",
          "args": [
            "new",
            "nn"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "gen_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2006-2011",
          "snippet": "static void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_client_expired_locked",
          "args": [
            "conf"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "mark_client_expired_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1787-1793",
          "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "unconf"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1752-1775",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_unconfirmed_client_by_name",
          "args": [
            "&exid->clname",
            "nn"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "find_unconfirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2186-2191",
          "snippet": "static struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "client_has_state",
          "args": [
            "conf"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "client_has_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2352-2360",
          "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mach_creds_match",
          "args": [
            "conf",
            "rqstp"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "mach_creds_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1975-1991",
          "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clp_used_exchangeid",
          "args": [
            "conf"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "clp_used_exchangeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2174-2177",
          "snippet": "static bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_verf",
          "args": [
            "&verf",
            "&conf->cl_verifier"
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "same_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1908-1912",
          "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_creds",
          "args": [
            "&conf->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "same_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1948-1961",
          "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_confirmed_client_by_name",
          "args": [
            "&exid->clname",
            "nn"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "find_confirmed_client_by_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2179-2184",
          "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_rqst_integrity_protected",
          "args": [
            "rqstp"
          ],
          "line": 2391
        },
        "resolved": true,
        "details": {
          "function_name": "svc_rqst_integrity_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1963-1973",
          "snippet": "static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_client",
          "args": [
            "exid->clname",
            "rqstp",
            "&verf"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "create_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2041-2066",
          "snippet": "static struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %d\\n\"",
            "__func__",
            "rqstp",
            "exid",
            "exid->clname.len",
            "exid->clname.data",
            "addr_str",
            "exid->flags",
            "exid->spa_how"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_ntop",
          "args": [
            "sa",
            "addr_str",
            "sizeof(addr_str)"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n__be32\nnfsd4_exchange_id(struct svc_rqst *rqstp,\n\t\t  struct nfsd4_compound_state *cstate,\n\t\t  struct nfsd4_exchange_id *exid)\n{\n\tstruct nfs4_client *conf, *new;\n\tstruct nfs4_client *unconf = NULL;\n\t__be32 status;\n\tchar\t\t\taddr_str[INET6_ADDRSTRLEN];\n\tnfs4_verifier\t\tverf = exid->verifier;\n\tstruct sockaddr\t\t*sa = svc_addr(rqstp);\n\tbool\tupdate = exid->flags & EXCHGID4_FLAG_UPD_CONFIRMED_REC_A;\n\tstruct nfsd_net\t\t*nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\trpc_ntop(sa, addr_str, sizeof(addr_str));\n\tdprintk(\"%s rqstp=%p exid=%p clname.len=%u clname.data=%p \"\n\t\t\"ip_addr=%s flags %x, spa_how %d\\n\",\n\t\t__func__, rqstp, exid, exid->clname.len, exid->clname.data,\n\t\taddr_str, exid->flags, exid->spa_how);\n\n\tif (exid->flags & ~EXCHGID4_FLAG_MASK_A)\n\t\treturn nfserr_inval;\n\n\tnew = create_client(exid->clname, rqstp, &verf);\n\tif (new == NULL)\n\t\treturn nfserr_jukebox;\n\n\tswitch (exid->spa_how) {\n\tcase SP4_MACH_CRED:\n\t\tif (!svc_rqst_integrity_protected(rqstp)) {\n\t\t\tstatus = nfserr_inval;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\t/*\n\t\t * Sometimes userspace doesn't give us a principal.\n\t\t * Which is a bug, really.  Anyway, we can't enforce\n\t\t * MACH_CRED in that case, better to give up now:\n\t\t */\n\t\tif (!new->cl_cred.cr_principal &&\n\t\t\t\t\t!new->cl_cred.cr_raw_principal) {\n\t\t\tstatus = nfserr_serverfault;\n\t\t\tgoto out_nolock;\n\t\t}\n\t\tnew->cl_mach_cred = true;\n\tcase SP4_NONE:\n\t\tbreak;\n\tdefault:\t\t\t\t/* checked by xdr code */\n\t\tWARN_ON_ONCE(1);\n\tcase SP4_SSV:\n\t\tstatus = nfserr_encr_alg_unsupp;\n\t\tgoto out_nolock;\n\t}\n\n\t/* Cases below refer to rfc 5661 section 18.35.4: */\n\tspin_lock(&nn->client_lock);\n\tconf = find_confirmed_client_by_name(&exid->clname, nn);\n\tif (conf) {\n\t\tbool creds_match = same_creds(&conf->cl_cred, &rqstp->rq_cred);\n\t\tbool verfs_match = same_verf(&verf, &conf->cl_verifier);\n\n\t\tif (update) {\n\t\t\tif (!clp_used_exchangeid(conf)) { /* buggy client */\n\t\t\t\tstatus = nfserr_inval;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!mach_creds_match(conf, rqstp)) {\n\t\t\t\tstatus = nfserr_wrong_cred;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!creds_match) { /* case 9 */\n\t\t\t\tstatus = nfserr_perm;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (!verfs_match) { /* case 8 */\n\t\t\t\tstatus = nfserr_not_same;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t/* case 6 */\n\t\t\texid->flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\tif (!creds_match) { /* case 3 */\n\t\t\tif (client_has_state(conf)) {\n\t\t\t\tstatus = nfserr_clid_inuse;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto out_new;\n\t\t}\n\t\tif (verfs_match) { /* case 2 */\n\t\t\tconf->cl_exchange_flags |= EXCHGID4_FLAG_CONFIRMED_R;\n\t\t\tgoto out_copy;\n\t\t}\n\t\t/* case 5, client reboot */\n\t\tconf = NULL;\n\t\tgoto out_new;\n\t}\n\n\tif (update) { /* case 7 */\n\t\tstatus = nfserr_noent;\n\t\tgoto out;\n\t}\n\n\tunconf  = find_unconfirmed_client_by_name(&exid->clname, nn);\n\tif (unconf) /* case 4, possible retry or client restart */\n\t\tunhash_client_locked(unconf);\n\n\t/* case 1 (normal case) */\nout_new:\n\tif (conf) {\n\t\tstatus = mark_client_expired_locked(conf);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\tnew->cl_minorversion = cstate->minorversion;\n\n\tgen_clid(new, nn);\n\tadd_to_unconfirmed(new);\n\tswap(new, conf);\nout_copy:\n\texid->clientid.cl_boot = conf->cl_clientid.cl_boot;\n\texid->clientid.cl_id = conf->cl_clientid.cl_id;\n\n\texid->seqid = conf->cl_cs_slot.sl_seqid + 1;\n\tnfsd4_set_ex_flags(conf, exid);\n\n\tdprintk(\"nfsd4_exchange_id seqid %d flags %x\\n\",\n\t\tconf->cl_cs_slot.sl_seqid, conf->cl_exchange_flags);\n\tstatus = nfs_ok;\n\nout:\n\tspin_unlock(&nn->client_lock);\nout_nolock:\n\tif (new)\n\t\texpire_client(new);\n\tif (unconf)\n\t\texpire_client(unconf);\n\treturn status;\n}"
  },
  {
    "function_name": "client_has_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2352-2360",
    "snippet": "static bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_sessions"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_delegations"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_lo_states"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "client_has_openowners",
          "args": [
            "clp"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "client_has_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2341-2350",
          "snippet": "static bool client_has_openowners(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tlist_for_each_entry(oo, &clp->cl_openowners, oo_perclient) {\n\t\tif (!list_empty(&oo->oo_owner.so_stateids))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_openowners(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tlist_for_each_entry(oo, &clp->cl_openowners, oo_perclient) {\n\t\tif (!list_empty(&oo->oo_owner.so_stateids))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_state(struct nfs4_client *clp)\n{\n\treturn client_has_openowners(clp)\n#ifdef CONFIG_NFSD_PNFS\n\t\t|| !list_empty(&clp->cl_lo_states)\n#endif\n\t\t|| !list_empty(&clp->cl_delegations)\n\t\t|| !list_empty(&clp->cl_sessions);\n}"
  },
  {
    "function_name": "client_has_openowners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2341-2350",
    "snippet": "static bool client_has_openowners(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tlist_for_each_entry(oo, &clp->cl_openowners, oo_perclient) {\n\t\tif (!list_empty(&oo->oo_owner.so_stateids))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&oo->oo_owner.so_stateids"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "oo",
            "&clp->cl_openowners",
            "oo_perclient"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool client_has_openowners(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tlist_for_each_entry(oo, &clp->cl_openowners, oo_perclient) {\n\t\tif (!list_empty(&oo->oo_owner.so_stateids))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "nfsd4_set_ex_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2325-2339",
    "snippet": "static void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void\nnfsd4_set_ex_flags(struct nfs4_client *new, struct nfsd4_exchange_id *clid)\n{\n#ifdef CONFIG_NFSD_PNFS\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_PNFS_MDS;\n#else\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_USE_NON_PNFS;\n#endif\n\n\t/* Referrals are supported, Migration is not. */\n\tnew->cl_exchange_flags |= EXCHGID4_FLAG_SUPP_MOVED_REFER;\n\n\t/* set the wire flags to return to client. */\n\tclid->flags = new->cl_exchange_flags;\n}"
  },
  {
    "function_name": "nfsd4_replay_cache_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2295-2320",
    "snippet": "static __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_commit_encode",
          "args": [
            "xdr"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_encode_opaque_fixed",
          "args": [
            "p",
            "slot->sl_data",
            "slot->sl_datalen"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "slot->sl_datalen"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_enc_sequence_replay",
          "args": [
            "resp->rqstp->rq_argp",
            "resp"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_enc_sequence_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2271-2289",
          "snippet": "static __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s slot %p\\n\"",
            "__func__",
            "slot"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_replay_cache_entry(struct nfsd4_compoundres *resp,\n\t\t\t struct nfsd4_sequence *seq)\n{\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tstruct xdr_stream *xdr = &resp->xdr;\n\t__be32 *p;\n\t__be32 status;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tstatus = nfsd4_enc_sequence_replay(resp->rqstp->rq_argp, resp);\n\tif (status)\n\t\treturn status;\n\n\tp = xdr_reserve_space(xdr, slot->sl_datalen);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn nfserr_serverfault;\n\t}\n\txdr_encode_opaque_fixed(p, slot->sl_data, slot->sl_datalen);\n\txdr_commit_encode(xdr);\n\n\tresp->opcnt = slot->sl_opcnt;\n\treturn slot->sl_status;\n}"
  },
  {
    "function_name": "nfsd4_enc_sequence_replay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2271-2289",
    "snippet": "static __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_encode_operation",
          "args": [
            "resp",
            "op"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_encode_operation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4xdr.c",
          "lines": "4353-4418",
          "snippet": "void\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"cache.h\"",
            "#include \"state.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4.h\"",
            "#include \"acl.h\"",
            "#include \"idmap.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/utsname.h>",
            "#include <linux/statfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_CLONE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"cache.h\"\n#include \"state.h\"\n#include \"vfs.h\"\n#include \"xdr4.h\"\n#include \"acl.h\"\n#include \"idmap.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/pagemap.h>\n#include <linux/utsname.h>\n#include <linux/statfs.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic nfsd4_enc nfsd4_enc_ops[] = {\n\t[OP_ACCESS]\t\t= (nfsd4_enc)nfsd4_encode_access,\n\t[OP_CLOSE]\t\t= (nfsd4_enc)nfsd4_encode_close,\n\t[OP_COMMIT]\t\t= (nfsd4_enc)nfsd4_encode_commit,\n\t[OP_CREATE]\t\t= (nfsd4_enc)nfsd4_encode_create,\n\t[OP_DELEGPURGE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DELEGRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETATTR]\t\t= (nfsd4_enc)nfsd4_encode_getattr,\n\t[OP_GETFH]\t\t= (nfsd4_enc)nfsd4_encode_getfh,\n\t[OP_LINK]\t\t= (nfsd4_enc)nfsd4_encode_link,\n\t[OP_LOCK]\t\t= (nfsd4_enc)nfsd4_encode_lock,\n\t[OP_LOCKT]\t\t= (nfsd4_enc)nfsd4_encode_lockt,\n\t[OP_LOCKU]\t\t= (nfsd4_enc)nfsd4_encode_locku,\n\t[OP_LOOKUP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LOOKUPP]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_NVERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN]\t\t= (nfsd4_enc)nfsd4_encode_open,\n\t[OP_OPENATTR]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OPEN_CONFIRM]\t= (nfsd4_enc)nfsd4_encode_open_confirm,\n\t[OP_OPEN_DOWNGRADE]\t= (nfsd4_enc)nfsd4_encode_open_downgrade,\n\t[OP_PUTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTPUBFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_PUTROOTFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ]\t\t= (nfsd4_enc)nfsd4_encode_read,\n\t[OP_READDIR]\t\t= (nfsd4_enc)nfsd4_encode_readdir,\n\t[OP_READLINK]\t\t= (nfsd4_enc)nfsd4_encode_readlink,\n\t[OP_REMOVE]\t\t= (nfsd4_enc)nfsd4_encode_remove,\n\t[OP_RENAME]\t\t= (nfsd4_enc)nfsd4_encode_rename,\n\t[OP_RENEW]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RESTOREFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SAVEFH]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SECINFO]\t\t= (nfsd4_enc)nfsd4_encode_secinfo,\n\t[OP_SETATTR]\t\t= (nfsd4_enc)nfsd4_encode_setattr,\n\t[OP_SETCLIENTID]\t= (nfsd4_enc)nfsd4_encode_setclientid,\n\t[OP_SETCLIENTID_CONFIRM] = (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_VERIFY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_WRITE]\t\t= (nfsd4_enc)nfsd4_encode_write,\n\t[OP_RELEASE_LOCKOWNER]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.1 operations */\n\t[OP_BACKCHANNEL_CTL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_BIND_CONN_TO_SESSION] = (nfsd4_enc)nfsd4_encode_bind_conn_to_session,\n\t[OP_EXCHANGE_ID]\t= (nfsd4_enc)nfsd4_encode_exchange_id,\n\t[OP_CREATE_SESSION]\t= (nfsd4_enc)nfsd4_encode_create_session,\n\t[OP_DESTROY_SESSION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_FREE_STATEID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GET_DIR_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n#ifdef CONFIG_NFSD_PNFS\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_getdeviceinfo,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_layoutcommit,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_layoutget,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_layoutreturn,\n#else\n\t[OP_GETDEVICEINFO]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_GETDEVICELIST]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTCOMMIT]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTGET]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTRETURN]\t= (nfsd4_enc)nfsd4_encode_noop,\n#endif\n\t[OP_SECINFO_NO_NAME]\t= (nfsd4_enc)nfsd4_encode_secinfo_no_name,\n\t[OP_SEQUENCE]\t\t= (nfsd4_enc)nfsd4_encode_sequence,\n\t[OP_SET_SSV]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_TEST_STATEID]\t= (nfsd4_enc)nfsd4_encode_test_stateid,\n\t[OP_WANT_DELEGATION]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DESTROY_CLIENTID]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_RECLAIM_COMPLETE]\t= (nfsd4_enc)nfsd4_encode_noop,\n\n\t/* NFSv4.2 operations */\n\t[OP_ALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_COPY_NOTIFY]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_DEALLOCATE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_IO_ADVISE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTERROR]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_LAYOUTSTATS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_CANCEL]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_OFFLOAD_STATUS]\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_READ_PLUS]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_SEEK]\t\t= (nfsd4_enc)nfsd4_encode_seek,\n\t[OP_WRITE_SAME]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n\t[OP_CLONE]\t\t= (nfsd4_enc)nfsd4_encode_noop,\n};\n\nvoid\nnfsd4_encode_operation(struct nfsd4_compoundres *resp, struct nfsd4_op *op)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tstruct nfs4_stateowner *so = resp->cstate.replay_owner;\n\tstruct svc_rqst *rqstp = resp->rqstp;\n\tint post_err_offset;\n\tnfsd4_enc encoder;\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 8);\n\tif (!p) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\t*p++ = cpu_to_be32(op->opnum);\n\tpost_err_offset = xdr->buf->len;\n\n\tif (op->opnum == OP_ILLEGAL)\n\t\tgoto status;\n\tBUG_ON(op->opnum < 0 || op->opnum >= ARRAY_SIZE(nfsd4_enc_ops) ||\n\t       !nfsd4_enc_ops[op->opnum]);\n\tencoder = nfsd4_enc_ops[op->opnum];\n\top->status = encoder(resp, op->status, &op->u);\n\txdr_commit_encode(xdr);\n\n\t/* nfsd4_check_resp_size guarantees enough room for error status */\n\tif (!op->status) {\n\t\tint space_needed = 0;\n\t\tif (!nfsd4_last_compound_op(rqstp))\n\t\t\tspace_needed = COMPOUND_ERR_SLACK_SPACE;\n\t\top->status = nfsd4_check_resp_size(resp, space_needed);\n\t}\n\tif (op->status == nfserr_resource && nfsd4_has_session(&resp->cstate)) {\n\t\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t\tif (slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t\top->status = nfserr_rep_too_big_to_cache;\n\t\telse\n\t\t\top->status = nfserr_rep_too_big;\n\t}\n\tif (op->status == nfserr_resource ||\n\t    op->status == nfserr_rep_too_big ||\n\t    op->status == nfserr_rep_too_big_to_cache) {\n\t\t/*\n\t\t * The operation may have already been encoded or\n\t\t * partially encoded.  No op returns anything additional\n\t\t * in the case of one of these three errors, so we can\n\t\t * just truncate back to after the status.  But it's a\n\t\t * bug if we had to do this on a non-idempotent op:\n\t\t */\n\t\twarn_on_nonidempotent_op(op);\n\t\txdr_truncate_encode(xdr, post_err_offset);\n\t}\n\tif (so) {\n\t\tint len = xdr->buf->len - post_err_offset;\n\n\t\tso->so_replay.rp_status = op->status;\n\t\tso->so_replay.rp_buflen = len;\n\t\tread_bytes_from_xdr_buf(xdr->buf, post_err_offset,\n\t\t\t\t\t\tso->so_replay.rp_buf, len);\n\t}\nstatus:\n\t/* Note that op->status is already in network byte order: */\n\twrite_bytes_to_xdr_buf(xdr->buf, post_err_offset - 4, &op->status, 4);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32\nnfsd4_enc_sequence_replay(struct nfsd4_compoundargs *args,\n\t\t\t  struct nfsd4_compoundres *resp)\n{\n\tstruct nfsd4_op *op;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\n\t/* Encode the replayed sequence operation */\n\top = &args->ops[resp->opcnt - 1];\n\tnfsd4_encode_operation(resp, op);\n\n\t/* Return nfserr_retry_uncached_rep in next operation. */\n\tif (args->opcnt > 1 && !(slot->sl_flags & NFSD4_SLOT_CACHETHIS)) {\n\t\top = &args->ops[resp->opcnt++];\n\t\top->status = nfserr_retry_uncached_rep;\n\t\tnfsd4_encode_operation(resp, op);\n\t}\n\treturn op->status;\n}"
  },
  {
    "function_name": "nfsd4_store_cache_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2239-2262",
    "snippet": "static void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(1, \"%s: sessions DRC could not cache compound\\n\",\n\t\t     __func__);\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s: sessions DRC could not cache compound\\n\"",
            "__func__"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_bytes_from_xdr_buf",
          "args": [
            "buf",
            "base",
            "slot->sl_data",
            "slot->sl_datalen"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_not_cached",
          "args": [
            "resp"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_not_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/xdr4.h",
          "lines": "622-626",
          "snippet": "static inline bool nfsd4_not_cached(struct nfsd4_compoundres *resp)\n{\n\treturn !(resp->cstate.slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t|| nfsd4_is_solo_sequence(resp);\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"state.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"state.h\"\n\nstatic inline bool nfsd4_not_cached(struct nfsd4_compoundres *resp)\n{\n\treturn !(resp->cstate.slot->sl_flags & NFSD4_SLOT_CACHETHIS)\n\t\t|| nfsd4_is_solo_sequence(resp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"--> %s slot %p\\n\"",
            "__func__",
            "slot"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_store_cache_entry(struct nfsd4_compoundres *resp)\n{\n\tstruct xdr_buf *buf = resp->xdr.buf;\n\tstruct nfsd4_slot *slot = resp->cstate.slot;\n\tunsigned int base;\n\n\tdprintk(\"--> %s slot %p\\n\", __func__, slot);\n\n\tslot->sl_opcnt = resp->opcnt;\n\tslot->sl_status = resp->cstate.status;\n\n\tslot->sl_flags |= NFSD4_SLOT_INITIALIZED;\n\tif (nfsd4_not_cached(resp)) {\n\t\tslot->sl_datalen = 0;\n\t\treturn;\n\t}\n\tbase = resp->cstate.data_offset;\n\tslot->sl_datalen = buf->len - base;\n\tif (read_bytes_from_xdr_buf(buf, base, slot->sl_data, slot->sl_datalen))\n\t\tWARN(1, \"%s: sessions DRC could not cache compound\\n\",\n\t\t     __func__);\n\treturn;\n}"
  },
  {
    "function_name": "gen_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2193-2234",
    "snippet": "static void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\"",
            "clp->cl_clientid.cl_boot",
            "clp->cl_clientid.cl_id"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&conn->cb_saddr",
            "&rqstp->rq_daddr",
            "rqstp->rq_daddrlen"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_uaddr2sockaddr",
          "args": [
            "clp->net",
            "se->se_callback_addr_val",
            "se->se_callback_addr_len",
            "(struct sockaddr *)&conn->cb_addr",
            "sizeof(conn->cb_addr)"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "se->se_callback_netid_val",
            "\"tcp6\"",
            "4"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "se->se_callback_netid_val",
            "\"tcp\"",
            "3"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_get_scope_id",
          "args": [
            "sa"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ngen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, struct svc_rqst *rqstp)\n{\n\tstruct nfs4_cb_conn *conn = &clp->cl_cb_conn;\n\tstruct sockaddr\t*sa = svc_addr(rqstp);\n\tu32 scopeid = rpc_get_scope_id(sa);\n\tunsigned short expected_family;\n\n\t/* Currently, we only support tcp and tcp6 for the callback channel */\n\tif (se->se_callback_netid_len == 3 &&\n\t    !memcmp(se->se_callback_netid_val, \"tcp\", 3))\n\t\texpected_family = AF_INET;\n\telse if (se->se_callback_netid_len == 4 &&\n\t\t !memcmp(se->se_callback_netid_val, \"tcp6\", 4))\n\t\texpected_family = AF_INET6;\n\telse\n\t\tgoto out_err;\n\n\tconn->cb_addrlen = rpc_uaddr2sockaddr(clp->net, se->se_callback_addr_val,\n\t\t\t\t\t    se->se_callback_addr_len,\n\t\t\t\t\t    (struct sockaddr *)&conn->cb_addr,\n\t\t\t\t\t    sizeof(conn->cb_addr));\n\n\tif (!conn->cb_addrlen || conn->cb_addr.ss_family != expected_family)\n\t\tgoto out_err;\n\n\tif (conn->cb_addr.ss_family == AF_INET6)\n\t\t((struct sockaddr_in6 *)&conn->cb_addr)->sin6_scope_id = scopeid;\n\n\tconn->cb_prog = se->se_callback_prog;\n\tconn->cb_ident = se->se_callback_ident;\n\tmemcpy(&conn->cb_saddr, &rqstp->rq_daddr, rqstp->rq_daddrlen);\n\treturn;\nout_err:\n\tconn->cb_addr.ss_family = AF_UNSPEC;\n\tconn->cb_addrlen = 0;\n\tdprintk(KERN_INFO \"NFSD: this client (clientid %08x/%08x) \"\n\t\t\"will not receive delegations\\n\",\n\t\tclp->cl_clientid.cl_boot, clp->cl_clientid.cl_id);\n\n\treturn;\n}"
  },
  {
    "function_name": "find_unconfirmed_client_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2186-2191",
    "snippet": "static struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_clp_in_name_tree",
          "args": [
            "name",
            "&nn->unconf_name_tree"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "find_clp_in_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2088-2106",
          "snippet": "static struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->unconf_name_tree);\n}"
  },
  {
    "function_name": "find_confirmed_client_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2179-2184",
    "snippet": "static struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_clp_in_name_tree",
          "args": [
            "name",
            "&nn->conf_name_tree"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "find_clp_in_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2088-2106",
          "snippet": "static struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client_by_name(struct xdr_netobj *name, struct nfsd_net *nn)\n{\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_clp_in_name_tree(name, &nn->conf_name_tree);\n}"
  },
  {
    "function_name": "clp_used_exchangeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2174-2177",
    "snippet": "static bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool clp_used_exchangeid(struct nfs4_client *clp)\n{\n\treturn clp->cl_exchange_flags != 0;\n}"
  },
  {
    "function_name": "find_unconfirmed_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2165-2172",
    "snippet": "static struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_client_in_id_table",
          "args": [
            "tbl",
            "clid",
            "sessions"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "find_client_in_id_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2139-2154",
          "snippet": "static struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_unconfirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->unconf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
  },
  {
    "function_name": "find_confirmed_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2156-2163",
    "snippet": "static struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_client_in_id_table",
          "args": [
            "tbl",
            "clid",
            "sessions"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "find_client_in_id_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2139-2154",
          "snippet": "static struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_confirmed_client(clientid_t *clid, bool sessions, struct nfsd_net *nn)\n{\n\tstruct list_head *tbl = nn->conf_id_hashtbl;\n\n\tlockdep_assert_held(&nn->client_lock);\n\treturn find_client_in_id_table(tbl, clid, sessions);\n}"
  },
  {
    "function_name": "find_client_in_id_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2139-2154",
    "snippet": "static struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "134-153",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_clid",
          "args": [
            "&clp->cl_clientid",
            "clid"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "same_clid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1914-1918",
          "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "clp",
            "&tbl[idhashval]",
            "cl_idhash"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientid_hashval",
          "args": [
            "clid->cl_id"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "clientid_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "903-906",
          "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_client_in_id_table(struct list_head *tbl, clientid_t *clid, bool sessions)\n{\n\tstruct nfs4_client *clp;\n\tunsigned int idhashval = clientid_hashval(clid->cl_id);\n\n\tlist_for_each_entry(clp, &tbl[idhashval], cl_idhash) {\n\t\tif (same_clid(&clp->cl_clientid, clid)) {\n\t\t\tif ((bool)clp->cl_minorversion != sessions)\n\t\t\t\treturn NULL;\n\t\t\trenew_client_locked(clp);\n\t\t\treturn clp;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "move_to_confirmed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2123-2137",
    "snippet": "static void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "134-153",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_CONFIRMED",
            "&clp->cl_flags"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_clp_to_name_tree",
          "args": [
            "clp",
            "&nn->conf_name_tree"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "add_clp_to_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2068-2086",
          "snippet": "static void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&clp->cl_namenode",
            "&nn->unconf_name_tree"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&clp->cl_idhash",
            "&nn->conf_id_hashtbl[idhashval]"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: move_to_confirm nfs4_client %p\\n\"",
            "clp"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientid_hashval",
          "args": [
            "clp->cl_clientid.cl_id"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "clientid_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "903-906",
          "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nmove_to_confirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdprintk(\"NFSD: move_to_confirm nfs4_client %p\\n\", clp);\n\tlist_move(&clp->cl_idhash, &nn->conf_id_hashtbl[idhashval]);\n\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\tadd_clp_to_name_tree(clp, &nn->conf_name_tree);\n\tset_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\trenew_client_locked(clp);\n}"
  },
  {
    "function_name": "add_to_unconfirmed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2108-2121",
    "snippet": "static void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "134-153",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&clp->cl_idhash",
            "&nn->unconf_id_hashtbl[idhashval]"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clientid_hashval",
          "args": [
            "clp->cl_clientid.cl_id"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "clientid_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "903-906",
          "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_clp_to_name_tree",
          "args": [
            "clp",
            "&nn->unconf_name_tree"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "add_clp_to_name_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2068-2086",
          "snippet": "static void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_CONFIRMED",
            "&clp->cl_flags"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_to_unconfirmed(struct nfs4_client *clp)\n{\n\tunsigned int idhashval;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tclear_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags);\n\tadd_clp_to_name_tree(clp, &nn->unconf_name_tree);\n\tidhashval = clientid_hashval(clp->cl_clientid.cl_id);\n\tlist_add(&clp->cl_idhash, &nn->unconf_id_hashtbl[idhashval]);\n\trenew_client_locked(clp);\n}"
  },
  {
    "function_name": "find_clp_in_name_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2088-2106",
    "snippet": "static struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compare_blob",
          "args": [
            "&clp->cl_name",
            "name"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "compare_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1893-1901",
          "snippet": "static int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structnfs4_client",
            "cl_namenode"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *\nfind_clp_in_name_tree(struct xdr_netobj *name, struct rb_root *root)\n{\n\tint cmp;\n\tstruct rb_node *node = root->rb_node;\n\tstruct nfs4_client *clp;\n\n\twhile (node) {\n\t\tclp = rb_entry(node, struct nfs4_client, cl_namenode);\n\t\tcmp = compare_blob(&clp->cl_name, name);\n\t\tif (cmp > 0)\n\t\t\tnode = node->rb_left;\n\t\telse if (cmp < 0)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn clp;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "add_clp_to_name_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2068-2086",
    "snippet": "static void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new_clp->cl_namenode",
            "root"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new_clp->cl_namenode",
            "parent",
            "new"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compare_blob",
          "args": [
            "&clp->cl_name",
            "&new_clp->cl_name"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "compare_blob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1893-1901",
          "snippet": "static int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "*new",
            "structnfs4_client",
            "cl_namenode"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nadd_clp_to_name_tree(struct nfs4_client *new_clp, struct rb_root *root)\n{\n\tstruct rb_node **new = &(root->rb_node), *parent = NULL;\n\tstruct nfs4_client *clp;\n\n\twhile (*new) {\n\t\tclp = rb_entry(*new, struct nfs4_client, cl_namenode);\n\t\tparent = *new;\n\n\t\tif (compare_blob(&clp->cl_name, &new_clp->cl_name) > 0)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse\n\t\t\tnew = &((*new)->rb_right);\n\t}\n\n\trb_link_node(&new_clp->cl_namenode, parent, new);\n\trb_insert_color(&new_clp->cl_namenode, root);\n}"
  },
  {
    "function_name": "create_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2041-2066",
    "snippet": "static struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_copy_addr",
          "args": [
            "(struct sockaddr *) &clp->cl_addr",
            "sa"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_verf",
          "args": [
            "clp",
            "verf"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "copy_verf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1848-1852",
          "snippet": "static void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "0",
            "&clp->cl_cb_slot_busy"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_init_cb",
          "args": [
            "&clp->cl_cb_null",
            "clp",
            "NULL",
            "NFSPROC4_CLNT_CB_NULL"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1133-1145",
          "snippet": "void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tcb->cb_need_restart = false;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tcb->cb_need_restart = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_client",
          "args": [
            "clp"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "free_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1732-1749",
          "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_cred",
          "args": [
            "&clp->cl_cred",
            "&rqstp->rq_cred"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "copy_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1871-1891",
          "snippet": "static int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tint ret;\n\n\tret = strdup_if_nonnull(&target->cr_principal, source->cr_principal);\n\tif (ret)\n\t\treturn ret;\n\tret = strdup_if_nonnull(&target->cr_raw_principal,\n\t\t\t\t\tsource->cr_raw_principal);\n\tif (ret)\n\t\treturn ret;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tint ret;\n\n\tret = strdup_if_nonnull(&target->cr_principal, source->cr_principal);\n\tif (ret)\n\t\treturn ret;\n\tret = strdup_if_nonnull(&target->cr_raw_principal,\n\t\t\t\t\tsource->cr_raw_principal);\n\tif (ret)\n\t\treturn ret;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_client",
          "args": [
            "name"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1692-1730",
          "snippet": "static struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)\n\nstatic struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_client *create_client(struct xdr_netobj name,\n\t\tstruct svc_rqst *rqstp, nfs4_verifier *verf)\n{\n\tstruct nfs4_client *clp;\n\tstruct sockaddr *sa = svc_addr(rqstp);\n\tint ret;\n\tstruct net *net = SVC_NET(rqstp);\n\n\tclp = alloc_client(name);\n\tif (clp == NULL)\n\t\treturn NULL;\n\n\tret = copy_cred(&clp->cl_cred, &rqstp->rq_cred);\n\tif (ret) {\n\t\tfree_client(clp);\n\t\treturn NULL;\n\t}\n\tnfsd4_init_cb(&clp->cl_cb_null, clp, NULL, NFSPROC4_CLNT_CB_NULL);\n\tclp->cl_time = get_seconds();\n\tclear_bit(0, &clp->cl_cb_slot_busy);\n\tcopy_verf(clp, verf);\n\trpc_copy_addr((struct sockaddr *) &clp->cl_addr, sa);\n\tclp->cl_cb_session = NULL;\n\tclp->net = net;\n\treturn clp;\n}"
  },
  {
    "function_name": "find_stateid_by_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2024-2039",
    "snippet": "static struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&s->sc_count"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_stateid_locked",
          "args": [
            "cl",
            "t"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "find_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "2013-2022",
          "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_by_type(struct nfs4_client *cl, stateid_t *t, char typemask)\n{\n\tstruct nfs4_stid *s;\n\n\tspin_lock(&cl->cl_lock);\n\ts = find_stateid_locked(cl, t);\n\tif (s != NULL) {\n\t\tif (typemask & s->sc_type)\n\t\t\tatomic_inc(&s->sc_count);\n\t\telse\n\t\t\ts = NULL;\n\t}\n\tspin_unlock(&cl->cl_lock);\n\treturn s;\n}"
  },
  {
    "function_name": "find_stateid_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2013-2022",
    "snippet": "static struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&cl->cl_stateids",
            "t->si_opaque.so_id"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_stid *\nfind_stateid_locked(struct nfs4_client *cl, stateid_t *t)\n{\n\tstruct nfs4_stid *ret;\n\n\tret = idr_find(&cl->cl_stateids, t->si_opaque.so_id);\n\tif (!ret || !ret->sc_type)\n\t\treturn NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "gen_clid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "2006-2011",
    "snippet": "static void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gen_confirm",
          "args": [
            "clp",
            "nn"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "gen_confirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1993-2004",
          "snippet": "static void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_clid(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\tclp->cl_clientid.cl_boot = nn->boot_time;\n\tclp->cl_clientid.cl_id = nn->clientid_counter++;\n\tgen_confirm(clp, nn);\n}"
  },
  {
    "function_name": "gen_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1993-2004",
    "snippet": "static void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "clp->cl_confirm.data",
            "verf",
            "sizeof(clp->cl_confirm.data)"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void gen_confirm(struct nfs4_client *clp, struct nfsd_net *nn)\n{\n\t__be32 verf[2];\n\n\t/*\n\t * This is opaque to client, so no need to byte-swap. Use\n\t * __force to keep sparse happy\n\t */\n\tverf[0] = (__force __be32)get_seconds();\n\tverf[1] = (__force __be32)nn->clverifier_counter++;\n\tmemcpy(clp->cl_confirm.data, verf, sizeof(clp->cl_confirm.data));\n}"
  },
  {
    "function_name": "mach_creds_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1975-1991",
    "snippet": "static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cl->cl_cred.cr_principal",
            "cr->cr_principal"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cl->cl_cred.cr_raw_principal",
            "cr->cr_raw_principal"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_rqst_integrity_protected",
          "args": [
            "rqstp"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "svc_rqst_integrity_protected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1963-1973",
          "snippet": "static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\n\tif (!cl->cl_mach_cred)\n\t\treturn true;\n\tif (cl->cl_cred.cr_gss_mech != cr->cr_gss_mech)\n\t\treturn false;\n\tif (!svc_rqst_integrity_protected(rqstp))\n\t\treturn false;\n\tif (cl->cl_cred.cr_raw_principal)\n\t\treturn 0 == strcmp(cl->cl_cred.cr_raw_principal,\n\t\t\t\t\t\tcr->cr_raw_principal);\n\tif (!cr->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cl->cl_cred.cr_principal, cr->cr_principal);\n}"
  },
  {
    "function_name": "svc_rqst_integrity_protected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1963-1973",
    "snippet": "static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_pseudoflavor_to_service",
          "args": [
            "cr->cr_gss_mech",
            "cr->cr_flavor"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)\n{\n\tstruct svc_cred *cr = &rqstp->rq_cred;\n\tu32 service;\n\n\tif (!cr->cr_gss_mech)\n\t\treturn false;\n\tservice = gss_pseudoflavor_to_service(cr->cr_gss_mech, cr->cr_flavor);\n\treturn service == RPC_GSS_SVC_INTEGRITY ||\n\t       service == RPC_GSS_SVC_PRIVACY;\n}"
  },
  {
    "function_name": "same_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1948-1961",
    "snippet": "static bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cr1->cr_principal",
            "cr2->cr_principal"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groups_equal",
          "args": [
            "cr1->cr_group_info",
            "cr2->cr_group_info"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "groups_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1920-1930",
          "snippet": "static bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "cr1->cr_gid",
            "cr2->cr_gid"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cr1->cr_uid",
            "cr2->cr_uid"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_gss_cred",
          "args": [
            "cr2"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "is_gss_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1941-1945",
          "snippet": "static bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool\nsame_creds(struct svc_cred *cr1, struct svc_cred *cr2)\n{\n\tif ((is_gss_cred(cr1) != is_gss_cred(cr2))\n\t\t|| (!uid_eq(cr1->cr_uid, cr2->cr_uid))\n\t\t|| (!gid_eq(cr1->cr_gid, cr2->cr_gid))\n\t\t|| !groups_equal(cr1->cr_group_info, cr2->cr_group_info))\n\t\treturn false;\n\tif (cr1->cr_principal == cr2->cr_principal)\n\t\treturn true;\n\tif (!cr1->cr_principal || !cr2->cr_principal)\n\t\treturn false;\n\treturn 0 == strcmp(cr1->cr_principal, cr2->cr_principal);\n}"
  },
  {
    "function_name": "is_gss_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1941-1945",
    "snippet": "static bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_gss_cred(struct svc_cred *cr)\n{\n\t/* Is cr_flavor one of the gss \"pseudoflavors\"?: */\n\treturn (cr->cr_flavor > RPC_AUTH_MAXFLAVOR);\n}"
  },
  {
    "function_name": "groups_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1920-1930",
    "snippet": "static bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "GROUP_AT(g1, i)",
            "GROUP_AT(g2, i)"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GROUP_AT",
          "args": [
            "g2",
            "i"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GROUP_AT",
          "args": [
            "g1",
            "i"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool groups_equal(struct group_info *g1, struct group_info *g2)\n{\n\tint i;\n\n\tif (g1->ngroups != g2->ngroups)\n\t\treturn false;\n\tfor (i=0; i<g1->ngroups; i++)\n\t\tif (!gid_eq(GROUP_AT(g1, i), GROUP_AT(g2, i)))\n\t\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "same_clid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1914-1918",
    "snippet": "static int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_clid(clientid_t *cl1, clientid_t *cl2)\n{\n\treturn (cl1->cl_boot == cl2->cl_boot) && (cl1->cl_id == cl2->cl_id);\n}"
  },
  {
    "function_name": "same_verf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1908-1912",
    "snippet": "static int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "v1->data",
            "v2->data",
            "sizeof(v1->data)"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_verf(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn 0 == memcmp(v1->data, v2->data, sizeof(v1->data));\n}"
  },
  {
    "function_name": "same_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1903-1906",
    "snippet": "static int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "n1",
            "n2",
            "HEXDIR_LEN"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int same_name(const char *n1, const char *n2)\n{\n\treturn 0 == memcmp(n1, n2, HEXDIR_LEN);\n}"
  },
  {
    "function_name": "compare_blob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1893-1901",
    "snippet": "static int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "o1->data",
            "o2->data",
            "o1->len"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\ncompare_blob(const struct xdr_netobj *o1, const struct xdr_netobj *o2)\n{\n\tif (o1->len < o2->len)\n\t\treturn -1;\n\tif (o1->len > o2->len)\n\t\treturn 1;\n\treturn memcmp(o1->data, o2->data, o1->len);\n}"
  },
  {
    "function_name": "copy_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1871-1891",
    "snippet": "static int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tint ret;\n\n\tret = strdup_if_nonnull(&target->cr_principal, source->cr_principal);\n\tif (ret)\n\t\treturn ret;\n\tret = strdup_if_nonnull(&target->cr_raw_principal,\n\t\t\t\t\tsource->cr_raw_principal);\n\tif (ret)\n\t\treturn ret;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_mech_get",
          "args": [
            "source->cr_gss_mech"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "target->cr_group_info"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup_if_nonnull",
          "args": [
            "&target->cr_raw_principal",
            "source->cr_raw_principal"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "strdup_if_nonnull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1860-1869",
          "snippet": "int strdup_if_nonnull(char **target, char *source)\n{\n\tif (source) {\n\t\t*target = kstrdup(source, GFP_KERNEL);\n\t\tif (!*target)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\t*target = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nint strdup_if_nonnull(char **target, char *source)\n{\n\tif (source) {\n\t\t*target = kstrdup(source, GFP_KERNEL);\n\t\tif (!*target)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\t*target = NULL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int copy_cred(struct svc_cred *target, struct svc_cred *source)\n{\n\tint ret;\n\n\tret = strdup_if_nonnull(&target->cr_principal, source->cr_principal);\n\tif (ret)\n\t\treturn ret;\n\tret = strdup_if_nonnull(&target->cr_raw_principal,\n\t\t\t\t\tsource->cr_raw_principal);\n\tif (ret)\n\t\treturn ret;\n\ttarget->cr_flavor = source->cr_flavor;\n\ttarget->cr_uid = source->cr_uid;\n\ttarget->cr_gid = source->cr_gid;\n\ttarget->cr_group_info = source->cr_group_info;\n\tget_group_info(target->cr_group_info);\n\ttarget->cr_gss_mech = source->cr_gss_mech;\n\tif (source->cr_gss_mech)\n\t\tgss_mech_get(source->cr_gss_mech);\n\treturn 0;\n}"
  },
  {
    "function_name": "strdup_if_nonnull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1860-1869",
    "snippet": "int strdup_if_nonnull(char **target, char *source)\n{\n\tif (source) {\n\t\t*target = kstrdup(source, GFP_KERNEL);\n\t\tif (!*target)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\t*target = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "source",
            "GFP_KERNEL"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nint strdup_if_nonnull(char **target, char *source)\n{\n\tif (source) {\n\t\t*target = kstrdup(source, GFP_KERNEL);\n\t\tif (!*target)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\t*target = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_clid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1854-1858",
    "snippet": "static void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_clid(struct nfs4_client *target, struct nfs4_client *source)\n{\n\ttarget->cl_clientid.cl_boot = source->cl_clientid.cl_boot; \n\ttarget->cl_clientid.cl_id = source->cl_clientid.cl_id; \n}"
  },
  {
    "function_name": "copy_verf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1848-1852",
    "snippet": "static void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target->cl_verifier.data",
            "source->data",
            "sizeof(target->cl_verifier.data)"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void copy_verf(struct nfs4_client *target, nfs4_verifier *source)\n{\n\tmemcpy(target->cl_verifier.data, source->data,\n\t\t\tsizeof(target->cl_verifier.data));\n}"
  },
  {
    "function_name": "expire_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1841-1846",
    "snippet": "static void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__destroy_client",
          "args": [
            "clp"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1795-1832",
          "snippet": "static void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_client_record_remove",
          "args": [
            "clp"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_record_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1482-1489",
          "snippet": "void\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client",
          "args": [
            "clp"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1777-1785",
          "snippet": "static void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void expire_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\tnfsd4_client_record_remove(clp);\n\t__destroy_client(clp);\n}"
  },
  {
    "function_name": "destroy_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1834-1839",
    "snippet": "static void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__destroy_client",
          "args": [
            "clp"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1795-1832",
          "snippet": "static void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_client",
          "args": [
            "clp"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1777-1785",
          "snippet": "static void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\ndestroy_client(struct nfs4_client *clp)\n{\n\tunhash_client(clp);\n\t__destroy_client(clp);\n}"
  },
  {
    "function_name": "__destroy_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1795-1832",
    "snippet": "static void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_client",
          "args": [
            "clp"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "free_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1732-1749",
          "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svc_xprt_put",
          "args": [
            "clp->cl_cb_conn.cb_xprt"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_shutdown_callback",
          "args": [
            "clp"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_shutdown_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1020-1030",
          "snippet": "void nfsd4_shutdown_callback(struct nfs4_client *clp)\n{\n\tset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\n\t/*\n\t * Note this won't actually result in a null callback;\n\t * instead, nfsd4_run_cb_null() will detect the killed\n\t * client, destroy the rpc client, and stop:\n\t */\n\tnfsd4_run_cb(&clp->cl_cb_null);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_shutdown_callback(struct nfs4_client *clp)\n{\n\tset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\n\t/*\n\t * Note this won't actually result in a null callback;\n\t * instead, nfsd4_run_cb_null() will detect the killed\n\t * client, destroy the rpc client, and stop:\n\t */\n\tnfsd4_run_cb(&clp->cl_cb_null);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_client_layouts",
          "args": [
            "clp"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "567-579",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_openowner",
          "args": [
            "oo"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "release_openowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1289-1309",
          "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_openowners.next",
            "structnfs4_openowner",
            "oo_perclient"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_openowners"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_revoked.next",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_revoked"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "761-774",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_clnt_odstate",
          "args": [
            "dp->dl_clnt_odstate"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "put_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "512-528",
          "snippet": "static void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *odstate_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "reaplist.next",
            "structnfs4_delegation",
            "dl_recall_lru"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&reaplist"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&reaplist"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!unhash_delegation_locked(dp)"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "845-864",
          "snippet": "static bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_delegations.next",
            "structnfs4_delegation",
            "dl_perclnt"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_delegations"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void\n__destroy_client(struct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\tstruct nfs4_delegation *dp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\tspin_lock(&state_lock);\n\twhile (!list_empty(&clp->cl_delegations)) {\n\t\tdp = list_entry(clp->cl_delegations.next, struct nfs4_delegation, dl_perclnt);\n\t\tWARN_ON(!unhash_delegation_locked(dp));\n\t\tlist_add(&dp->dl_recall_lru, &reaplist);\n\t}\n\tspin_unlock(&state_lock);\n\twhile (!list_empty(&reaplist)) {\n\t\tdp = list_entry(reaplist.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_revoked)) {\n\t\tdp = list_entry(clp->cl_revoked.next, struct nfs4_delegation, dl_recall_lru);\n\t\tlist_del_init(&dp->dl_recall_lru);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n\twhile (!list_empty(&clp->cl_openowners)) {\n\t\too = list_entry(clp->cl_openowners.next, struct nfs4_openowner, oo_perclient);\n\t\tnfs4_get_stateowner(&oo->oo_owner);\n\t\trelease_openowner(oo);\n\t}\n\tnfsd4_return_all_client_layouts(clp);\n\tnfsd4_shutdown_callback(clp);\n\tif (clp->cl_cb_conn.cb_xprt)\n\t\tsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\n\tfree_client(clp);\n}"
  },
  {
    "function_name": "mark_client_expired_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1787-1793",
    "snippet": "static __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "clp"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1752-1775",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 mark_client_expired_locked(struct nfs4_client *clp)\n{\n\tif (atomic_read(&clp->cl_refcount))\n\t\treturn nfserr_jukebox;\n\tunhash_client_locked(clp);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "unhash_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1777-1785",
    "snippet": "static void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_client_locked",
          "args": [
            "clp"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1752-1775",
          "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nunhash_client(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tunhash_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
  },
  {
    "function_name": "unhash_client_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1752-1775",
    "snippet": "static void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ses->se_hash"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ses",
            "&clp->cl_sessions",
            "se_perclnt"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&clp->cl_lru"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&clp->cl_namenode",
            "&nn->unconf_name_tree"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&clp->cl_namenode",
            "&nn->conf_name_tree"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_CONFIRMED",
            "&clp->cl_flags"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&clp->cl_idhash"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_idhash"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct nfsd4_session *ses;\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\t/* Mark the client as expired! */\n\tclp->cl_time = 0;\n\t/* Make it invisible */\n\tif (!list_empty(&clp->cl_idhash)) {\n\t\tlist_del_init(&clp->cl_idhash);\n\t\tif (test_bit(NFSD4_CLIENT_CONFIRMED, &clp->cl_flags))\n\t\t\trb_erase(&clp->cl_namenode, &nn->conf_name_tree);\n\t\telse\n\t\t\trb_erase(&clp->cl_namenode, &nn->unconf_name_tree);\n\t}\n\tlist_del_init(&clp->cl_lru);\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry(ses, &clp->cl_sessions, se_perclnt)\n\t\tlist_del_init(&ses->se_hash);\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "free_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1732-1749",
    "snippet": "static void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&clp->cl_stateids"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp->cl_name.data"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp->cl_ownerstr_hashtbl"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_svc_cred",
          "args": [
            "&clp->cl_cred"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_destroy_wait_queue",
          "args": [
            "&clp->cl_cb_waitq"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_session",
          "args": [
            "ses"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1572-1577",
          "snippet": "static void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&ses->se_ref)"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ses->se_ref"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ses->se_perclnt"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clp->cl_sessions.next",
            "structnfsd4_session",
            "se_perclnt"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clp->cl_sessions"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_client(struct nfs4_client *clp)\n{\n\twhile (!list_empty(&clp->cl_sessions)) {\n\t\tstruct nfsd4_session *ses;\n\t\tses = list_entry(clp->cl_sessions.next, struct nfsd4_session,\n\t\t\t\tse_perclnt);\n\t\tlist_del(&ses->se_perclnt);\n\t\tWARN_ON_ONCE(atomic_read(&ses->se_ref));\n\t\tfree_session(ses);\n\t}\n\trpc_destroy_wait_queue(&clp->cl_cb_waitq);\n\tfree_svc_cred(&clp->cl_cred);\n\tkfree(clp->cl_ownerstr_hashtbl);\n\tkfree(clp->cl_name.data);\n\tidr_destroy(&clp->cl_stateids);\n\tkfree(clp);\n}"
  },
  {
    "function_name": "alloc_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1692-1730",
    "snippet": "static struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "clp->cl_name.data"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_init_wait_queue",
          "args": [
            "&clp->cl_cb_waitq",
            "\"Backchannel slot table\""
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_lo_states"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_revoked"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_lru"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_delegations"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_openowners"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_idhash"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&clp->cl_refcount",
            "0"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&clp->cl_stateids"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_sessions"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&clp->cl_ownerstr_hashtbl[i]"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "name.data",
            "name.len",
            "GFP_KERNEL"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct nfs4_client)",
            "GFP_KERNEL"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_SIZE             (1 << OWNER_HASH_BITS)\n\nstatic struct nfs4_client *alloc_client(struct xdr_netobj name)\n{\n\tstruct nfs4_client *clp;\n\tint i;\n\n\tclp = kzalloc(sizeof(struct nfs4_client), GFP_KERNEL);\n\tif (clp == NULL)\n\t\treturn NULL;\n\tclp->cl_name.data = kmemdup(name.data, name.len, GFP_KERNEL);\n\tif (clp->cl_name.data == NULL)\n\t\tgoto err_no_name;\n\tclp->cl_ownerstr_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\tOWNER_HASH_SIZE, GFP_KERNEL);\n\tif (!clp->cl_ownerstr_hashtbl)\n\t\tgoto err_no_hashtbl;\n\tfor (i = 0; i < OWNER_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&clp->cl_ownerstr_hashtbl[i]);\n\tclp->cl_name.len = name.len;\n\tINIT_LIST_HEAD(&clp->cl_sessions);\n\tidr_init(&clp->cl_stateids);\n\tatomic_set(&clp->cl_refcount, 0);\n\tclp->cl_cb_state = NFSD4_CB_UNKNOWN;\n\tINIT_LIST_HEAD(&clp->cl_idhash);\n\tINIT_LIST_HEAD(&clp->cl_openowners);\n\tINIT_LIST_HEAD(&clp->cl_delegations);\n\tINIT_LIST_HEAD(&clp->cl_lru);\n\tINIT_LIST_HEAD(&clp->cl_revoked);\n#ifdef CONFIG_NFSD_PNFS\n\tINIT_LIST_HEAD(&clp->cl_lo_states);\n#endif\n\tspin_lock_init(&clp->cl_lock);\n\trpc_init_wait_queue(&clp->cl_cb_waitq, \"Backchannel slot table\");\n\treturn clp;\nerr_no_hashtbl:\n\tkfree(clp->cl_name.data);\nerr_no_name:\n\tkfree(clp);\n\treturn NULL;\n}"
  },
  {
    "function_name": "STALE_CLIENTID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1672-1685",
    "snippet": "static int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\"",
            "clid->cl_boot",
            "clid->cl_id",
            "nn->boot_time"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nSTALE_CLIENTID(clientid_t *clid, struct nfsd_net *nn)\n{\n\t/*\n\t * We're assuming the clid was not given out from a boot\n\t * precisely 2^32 (about 136 years) before this one.  That seems\n\t * a safe assumption:\n\t */\n\tif (clid->cl_boot == (u32)nn->boot_time)\n\t\treturn 0;\n\tdprintk(\"NFSD stale clientid (%08x/%08x) boot_time %08lx\\n\",\n\t\tclid->cl_boot, clid->cl_id, nn->boot_time);\n\treturn 1;\n}"
  },
  {
    "function_name": "unhash_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1657-1669",
    "snippet": "static void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ses->se_client->cl_lock"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ses->se_perclnt"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ses->se_client->cl_lock"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ses->se_hash"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nunhash_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tlist_del(&ses->se_hash);\n\tspin_lock(&ses->se_client->cl_lock);\n\tlist_del(&ses->se_perclnt);\n\tspin_unlock(&ses->se_client->cl_lock);\n}"
  },
  {
    "function_name": "find_in_sessionid_hashtbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1638-1654",
    "snippet": "static struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_get_session_locked",
          "args": [
            "session"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_get_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "178-189",
          "snippet": "static __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_in_sessionid_hashtbl",
          "args": [
            "sessionid",
            "net"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "__find_in_sessionid_hashtbl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1615-1636",
          "snippet": "static struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\nfind_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net,\n\t\t__be32 *ret)\n{\n\tstruct nfsd4_session *session;\n\t__be32 status = nfserr_badsession;\n\n\tsession = __find_in_sessionid_hashtbl(sessionid, net);\n\tif (!session)\n\t\tgoto out;\n\tstatus = nfsd4_get_session_locked(session);\n\tif (status)\n\t\tsession = NULL;\nout:\n\t*ret = status;\n\treturn session;\n}"
  },
  {
    "function_name": "__find_in_sessionid_hashtbl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1615-1636",
    "snippet": "static struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: session not found\\n\"",
            "__func__"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "elem->se_sessionid.data",
            "sessionid->data",
            "NFS4_MAX_SESSIONID_LEN"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "elem",
            "&nn->sessionid_hashtbl[idx]",
            "se_hash"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_sessionid",
          "args": [
            "sessionid"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "hash_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1311-1317",
          "snippet": "static inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_sessionid",
          "args": [
            "__func__",
            "sessionid"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "dump_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1327-1330",
          "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *\n__find_in_sessionid_hashtbl(struct nfs4_sessionid *sessionid, struct net *net)\n{\n\tstruct nfsd4_session *elem;\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tdump_sessionid(__func__, sessionid);\n\tidx = hash_sessionid(sessionid);\n\t/* Search in the appropriate list */\n\tlist_for_each_entry(elem, &nn->sessionid_hashtbl[idx], se_hash) {\n\t\tif (!memcmp(elem->se_sessionid.data, sessionid->data,\n\t\t\t    NFS4_MAX_SESSIONID_LEN)) {\n\t\t\treturn elem;\n\t\t}\n\t}\n\n\tdprintk(\"%s: session not found\\n\", __func__);\n\treturn NULL;\n}"
  },
  {
    "function_name": "init_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1579-1612",
    "snippet": "static void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_addr_len",
          "args": [
            "sa"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_copy_addr",
          "args": [
            "(struct sockaddr *)&clp->cl_cb_conn.cb_addr",
            "sa"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_addr",
          "args": [
            "rqstp"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->se_perclnt",
            "&clp->cl_sessions"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->se_hash",
            "&nn->sessionid_hashtbl[idx]"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_sessionid",
          "args": [
            "&new->se_sessionid"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "hash_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1311-1317",
          "snippet": "static inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->se_ref",
            "0"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new->se_conns"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_sessionid",
          "args": [
            "new"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "gen_sessionid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1356-1366",
          "snippet": "static void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 current_sessionid = 1;",
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 current_sessionid = 1;\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "SVC_NET(rqstp)",
            "nfsd_net_id"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVC_NET",
          "args": [
            "rqstp"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void init_session(struct svc_rqst *rqstp, struct nfsd4_session *new, struct nfs4_client *clp, struct nfsd4_create_session *cses)\n{\n\tint idx;\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tnew->se_client = clp;\n\tgen_sessionid(new);\n\n\tINIT_LIST_HEAD(&new->se_conns);\n\n\tnew->se_cb_seq_nr = 1;\n\tnew->se_flags = cses->flags;\n\tnew->se_cb_prog = cses->callback_prog;\n\tnew->se_cb_sec = cses->cb_sec;\n\tatomic_set(&new->se_ref, 0);\n\tidx = hash_sessionid(&new->se_sessionid);\n\tlist_add(&new->se_hash, &nn->sessionid_hashtbl[idx]);\n\tspin_lock(&clp->cl_lock);\n\tlist_add(&new->se_perclnt, &clp->cl_sessions);\n\tspin_unlock(&clp->cl_lock);\n\n\t{\n\t\tstruct sockaddr *sa = svc_addr(rqstp);\n\t\t/*\n\t\t * This is a little silly; with sessions there's no real\n\t\t * use for the callback address.  Use the peer address\n\t\t * as a reasonable default for now, but consider fixing\n\t\t * the rpc client not to require an address in the\n\t\t * future:\n\t\t */\n\t\trpc_copy_addr((struct sockaddr *)&clp->cl_cb_conn.cb_addr, sa);\n\t\tclp->cl_cb_conn.cb_addrlen = svc_addr_len(sa);\n\t}\n}"
  },
  {
    "function_name": "free_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1572-1577",
    "snippet": "static void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_session",
          "args": [
            "ses"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "__free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1566-1570",
          "snippet": "static void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_put_drc_mem",
          "args": [
            "&ses->se_fchannel"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_drc_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1427-1434",
          "snippet": "static void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_del_conns",
          "args": [
            "ses"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_del_conns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1547-1564",
          "snippet": "static void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}"
  },
  {
    "function_name": "__free_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1566-1570",
    "snippet": "static void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_session_slots",
          "args": [
            "ses"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "free_session_slots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1382-1389",
          "snippet": "static void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __free_session(struct nfsd4_session *ses)\n{\n\tfree_session_slots(ses);\n\tkfree(ses);\n}"
  },
  {
    "function_name": "nfsd4_del_conns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1547-1564",
    "snippet": "static void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "c"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1469-1473",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_xpt_user",
          "args": [
            "c->cn_xprt",
            "&c->cn_xpt_user"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&c->cn_persession"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&s->se_conns",
            "structnfsd4_conn",
            "cn_persession"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&s->se_conns"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_del_conns(struct nfsd4_session *s)\n{\n\tstruct nfs4_client *clp = s->se_client;\n\tstruct nfsd4_conn *c;\n\n\tspin_lock(&clp->cl_lock);\n\twhile (!list_empty(&s->se_conns)) {\n\t\tc = list_first_entry(&s->se_conns, struct nfsd4_conn, cn_persession);\n\t\tlist_del_init(&c->cn_persession);\n\t\tspin_unlock(&clp->cl_lock);\n\n\t\tunregister_xpt_user(c->cn_xprt, &c->cn_xpt_user);\n\t\tfree_conn(c);\n\n\t\tspin_lock(&clp->cl_lock);\n\t}\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "alloc_conn_from_crses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1537-1544",
    "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_conn",
          "args": [
            "rqstp",
            "dir"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_conn_from_crses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1537-1544",
          "snippet": "static struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn_from_crses(struct svc_rqst *rqstp, struct nfsd4_create_session *cses)\n{\n\tu32 dir = NFS4_CDFC4_FORE;\n\n\tif (cses->flags & SESSION4_BACK_CHAN)\n\t\tdir |= NFS4_CDFC4_BACK;\n\treturn alloc_conn(rqstp, dir);\n}"
  },
  {
    "function_name": "nfsd4_init_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1524-1535",
    "snippet": "static void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_probe_callback_sync",
          "args": [
            "ses->se_client"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "822-826",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_conn_lost",
          "args": [
            "&conn->cn_xpt_user"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_conn_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1475-1487",
          "snippet": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_register_conn",
          "args": [
            "conn"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_register_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1518-1522",
          "snippet": "static int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_hash_conn",
          "args": [
            "conn",
            "ses"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_hash_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1509-1516",
          "snippet": "static void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_init_conn(struct svc_rqst *rqstp, struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tint ret;\n\n\tnfsd4_hash_conn(conn, ses);\n\tret = nfsd4_register_conn(conn);\n\tif (ret)\n\t\t/* oops; xprt is already down: */\n\t\tnfsd4_conn_lost(&conn->cn_xpt_user);\n\t/* We may have gained or lost a callback channel: */\n\tnfsd4_probe_callback_sync(ses->se_client);\n}"
  },
  {
    "function_name": "nfsd4_register_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1518-1522",
    "snippet": "static int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_xpt_user",
          "args": [
            "conn->cn_xprt",
            "&conn->cn_xpt_user"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfsd4_register_conn(struct nfsd4_conn *conn)\n{\n\tconn->cn_xpt_user.callback = nfsd4_conn_lost;\n\treturn register_xpt_user(conn->cn_xprt, &conn->cn_xpt_user);\n}"
  },
  {
    "function_name": "nfsd4_hash_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1509-1516",
    "snippet": "static void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfsd4_hash_conn",
          "args": [
            "conn",
            "ses"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "__nfsd4_hash_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1503-1507",
          "snippet": "static void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\t__nfsd4_hash_conn(conn, ses);\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "__nfsd4_hash_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1503-1507",
    "snippet": "static void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&conn->cn_persession",
            "&ses->se_conns"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void __nfsd4_hash_conn(struct nfsd4_conn *conn, struct nfsd4_session *ses)\n{\n\tconn->cn_session = ses;\n\tlist_add(&conn->cn_persession, &ses->se_conns);\n}"
  },
  {
    "function_name": "alloc_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1489-1501",
    "snippet": "static struct nfsd4_conn *alloc_conn(struct svc_rqst *rqstp, u32 flags)\n{\n\tstruct nfsd4_conn *conn;\n\n\tconn = kmalloc(sizeof(struct nfsd4_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\tsvc_xprt_get(rqstp->rq_xprt);\n\tconn->cn_xprt = rqstp->rq_xprt;\n\tconn->cn_flags = flags;\n\tINIT_LIST_HEAD(&conn->cn_xpt_user.list);\n\treturn conn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&conn->cn_xpt_user.list"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_xprt_get",
          "args": [
            "rqstp->rq_xprt"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nfsd4_conn)",
            "GFP_KERNEL"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_conn *alloc_conn(struct svc_rqst *rqstp, u32 flags)\n{\n\tstruct nfsd4_conn *conn;\n\n\tconn = kmalloc(sizeof(struct nfsd4_conn), GFP_KERNEL);\n\tif (!conn)\n\t\treturn NULL;\n\tsvc_xprt_get(rqstp->rq_xprt);\n\tconn->cn_xprt = rqstp->rq_xprt;\n\tconn->cn_flags = flags;\n\tINIT_LIST_HEAD(&conn->cn_xpt_user.list);\n\treturn conn;\n}"
  },
  {
    "function_name": "nfsd4_conn_lost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1475-1487",
    "snippet": "static void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_probe_callback",
          "args": [
            "clp"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_probe_callback_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "822-826",
          "snippet": "void nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *callback_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct workqueue_struct *callback_wq;\n\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\n{\n\tnfsd4_probe_callback(clp);\n\tflush_workqueue(callback_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_conn",
          "args": [
            "c"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "free_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1469-1473",
          "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&c->cn_persession"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&c->cn_persession"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "u",
            "structnfsd4_conn",
            "cn_xpt_user"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_conn_lost(struct svc_xpt_user *u)\n{\n\tstruct nfsd4_conn *c = container_of(u, struct nfsd4_conn, cn_xpt_user);\n\tstruct nfs4_client *clp = c->cn_session->se_client;\n\n\tspin_lock(&clp->cl_lock);\n\tif (!list_empty(&c->cn_persession)) {\n\t\tlist_del(&c->cn_persession);\n\t\tfree_conn(c);\n\t}\n\tnfsd4_probe_callback(clp);\n\tspin_unlock(&clp->cl_lock);\n}"
  },
  {
    "function_name": "free_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1469-1473",
    "snippet": "static void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "c"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_xprt_put",
          "args": [
            "c->cn_xprt"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_conn(struct nfsd4_conn *c)\n{\n\tsvc_xprt_put(c->cn_xprt);\n\tkfree(c);\n}"
  },
  {
    "function_name": "alloc_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1436-1467",
    "snippet": "static struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new->se_slots[i]"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->se_bchannel",
            "battrs",
            "sizeof(struct nfsd4_channel_attrs)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&new->se_fchannel",
            "fattrs",
            "sizeof(struct nfsd4_channel_attrs)"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "slotsize",
            "GFP_KERNEL"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new) + mem",
            "GFP_KERNEL"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_bytes",
          "args": [
            "fattrs"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "slot_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1395-1404",
          "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic struct nfsd4_session *alloc_session(struct nfsd4_channel_attrs *fattrs,\n\t\t\t\t\t   struct nfsd4_channel_attrs *battrs)\n{\n\tint numslots = fattrs->maxreqs;\n\tint slotsize = slot_bytes(fattrs);\n\tstruct nfsd4_session *new;\n\tint mem, i;\n\n\tBUILD_BUG_ON(NFSD_MAX_SLOTS_PER_SESSION * sizeof(struct nfsd4_slot *)\n\t\t\t+ sizeof(struct nfsd4_session) > PAGE_SIZE);\n\tmem = numslots * sizeof(struct nfsd4_slot *);\n\n\tnew = kzalloc(sizeof(*new) + mem, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\t/* allocate each struct nfsd4_slot and data cache in one piece */\n\tfor (i = 0; i < numslots; i++) {\n\t\tnew->se_slots[i] = kzalloc(slotsize, GFP_KERNEL);\n\t\tif (!new->se_slots[i])\n\t\t\tgoto out_free;\n\t}\n\n\tmemcpy(&new->se_fchannel, fattrs, sizeof(struct nfsd4_channel_attrs));\n\tmemcpy(&new->se_bchannel, battrs, sizeof(struct nfsd4_channel_attrs));\n\n\treturn new;\nout_free:\n\twhile (i--)\n\t\tkfree(new->se_slots[i]);\n\tkfree(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "nfsd4_put_drc_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1427-1434",
    "snippet": "static void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_bytes",
          "args": [
            "ca"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "slot_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1395-1404",
          "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfsd4_put_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tint slotsize = slot_bytes(ca);\n\n\tspin_lock(&nfsd_drc_lock);\n\tnfsd_drc_mem_used -= slotsize * ca->maxreqs;\n\tspin_unlock(&nfsd_drc_lock);\n}"
  },
  {
    "function_name": "nfsd4_get_drc_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1411-1425",
    "snippet": "static u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "num",
            "avail / slotsize"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(unsigned long)NFSD_MAX_MEM_PER_SESSION",
            "nfsd_drc_max_mem - nfsd_drc_mem_used"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_minorversion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfssvc.c",
          "lines": "156-173",
          "snippet": "int nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"cache.h\"",
            "#include \"nfsd.h\"",
            "#include <net/net_namespace.h>",
            "#include <net/ipv6.h>",
            "#include <net/addrconf.h>",
            "#include <linux/inetdevice.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/nfsacl.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/svcsock.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/swap.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/module.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"cache.h\"\n#include \"nfsd.h\"\n#include <net/net_namespace.h>\n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/inetdevice.h>\n#include <linux/seq_file.h>\n#include <linux/nfsacl.h>\n#include <linux/lockd/bind.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/svcsock.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/swap.h>\n#include <linux/fs_struct.h>\n#include <linux/module.h>\n#include <linux/freezer.h>\n#include <linux/sched.h>\n\nint nfsd_minorversion(u32 minorversion, enum vers_op change)\n{\n\tif (minorversion > NFSD_SUPPORTED_MINOR_VERSION)\n\t\treturn -1;\n\tswitch(change) {\n\tcase NFSD_SET:\n\t\tnfsd_supported_minorversions[minorversion] = true;\n\t\tbreak;\n\tcase NFSD_CLEAR:\n\t\tnfsd_supported_minorversions[minorversion] = false;\n\t\tbreak;\n\tcase NFSD_TEST:\n\t\treturn nfsd_supported_minorversions[minorversion];\n\tcase NFSD_AVAIL:\n\t\treturn minorversion <= NFSD_SUPPORTED_MINOR_VERSION;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nfsd_drc_lock"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_bytes",
          "args": [
            "ca"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "slot_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1395-1404",
          "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u32 nfsd4_get_drc_mem(struct nfsd4_channel_attrs *ca)\n{\n\tu32 slotsize = slot_bytes(ca);\n\tu32 num = ca->maxreqs;\n\tint avail;\n\n\tspin_lock(&nfsd_drc_lock);\n\tavail = min((unsigned long)NFSD_MAX_MEM_PER_SESSION,\n\t\t    nfsd_drc_max_mem - nfsd_drc_mem_used);\n\tnum = min_t(int, num, avail / slotsize);\n\tnfsd_drc_mem_used += num * slotsize;\n\tspin_unlock(&nfsd_drc_lock);\n\n\treturn num;\n}"
  },
  {
    "function_name": "slot_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1395-1404",
    "snippet": "static inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define NFSD_MIN_HDR_SEQ_SZ  (24 + 12 + 44)\n\nstatic inline u32 slot_bytes(struct nfsd4_channel_attrs *ca)\n{\n\tu32 size;\n\n\tif (ca->maxresp_cached < NFSD_MIN_HDR_SEQ_SZ)\n\t\tsize = 0;\n\telse\n\t\tsize = ca->maxresp_cached - NFSD_MIN_HDR_SEQ_SZ;\n\treturn size + sizeof(struct nfsd4_slot);\n}"
  },
  {
    "function_name": "free_session_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1382-1389",
    "snippet": "static void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ses->se_slots[i]"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\nfree_session_slots(struct nfsd4_session *ses)\n{\n\tint i;\n\n\tfor (i = 0; i < ses->se_fchannel.maxreqs; i++)\n\t\tkfree(ses->se_slots[i]);\n}"
  },
  {
    "function_name": "gen_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1356-1366",
    "snippet": "static void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 current_sessionid = 1;",
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic u64 current_sessionid = 1;\nstatic void free_session(struct nfsd4_session *);\n\nstatic void\ngen_sessionid(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd4_sessionid *sid;\n\n\tsid = (struct nfsd4_sessionid *)ses->se_sessionid.data;\n\tsid->clientid = clp->cl_clientid;\n\tsid->sequence = current_sessionid++;\n\tsid->reserved = 0;\n}"
  },
  {
    "function_name": "nfsd4_bump_seqid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1337-1354",
    "snippet": "void nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_last_closed_stateid",
          "args": [
            "openowner(so)"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "release_last_closed_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1272-1287",
          "snippet": "static void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "so"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cstate_clear_replay",
          "args": [
            "cstate"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cstate_clear_replay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "3371-3380",
          "snippet": "void nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_cstate_clear_replay(struct nfsd4_compound_state *cstate)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (so != NULL) {\n\t\tcstate->replay_owner = NULL;\n\t\tmutex_unlock(&so->so_replay.rp_mutex);\n\t\tnfs4_put_stateowner(so);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seqid_mutating_err",
          "args": [
            "ntohl(nfserr)"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "nfserr"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfsd4_bump_seqid(struct nfsd4_compound_state *cstate, __be32 nfserr)\n{\n\tstruct nfs4_stateowner *so = cstate->replay_owner;\n\n\tif (nfserr == nfserr_replay_me)\n\t\treturn;\n\n\tif (!seqid_mutating_err(ntohl(nfserr))) {\n\t\tnfsd4_cstate_clear_replay(cstate);\n\t\treturn;\n\t}\n\tif (!so)\n\t\treturn;\n\tif (so->so_is_open_owner)\n\t\trelease_last_closed_stateid(openowner(so));\n\tso->so_seqid++;\n\treturn;\n}"
  },
  {
    "function_name": "dump_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1327-1330",
    "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n}"
  },
  {
    "function_name": "dump_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1320-1325",
    "snippet": "static inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n\tu32 *ptr = (u32 *)(&sessionid->data[0]);\n\tdprintk(\"%s: %u:%u:%u:%u\\n\", fn, ptr[0], ptr[1], ptr[2], ptr[3]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: %u:%u:%u:%u\\n\"",
            "fn",
            "ptr[0]",
            "ptr[1]",
            "ptr[2]",
            "ptr[3]"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\ndump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)\n{\n\tu32 *ptr = (u32 *)(&sessionid->data[0]);\n\tdprintk(\"%s: %u:%u:%u:%u\\n\", fn, ptr[0], ptr[1], ptr[2], ptr[3]);\n}"
  },
  {
    "function_name": "hash_sessionid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1311-1317",
    "snippet": "static inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline int\nhash_sessionid(struct nfs4_sessionid *sessionid)\n{\n\tstruct nfsd4_sessionid *sid = (struct nfsd4_sessionid *)sessionid;\n\n\treturn sid->sequence % SESSION_HASH_SIZE;\n}"
  },
  {
    "function_name": "release_openowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1289-1309",
    "snippet": "static void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&oo->oo_owner"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_last_closed_stateid",
          "args": [
            "oo"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "release_last_closed_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1272-1287",
          "snippet": "static void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1184-1201",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1129-1146",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_open_stateid",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1239-1249",
          "snippet": "static bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&oo->oo_owner.so_stateids",
            "structnfs4_ol_stateid",
            "st_perstateowner"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&oo->oo_owner.so_stateids"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_openowner_locked",
          "args": [
            "oo"
          ],
          "line": 1298
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_openowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1262-1270",
          "snippet": "static void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_openowner(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_openowner_locked(oo);\n\twhile (!list_empty(&oo->oo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&oo->oo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tif (unhash_open_stateid(stp, &reaplist))\n\t\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\trelease_last_closed_stateid(oo);\n\tnfs4_put_stateowner(&oo->oo_owner);\n}"
  },
  {
    "function_name": "release_last_closed_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1272-1287",
    "snippet": "static void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&s->st_stid"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_close_lru"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "oo->oo_owner.so_client->net",
            "nfsd_net_id"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_last_closed_stateid(struct nfs4_openowner *oo)\n{\n\tstruct nfsd_net *nn = net_generic(oo->oo_owner.so_client->net,\n\t\t\t\t\t  nfsd_net_id);\n\tstruct nfs4_ol_stateid *s;\n\n\tspin_lock(&nn->client_lock);\n\ts = oo->oo_last_closed_stid;\n\tif (s) {\n\t\tlist_del_init(&oo->oo_close_lru);\n\t\too->oo_last_closed_stid = NULL;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tif (s)\n\t\tnfs4_put_stid(&s->st_stid);\n}"
  },
  {
    "function_name": "unhash_openowner_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1262-1270",
    "snippet": "static void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_perclient"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&oo->oo_owner.so_strhash"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_openowner_locked(struct nfs4_openowner *oo)\n{\n\tstruct nfs4_client *clp = oo->oo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&oo->oo_owner.so_strhash);\n\tlist_del_init(&oo->oo_perclient);\n}"
  },
  {
    "function_name": "release_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1251-1260",
    "snippet": "static void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tif (unhash_open_stateid(stp, &reaplist))\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1184-1201",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&stp->st_stid.sc_client->cl_lock"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1129-1146",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_open_stateid",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_open_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1239-1249",
          "snippet": "static bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&stp->st_stid.sc_client->cl_lock"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "reaplist"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid(struct nfs4_ol_stateid *stp)\n{\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&stp->st_stid.sc_client->cl_lock);\n\tif (unhash_open_stateid(stp, &reaplist))\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\tspin_unlock(&stp->st_stid.sc_client->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n}"
  },
  {
    "function_name": "unhash_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1239-1249",
    "snippet": "static bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_open_stateid_locks",
          "args": [
            "stp",
            "reaplist"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "release_open_stateid_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1224-1237",
          "snippet": "static void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tlockdep_assert_held(&open_stp->st_stid.sc_client->cl_lock);\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tlockdep_assert_held(&open_stp->st_stid.sc_client->cl_lock);\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unhash_ol_stateid",
          "args": [
            "stp"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_ol_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1085-1099",
          "snippet": "static bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&stp->st_stid.sc_client->cl_lock"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_open_stateid(struct nfs4_ol_stateid *stp,\n\t\t\t\tstruct list_head *reaplist)\n{\n\tbool unhashed;\n\n\tlockdep_assert_held(&stp->st_stid.sc_client->cl_lock);\n\n\tunhashed = unhash_ol_stateid(stp);\n\trelease_open_stateid_locks(stp, reaplist);\n\treturn unhashed;\n}"
  },
  {
    "function_name": "release_open_stateid_locks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1224-1237",
    "snippet": "static void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tlockdep_assert_held(&open_stp->st_stid.sc_client->cl_lock);\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "reaplist"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1129-1146",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!unhash_lock_stateid(stp)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1148-1157",
          "snippet": "static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "open_stp->st_locks.next",
            "structnfs4_ol_stateid",
            "st_locks"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&open_stp->st_locks"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&open_stp->st_stid.sc_client->cl_lock"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tlockdep_assert_held(&open_stp->st_stid.sc_client->cl_lock);\n\n\twhile (!list_empty(&open_stp->st_locks)) {\n\t\tstp = list_entry(open_stp->st_locks.next,\n\t\t\t\tstruct nfs4_ol_stateid, st_locks);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, reaplist);\n\t}\n}"
  },
  {
    "function_name": "release_lockowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1203-1222",
    "snippet": "static void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "&lo->lo_owner"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_ol_stateid_reaplist",
          "args": [
            "&reaplist"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "free_ol_stateid_reaplist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1184-1201",
          "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_ol_stateid_locked",
          "args": [
            "stp",
            "&reaplist"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "put_ol_stateid_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1129-1146",
          "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!unhash_lock_stateid(stp)"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1148-1157",
          "snippet": "static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&lo->lo_owner.so_stateids",
            "structnfs4_ol_stateid",
            "st_perstateowner"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lo->lo_owner.so_stateids"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_lockowner_locked",
          "args": [
            "lo"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lockowner_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1171-1178",
          "snippet": "static void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&reaplist"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lockowner(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct list_head reaplist;\n\n\tINIT_LIST_HEAD(&reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tunhash_lockowner_locked(lo);\n\twhile (!list_empty(&lo->lo_owner.so_stateids)) {\n\t\tstp = list_first_entry(&lo->lo_owner.so_stateids,\n\t\t\t\tstruct nfs4_ol_stateid, st_perstateowner);\n\t\tWARN_ON(!unhash_lock_stateid(stp));\n\t\tput_ol_stateid_locked(stp, &reaplist);\n\t}\n\tspin_unlock(&clp->cl_lock);\n\tfree_ol_stateid_reaplist(&reaplist);\n\tnfs4_put_stateowner(&lo->lo_owner);\n}"
  },
  {
    "function_name": "free_ol_stateid_reaplist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1184-1201",
    "snippet": "static void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "277-289",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "stp->st_stid.sc_free",
          "args": [
            "&stp->st_stid"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&stp->st_locks"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "reaplist",
            "structnfs4_ol_stateid",
            "st_locks"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "reaplist"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nfree_ol_stateid_reaplist(struct list_head *reaplist)\n{\n\tstruct nfs4_ol_stateid *stp;\n\tstruct nfs4_file *fp;\n\n\tmight_sleep();\n\n\twhile (!list_empty(reaplist)) {\n\t\tstp = list_first_entry(reaplist, struct nfs4_ol_stateid,\n\t\t\t\t       st_locks);\n\t\tlist_del(&stp->st_locks);\n\t\tfp = stp->st_stid.sc_file;\n\t\tstp->st_stid.sc_free(&stp->st_stid);\n\t\tif (fp)\n\t\t\tput_nfs4_file(fp);\n\t}\n}"
  },
  {
    "function_name": "unhash_lockowner_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1171-1178",
    "snippet": "static void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lo->lo_owner.so_strhash"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void unhash_lockowner_locked(struct nfs4_lockowner *lo)\n{\n\tstruct nfs4_client *clp = lo->lo_owner.so_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_del_init(&lo->lo_owner.so_strhash);\n}"
  },
  {
    "function_name": "release_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1159-1169",
    "snippet": "static void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\tbool unhashed;\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhashed = unhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (unhashed)\n\t\tnfs4_put_stid(&stp->st_stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_lock_stateid",
          "args": [
            "stp"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_lock_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1148-1157",
          "snippet": "static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_openstp->st_stateowner"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void release_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\tbool unhashed;\n\n\tspin_lock(&oo->oo_owner.so_client->cl_lock);\n\tunhashed = unhash_lock_stateid(stp);\n\tspin_unlock(&oo->oo_owner.so_client->cl_lock);\n\tif (unhashed)\n\t\tnfs4_put_stid(&stp->st_stid);\n}"
  },
  {
    "function_name": "unhash_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1148-1157",
    "snippet": "static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unhash_ol_stateid",
          "args": [
            "stp"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_ol_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1085-1099",
          "snippet": "static bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_unhash_stid",
          "args": [
            "&stp->st_stid"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_unhash_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "776-779",
          "snippet": "void nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&stp->st_locks"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&oo->oo_owner.so_client->cl_lock"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "stp->st_openstp->st_stateowner"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_openowner *oo = openowner(stp->st_openstp->st_stateowner);\n\n\tlockdep_assert_held(&oo->oo_owner.so_client->cl_lock);\n\n\tlist_del_init(&stp->st_locks);\n\tnfs4_unhash_stid(&stp->st_stid);\n\treturn unhash_ol_stateid(stp);\n}"
  },
  {
    "function_name": "put_ol_stateid_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1129-1146",
    "snippet": "static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&stp->st_locks",
            "reaplist"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&clp->cl_stateids",
            "s->sc_stateid.si_opaque.so_id"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&close_wq"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&s->sc_count"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&stp->st_locks)"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stp->st_locks"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nstatic void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,\n\t\t\t\t       struct list_head *reaplist)\n{\n\tstruct nfs4_stid *s = &stp->st_stid;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tWARN_ON_ONCE(!list_empty(&stp->st_locks));\n\n\tif (!atomic_dec_and_test(&s->sc_count)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tlist_add(&stp->st_locks, reaplist);\n}"
  },
  {
    "function_name": "nfs4_free_lock_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1112-1122",
    "snippet": "static void nfs4_free_lock_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\tstruct nfs4_lockowner *lo = lockowner(stp->st_stateowner);\n\tstruct file *file;\n\n\tfile = find_any_file(stp->st_stid.sc_file);\n\tif (file)\n\t\tfilp_close(file, (fl_owner_t)lo);\n\tnfs4_free_ol_stateid(stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_ol_stateid",
          "args": [
            "stid"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_ol_stateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1101-1110",
          "snippet": "static void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\tput_clnt_odstate(stp->st_clnt_odstate);\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
            "static struct kmem_cache *stateid_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\tput_clnt_odstate(stp->st_clnt_odstate);\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "(fl_owner_t)lo"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_any_file",
          "args": [
            "stp->st_stid.sc_file"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "348-362",
          "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_lockowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5368-5373",
          "snippet": "static void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *lockowner_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *lockowner_slab;\n\nstatic void nfs4_free_lockowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_lockowner *lo = lockowner(sop);\n\n\tkmem_cache_free(lockowner_slab, lo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "stid"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstatic void nfs4_free_lock_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\tstruct nfs4_lockowner *lo = lockowner(stp->st_stateowner);\n\tstruct file *file;\n\n\tfile = find_any_file(stp->st_stid.sc_file);\n\tif (file)\n\t\tfilp_close(file, (fl_owner_t)lo);\n\tnfs4_free_ol_stateid(stid);\n}"
  },
  {
    "function_name": "nfs4_free_ol_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1101-1110",
    "snippet": "static void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\tput_clnt_odstate(stp->st_clnt_odstate);\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
      "static struct kmem_cache *stateid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "stateid_slab",
            "stid"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stateowner",
          "args": [
            "stp->st_stateowner"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1072-1083",
          "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_all_access",
          "args": [
            "stp"
          ],
          "line": 1106
        },
        "resolved": true,
        "details": {
          "function_name": "release_all_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1050-1064",
          "snippet": "static void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_clnt_odstate",
          "args": [
            "stp->st_clnt_odstate"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "put_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "512-528",
          "snippet": "static void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *odstate_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "stid"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid)\n{\n\tstruct nfs4_ol_stateid *stp = openlockstateid(stid);\n\n\tput_clnt_odstate(stp->st_clnt_odstate);\n\trelease_all_access(stp);\n\tif (stp->st_stateowner)\n\t\tnfs4_put_stateowner(stp->st_stateowner);\n\tkmem_cache_free(stateid_slab, stid);\n}"
  },
  {
    "function_name": "unhash_ol_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1085-1099",
    "snippet": "static bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&stp->st_perstateowner"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&stp->st_perfile"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&stp->st_perfile"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&stp->st_stateowner->so_client->cl_lock"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)\n{\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tlockdep_assert_held(&stp->st_stateowner->so_client->cl_lock);\n\n\tif (list_empty(&stp->st_perfile))\n\t\treturn false;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&stp->st_perfile);\n\tspin_unlock(&fp->fi_lock);\n\tlist_del(&stp->st_perstateowner);\n\treturn true;\n}"
  },
  {
    "function_name": "nfs4_put_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1072-1083",
    "snippet": "static void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_free_stateowner",
          "args": [
            "sop"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_free_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1066-1070",
          "snippet": "static inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sop->so_ops->so_unhash",
          "args": [
            "sop"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&sop->so_count",
            "&clp->cl_lock"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_stateowner(struct nfs4_stateowner *sop)\n{\n\tstruct nfs4_client *clp = sop->so_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&sop->so_count, &clp->cl_lock))\n\t\treturn;\n\tsop->so_ops->so_unhash(sop);\n\tspin_unlock(&clp->cl_lock);\n\tnfs4_free_stateowner(sop);\n}"
  },
  {
    "function_name": "nfs4_free_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1066-1070",
    "snippet": "static inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sop->so_ops->so_free",
          "args": [
            "sop"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sop->so_owner.data"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void nfs4_free_stateowner(struct nfs4_stateowner *sop)\n{\n\tkfree(sop->so_owner.data);\n\tsop->so_ops->so_free(sop);\n}"
  },
  {
    "function_name": "release_all_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1050-1064",
    "snippet": "static void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_access",
          "args": [
            "i",
            "stp"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "clear_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "954-961",
          "snippet": "static inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_file_put_access",
          "args": [
            "stp->st_stid.sc_file",
            "i"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "466-474",
          "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_access",
          "args": [
            "i",
            "stp"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "test_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "964-970",
          "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalculate_deny_mode",
          "args": [
            "fp"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_deny_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1019-1029",
          "snippet": "static void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrelease_all_access(struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tstruct nfs4_file *fp = stp->st_stid.sc_file;\n\n\tif (fp && stp->st_deny_bmap != 0)\n\t\trecalculate_deny_mode(fp);\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_access(i, stp))\n\t\t\tnfs4_file_put_access(stp->st_stid.sc_file, i);\n\t\tclear_access(i, stp);\n\t}\n}"
  },
  {
    "function_name": "reset_union_bmap_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1031-1047",
    "snippet": "static void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalculate_deny_mode",
          "args": [
            "stp->st_stid.sc_file"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_deny_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1019-1029",
          "snippet": "static void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_deny",
          "args": [
            "i",
            "stp"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "clear_deny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "983-990",
          "snippet": "static inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nreset_union_bmap_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tint i;\n\tbool change = false;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif ((i & deny) != i) {\n\t\t\tchange = true;\n\t\t\tclear_deny(i, stp);\n\t\t}\n\t}\n\n\t/* Recalculate per-file deny mode if there was a change */\n\tif (change)\n\t\trecalculate_deny_mode(stp->st_stid.sc_file);\n}"
  },
  {
    "function_name": "recalculate_deny_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1019-1029",
    "snippet": "static void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bmap_to_share_mode",
          "args": [
            "stp->st_deny_bmap"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "bmap_to_share_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "931-941",
          "snippet": "static unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "stp",
            "&fp->fi_stateids",
            "st_perfile"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nrecalculate_deny_mode(struct nfs4_file *fp)\n{\n\tstruct nfs4_ol_stateid *stp;\n\n\tspin_lock(&fp->fi_lock);\n\tfp->fi_share_deny = 0;\n\tlist_for_each_entry(stp, &fp->fi_stateids, st_perfile)\n\t\tfp->fi_share_deny |= bmap_to_share_mode(stp->st_deny_bmap);\n\tspin_unlock(&fp->fi_lock);\n}"
  },
  {
    "function_name": "nfs4_access_to_omode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "1001-1013",
    "snippet": "static int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int nfs4_access_to_omode(u32 access)\n{\n\tswitch (access & NFS4_SHARE_ACCESS_BOTH) {\n\tcase NFS4_SHARE_ACCESS_READ:\n\t\treturn O_RDONLY;\n\tcase NFS4_SHARE_ACCESS_WRITE:\n\t\treturn O_WRONLY;\n\tcase NFS4_SHARE_ACCESS_BOTH:\n\t\treturn O_RDWR;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn O_RDONLY;\n}"
  },
  {
    "function_name": "test_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "993-999",
    "snippet": "static inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\treturn (bool)(stp->st_deny_bmap & mask);\n}"
  },
  {
    "function_name": "clear_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "983-990",
    "snippet": "static inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "deny > NFS4_SHARE_DENY_BOTH"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap &= ~mask;\n}"
  },
  {
    "function_name": "set_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "973-980",
    "snippet": "static inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "deny > NFS4_SHARE_DENY_BOTH"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_deny(u32 deny, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << deny;\n\n\tWARN_ON_ONCE(deny > NFS4_SHARE_DENY_BOTH);\n\tstp->st_deny_bmap |= mask;\n}"
  },
  {
    "function_name": "test_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "964-970",
    "snippet": "static inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline bool\ntest_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\treturn (bool)(stp->st_access_bmap & mask);\n}"
  },
  {
    "function_name": "clear_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "954-961",
    "snippet": "static inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "access > NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nclear_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap &= ~mask;\n}"
  },
  {
    "function_name": "set_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "944-951",
    "snippet": "static inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "access > NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nset_access(u32 access, struct nfs4_ol_stateid *stp)\n{\n\tunsigned char mask = 1 << access;\n\n\tWARN_ON_ONCE(access > NFS4_SHARE_ACCESS_BOTH);\n\tstp->st_access_bmap |= mask;\n}"
  },
  {
    "function_name": "bmap_to_share_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "931-941",
    "snippet": "static unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "&bmap"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int\nbmap_to_share_mode(unsigned long bmap) {\n\tint i;\n\tunsigned int access = 0;\n\n\tfor (i = 1; i < 4; i++) {\n\t\tif (test_bit(i, &bmap))\n\t\t\taccess |= i;\n\t}\n\treturn access;\n}"
  },
  {
    "function_name": "clientstr_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "908-911",
    "snippet": "static unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opaque_hashval",
          "args": [
            "name",
            "8"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "opaque_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "257-268",
          "snippet": "static inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientstr_hashval(const char *name)\n{\n\treturn opaque_hashval(name, 8) & CLIENT_HASH_MASK;\n}"
  },
  {
    "function_name": "clientid_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "903-906",
    "snippet": "static unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int clientid_hashval(u32 id)\n{\n\treturn id & CLIENT_HASH_MASK;\n}"
  },
  {
    "function_name": "revoke_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "880-897",
    "snippet": "static void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_recall_lru",
            "&clp->cl_revoked"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "761-774",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_clnt_odstate",
          "args": [
            "dp->dl_clnt_odstate"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "put_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "512-528",
          "snippet": "static void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *odstate_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&dp->dl_recall_lru)"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void revoke_delegation(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tWARN_ON(!list_empty(&dp->dl_recall_lru));\n\n\tput_clnt_odstate(dp->dl_clnt_odstate);\n\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\n\tif (clp->cl_minorversion == 0)\n\t\tnfs4_put_stid(&dp->dl_stid);\n\telse {\n\t\tdp->dl_stid.sc_type = NFS4_REVOKED_DELEG_STID;\n\t\tspin_lock(&clp->cl_lock);\n\t\tlist_add(&dp->dl_recall_lru, &clp->cl_revoked);\n\t\tspin_unlock(&clp->cl_lock);\n\t}\n}"
  },
  {
    "function_name": "destroy_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "866-878",
    "snippet": "static void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tbool unhashed;\n\n\tspin_lock(&state_lock);\n\tunhashed = unhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tif (unhashed) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_put_stid",
          "args": [
            "&dp->dl_stid"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "730-747",
          "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_put_deleg_lease",
          "args": [
            "dp->dl_stid.sc_file"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_put_deleg_lease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "761-774",
          "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_clnt_odstate",
          "args": [
            "dp->dl_clnt_odstate"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "put_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "512-528",
          "snippet": "static void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *odstate_slab;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unhash_delegation_locked",
          "args": [
            "dp"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "unhash_delegation_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "845-864",
          "snippet": "static bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&state_lock"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic void destroy_delegation(struct nfs4_delegation *dp)\n{\n\tbool unhashed;\n\n\tspin_lock(&state_lock);\n\tunhashed = unhash_delegation_locked(dp);\n\tspin_unlock(&state_lock);\n\tif (unhashed) {\n\t\tput_clnt_odstate(dp->dl_clnt_odstate);\n\t\tnfs4_put_deleg_lease(dp->dl_stid.sc_file);\n\t\tnfs4_put_stid(&dp->dl_stid);\n\t}\n}"
  },
  {
    "function_name": "unhash_delegation_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "845-864",
    "snippet": "static bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_perfile"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dp->dl_perclnt"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dp->dl_perfile"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&state_lock"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic bool\nunhash_delegation_locked(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_file *fp = dp->dl_stid.sc_file;\n\n\tlockdep_assert_held(&state_lock);\n\n\tif (list_empty(&dp->dl_perfile))\n\t\treturn false;\n\n\tdp->dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;\n\t/* Ensure that deleg break won't try to requeue it */\n\t++dp->dl_time;\n\tspin_lock(&fp->fi_lock);\n\tlist_del_init(&dp->dl_perclnt);\n\tlist_del_init(&dp->dl_recall_lru);\n\tlist_del_init(&dp->dl_perfile);\n\tspin_unlock(&fp->fi_lock);\n\treturn true;\n}"
  },
  {
    "function_name": "hash_delegation_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "825-843",
    "snippet": "static int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tif (status)\n\t\treturn status;\n\t++fp->fi_delegees;\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_perclnt",
            "&clp->cl_delegations"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dp->dl_perfile",
            "&fp->fi_delegations"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dp->dl_stid.sc_count"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_get_existing_delegation",
          "args": [
            "clp",
            "fp"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_existing_delegation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "794-810",
          "snippet": "static int\nnfs4_get_existing_delegation(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int\nnfs4_get_existing_delegation(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&state_lock"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int\nhash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)\n{\n\tint status;\n\tstruct nfs4_client *clp = dp->dl_stid.sc_client;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tstatus = nfs4_get_existing_delegation(clp, fp);\n\tif (status)\n\t\treturn status;\n\t++fp->fi_delegees;\n\tatomic_inc(&dp->dl_stid.sc_count);\n\tdp->dl_stid.sc_type = NFS4_DELEG_STID;\n\tlist_add(&dp->dl_perfile, &fp->fi_delegations);\n\tlist_add(&dp->dl_perclnt, &clp->cl_delegations);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_get_existing_delegation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "794-810",
    "snippet": "static int\nnfs4_get_existing_delegation(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "searchdp",
            "&fp->fi_delegations",
            "dl_perfile"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&state_lock"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nstatic int\nnfs4_get_existing_delegation(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_delegation *searchdp = NULL;\n\tstruct nfs4_client *searchclp = NULL;\n\n\tlockdep_assert_held(&state_lock);\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tlist_for_each_entry(searchdp, &fp->fi_delegations, dl_perfile) {\n\t\tsearchclp = searchdp->dl_stid.sc_client;\n\t\tif (clp == searchclp) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_unhash_stid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "776-779",
    "snippet": "void nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid nfs4_unhash_stid(struct nfs4_stid *s)\n{\n\ts->sc_type = 0;\n}"
  },
  {
    "function_name": "nfs4_put_deleg_lease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "761-774",
    "snippet": "static void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "filp"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setlease",
          "args": [
            "filp",
            "F_UNLCK",
            "NULL",
            "(void **)&fp"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "filp",
            "fp->fi_deleg_file"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_put_deleg_lease(struct nfs4_file *fp)\n{\n\tstruct file *filp = NULL;\n\n\tspin_lock(&fp->fi_lock);\n\tif (fp->fi_deleg_file && --fp->fi_delegees == 0)\n\t\tswap(filp, fp->fi_deleg_file);\n\tspin_unlock(&fp->fi_lock);\n\n\tif (filp) {\n\t\tvfs_setlease(filp, F_UNLCK, NULL, (void **)&fp);\n\t\tfput(filp);\n\t}\n}"
  },
  {
    "function_name": "nfs4_inc_and_copy_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "749-759",
    "snippet": "void\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&stid->sc_lock"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "sizeof(*dst)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++src->si_generation == 0"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&stid->sc_lock"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nvoid\nnfs4_inc_and_copy_stateid(stateid_t *dst, struct nfs4_stid *stid)\n{\n\tstateid_t *src = &stid->sc_stateid;\n\n\tspin_lock(&stid->sc_lock);\n\tif (unlikely(++src->si_generation == 0))\n\t\tsrc->si_generation = 1;\n\tmemcpy(dst, src, sizeof(*dst));\n\tspin_unlock(&stid->sc_lock);\n}"
  },
  {
    "function_name": "nfs4_put_stid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "730-747",
    "snippet": "void\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(close_wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_nfs4_file",
          "args": [
            "fp"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "put_nfs4_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "277-289",
          "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(state_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "s->sc_free",
          "args": [
            "s"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&clp->cl_stateids",
            "s->sc_stateid.si_opaque.so_id"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&close_wq"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&s->sc_count",
            "&clp->cl_lock"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(close_wq);\n\nvoid\nnfs4_put_stid(struct nfs4_stid *s)\n{\n\tstruct nfs4_file *fp = s->sc_file;\n\tstruct nfs4_client *clp = s->sc_client;\n\n\tmight_lock(&clp->cl_lock);\n\n\tif (!atomic_dec_and_lock(&s->sc_count, &clp->cl_lock)) {\n\t\twake_up_all(&close_wq);\n\t\treturn;\n\t}\n\tidr_remove(&clp->cl_stateids, s->sc_stateid.si_opaque.so_id);\n\tspin_unlock(&clp->cl_lock);\n\ts->sc_free(s);\n\tif (fp)\n\t\tput_nfs4_file(fp);\n}"
  },
  {
    "function_name": "alloc_init_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "691-728",
    "snippet": "static struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh,\n\t\t struct nfs4_clnt_odstate *odstate)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_clnt_odstate = odstate;\n\tget_clnt_odstate(odstate);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *deleg_slab;",
      "static const struct nfsd4_callback_ops nfsd4_cb_recall_ops;",
      "static atomic_long_t num_delegations;",
      "unsigned long max_delegations;",
      "static const struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&num_delegations"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_init_cb",
          "args": [
            "&dp->dl_recall",
            "dp->dl_stid.sc_client",
            "&nfsd4_cb_recall_ops",
            "NFSPROC4_CLNT_CB_RECALL"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4callback.c",
          "lines": "1133-1145",
          "snippet": "void nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tcb->cb_need_restart = false;\n}",
          "includes": [
            "#include \"xdr4cb.h\"",
            "#include \"netns.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/sunrpc/xprt.h>",
            "#include <linux/sunrpc/clnt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xdr4cb.h\"\n#include \"netns.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/slab.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/clnt.h>\n\nstatic struct rpc_procinfo nfs4_cb_procedures[] = {\n\tPROC(CB_NULL,\tNULL,\t\tcb_null,\tcb_null),\n\tPROC(CB_RECALL,\tCOMPOUND,\tcb_recall,\tcb_recall),\n#ifdef CONFIG_NFSD_PNFS\n\tPROC(CB_LAYOUT,\tCOMPOUND,\tcb_layout,\tcb_layout),\n#endif\n};\n\nvoid nfsd4_init_cb(struct nfsd4_callback *cb, struct nfs4_client *clp,\n\t\tconst struct nfsd4_callback_ops *ops, enum nfsd4_cb_op op)\n{\n\tcb->cb_clp = clp;\n\tcb->cb_msg.rpc_proc = &nfs4_cb_procedures[op];\n\tcb->cb_msg.rpc_argp = cb;\n\tcb->cb_msg.rpc_resp = cb;\n\tcb->cb_ops = ops;\n\tINIT_WORK(&cb->cb_work, nfsd4_run_cb_work);\n\tcb->cb_seq_status = 1;\n\tcb->cb_status = 0;\n\tcb->cb_need_restart = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_clnt_odstate",
          "args": [
            "odstate"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "get_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "505-510",
          "snippet": "static inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\tatomic_inc(&co->co_odcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\tatomic_inc(&co->co_odcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dp->dl_recall_lru"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dp->dl_perclnt"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dp->dl_perfile"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delegstateid",
          "args": [
            "nfs4_alloc_stid(clp, deleg_slab)"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "delegstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "154-157",
          "snippet": "static inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_delegation *delegstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_delegation, dl_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "clp",
            "deleg_slab"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "556-593",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "delegation_blocked",
          "args": [
            "&current_fh->fh_handle"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "delegation_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "641-672",
          "snippet": "static int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_delegations_lock);",
            "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&num_delegations"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD alloc_init_deleg\\n\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *deleg_slab;\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops;\nstatic atomic_long_t num_delegations;\nunsigned long max_delegations;\nstatic const struct nfsd4_callback_ops nfsd4_cb_recall_ops = {\n\t.prepare\t= nfsd4_cb_recall_prepare,\n\t.done\t\t= nfsd4_cb_recall_done,\n\t.release\t= nfsd4_cb_recall_release,\n};\n\nstatic struct nfs4_delegation *\nalloc_init_deleg(struct nfs4_client *clp, struct svc_fh *current_fh,\n\t\t struct nfs4_clnt_odstate *odstate)\n{\n\tstruct nfs4_delegation *dp;\n\tlong n;\n\n\tdprintk(\"NFSD alloc_init_deleg\\n\");\n\tn = atomic_long_inc_return(&num_delegations);\n\tif (n < 0 || n > max_delegations)\n\t\tgoto out_dec;\n\tif (delegation_blocked(&current_fh->fh_handle))\n\t\tgoto out_dec;\n\tdp = delegstateid(nfs4_alloc_stid(clp, deleg_slab));\n\tif (dp == NULL)\n\t\tgoto out_dec;\n\n\tdp->dl_stid.sc_free = nfs4_free_deleg;\n\t/*\n\t * delegation seqid's are never incremented.  The 4.1 special\n\t * meaning of seqid 0 isn't meaningful, really, but let's avoid\n\t * 0 anyway just for consistency and use 1:\n\t */\n\tdp->dl_stid.sc_stateid.si_generation = 1;\n\tINIT_LIST_HEAD(&dp->dl_perfile);\n\tINIT_LIST_HEAD(&dp->dl_perclnt);\n\tINIT_LIST_HEAD(&dp->dl_recall_lru);\n\tdp->dl_clnt_odstate = odstate;\n\tget_clnt_odstate(odstate);\n\tdp->dl_type = NFS4_OPEN_DELEGATE_READ;\n\tdp->dl_retries = 1;\n\tnfsd4_init_cb(&dp->dl_recall, dp->dl_stid.sc_client,\n\t\t      &nfsd4_cb_recall_ops, NFSPROC4_CLNT_CB_RECALL);\n\treturn dp;\nout_dec:\n\tatomic_long_dec(&num_delegations);\n\treturn NULL;\n}"
  },
  {
    "function_name": "block_delegations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "674-689",
    "snippet": "static void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_delegations_lock);",
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "(hash>>16)&255",
            "bd->set[bd->new]"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "(hash>>8)&255",
            "bd->set[bd->new]"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "hash&255",
            "bd->set[bd->new]"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "&fh->fh_base",
            "fh->fh_size",
            "0"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic void block_delegations(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\n\tspin_lock(&blocked_delegations_lock);\n\t__set_bit(hash&255, bd->set[bd->new]);\n\t__set_bit((hash>>8)&255, bd->set[bd->new]);\n\t__set_bit((hash>>16)&255, bd->set[bd->new]);\n\tif (bd->entries == 0)\n\t\tbd->swap_time = seconds_since_boot();\n\tbd->entries += 1;\n\tspin_unlock(&blocked_delegations_lock);\n}"
  },
  {
    "function_name": "delegation_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "641-672",
    "snippet": "static int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(blocked_delegations_lock);",
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(hash>>16)&255",
            "bd->set[1]"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(hash>>8)&255",
            "bd->set[1]"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "hash&255",
            "bd->set[1]"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(hash>>16)&255",
            "bd->set[0]"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(hash>>8)&255",
            "bd->set[0]"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "hash&255",
            "bd->set[0]"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhash",
          "args": [
            "&fh->fh_base",
            "fh->fh_size",
            "0"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bd->set[bd->new]",
            "0",
            "sizeof(bd->set[0])"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&blocked_delegations_lock"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seconds_since_boot",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(blocked_delegations_lock);\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic int delegation_blocked(struct knfsd_fh *fh)\n{\n\tu32 hash;\n\tstruct bloom_pair *bd = &blocked_delegations;\n\n\tif (bd->entries == 0)\n\t\treturn 0;\n\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\tspin_lock(&blocked_delegations_lock);\n\t\tif (seconds_since_boot() - bd->swap_time > 30) {\n\t\t\tbd->entries -= bd->old_entries;\n\t\t\tbd->old_entries = bd->entries;\n\t\t\tmemset(bd->set[bd->new], 0,\n\t\t\t       sizeof(bd->set[0]));\n\t\t\tbd->new = 1-bd->new;\n\t\t\tbd->swap_time = seconds_since_boot();\n\t\t}\n\t\tspin_unlock(&blocked_delegations_lock);\n\t}\n\thash = jhash(&fh->fh_base, fh->fh_size, 0);\n\tif (test_bit(hash&255, bd->set[0]) &&\n\t    test_bit((hash>>8)&255, bd->set[0]) &&\n\t    test_bit((hash>>16)&255, bd->set[0]))\n\t\treturn 1;\n\n\tif (test_bit(hash&255, bd->set[1]) &&\n\t    test_bit((hash>>8)&255, bd->set[1]) &&\n\t    test_bit((hash>>16)&255, bd->set[1]))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs4_free_deleg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "609-613",
    "snippet": "static void nfs4_free_deleg(struct nfs4_stid *stid)\n{\n\tkmem_cache_free(deleg_slab, stid);\n\tatomic_long_dec(&num_delegations);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
      "static struct kmem_cache *deleg_slab;",
      "static atomic_long_t num_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&num_delegations"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "deleg_slab",
            "stid"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *deleg_slab;\nstatic atomic_long_t num_delegations;\n\nstatic void nfs4_free_deleg(struct nfs4_stid *stid)\n{\n\tkmem_cache_free(deleg_slab, stid);\n\tatomic_long_dec(&num_delegations);\n}"
  },
  {
    "function_name": "nfs4_alloc_open_stateid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "595-607",
    "snippet": "static struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);",
      "static struct kmem_cache *stateid_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "openlockstateid",
          "args": [
            "stid"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "openlockstateid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/state.h",
          "lines": "541-544",
          "snippet": "static inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}",
          "includes": [
            "#include \"nfsfh.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/idr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsfh.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/idr.h>\n\nstatic inline struct nfs4_ol_stateid *openlockstateid(struct nfs4_stid *s)\n{\n\treturn container_of(s, struct nfs4_ol_stateid, st_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_alloc_stid",
          "args": [
            "clp",
            "stateid_slab"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_alloc_stid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "556-593",
          "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\nstatic struct kmem_cache *stateid_slab;\n\nstatic struct nfs4_ol_stateid * nfs4_alloc_open_stateid(struct nfs4_client *clp)\n{\n\tstruct nfs4_stid *stid;\n\tstruct nfs4_ol_stateid *stp;\n\n\tstid = nfs4_alloc_stid(clp, stateid_slab);\n\tif (!stid)\n\t\treturn NULL;\n\n\tstp = openlockstateid(stid);\n\tstp->st_stid.sc_free = nfs4_free_ol_stateid;\n\treturn stp;\n}"
  },
  {
    "function_name": "nfs4_alloc_stid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "556-593",
    "snippet": "struct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void nfs4_free_ol_stateid(struct nfs4_stid *stid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "slab",
            "stid"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&stid->sc_lock"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&stid->sc_count",
            "1"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&cl->cl_stateids",
            "stid",
            "0",
            "0",
            "GFP_NOWAIT"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cl->cl_lock"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "slab",
            "GFP_KERNEL"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_free_ol_stateid(struct nfs4_stid *stid);\n\nstruct nfs4_stid *nfs4_alloc_stid(struct nfs4_client *cl,\n\t\t\t\t\t struct kmem_cache *slab)\n{\n\tstruct nfs4_stid *stid;\n\tint new_id;\n\n\tstid = kmem_cache_zalloc(slab, GFP_KERNEL);\n\tif (!stid)\n\t\treturn NULL;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&cl->cl_lock);\n\tnew_id = idr_alloc_cyclic(&cl->cl_stateids, stid, 0, 0, GFP_NOWAIT);\n\tspin_unlock(&cl->cl_lock);\n\tidr_preload_end();\n\tif (new_id < 0)\n\t\tgoto out_free;\n\tstid->sc_client = cl;\n\tstid->sc_stateid.si_opaque.so_id = new_id;\n\tstid->sc_stateid.si_opaque.so_clid = cl->cl_clientid;\n\t/* Will be incremented before return to client: */\n\tatomic_set(&stid->sc_count, 1);\n\tspin_lock_init(&stid->sc_lock);\n\n\t/*\n\t * It shouldn't be a problem to reuse an opaque stateid value.\n\t * I don't think it is for 4.1.  But with 4.0 I worry that, for\n\t * example, a stray write retransmission could be accepted by\n\t * the server when it should have been rejected.  Therefore,\n\t * adopt a trick from the sctp code to attempt to maximize the\n\t * amount of time until an id is reused, by ensuring they always\n\t * \"increase\" (mod INT_MAX):\n\t */\n\treturn stid;\nout_free:\n\tkmem_cache_free(slab, stid);\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_or_hash_clnt_odstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "530-554",
    "snippet": "static struct nfs4_clnt_odstate *\nfind_or_hash_clnt_odstate(struct nfs4_file *fp, struct nfs4_clnt_odstate *new)\n{\n\tstruct nfs4_clnt_odstate *co;\n\tstruct nfs4_client *cl;\n\n\tif (!new)\n\t\treturn NULL;\n\n\tcl = new->co_client;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(co, &fp->fi_clnt_odstate, co_perfile) {\n\t\tif (co->co_client == cl) {\n\t\t\tget_clnt_odstate(co);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tco = new;\n\tco->co_file = fp;\n\thash_clnt_odstate_locked(new);\nout:\n\tspin_unlock(&fp->fi_lock);\n\treturn co;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_clnt_odstate_locked",
          "args": [
            "new"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "hash_clnt_odstate_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "496-503",
          "snippet": "static void\nhash_clnt_odstate_locked(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp = co->co_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\tlist_add(&co->co_perfile, &fp->fi_clnt_odstate);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nhash_clnt_odstate_locked(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp = co->co_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\tlist_add(&co->co_perfile, &fp->fi_clnt_odstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_clnt_odstate",
          "args": [
            "co"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "get_clnt_odstate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "505-510",
          "snippet": "static inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\tatomic_inc(&co->co_odcount);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\tatomic_inc(&co->co_odcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "co",
            "&fp->fi_clnt_odstate",
            "co_perfile"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_clnt_odstate *\nfind_or_hash_clnt_odstate(struct nfs4_file *fp, struct nfs4_clnt_odstate *new)\n{\n\tstruct nfs4_clnt_odstate *co;\n\tstruct nfs4_client *cl;\n\n\tif (!new)\n\t\treturn NULL;\n\n\tcl = new->co_client;\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry(co, &fp->fi_clnt_odstate, co_perfile) {\n\t\tif (co->co_client == cl) {\n\t\t\tget_clnt_odstate(co);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tco = new;\n\tco->co_file = fp;\n\thash_clnt_odstate_locked(new);\nout:\n\tspin_unlock(&fp->fi_lock);\n\treturn co;\n}"
  },
  {
    "function_name": "put_clnt_odstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "512-528",
    "snippet": "static void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *odstate_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "odstate_slab",
            "co"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_return_all_file_layouts",
          "args": [
            "co->co_client",
            "fp"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_file_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4layouts.c",
          "lines": "581-595",
          "snippet": "void\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n#include <linux/blkdev.h>\n\nvoid\nnfsd4_return_all_file_layouts(struct nfs4_client *clp, struct nfs4_file *fp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&fp->fi_lock);\n\tlist_for_each_entry_safe(ls, n, &fp->fi_lo_states, ls_perfile) {\n\t\tif (ls->ls_stid.sc_client == clp)\n\t\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\t}\n\tspin_unlock(&fp->fi_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&co->co_perfile"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&co->co_odcount",
            "&fp->fi_lock"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic void\nput_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp;\n\n\tif (!co)\n\t\treturn;\n\n\tfp = co->co_file;\n\tif (atomic_dec_and_lock(&co->co_odcount, &fp->fi_lock)) {\n\t\tlist_del(&co->co_perfile);\n\t\tspin_unlock(&fp->fi_lock);\n\n\t\tnfsd4_return_all_file_layouts(co->co_client, fp);\n\t\tkmem_cache_free(odstate_slab, co);\n\t}\n}"
  },
  {
    "function_name": "get_clnt_odstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "505-510",
    "snippet": "static inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\tatomic_inc(&co->co_odcount);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&co->co_odcount"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nget_clnt_odstate(struct nfs4_clnt_odstate *co)\n{\n\tif (co)\n\t\tatomic_inc(&co->co_odcount);\n}"
  },
  {
    "function_name": "hash_clnt_odstate_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "496-503",
    "snippet": "static void\nhash_clnt_odstate_locked(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp = co->co_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\tlist_add(&co->co_perfile, &fp->fi_clnt_odstate);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&co->co_perfile",
            "&fp->fi_clnt_odstate"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\nhash_clnt_odstate_locked(struct nfs4_clnt_odstate *co)\n{\n\tstruct nfs4_file *fp = co->co_file;\n\n\tlockdep_assert_held(&fp->fi_lock);\n\tlist_add(&co->co_perfile, &fp->fi_clnt_odstate);\n}"
  },
  {
    "function_name": "alloc_clnt_odstate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "483-494",
    "snippet": "static struct nfs4_clnt_odstate *\nalloc_clnt_odstate(struct nfs4_client *clp)\n{\n\tstruct nfs4_clnt_odstate *co;\n\n\tco = kmem_cache_zalloc(odstate_slab, GFP_KERNEL);\n\tif (co) {\n\t\tco->co_client = clp;\n\t\tatomic_set(&co->co_odcount, 1);\n\t}\n\treturn co;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *odstate_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&co->co_odcount",
            "1"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "odstate_slab",
            "GFP_KERNEL"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *odstate_slab;\n\nstatic struct nfs4_clnt_odstate *\nalloc_clnt_odstate(struct nfs4_client *clp)\n{\n\tstruct nfs4_clnt_odstate *co;\n\n\tco = kmem_cache_zalloc(odstate_slab, GFP_KERNEL);\n\tif (co) {\n\t\tco->co_client = clp;\n\t\tatomic_set(&co->co_odcount, 1);\n\t}\n\treturn co;\n}"
  },
  {
    "function_name": "nfs4_file_put_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "466-474",
    "snippet": "static void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_file_put_access",
          "args": [
            "fp",
            "O_RDONLY"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_file_put_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "447-464",
          "snippet": "static void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "access & ~NFS4_SHARE_ACCESS_BOTH"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void nfs4_file_put_access(struct nfs4_file *fp, u32 access)\n{\n\tWARN_ON_ONCE(access & ~NFS4_SHARE_ACCESS_BOTH);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\t__nfs4_file_put_access(fp, O_WRONLY);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\t__nfs4_file_put_access(fp, O_RDONLY);\n}"
  },
  {
    "function_name": "__nfs4_file_put_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "447-464",
    "snippet": "static void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f2"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "f1"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "f2",
            "fp->fi_fds[O_RDWR]"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fp->fi_access[1 - oflag]"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "f1",
            "fp->fi_fds[oflag]"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&fp->fi_access[oflag]",
            "&fp->fi_lock"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void __nfs4_file_put_access(struct nfs4_file *fp, int oflag)\n{\n\tmight_lock(&fp->fi_lock);\n\n\tif (atomic_dec_and_lock(&fp->fi_access[oflag], &fp->fi_lock)) {\n\t\tstruct file *f1 = NULL;\n\t\tstruct file *f2 = NULL;\n\n\t\tswap(f1, fp->fi_fds[oflag]);\n\t\tif (atomic_read(&fp->fi_access[1 - oflag]) == 0)\n\t\t\tswap(f2, fp->fi_fds[O_RDWR]);\n\t\tspin_unlock(&fp->fi_lock);\n\t\tif (f1)\n\t\t\tfput(f1);\n\t\tif (f2)\n\t\t\tfput(f2);\n\t}\n}"
  },
  {
    "function_name": "nfs4_file_check_deny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "428-445",
    "snippet": "static __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fp->fi_access[O_WRONLY]"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fp->fi_access[O_RDONLY]"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 nfs4_file_check_deny(struct nfs4_file *fp, u32 deny)\n{\n\t/* Common case is that there is no deny mode. */\n\tif (deny) {\n\t\t/* Does this deny mode make sense? */\n\t\tif (deny & ~NFS4_SHARE_DENY_BOTH)\n\t\t\treturn nfserr_inval;\n\n\t\tif ((deny & NFS4_SHARE_DENY_READ) &&\n\t\t    atomic_read(&fp->fi_access[O_RDONLY]))\n\t\t\treturn nfserr_share_denied;\n\n\t\tif ((deny & NFS4_SHARE_DENY_WRITE) &&\n\t\t    atomic_read(&fp->fi_access[O_WRONLY]))\n\t\t\treturn nfserr_share_denied;\n\t}\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfs4_file_get_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "411-426",
    "snippet": "static __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_file_get_access",
          "args": [
            "fp",
            "access"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_file_get_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "400-409",
          "snippet": "static void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct bloom_pair {\n\tint\tentries, old_entries;\n\ttime_t\tswap_time;\n\tint\tnew; /* index into 'set' */\n\tDECLARE_BITMAP(set[2], 256);\n} blocked_delegations;\n\nstatic __be32\nnfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\t/* Does this access mode make sense? */\n\tif (access & ~NFS4_SHARE_ACCESS_BOTH)\n\t\treturn nfserr_inval;\n\n\t/* Does it conflict with a deny mode already set? */\n\tif ((access & fp->fi_share_deny) != 0)\n\t\treturn nfserr_share_denied;\n\n\t__nfs4_file_get_access(fp, access);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "__nfs4_file_get_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "400-409",
    "snippet": "static void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fp->fi_access[O_RDONLY]"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&fp->fi_access[O_WRONLY]"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&fp->fi_lock"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void\n__nfs4_file_get_access(struct nfs4_file *fp, u32 access)\n{\n\tlockdep_assert_held(&fp->fi_lock);\n\n\tif (access & NFS4_SHARE_ACCESS_WRITE)\n\t\tatomic_inc(&fp->fi_access[O_WRONLY]);\n\tif (access & NFS4_SHARE_ACCESS_READ)\n\t\tatomic_inc(&fp->fi_access[O_RDONLY]);\n}"
  },
  {
    "function_name": "file_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "393-396",
    "snippet": "static unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd_fh_hashval",
          "args": [
            "fh"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_fh_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "388-391",
          "snippet": "static unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define FILE_HASH_SIZE                  (1 << FILE_HASH_BITS)\n\nstatic unsigned int file_hashval(struct knfsd_fh *fh)\n{\n\treturn nfsd_fh_hashval(fh) & (FILE_HASH_SIZE - 1);\n}"
  },
  {
    "function_name": "nfsd_fh_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "388-391",
    "snippet": "static unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jhash2",
          "args": [
            "fh->fh_base.fh_pad",
            "XDR_QUADLEN(fh->fh_size)",
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XDR_QUADLEN",
          "args": [
            "fh->fh_size"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic unsigned int nfsd_fh_hashval(struct knfsd_fh *fh)\n{\n\treturn jhash2(fh->fh_base.fh_pad, XDR_QUADLEN(fh->fh_size), 0);\n}"
  },
  {
    "function_name": "ownerstr_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "376-382",
    "snippet": "static unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opaque_hashval",
          "args": [
            "ownername->data",
            "ownername->len"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "opaque_hashval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "257-268",
          "snippet": "static inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\n#define OWNER_HASH_MASK             (OWNER_HASH_SIZE - 1)\n\nstatic unsigned int ownerstr_hashval(struct xdr_netobj *ownername)\n{\n\tunsigned int ret;\n\n\tret = opaque_hashval(ownername->data, ownername->len);\n\treturn ret & OWNER_HASH_MASK;\n}"
  },
  {
    "function_name": "find_any_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "348-362",
    "snippet": "struct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__nfs4_get_fd",
          "args": [
            "f",
            "O_RDONLY"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_get_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "291-297",
          "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct file *\nfind_any_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = __nfs4_get_fd(f, O_RDWR);\n\tif (!ret) {\n\t\tret = __nfs4_get_fd(f, O_WRONLY);\n\t\tif (!ret)\n\t\t\tret = __nfs4_get_fd(f, O_RDONLY);\n\t}\n\tspin_unlock(&f->fi_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_readable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "336-346",
    "snippet": "static struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_readable_file_locked",
          "args": [
            "f"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "find_readable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "324-334",
          "snippet": "static struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_readable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_readable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_readable_file_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "324-334",
    "snippet": "static struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_get_fd",
          "args": [
            "f",
            "O_RDWR"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_get_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "291-297",
          "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&f->fi_lock"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *find_readable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_RDONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_writeable_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "312-322",
    "snippet": "static struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_writeable_file_locked",
          "args": [
            "f"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "find_writeable_file_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "299-310",
          "snippet": "static struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&f->fi_lock"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tspin_lock(&f->fi_lock);\n\tret = find_writeable_file_locked(f);\n\tspin_unlock(&f->fi_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "find_writeable_file_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "299-310",
    "snippet": "static struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__nfs4_get_fd",
          "args": [
            "f",
            "O_RDWR"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__nfs4_get_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "291-297",
          "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&f->fi_lock"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\nfind_writeable_file_locked(struct nfs4_file *f)\n{\n\tstruct file *ret;\n\n\tlockdep_assert_held(&f->fi_lock);\n\n\tret = __nfs4_get_fd(f, O_WRONLY);\n\tif (!ret)\n\t\tret = __nfs4_get_fd(f, O_RDWR);\n\treturn ret;\n}"
  },
  {
    "function_name": "__nfs4_get_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "291-297",
    "snippet": "static struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "f->fi_fds[oflag]"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct file *\n__nfs4_get_fd(struct nfs4_file *f, int oflag)\n{\n\tif (f->fi_fds[oflag])\n\t\treturn get_file(f->fi_fds[oflag]);\n\treturn NULL;\n}"
  },
  {
    "function_name": "put_nfs4_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "277-289",
    "snippet": "void\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(state_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&fi->fi_rcu",
            "nfsd4_free_file_rcu"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&fi->fi_delegations)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fi->fi_delegations"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&fi->fi_clnt_odstate)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&fi->fi_clnt_odstate"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&state_lock"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&fi->fi_hash"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&fi->fi_ref",
            "&state_lock"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_lock",
          "args": [
            "&state_lock"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic DEFINE_SPINLOCK(state_lock);\n\nvoid\nput_nfs4_file(struct nfs4_file *fi)\n{\n\tmight_lock(&state_lock);\n\n\tif (atomic_dec_and_lock(&fi->fi_ref, &state_lock)) {\n\t\thlist_del_rcu(&fi->fi_hash);\n\t\tspin_unlock(&state_lock);\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_clnt_odstate));\n\t\tWARN_ON_ONCE(!list_empty(&fi->fi_delegations));\n\t\tcall_rcu(&fi->fi_rcu, nfsd4_free_file_rcu);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_free_file_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "270-275",
    "snippet": "static void nfsd4_free_file_rcu(struct rcu_head *rcu)\n{\n\tstruct nfs4_file *fp = container_of(rcu, struct nfs4_file, fi_rcu);\n\n\tkmem_cache_free(file_slab, fp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *file_slab;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "file_slab",
            "fp"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structnfs4_file",
            "fi_rcu"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct kmem_cache *file_slab;\n\nstatic void nfsd4_free_file_rcu(struct rcu_head *rcu)\n{\n\tstruct nfs4_file *fp = container_of(rcu, struct nfs4_file, fi_rcu);\n\n\tkmem_cache_free(file_slab, fp);\n}"
  },
  {
    "function_name": "opaque_hashval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "257-268",
    "snippet": "static inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline u32\nopaque_hashval(const void *ptr, int nbytes)\n{\n\tunsigned char *cptr = (unsigned char *) ptr;\n\n\tu32 x = 0;\n\twhile (nbytes--) {\n\t\tx *= 37;\n\t\tx += *cptr++;\n\t}\n\treturn x;\n}"
  },
  {
    "function_name": "find_openstateowner_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "245-255",
    "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_openstateowner_str_locked",
          "args": [
            "hashval",
            "open",
            "clp"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "find_openstateowner_str_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "227-243",
          "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_openowner *oo;\n\n\tspin_lock(&clp->cl_lock);\n\too = find_openstateowner_str_locked(hashval, open, clp);\n\tspin_unlock(&clp->cl_lock);\n\treturn oo;\n}"
  },
  {
    "function_name": "find_openstateowner_str_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "227-243",
    "snippet": "static struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "openowner",
          "args": [
            "nfs4_get_stateowner(so)"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_inject_forget_openowners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6455-6477",
          "snippet": "u64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nu64\nnfsd_inject_forget_openowners(u64 max)\n{\n\tu64 count = 0;\n\tstruct nfs4_client *clp;\n\tstruct nfsd_net *nn = net_generic(current->nsproxy->net_ns,\n\t\t\t\t\t\tnfsd_net_id);\n\tLIST_HEAD(reaplist);\n\n\tif (!nfsd_netns_ready(nn))\n\t\treturn count;\n\n\tspin_lock(&nn->client_lock);\n\tlist_for_each_entry(clp, &nn->client_lru, cl_lru) {\n\t\tcount += nfsd_collect_client_openowners(clp, &reaplist,\n\t\t\t\t\t\t\tmax - count);\n\t\tif (max != 0 && count >= max)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&nn->client_lock);\n\tnfsd_reap_openowners(&reaplist);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_get_stateowner",
          "args": [
            "so"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_get_stateowner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "213-218",
          "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_owner_str",
          "args": [
            "so",
            "&open->op_owner"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "same_owner_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "220-225",
          "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "so",
            "&clp->cl_ownerstr_hashtbl[hashval]",
            "so_strhash"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&clp->cl_lock"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic struct nfs4_openowner *\nfind_openstateowner_str_locked(unsigned int hashval, struct nfsd4_open *open,\n\t\t\tstruct nfs4_client *clp)\n{\n\tstruct nfs4_stateowner *so;\n\n\tlockdep_assert_held(&clp->cl_lock);\n\n\tlist_for_each_entry(so, &clp->cl_ownerstr_hashtbl[hashval],\n\t\t\t    so_strhash) {\n\t\tif (!so->so_is_open_owner)\n\t\t\tcontinue;\n\t\tif (same_owner_str(so, &open->op_owner))\n\t\t\treturn openowner(nfs4_get_stateowner(so));\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "same_owner_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "220-225",
    "snippet": "static int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "sop->so_owner.data",
            "owner->data",
            "owner->len"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic int\nsame_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner)\n{\n\treturn (sop->so_owner.len == owner->len) &&\n\t\t0 == memcmp(sop->so_owner.data, owner->data, owner->len);\n}"
  },
  {
    "function_name": "nfs4_get_stateowner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "213-218",
    "snippet": "static inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sop->so_count"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline struct nfs4_stateowner *\nnfs4_get_stateowner(struct nfs4_stateowner *sop)\n{\n\tatomic_inc(&sop->so_count);\n\treturn sop;\n}"
  },
  {
    "function_name": "nfsd4_put_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "203-211",
    "snippet": "static void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_put_session_locked",
          "args": [
            "ses"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_put_session_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "191-201",
          "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tspin_lock(&nn->client_lock);\n\tnfsd4_put_session_locked(ses);\n\tspin_unlock(&nn->client_lock);\n}"
  },
  {
    "function_name": "nfsd4_put_session_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "191-201",
    "snippet": "static void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_client_renew_locked",
          "args": [
            "clp"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "put_client_renew_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "155-165",
          "snippet": "static void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_session",
          "args": [
            "ses"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "free_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "1572-1577",
          "snippet": "static void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void free_session(struct nfsd4_session *ses)\n{\n\tnfsd4_del_conns(ses);\n\tnfsd4_put_drc_mem(&ses->se_fchannel);\n\t__free_session(ses);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_session_dead",
          "args": [
            "ses"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "is_session_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "103-106",
          "snippet": "static bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ses->se_ref"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic void nfsd4_put_session_locked(struct nfsd4_session *ses)\n{\n\tstruct nfs4_client *clp = ses->se_client;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (atomic_dec_and_test(&ses->se_ref) && is_session_dead(ses))\n\t\tfree_session(ses);\n\tput_client_renew_locked(clp);\n}"
  },
  {
    "function_name": "nfsd4_get_session_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "178-189",
    "snippet": "static __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ses->se_ref"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_client_locked",
          "args": [
            "ses->se_client"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "get_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "121-131",
          "snippet": "static __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_session_dead",
          "args": [
            "ses"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "is_session_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "103-106",
          "snippet": "static bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_session(struct nfsd4_session *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 nfsd4_get_session_locked(struct nfsd4_session *ses)\n{\n\t__be32 status;\n\n\tif (is_session_dead(ses))\n\t\treturn nfserr_badsession;\n\tstatus = get_client_locked(ses->se_client);\n\tif (status)\n\t\treturn status;\n\tatomic_inc(&ses->se_ref);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "put_client_renew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "167-176",
    "snippet": "static void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&nn->client_lock"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "134-153",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "116-119",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&clp->cl_refcount",
            "&nn->client_lock"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!atomic_dec_and_lock(&clp->cl_refcount, &nn->client_lock))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n\tspin_unlock(&nn->client_lock);\n}"
  },
  {
    "function_name": "put_client_renew_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "155-165",
    "snippet": "static void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "renew_client_locked",
          "args": [
            "clp"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "renew_client_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "134-153",
          "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "116-119",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void put_client_renew_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (!atomic_dec_and_test(&clp->cl_refcount))\n\t\treturn;\n\tif (!is_client_expired(clp))\n\t\trenew_client_locked(clp);\n}"
  },
  {
    "function_name": "renew_client_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "134-153",
    "snippet": "static inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&clp->cl_lru",
            "&nn->client_lru"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"renewing client (clientid %08x/%08x)\\n\"",
            "clp->cl_clientid.cl_boot",
            "clp->cl_clientid.cl_id"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s: client (clientid %08x/%08x) already expired\\n\"",
            "__func__",
            "clp->cl_clientid.cl_boot",
            "clp->cl_clientid.cl_id"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "116-119",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic inline void\nrenew_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (is_client_expired(clp)) {\n\t\tWARN_ON(1);\n\t\tprintk(\"%s: client (clientid %08x/%08x) already expired\\n\",\n\t\t\t__func__,\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\t\treturn;\n\t}\n\n\tdprintk(\"renewing client (clientid %08x/%08x)\\n\",\n\t\t\tclp->cl_clientid.cl_boot,\n\t\t\tclp->cl_clientid.cl_id);\n\tlist_move_tail(&clp->cl_lru, &nn->client_lru);\n\tclp->cl_time = get_seconds();\n}"
  },
  {
    "function_name": "get_client_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "121-131",
    "snippet": "static __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&clp->cl_refcount"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_client_expired",
          "args": [
            "clp"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "is_client_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "116-119",
          "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&nn->client_lock"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic __be32 get_client_locked(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tlockdep_assert_held(&nn->client_lock);\n\n\tif (is_client_expired(clp))\n\t\treturn nfserr_expired;\n\tatomic_inc(&clp->cl_refcount);\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "is_client_expired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "116-119",
    "snippet": "static bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic bool is_client_expired(struct nfs4_client *clp)\n{\n\treturn clp->cl_time == 0;\n}"
  },
  {
    "function_name": "mark_session_dead_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "108-114",
    "snippet": "static __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ses->se_ref"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic __be32 mark_session_dead_locked(struct nfsd4_session *ses, int ref_held_by_me)\n{\n\tif (atomic_read(&ses->se_ref) > ref_held_by_me)\n\t\treturn nfserr_jukebox;\n\tses->se_flags |= NFS4_SESSION_DEAD;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "is_session_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
    "lines": "103-106",
    "snippet": "static bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}",
    "includes": [
      "#include \"pnfs.h\"",
      "#include \"netns.h\"",
      "#include \"current_stateid.h\"",
      "#include \"vfs.h\"",
      "#include \"xdr4cb.h\"",
      "#include \"xdr4.h\"",
      "#include <linux/jhash.h>",
      "#include <linux/sunrpc/addr.h>",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/swap.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void free_session(struct nfsd4_session *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstatic void free_session(struct nfsd4_session *);\n\nstatic bool is_session_dead(struct nfsd4_session *ses)\n{\n\treturn ses->se_flags & NFS4_SESSION_DEAD;\n}"
  }
]