[
  {
    "function_name": "fsid_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "663-689",
    "snippet": "enum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "fhp->fh_export"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nenum fsid_source fsid_source(struct svc_fh *fhp)\n{\n\tif (fhp->fh_handle.fh_version != 1)\n\t\treturn FSIDSOURCE_DEV;\n\tswitch(fhp->fh_handle.fh_fsid_type) {\n\tcase FSID_DEV:\n\tcase FSID_ENCODE_DEV:\n\tcase FSID_MAJOR_MINOR:\n\t\tif (exp_sb(fhp->fh_export)->s_type->fs_flags & FS_REQUIRES_DEV)\n\t\t\treturn FSIDSOURCE_DEV;\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\t\treturn FSIDSOURCE_FSID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t/* either a UUID type filehandle, or the filehandle doesn't\n\t * match the export.\n\t */\n\tif (fhp->fh_export->ex_flags & NFSEXP_FSID)\n\t\treturn FSIDSOURCE_FSID;\n\tif (fhp->fh_export->ex_uuid)\n\t\treturn FSIDSOURCE_UUID;\n\treturn FSIDSOURCE_DEV;\n}"
  },
  {
    "function_name": "SVCFH_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "647-661",
    "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d: %08x %08x %08x %08x %08x %08x\"",
            "fh->fh_size",
            "fh->fh_base.fh_pad[0]",
            "fh->fh_base.fh_pad[1]",
            "fh->fh_base.fh_pad[2]",
            "fh->fh_base.fh_pad[3]",
            "fh->fh_base.fh_pad[4]",
            "fh->fh_base.fh_pad[5]"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
  },
  {
    "function_name": "fh_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "625-642",
    "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_drop_write",
          "args": [
            "fhp"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "fh_drop_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
          "lines": "121-127",
          "snippet": "static inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}",
          "includes": [
            "#include \"nfsd.h\"",
            "#include \"nfsfh.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fh_clear_wcc",
          "args": [
            "fhp"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "fh_clear_wcc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "236-241",
          "snippet": "static inline void\nfh_clear_wcc(struct svc_fh *fhp)\n{\n\tfhp->fh_post_saved = false;\n\tfhp->fh_pre_saved = false;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_clear_wcc(struct svc_fh *fhp)\n{\n\tfhp->fh_post_saved = false;\n\tfhp->fh_pre_saved = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fh_unlock",
          "args": [
            "fhp"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "fh_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "305-313",
          "snippet": "static inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tinode_unlock(d_inode(fhp->fh_dentry));\n\t\tfhp->fh_locked = false;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void\nfh_unlock(struct svc_fh *fhp)\n{\n\tif (fhp->fh_locked) {\n\t\tfill_post_wcc(fhp);\n\t\tinode_unlock(d_inode(fhp->fh_dentry));\n\t\tfhp->fh_locked = false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "fh_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "591-620",
    "snippet": "__be32\nfh_update(struct svc_fh *fhp)\n{\n\tstruct dentry *dentry;\n\n\tif (!fhp->fh_dentry)\n\t\tgoto out_bad;\n\n\tdentry = fhp->fh_dentry;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out_negative;\n\tif (fhp->fh_handle.fh_version != 1) {\n\t\t_fh_update_old(dentry, fhp->fh_export, &fhp->fh_handle);\n\t} else {\n\t\tif (fhp->fh_handle.fh_fileid_type != FILEID_ROOT)\n\t\t\treturn 0;\n\n\t\t_fh_update(fhp, fhp->fh_export, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID)\n\t\t\treturn nfserr_opnotsupp;\n\t}\n\treturn 0;\nout_bad:\n\tprintk(KERN_ERR \"fh_update: fh not verified!\\n\");\n\treturn nfserr_serverfault;\nout_negative:\n\tprintk(KERN_ERR \"fh_update: %pd2 still negative!\\n\",\n\t\tdentry);\n\treturn nfserr_serverfault;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fh_update: %pd2 still negative!\\n\"",
            "dentry"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fh_update: fh not verified!\\n\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_fh_update",
          "args": [
            "fhp",
            "fhp->fh_export",
            "dentry"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "_fh_update_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "411-420",
          "snippet": "static inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);\n\tfh->ofh_generation = d_inode(dentry)->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);\n\tfh->ofh_generation = d_inode(dentry)->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_really_is_negative",
          "args": [
            "dentry"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_update(struct svc_fh *fhp)\n{\n\tstruct dentry *dentry;\n\n\tif (!fhp->fh_dentry)\n\t\tgoto out_bad;\n\n\tdentry = fhp->fh_dentry;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out_negative;\n\tif (fhp->fh_handle.fh_version != 1) {\n\t\t_fh_update_old(dentry, fhp->fh_export, &fhp->fh_handle);\n\t} else {\n\t\tif (fhp->fh_handle.fh_fileid_type != FILEID_ROOT)\n\t\t\treturn 0;\n\n\t\t_fh_update(fhp, fhp->fh_export, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID)\n\t\t\treturn nfserr_opnotsupp;\n\t}\n\treturn 0;\nout_bad:\n\tprintk(KERN_ERR \"fh_update: fh not verified!\\n\");\n\treturn nfserr_serverfault;\nout_negative:\n\tprintk(KERN_ERR \"fh_update: %pd2 still negative!\\n\",\n\t\tdentry);\n\treturn nfserr_serverfault;\n}"
  },
  {
    "function_name": "fh_compose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "511-585",
    "snippet": "__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fh_put",
          "args": [
            "fhp"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "fh_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "625-642",
          "snippet": "void\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nvoid\nfh_put(struct svc_fh *fhp)\n{\n\tstruct dentry * dentry = fhp->fh_dentry;\n\tstruct svc_export * exp = fhp->fh_export;\n\tif (dentry) {\n\t\tfh_unlock(fhp);\n\t\tfhp->fh_dentry = NULL;\n\t\tdput(dentry);\n\t\tfh_clear_wcc(fhp);\n\t}\n\tfh_drop_write(fhp);\n\tif (exp) {\n\t\texp_put(exp);\n\t\tfhp->fh_export = NULL;\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_fh_update",
          "args": [
            "fhp",
            "exp",
            "dentry"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "_fh_update_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "411-420",
          "snippet": "static inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);\n\tfh->ofh_generation = d_inode(dentry)->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);\n\tfh->ofh_generation = d_inode(dentry)->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_fsid",
          "args": [
            "fhp->fh_handle.fh_fsid_type",
            "fhp->fh_handle.fh_fsid",
            "ex_dev",
            "d_inode(exp->ex_path.dentry)->i_ino",
            "exp->ex_fsid",
            "exp->ex_uuid"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "mk_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "87-137",
          "snippet": "static inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "exp->ex_path.dentry"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "fhp->fh_handle.fh_fsid_type"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ino_t_to_u32",
          "args": [
            "parent_ino(dentry)"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ino_t_to_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "14-17",
          "snippet": "static inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_ino",
          "args": [
            "dentry"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "exp->ex_path.dentry"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "ex_dev"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fhp->fh_handle.fh_base",
            "0",
            "NFS_FHSIZE"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_get",
          "args": [
            "exp"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "exp_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "107-111",
          "snippet": "static inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline struct svc_export *exp_get(struct svc_export *exp)\n{\n\tcache_get(&exp->h);\n\treturn exp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\"",
            "fhp->fh_maxsize",
            "dentry"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\"",
            "dentry"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_version_and_fsid_type",
          "args": [
            "fhp",
            "exp",
            "ref_fh"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "set_version_and_fsid_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "457-509",
          "snippet": "static void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\"",
            "MAJOR(ex_dev)",
            "MINOR(ex_dev)",
            "(long) d_inode(exp->ex_path.dentry)->i_ino",
            "dentry",
            "(inode ? inode->i_ino : 0)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "exp->ex_path.dentry"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "ex_dev"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "ex_dev"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "exp"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_compose(struct svc_fh *fhp, struct svc_export *exp, struct dentry *dentry,\n\t   struct svc_fh *ref_fh)\n{\n\t/* ref_fh is a reference file handle.\n\t * if it is non-null and for the same filesystem, then we should compose\n\t * a filehandle which is of the same version, where possible.\n\t * Currently, that means that if ref_fh->fh_handle.fh_version == 0xca\n\t * Then create a 32byte filehandle using nfs_fhbase_old\n\t *\n\t */\n\n\tstruct inode * inode = d_inode(dentry);\n\tdev_t ex_dev = exp_sb(exp)->s_dev;\n\n\tdprintk(\"nfsd: fh_compose(exp %02x:%02x/%ld %pd2, ino=%ld)\\n\",\n\t\tMAJOR(ex_dev), MINOR(ex_dev),\n\t\t(long) d_inode(exp->ex_path.dentry)->i_ino,\n\t\tdentry,\n\t\t(inode ? inode->i_ino : 0));\n\n\t/* Choose filehandle version and fsid type based on\n\t * the reference filehandle (if it is in the same export)\n\t * or the export options.\n\t */\n\t set_version_and_fsid_type(fhp, exp, ref_fh);\n\n\tif (ref_fh == fhp)\n\t\tfh_put(ref_fh);\n\n\tif (fhp->fh_locked || fhp->fh_dentry) {\n\t\tprintk(KERN_ERR \"fh_compose: fh %pd2 not initialized!\\n\",\n\t\t       dentry);\n\t}\n\tif (fhp->fh_maxsize < NFS_FHSIZE)\n\t\tprintk(KERN_ERR \"fh_compose: called with maxsize %d! %pd2\\n\",\n\t\t       fhp->fh_maxsize,\n\t\t       dentry);\n\n\tfhp->fh_dentry = dget(dentry); /* our internal copy */\n\tfhp->fh_export = exp_get(exp);\n\n\tif (fhp->fh_handle.fh_version == 0xca) {\n\t\t/* old style filehandle please */\n\t\tmemset(&fhp->fh_handle.fh_base, 0, NFS_FHSIZE);\n\t\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\t\tfhp->fh_handle.ofh_dcookie = 0xfeebbaca;\n\t\tfhp->fh_handle.ofh_dev =  old_encode_dev(ex_dev);\n\t\tfhp->fh_handle.ofh_xdev = fhp->fh_handle.ofh_dev;\n\t\tfhp->fh_handle.ofh_xino =\n\t\t\tino_t_to_u32(d_inode(exp->ex_path.dentry)->i_ino);\n\t\tfhp->fh_handle.ofh_dirino = ino_t_to_u32(parent_ino(dentry));\n\t\tif (inode)\n\t\t\t_fh_update_old(dentry, exp, &fhp->fh_handle);\n\t} else {\n\t\tfhp->fh_handle.fh_size =\n\t\t\tkey_len(fhp->fh_handle.fh_fsid_type) + 4;\n\t\tfhp->fh_handle.fh_auth_type = 0;\n\n\t\tmk_fsid(fhp->fh_handle.fh_fsid_type,\n\t\t\tfhp->fh_handle.fh_fsid,\n\t\t\tex_dev,\n\t\t\td_inode(exp->ex_path.dentry)->i_ino,\n\t\t\texp->ex_fsid, exp->ex_uuid);\n\n\t\tif (inode)\n\t\t\t_fh_update(fhp, exp, dentry);\n\t\tif (fhp->fh_handle.fh_fileid_type == FILEID_INVALID) {\n\t\t\tfh_put(fhp);\n\t\t\treturn nfserr_opnotsupp;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_version_and_fsid_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "457-509",
    "snippet": "static void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "exp_sb(exp)->s_dev"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "exp"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_root_export",
          "args": [
            "exp"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "422-425",
          "snippet": "static bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsid_type_ok_for_exp",
          "args": [
            "fsid_type",
            "exp"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "fsid_type_ok_for_exp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "432-454",
          "snippet": "static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic void set_version_and_fsid_type(struct svc_fh *fhp, struct svc_export *exp, struct svc_fh *ref_fh)\n{\n\tu8 version;\n\tu8 fsid_type;\nretry:\n\tversion = 1;\n\tif (ref_fh && ref_fh->fh_export == exp) {\n\t\tversion = ref_fh->fh_handle.fh_version;\n\t\tfsid_type = ref_fh->fh_handle.fh_fsid_type;\n\n\t\tref_fh = NULL;\n\n\t\tswitch (version) {\n\t\tcase 0xca:\n\t\t\tfsid_type = FSID_DEV;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto retry;\n\t\t}\n\n\t\t/*\n\t\t * As the fsid -> filesystem mapping was guided by\n\t\t * user-space, there is no guarantee that the filesystem\n\t\t * actually supports that fsid type. If it doesn't we\n\t\t * loop around again without ref_fh set.\n\t\t */\n\t\tif (!fsid_type_ok_for_exp(fsid_type, exp))\n\t\t\tgoto retry;\n\t} else if (exp->ex_flags & NFSEXP_FSID) {\n\t\tfsid_type = FSID_NUM;\n\t} else if (exp->ex_uuid) {\n\t\tif (fhp->fh_maxsize >= 64) {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID16;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID16_INUM;\n\t\t} else {\n\t\t\tif (is_root_export(exp))\n\t\t\t\tfsid_type = FSID_UUID8;\n\t\t\telse\n\t\t\t\tfsid_type = FSID_UUID4_INUM;\n\t\t}\n\t} else if (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t/* for newer device numbers, we must use a newer fsid format */\n\t\tfsid_type = FSID_ENCODE_DEV;\n\telse\n\t\tfsid_type = FSID_DEV;\n\tfhp->fh_handle.fh_version = version;\n\tif (version)\n\t\tfhp->fh_handle.fh_fsid_type = fsid_type;\n}"
  },
  {
    "function_name": "fsid_type_ok_for_exp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "432-454",
    "snippet": "static bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_export",
          "args": [
            "exp"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "422-425",
          "snippet": "static bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exp_sb",
          "args": [
            "exp"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "exp_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "427-430",
          "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_valid_dev",
          "args": [
            "exp_sb(exp)->s_dev"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool fsid_type_ok_for_exp(u8 fsid_type, struct svc_export *exp)\n{\n\tswitch (fsid_type) {\n\tcase FSID_DEV:\n\t\tif (!old_valid_dev(exp_sb(exp)->s_dev))\n\t\t\treturn 0;\n\t\t/* FALL THROUGH */\n\tcase FSID_MAJOR_MINOR:\n\tcase FSID_ENCODE_DEV:\n\t\treturn exp_sb(exp)->s_type->fs_flags & FS_REQUIRES_DEV;\n\tcase FSID_NUM:\n\t\treturn exp->ex_flags & NFSEXP_FSID;\n\tcase FSID_UUID8:\n\tcase FSID_UUID16:\n\t\tif (!is_root_export(exp))\n\t\t\treturn 0;\n\t\t/* fall through */\n\tcase FSID_UUID4_INUM:\n\tcase FSID_UUID16_INUM:\n\t\treturn exp->ex_uuid != NULL;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "exp_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "427-430",
    "snippet": "static struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic struct super_block *exp_sb(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry->d_sb;\n}"
  },
  {
    "function_name": "is_root_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "422-425",
    "snippet": "static bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic bool is_root_export(struct svc_export *exp)\n{\n\treturn exp->ex_path.dentry == exp->ex_path.dentry->d_sb->s_root;\n}"
  },
  {
    "function_name": "_fh_update_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "411-420",
    "snippet": "static inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);\n\tfh->ofh_generation = d_inode(dentry)->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino_t_to_u32",
          "args": [
            "d_inode(dentry)->i_ino"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ino_t_to_u32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "14-17",
          "snippet": "static inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline __u32 ino_t_to_u32(ino_t ino)\n{\n\treturn (__u32) ino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline void _fh_update_old(struct dentry *dentry,\n\t\t\t\t  struct svc_export *exp,\n\t\t\t\t  struct knfsd_fh *fh)\n{\n\tfh->ofh_ino = ino_t_to_u32(d_inode(dentry)->i_ino);\n\tfh->ofh_generation = d_inode(dentry)->i_generation;\n\tif (d_is_dir(dentry) ||\n\t    (exp->ex_flags & NFSEXP_NOSUBTREECHECK))\n\t\tfh->ofh_dirino = 0;\n}"
  },
  {
    "function_name": "_fh_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "391-406",
    "snippet": "static void _fh_update(struct svc_fh *fhp, struct svc_export *exp,\n\t\tstruct dentry *dentry)\n{\n\tif (dentry != exp->ex_path.dentry) {\n\t\tstruct fid *fid = (struct fid *)\n\t\t\t(fhp->fh_handle.fh_fsid + fhp->fh_handle.fh_size/4 - 1);\n\t\tint maxsize = (fhp->fh_maxsize - fhp->fh_handle.fh_size)/4;\n\t\tint subtreecheck = !(exp->ex_flags & NFSEXP_NOSUBTREECHECK);\n\n\t\tfhp->fh_handle.fh_fileid_type =\n\t\t\texportfs_encode_fh(dentry, fid, &maxsize, subtreecheck);\n\t\tfhp->fh_handle.fh_size += maxsize * 4;\n\t} else {\n\t\tfhp->fh_handle.fh_fileid_type = FILEID_ROOT;\n\t}\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exportfs_encode_fh",
          "args": [
            "dentry",
            "fid",
            "&maxsize",
            "subtreecheck"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic void _fh_update(struct svc_fh *fhp, struct svc_export *exp,\n\t\tstruct dentry *dentry)\n{\n\tif (dentry != exp->ex_path.dentry) {\n\t\tstruct fid *fid = (struct fid *)\n\t\t\t(fhp->fh_handle.fh_fsid + fhp->fh_handle.fh_size/4 - 1);\n\t\tint maxsize = (fhp->fh_maxsize - fhp->fh_handle.fh_size)/4;\n\t\tint subtreecheck = !(exp->ex_flags & NFSEXP_NOSUBTREECHECK);\n\n\t\tfhp->fh_handle.fh_fileid_type =\n\t\t\texportfs_encode_fh(dentry, fid, &maxsize, subtreecheck);\n\t\tfhp->fh_handle.fh_size += maxsize * 4;\n\t} else {\n\t\tfhp->fh_handle.fh_fileid_type = FILEID_ROOT;\n\t}\n}"
  },
  {
    "function_name": "fh_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "303-381",
    "snippet": "__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\"",
            "dentry",
            "access",
            "ntohl(error)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "error"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_permission",
          "args": [
            "rqstp",
            "exp",
            "dentry",
            "access"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.c",
          "lines": "1952-2032",
          "snippet": "__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include \"idmap.h\"",
            "#include \"acl.h\"",
            "#include \"../internal.h\"",
            "#include \"xdr3.h\"",
            "#include <linux/security.h>",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/ima.h>",
            "#include <linux/jhash.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/delay.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/falloc.h>",
            "#include <linux/splice.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include \"idmap.h\"\n#include \"acl.h\"\n#include \"../internal.h\"\n#include \"xdr3.h\"\n#include <linux/security.h>\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/ima.h>\n#include <linux/jhash.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/fsnotify.h>\n#include <linux/delay.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/falloc.h>\n#include <linux/splice.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\n__be32\nnfsd_permission(struct svc_rqst *rqstp, struct svc_export *exp,\n\t\t\t\t\tstruct dentry *dentry, int acc)\n{\n\tstruct inode\t*inode = d_inode(dentry);\n\tint\t\terr;\n\n\tif ((acc & NFSD_MAY_MASK) == NFSD_MAY_NOP)\n\t\treturn 0;\n#if 0\n\tdprintk(\"nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s\\n\",\n\t\tacc,\n\t\t(acc & NFSD_MAY_READ)?\t\" read\"  : \"\",\n\t\t(acc & NFSD_MAY_WRITE)?\t\" write\" : \"\",\n\t\t(acc & NFSD_MAY_EXEC)?\t\" exec\"  : \"\",\n\t\t(acc & NFSD_MAY_SATTR)?\t\" sattr\" : \"\",\n\t\t(acc & NFSD_MAY_TRUNC)?\t\" trunc\" : \"\",\n\t\t(acc & NFSD_MAY_LOCK)?\t\" lock\"  : \"\",\n\t\t(acc & NFSD_MAY_OWNER_OVERRIDE)? \" owneroverride\" : \"\",\n\t\tinode->i_mode,\n\t\tIS_IMMUTABLE(inode)?\t\" immut\" : \"\",\n\t\tIS_APPEND(inode)?\t\" append\" : \"\",\n\t\t__mnt_is_readonly(exp->ex_path.mnt)?\t\" ro\" : \"\");\n\tdprintk(\"      owner %d/%d user %d/%d\\n\",\n\t\tinode->i_uid, inode->i_gid, current_fsuid(), current_fsgid());\n#endif\n\n\t/* Normally we reject any write/sattr etc access on a read-only file\n\t * system.  But if it is IRIX doing check on write-access for a \n\t * device special file, we ignore rofs.\n\t */\n\tif (!(acc & NFSD_MAY_LOCAL_ACCESS))\n\t\tif (acc & (NFSD_MAY_WRITE | NFSD_MAY_SATTR | NFSD_MAY_TRUNC)) {\n\t\t\tif (exp_rdonly(rqstp, exp) ||\n\t\t\t    __mnt_is_readonly(exp->ex_path.mnt))\n\t\t\t\treturn nfserr_rofs;\n\t\t\tif (/* (acc & NFSD_MAY_WRITE) && */ IS_IMMUTABLE(inode))\n\t\t\t\treturn nfserr_perm;\n\t\t}\n\tif ((acc & NFSD_MAY_TRUNC) && IS_APPEND(inode))\n\t\treturn nfserr_perm;\n\n\tif (acc & NFSD_MAY_LOCK) {\n\t\t/* If we cannot rely on authentication in NLM requests,\n\t\t * just allow locks, otherwise require read permission, or\n\t\t * ownership\n\t\t */\n\t\tif (exp->ex_flags & NFSEXP_NOAUTHNLM)\n\t\t\treturn 0;\n\t\telse\n\t\t\tacc = NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE;\n\t}\n\t/*\n\t * The file owner always gets access permission for accesses that\n\t * would normally be checked at open time. This is to make\n\t * file access work even when the client has done a fchmod(fd, 0).\n\t *\n\t * However, `cp foo bar' should fail nevertheless when bar is\n\t * readonly. A sensible way to do this might be to reject all\n\t * attempts to truncate a read-only file, because a creat() call\n\t * always implies file truncation.\n\t * ... but this isn't really fair.  A process may reasonably call\n\t * ftruncate on an open file descriptor on a file with perm 000.\n\t * We must trust the client to do permission checking - using \"ACCESS\"\n\t * with NFSv3.\n\t */\n\tif ((acc & NFSD_MAY_OWNER_OVERRIDE) &&\n\t    uid_eq(inode->i_uid, current_fsuid()))\n\t\treturn 0;\n\n\t/* This assumes  NFSD_MAY_{READ,WRITE,EXEC} == MAY_{READ,WRITE,EXEC} */\n\terr = inode_permission(inode, acc & (MAY_READ|MAY_WRITE|MAY_EXEC));\n\n\t/* Allow read access to binaries even when mode 111 */\n\tif (err == -EACCES && S_ISREG(inode->i_mode) &&\n\t     (acc == (NFSD_MAY_READ | NFSD_MAY_OWNER_OVERRIDE) ||\n\t      acc == (NFSD_MAY_READ | NFSD_MAY_READ_IF_EXEC)))\n\t\terr = inode_permission(inode, MAY_EXEC);\n\n\treturn err? nfserrno(err) : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_nfsd_access",
          "args": [
            "exp",
            "rqstp"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "check_nfsd_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "938-958",
          "snippet": "__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\n__be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\t/* legacy gss-only clients are always OK: */\n\tif (exp->ex_client == rqstp->rq_gssclient)\n\t\treturn 0;\n\t/* ip-address based client; check sec= export option: */\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn 0;\n\t}\n\t/* defaults in absence of sec= options: */\n\tif (exp->ex_nflavors == 0) {\n\t\tif (rqstp->rq_cred.cr_flavor == RPC_AUTH_NULL ||\n\t\t    rqstp->rq_cred.cr_flavor == RPC_AUTH_UNIX)\n\t\t\treturn 0;\n\t}\n\treturn nfserr_wrongsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_mode_check",
          "args": [
            "rqstp",
            "d_inode(dentry)->i_mode",
            "type"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_mode_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "61-81",
          "snippet": "static inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_setuser_and_check_port",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setuser_and_check_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "83-98",
          "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_pseudo_root",
          "args": [
            "rqstp",
            "dentry",
            "exp"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "check_pseudo_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "100-128",
          "snippet": "static inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_set_fh_dentry",
          "args": [
            "rqstp",
            "fhp"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_set_fh_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "135-274",
          "snippet": "static __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: fh_verify(%s)\\n\"",
            "SVCFH_fmt(fhp)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SVCFH_fmt",
          "args": [
            "fhp"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "SVCFH_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "647-661",
          "snippet": "char * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nchar * SVCFH_fmt(struct svc_fh *fhp)\n{\n\tstruct knfsd_fh *fh = &fhp->fh_handle;\n\n\tstatic char buf[80];\n\tsprintf(buf, \"%d: %08x %08x %08x %08x %08x %08x\",\n\t\tfh->fh_size,\n\t\tfh->fh_base.fh_pad[0],\n\t\tfh->fh_base.fh_pad[1],\n\t\tfh->fh_base.fh_pad[2],\n\t\tfh->fh_base.fh_pad[3],\n\t\tfh->fh_base.fh_pad[4],\n\t\tfh->fh_base.fh_pad[5]);\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\n__be32\nfh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type, int access)\n{\n\tstruct svc_export *exp;\n\tstruct dentry\t*dentry;\n\t__be32\t\terror;\n\n\tdprintk(\"nfsd: fh_verify(%s)\\n\", SVCFH_fmt(fhp));\n\n\tif (!fhp->fh_dentry) {\n\t\terror = nfsd_set_fh_dentry(rqstp, fhp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tdentry = fhp->fh_dentry;\n\texp = fhp->fh_export;\n\t/*\n\t * We still have to do all these permission checks, even when\n\t * fh_dentry is already set:\n\t * \t- fh_verify may be called multiple times with different\n\t * \t  \"access\" arguments (e.g. nfsd_proc_create calls\n\t * \t  fh_verify(...,NFSD_MAY_EXEC) first, then later (in\n\t * \t  nfsd_create) calls fh_verify(...,NFSD_MAY_CREATE).\n\t *\t- in the NFSv4 case, the filehandle may have been filled\n\t *\t  in by fh_compose, and given a dentry, but further\n\t *\t  compound operations performed with that filehandle\n\t *\t  still need permissions checks.  In the worst case, a\n\t *\t  mountpoint crossing may have changed the export\n\t *\t  options, and we may now need to use a different uid\n\t *\t  (for example, if different id-squashing options are in\n\t *\t  effect on the new filesystem).\n\t */\n\terror = check_pseudo_root(rqstp, dentry, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\tif (error)\n\t\tgoto out;\n\n\terror = nfsd_mode_check(rqstp, d_inode(dentry)->i_mode, type);\n\tif (error)\n\t\tgoto out;\n\n\t/*\n\t * pseudoflavor restrictions are not enforced on NLM,\n\t * which clients virtually always use auth_sys for,\n\t * even while using RPCSEC_GSS for NFS.\n\t */\n\tif (access & NFSD_MAY_LOCK || access & NFSD_MAY_BYPASS_GSS)\n\t\tgoto skip_pseudoflavor_check;\n\t/*\n\t * Clients may expect to be able to use auth_sys during mount,\n\t * even if they use gss for everything else; see section 2.3.2\n\t * of rfc 2623.\n\t */\n\tif (access & NFSD_MAY_BYPASS_GSS_ON_ROOT\n\t\t\t&& exp->ex_path.dentry == dentry)\n\t\tgoto skip_pseudoflavor_check;\n\n\terror = check_nfsd_access(exp, rqstp);\n\tif (error)\n\t\tgoto out;\n\nskip_pseudoflavor_check:\n\t/* Finally, check access permissions. */\n\terror = nfsd_permission(rqstp, exp, dentry, access);\n\n\tif (error) {\n\t\tdprintk(\"fh_verify: %pd2 permission failure, \"\n\t\t\t\"acc=%x, error=%d\\n\",\n\t\t\tdentry,\n\t\t\taccess, ntohl(error));\n\t}\nout:\n\tif (error == nfserr_stale)\n\t\tnfsdstats.fh_stale++;\n\treturn error;\n}"
  },
  {
    "function_name": "nfsd_set_fh_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "135-274",
    "snippet": "static __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exp_put",
          "args": [
            "exp"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "exp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.h",
          "lines": "102-105",
          "snippet": "static inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}",
          "includes": [
            "#include <linux/nfs4.h>",
            "#include <uapi/linux/nfsd/export.h>",
            "#include <linux/sunrpc/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs4.h>\n#include <uapi/linux/nfsd/export.h>\n#include <linux/sunrpc/cache.h>\n\nstatic inline void exp_put(struct svc_export *exp)\n{\n\tcache_put(&exp->h, exp->cd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\"",
            "dentry"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "PTR_ERR(dentry)"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exportfs_decode_fh",
          "args": [
            "exp->ex_path.mnt",
            "fid",
            "data_left",
            "fileid_type",
            "nfsd_acceptable",
            "exp"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "exp->ex_path.dentry"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_setuser_and_check_port",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setuser_and_check_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "83-98",
          "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"vfs.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "new"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override_creds(new)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "new"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_raise_nfsd_set",
          "args": [
            "new->cap_effective",
            "new->cap_permitted"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "exp"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "exp"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rqst_exp_find",
          "args": [
            "rqstp",
            "FSID_DEV",
            "tfh"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "rqst_exp_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/export.c",
          "lines": "1000-1031",
          "snippet": "struct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_export *svc_export_lookup(struct svc_export *);",
            "static void show_secinfo(struct seq_file *m, struct svc_export *exp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_export *svc_export_lookup(struct svc_export *);\nstatic void show_secinfo(struct seq_file *m, struct svc_export *exp);\n\nstruct svc_export *\nrqst_exp_find(struct svc_rqst *rqstp, int fsid_type, u32 *fsidv)\n{\n\tstruct svc_export *gssexp, *exp = ERR_PTR(-ENOENT);\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\tstruct cache_detail *cd = nn->svc_export_cache;\n\n\tif (rqstp->rq_client == NULL)\n\t\tgoto gss;\n\n\t/* First try the auth_unix client: */\n\texp = exp_find(cd, rqstp->rq_client, fsid_type,\n\t\t       fsidv, &rqstp->rq_chandle);\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\tgoto gss;\n\tif (IS_ERR(exp))\n\t\treturn exp;\n\t/* If it has secinfo, assume there are no gss/... clients */\n\tif (exp->ex_nflavors > 0)\n\t\treturn exp;\ngss:\n\t/* Otherwise, try falling back on gss client */\n\tif (rqstp->rq_gssclient == NULL)\n\t\treturn exp;\n\tgssexp = exp_find(cd, rqstp->rq_gssclient, fsid_type, fsidv,\n\t\t\t\t\t\t&rqstp->rq_chandle);\n\tif (PTR_ERR(gssexp) == -ENOENT)\n\t\treturn exp;\n\tif (!IS_ERR(exp))\n\t\texp_put(exp);\n\treturn gssexp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_fsid",
          "args": [
            "FSID_DEV",
            "tfh",
            "xdev",
            "xino",
            "0",
            "NULL"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "mk_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "87-137",
          "snippet": "static inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline void mk_fsid(int vers, u32 *fsidv, dev_t dev, ino_t ino,\n\t\t\t   u32 fsid, unsigned char *uuid)\n{\n\tu32 *up;\n\tswitch(vers) {\n\tcase FSID_DEV:\n\t\tfsidv[0] = (__force __u32)htonl((MAJOR(dev)<<16) |\n\t\t\t\t MINOR(dev));\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\tcase FSID_NUM:\n\t\tfsidv[0] = fsid;\n\t\tbreak;\n\tcase FSID_MAJOR_MINOR:\n\t\tfsidv[0] = (__force __u32)htonl(MAJOR(dev));\n\t\tfsidv[1] = (__force __u32)htonl(MINOR(dev));\n\t\tfsidv[2] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_ENCODE_DEV:\n\t\tfsidv[0] = new_encode_dev(dev);\n\t\tfsidv[1] = ino_t_to_u32(ino);\n\t\tbreak;\n\n\tcase FSID_UUID4_INUM:\n\t\t/* 4 byte fsid and inode number */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = ino_t_to_u32(ino);\n\t\tfsidv[1] = up[0] ^ up[1] ^ up[2] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID8:\n\t\t/* 8 byte fsid  */\n\t\tup = (u32*)uuid;\n\t\tfsidv[0] = up[0] ^ up[2];\n\t\tfsidv[1] = up[1] ^ up[3];\n\t\tbreak;\n\n\tcase FSID_UUID16:\n\t\t/* 16 byte fsid - NFSv3+ only */\n\t\tmemcpy(fsidv, uuid, 16);\n\t\tbreak;\n\n\tcase FSID_UUID16_INUM:\n\t\t/* 8 byte inode and 16 byte fsid */\n\t\t*(u64*)fsidv = (u64)ino;\n\t\tmemcpy(fsidv+2, uuid, 16);\n\t\tbreak;\n\tdefault: BUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "u32_to_ino_t",
          "args": [
            "fh->ofh_xino"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "u32_to_ino_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "19-22",
          "snippet": "static inline ino_t u32_to_ino_t(__u32 uino)\n{\n\treturn (ino_t) uino;\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline ino_t u32_to_ino_t(__u32 uino)\n{\n\treturn (ino_t) uino;\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "fh->ofh_xdev"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1]))"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "ntohl((__force __be32)fh->fh_fsid[0])",
            "ntohl((__force __be32)fh->fh_fsid[1])"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "(__force __be32)fh->fh_fsid[1]"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "(__force __be32)fh->fh_fsid[0]"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_len",
          "args": [
            "FSID_ENCODE_DEV"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "key_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.h",
          "lines": "139-152",
          "snippet": "static inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}",
          "includes": [
            "#include <uapi/linux/nfsd/nfsfh.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/crc32.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/nfsd/nfsfh.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/crc32.h>\n\nstatic inline int key_len(int type)\n{\n\tswitch(type) {\n\tcase FSID_DEV:\t\treturn 8;\n\tcase FSID_NUM: \t\treturn 4;\n\tcase FSID_MAJOR_MINOR:\treturn 12;\n\tcase FSID_ENCODE_DEV:\treturn 8;\n\tcase FSID_UUID4_INUM:\treturn 8;\n\tcase FSID_UUID8:\treturn 8;\n\tcase FSID_UUID16:\treturn 16;\n\tcase FSID_UUID16_INUM:\treturn 24;\n\tdefault: return 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)\n{\n\tstruct knfsd_fh\t*fh = &fhp->fh_handle;\n\tstruct fid *fid = NULL, sfid;\n\tstruct svc_export *exp;\n\tstruct dentry *dentry;\n\tint fileid_type;\n\tint data_left = fh->fh_size/4;\n\t__be32 error;\n\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\tif (rqstp->rq_vers == 4 && fh->fh_size == 0)\n\t\treturn nfserr_nofilehandle;\n\n\tif (fh->fh_version == 1) {\n\t\tint len;\n\n\t\tif (--data_left < 0)\n\t\t\treturn error;\n\t\tif (fh->fh_auth_type != 0)\n\t\t\treturn error;\n\t\tlen = key_len(fh->fh_fsid_type) / 4;\n\t\tif (len == 0)\n\t\t\treturn error;\n\t\tif  (fh->fh_fsid_type == FSID_MAJOR_MINOR) {\n\t\t\t/* deprecated, convert to type 3 */\n\t\t\tlen = key_len(FSID_ENCODE_DEV)/4;\n\t\t\tfh->fh_fsid_type = FSID_ENCODE_DEV;\n\t\t\t/*\n\t\t\t * struct knfsd_fh uses host-endian fields, which are\n\t\t\t * sometimes used to hold net-endian values. This\n\t\t\t * confuses sparse, so we must use __force here to\n\t\t\t * keep it from complaining.\n\t\t\t */\n\t\t\tfh->fh_fsid[0] = new_encode_dev(MKDEV(ntohl((__force __be32)fh->fh_fsid[0]),\n\t\t\t\t\t\t\tntohl((__force __be32)fh->fh_fsid[1])));\n\t\t\tfh->fh_fsid[1] = fh->fh_fsid[2];\n\t\t}\n\t\tdata_left -= len;\n\t\tif (data_left < 0)\n\t\t\treturn error;\n\t\texp = rqst_exp_find(rqstp, fh->fh_fsid_type, fh->fh_fsid);\n\t\tfid = (struct fid *)(fh->fh_fsid + len);\n\t} else {\n\t\t__u32 tfh[2];\n\t\tdev_t xdev;\n\t\tino_t xino;\n\n\t\tif (fh->fh_size != NFS_FHSIZE)\n\t\t\treturn error;\n\t\t/* assume old filehandle format */\n\t\txdev = old_decode_dev(fh->ofh_xdev);\n\t\txino = u32_to_ino_t(fh->ofh_xino);\n\t\tmk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);\n\t\texp = rqst_exp_find(rqstp, FSID_DEV, tfh);\n\t}\n\n\terror = nfserr_stale;\n\tif (PTR_ERR(exp) == -ENOENT)\n\t\treturn error;\n\n\tif (IS_ERR(exp))\n\t\treturn nfserrno(PTR_ERR(exp));\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK) {\n\t\t/* Elevate privileges so that the lack of 'r' or 'x'\n\t\t * permission on some parent directory will\n\t\t * not stop exportfs_decode_fh from being able\n\t\t * to reconnect a directory into the dentry cache.\n\t\t * The same problem can affect \"SUBTREECHECK\" exports,\n\t\t * but as nfsd_acceptable depends on correct\n\t\t * access control settings being in effect, we cannot\n\t\t * fix that case easily.\n\t\t */\n\t\tstruct cred *new = prepare_creds();\n\t\tif (!new) {\n\t\t\terror =  nfserrno(-ENOMEM);\n\t\t\tgoto out;\n\t\t}\n\t\tnew->cap_effective =\n\t\t\tcap_raise_nfsd_set(new->cap_effective,\n\t\t\t\t\t   new->cap_permitted);\n\t\tput_cred(override_creds(new));\n\t\tput_cred(new);\n\t} else {\n\t\terror = nfsd_setuser_and_check_port(rqstp, exp);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Look up the dentry using the NFS file handle.\n\t */\n\terror = nfserr_stale;\n\tif (rqstp->rq_vers > 2)\n\t\terror = nfserr_badhandle;\n\n\tif (fh->fh_version != 1) {\n\t\tsfid.i32.ino = fh->ofh_ino;\n\t\tsfid.i32.gen = fh->ofh_generation;\n\t\tsfid.i32.parent_ino = fh->ofh_dirino;\n\t\tfid = &sfid;\n\t\tdata_left = 3;\n\t\tif (fh->ofh_dirino == 0)\n\t\t\tfileid_type = FILEID_INO32_GEN;\n\t\telse\n\t\t\tfileid_type = FILEID_INO32_GEN_PARENT;\n\t} else\n\t\tfileid_type = fh->fh_fileid_type;\n\n\tif (fileid_type == FILEID_ROOT)\n\t\tdentry = dget(exp->ex_path.dentry);\n\telse {\n\t\tdentry = exportfs_decode_fh(exp->ex_path.mnt, fid,\n\t\t\t\tdata_left, fileid_type,\n\t\t\t\tnfsd_acceptable, exp);\n\t}\n\tif (dentry == NULL)\n\t\tgoto out;\n\tif (IS_ERR(dentry)) {\n\t\tif (PTR_ERR(dentry) != -EINVAL)\n\t\t\terror = nfserrno(PTR_ERR(dentry));\n\t\tgoto out;\n\t}\n\n\tif (d_is_dir(dentry) &&\n\t\t\t(dentry->d_flags & DCACHE_DISCONNECTED)) {\n\t\tprintk(\"nfsd: find_fh_dentry returned a DISCONNECTED directory: %pd2\\n\",\n\t\t\t\tdentry);\n\t}\n\n\tfhp->fh_dentry = dentry;\n\tfhp->fh_export = exp;\n\treturn 0;\nout:\n\texp_put(exp);\n\treturn error;\n}"
  },
  {
    "function_name": "check_pseudo_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "100-128",
    "snippet": "static inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry != exp->ex_path.dentry"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_symlink",
          "args": [
            "dentry"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd_v4client",
          "args": [
            "rqstp"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_v4client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsd.h",
          "lines": "108-111",
          "snippet": "static inline int nfsd_v4client(struct svc_rqst *rq)\n{\n\treturn rq->rq_prog == NFS_PROGRAM && rq->rq_vers == 4;\n}",
          "includes": [
            "#include \"export.h\"",
            "#include \"stats.h\"",
            "#include <uapi/linux/nfsd/debug.h>",
            "#include <linux/sunrpc/msg_prot.h>",
            "#include <linux/sunrpc/svc.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs3.h>",
            "#include <linux/nfs2.h>",
            "#include <linux/nfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"export.h\"\n#include \"stats.h\"\n#include <uapi/linux/nfsd/debug.h>\n#include <linux/sunrpc/msg_prot.h>\n#include <linux/sunrpc/svc.h>\n#include <linux/nfs4.h>\n#include <linux/nfs3.h>\n#include <linux/nfs2.h>\n#include <linux/nfs.h>\n#include <linux/mount.h>\n#include <linux/types.h>\n\nstatic inline int nfsd_v4client(struct svc_rqst *rq)\n{\n\treturn rq->rq_prog == NFS_PROGRAM && rq->rq_vers == 4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32 check_pseudo_root(struct svc_rqst *rqstp,\n\tstruct dentry *dentry, struct svc_export *exp)\n{\n\tif (!(exp->ex_flags & NFSEXP_V4ROOT))\n\t\treturn nfs_ok;\n\t/*\n\t * v2/v3 clients have no need for the V4ROOT export--they use\n\t * the mount protocl instead; also, further V4ROOT checks may be\n\t * in v4-specific code, in which case v2/v3 clients could bypass\n\t * them.\n\t */\n\tif (!nfsd_v4client(rqstp))\n\t\treturn nfserr_stale;\n\t/*\n\t * We're exposing only the directories and symlinks that have to be\n\t * traversed on the way to real exports:\n\t */\n\tif (unlikely(!d_is_dir(dentry) &&\n\t\t     !d_is_symlink(dentry)))\n\t\treturn nfserr_stale;\n\t/*\n\t * A pseudoroot export gives permission to access only one\n\t * single directory; the kernel has to make another upcall\n\t * before granting access to anything else under it:\n\t */\n\tif (unlikely(dentry != exp->ex_path.dentry))\n\t\treturn nfserr_stale;\n\treturn nfs_ok;\n}"
  },
  {
    "function_name": "nfsd_setuser_and_check_port",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "83-98",
    "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "nfsd_setuser(rqstp, exp)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd_setuser",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd_setuser_and_check_port",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
          "lines": "83-98",
          "snippet": "static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd: request from insecure port %s!\\n\"",
            "svc_print_addr(rqstp, buf, sizeof(buf))"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_print_addr",
          "args": [
            "rqstp",
            "buf",
            "sizeof(buf)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RQ_SECURE",
            "&rqstp->rq_flags"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsexp_flags",
          "args": [
            "rqstp",
            "exp"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "nfsexp_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/auth.c",
          "lines": "7-18",
          "snippet": "int nfsexp_flags(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn f->flags;\n\t}\n\treturn exp->ex_flags;\n\n}",
          "includes": [
            "#include \"auth.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"auth.h\"\n#include \"nfsd.h\"\n#include <linux/sched.h>\n\nint nfsexp_flags(struct svc_rqst *rqstp, struct svc_export *exp)\n{\n\tstruct exp_flavor_info *f;\n\tstruct exp_flavor_info *end = exp->ex_flavors + exp->ex_nflavors;\n\n\tfor (f = exp->ex_flavors; f < end; f++) {\n\t\tif (f->pseudoflavor == rqstp->rq_cred.cr_flavor)\n\t\t\treturn f->flags;\n\t}\n\treturn exp->ex_flags;\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,\n\t\t\t\t\t  struct svc_export *exp)\n{\n\tint flags = nfsexp_flags(rqstp, exp);\n\n\t/* Check if the request originated from a secure port. */\n\tif (!test_bit(RQ_SECURE, &rqstp->rq_flags) && !(flags & NFSEXP_INSECURE_PORT)) {\n\t\tRPC_IFDEBUG(char buf[RPC_MAX_ADDRBUFLEN]);\n\t\tdprintk(\"nfsd: request from insecure port %s!\\n\",\n\t\t        svc_print_addr(rqstp, buf, sizeof(buf)));\n\t\treturn nfserr_perm;\n\t}\n\n\t/* Set user creds for this exportpoint */\n\treturn nfserrno(nfsd_setuser(rqstp, exp));\n}"
  },
  {
    "function_name": "nfsd_mode_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "61-81",
    "snippet": "static inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic inline __be32\nnfsd_mode_check(struct svc_rqst *rqstp, umode_t mode, umode_t requested)\n{\n\tmode &= S_IFMT;\n\n\tif (requested == 0) /* the caller doesn't care */\n\t\treturn nfs_ok;\n\tif (mode == requested)\n\t\treturn nfs_ok;\n\t/*\n\t * v4 has an error more specific than err_notdir which we should\n\t * return in preference to err_notdir:\n\t */\n\tif (rqstp->rq_vers == 4 && mode == S_IFLNK)\n\t\treturn nfserr_symlink;\n\tif (requested == S_IFDIR)\n\t\treturn nfserr_notdir;\n\tif (mode == S_IFDIR)\n\t\treturn nfserr_isdir;\n\treturn nfserr_inval;\n}"
  },
  {
    "function_name": "nfsd_acceptable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsfh.c",
    "lines": "26-54",
    "snippet": "static int nfsd_acceptable(void *expv, struct dentry *dentry)\n{\n\tstruct svc_export *exp = expv;\n\tint rv;\n\tstruct dentry *tdentry;\n\tstruct dentry *parent;\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\treturn 1;\n\n\ttdentry = dget(dentry);\n\twhile (tdentry != exp->ex_path.dentry && !IS_ROOT(tdentry)) {\n\t\t/* make sure parents give x permission to user */\n\t\tint err;\n\t\tparent = dget_parent(tdentry);\n\t\terr = inode_permission(d_inode(parent), MAY_EXEC);\n\t\tif (err < 0) {\n\t\t\tdput(parent);\n\t\t\tbreak;\n\t\t}\n\t\tdput(tdentry);\n\t\ttdentry = parent;\n\t}\n\tif (tdentry != exp->ex_path.dentry)\n\t\tdprintk(\"nfsd_acceptable failed at %p %pd\\n\", tdentry, tdentry);\n\trv = (tdentry == exp->ex_path.dentry);\n\tdput(tdentry);\n\treturn rv;\n}",
    "includes": [
      "#include \"auth.h\"",
      "#include \"vfs.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/sunrpc/svcauth_gss.h>",
      "#include <linux/exportfs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "tdentry"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"nfsd_acceptable failed at %p %pd\\n\"",
            "tdentry",
            "tdentry"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "tdentry"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "d_inode(parent)",
            "MAY_EXEC"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "parent"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "tdentry"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "tdentry"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"auth.h\"\n#include \"vfs.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/exportfs.h>\n\nstatic int nfsd_acceptable(void *expv, struct dentry *dentry)\n{\n\tstruct svc_export *exp = expv;\n\tint rv;\n\tstruct dentry *tdentry;\n\tstruct dentry *parent;\n\n\tif (exp->ex_flags & NFSEXP_NOSUBTREECHECK)\n\t\treturn 1;\n\n\ttdentry = dget(dentry);\n\twhile (tdentry != exp->ex_path.dentry && !IS_ROOT(tdentry)) {\n\t\t/* make sure parents give x permission to user */\n\t\tint err;\n\t\tparent = dget_parent(tdentry);\n\t\terr = inode_permission(d_inode(parent), MAY_EXEC);\n\t\tif (err < 0) {\n\t\t\tdput(parent);\n\t\t\tbreak;\n\t\t}\n\t\tdput(tdentry);\n\t\ttdentry = parent;\n\t}\n\tif (tdentry != exp->ex_path.dentry)\n\t\tdprintk(\"nfsd_acceptable failed at %p %pd\\n\", tdentry, tdentry);\n\trv = (tdentry == exp->ex_path.dentry);\n\tdput(tdentry);\n\treturn rv;\n}"
  }
]