[
  {
    "function_name": "unregister_cld_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1558-1562",
    "snippet": "void\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_pipefs_notifier_unregister",
          "args": [
            "&nfsd4_cld_block"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nvoid\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}"
  },
  {
    "function_name": "register_cld_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1552-1556",
    "snippet": "int\nregister_cld_notifier(void)\n{\n\treturn rpc_pipefs_notifier_register(&nfsd4_cld_block);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_pipefs_notifier_register",
          "args": [
            "&nfsd4_cld_block"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nint\nregister_cld_notifier(void)\n{\n\treturn rpc_pipefs_notifier_register(&nfsd4_cld_block);\n}"
  },
  {
    "function_name": "rpc_pipefs_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1509-1546",
    "snippet": "static int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_unregister_sb",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_unregister_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "793-798",
          "snippet": "static void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_register_sb",
          "args": [
            "sb",
            "cn->cn_pipe"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_register_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "780-791",
          "snippet": "static struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define NFSD_CLD_PIPE\t\t\"cld\"",
            "#define NFSD_PIPE_DIR\t\t\"nfsd\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define NFSD_CLD_PIPE\t\t\"cld\"\n#define NFSD_PIPE_DIR\t\t\"nfsd\"\n\nstatic struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_record_grace_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1502-1507",
    "snippet": "void\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->grace_done",
          "args": [
            "nn"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}"
  },
  {
    "function_name": "nfsd4_client_record_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1491-1500",
    "snippet": "int\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->check",
          "args": [
            "clp"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nint\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "nfsd4_client_record_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1482-1489",
    "snippet": "void\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->remove",
          "args": [
            "clp"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}"
  },
  {
    "function_name": "nfsd4_client_record_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1473-1480",
    "snippet": "void\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->create",
          "args": [
            "clp"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}"
  },
  {
    "function_name": "nfsd4_client_tracking_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1461-1471",
    "snippet": "void\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->exit",
          "args": [
            "net"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}"
  },
  {
    "function_name": "nfsd4_client_tracking_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1413-1459",
    "snippet": "int\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};",
      "static const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};",
      "static const struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\"",
            "status"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->init",
          "args": [
            "net"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\""
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "path.dentry"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "nfs4_recoverydir()",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_recoverydir",
          "args": [],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "605-609",
          "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->init",
          "args": [
            "net"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic const struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};\nstatic const struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};\nstatic const struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};\n\nint\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_grace_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1392-1402",
    "snippet": "static void\nnfsd4_umh_cltrack_grace_done(struct nfsd_net *nn)\n{\n\tchar *legacy;\n\tchar timestr[22]; /* FIXME: better way to determine max size? */\n\n\tsprintf(timestr, \"%ld\", nn->boot_time);\n\tlegacy = nfsd4_cltrack_legacy_topdir();\n\tnfsd4_umh_cltrack_upcall(\"gracedone\", timestr, legacy, NULL);\n\tkfree(legacy);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "legacy"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"gracedone\"",
            "timestr",
            "legacy",
            "NULL"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1197-1238",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_legacy_topdir",
          "args": [],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_legacy_topdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1084-1110",
          "snippet": "static char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\""
          ],
          "globals_used": [
            "static bool cltrack_legacy_disable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "timestr",
            "\"%ld\"",
            "nn->boot_time"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_umh_cltrack_grace_done(struct nfsd_net *nn)\n{\n\tchar *legacy;\n\tchar timestr[22]; /* FIXME: better way to determine max size? */\n\n\tsprintf(timestr, \"%ld\", nn->boot_time);\n\tlegacy = nfsd4_cltrack_legacy_topdir();\n\tnfsd4_umh_cltrack_upcall(\"gracedone\", timestr, legacy, NULL);\n\tkfree(legacy);\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1358-1390",
    "snippet": "static int\nnfsd4_umh_cltrack_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tchar *hexid, *has_session, *legacy;\n\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tlegacy = nfsd4_cltrack_legacy_recdir(&clp->cl_name);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags)) {\n\t\tret = 0;\n\t} else {\n\t\tret = nfsd4_umh_cltrack_upcall(\"check\", hexid, has_session, legacy);\n\t\tif (ret == 0)\n\t\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\tnfsd4_cltrack_upcall_unlock(clp);\n\tkfree(has_session);\n\tkfree(legacy);\n\tkfree(hexid);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hexid"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "legacy"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "has_session"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_unlock",
          "args": [
            "clp"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1285-1292",
          "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"check\"",
            "hexid",
            "has_session",
            "legacy"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1197-1238",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_lock",
          "args": [
            "clp"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1278-1283",
          "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_legacy_recdir",
          "args": [
            "&clp->cl_name"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_legacy_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1112-1145",
          "snippet": "static char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\""
          ],
          "globals_used": [
            "static bool cltrack_legacy_disable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_client_has_session",
          "args": [
            "clp"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_client_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1147-1170",
          "snippet": "static char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\"\n\nstatic char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: can't allocate memory for upcall!\\n\"",
            "__func__"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_to_hex_dup",
          "args": [
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "bin_to_hex_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1240-1257",
          "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_umh_cltrack_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tchar *hexid, *has_session, *legacy;\n\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tlegacy = nfsd4_cltrack_legacy_recdir(&clp->cl_name);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags)) {\n\t\tret = 0;\n\t} else {\n\t\tret = nfsd4_umh_cltrack_upcall(\"check\", hexid, has_session, legacy);\n\t\tif (ret == 0)\n\t\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\tnfsd4_cltrack_upcall_unlock(clp);\n\tkfree(has_session);\n\tkfree(legacy);\n\tkfree(hexid);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1335-1356",
    "snippet": "static void\nnfsd4_umh_cltrack_remove(struct nfs4_client *clp)\n{\n\tchar *hexid;\n\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags) &&\n\t    nfsd4_umh_cltrack_upcall(\"remove\", hexid, NULL, NULL) == 0)\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(hexid);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hexid"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_unlock",
          "args": [
            "clp"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1285-1292",
          "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"remove\"",
            "hexid",
            "NULL",
            "NULL"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1197-1238",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_lock",
          "args": [
            "clp"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1278-1283",
          "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: can't allocate memory for upcall!\\n\"",
            "__func__"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_to_hex_dup",
          "args": [
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "bin_to_hex_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1240-1257",
          "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_umh_cltrack_remove(struct nfs4_client *clp)\n{\n\tchar *hexid;\n\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags) &&\n\t    nfsd4_umh_cltrack_upcall(\"remove\", hexid, NULL, NULL) == 0)\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(hexid);\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1294-1333",
    "snippet": "static void\nnfsd4_umh_cltrack_create(struct nfs4_client *clp)\n{\n\tchar *hexid, *has_session, *grace_start;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/*\n\t * With v4.0 clients, there's little difference in outcome between a\n\t * create and check operation, and we can end up calling into this\n\t * function multiple times per client (once for each openowner). So,\n\t * for v4.0 clients skip upcalling once the client has been recorded\n\t * on stable storage.\n\t *\n\t * For v4.1+ clients, the outcome of the two operations is different,\n\t * so we must ensure that we upcall for the create operation. v4.1+\n\t * clients call this on RECLAIM_COMPLETE though, so we should only end\n\t * up doing a single create upcall per client.\n\t */\n\tif (clp->cl_minorversion == 0 &&\n\t    test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tgrace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (!nfsd4_umh_cltrack_upcall(\"create\", hexid, has_session, grace_start))\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(has_session);\n\tkfree(grace_start);\n\tkfree(hexid);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hexid"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "grace_start"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "has_session"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_unlock",
          "args": [
            "clp"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1285-1292",
          "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"create\"",
            "hexid",
            "has_session",
            "grace_start"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1197-1238",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_lock",
          "args": [
            "clp"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1278-1283",
          "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_grace_start",
          "args": [
            "nn->boot_time"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_grace_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1172-1195",
          "snippet": "static char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\"\n\nstatic char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_client_has_session",
          "args": [
            "clp"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_client_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1147-1170",
          "snippet": "static char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\"\n\nstatic char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: can't allocate memory for upcall!\\n\"",
            "__func__"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_to_hex_dup",
          "args": [
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "bin_to_hex_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1240-1257",
          "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_umh_cltrack_create(struct nfs4_client *clp)\n{\n\tchar *hexid, *has_session, *grace_start;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/*\n\t * With v4.0 clients, there's little difference in outcome between a\n\t * create and check operation, and we can end up calling into this\n\t * function multiple times per client (once for each openowner). So,\n\t * for v4.0 clients skip upcalling once the client has been recorded\n\t * on stable storage.\n\t *\n\t * For v4.1+ clients, the outcome of the two operations is different,\n\t * so we must ensure that we upcall for the create operation. v4.1+\n\t * clients call this on RECLAIM_COMPLETE though, so we should only end\n\t * up doing a single create upcall per client.\n\t */\n\tif (clp->cl_minorversion == 0 &&\n\t    test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tgrace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (!nfsd4_umh_cltrack_upcall(\"create\", hexid, has_session, grace_start))\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(has_session);\n\tkfree(grace_start);\n\tkfree(hexid);\n}"
  },
  {
    "function_name": "nfsd4_cltrack_upcall_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1285-1292",
    "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&clp->cl_flags",
            "NFSD4_CLIENT_UPCALL_LOCK"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_UPCALL_LOCK",
            "&clp->cl_flags"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
  },
  {
    "function_name": "nfsd4_cltrack_upcall_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1278-1283",
    "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_lock",
          "args": [
            "&clp->cl_flags",
            "NFSD4_CLIENT_UPCALL_LOCK",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1259-1276",
    "snippet": "static int\nnfsd4_umh_cltrack_init(struct net *net)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tchar *grace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\t/* XXX: The usermode helper s not working in container yet. */\n\tif (net != &init_net) {\n\t\tpr_warn(\"NFSD: attempt to initialize umh client tracking in a container ignored.\\n\");\n\t\tkfree(grace_start);\n\t\treturn -EINVAL;\n\t}\n\n\tret = nfsd4_umh_cltrack_upcall(\"init\", NULL, grace_start, NULL);\n\tkfree(grace_start);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "grace_start"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"init\"",
            "NULL",
            "grace_start",
            "NULL"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1197-1238",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "grace_start"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NFSD: attempt to initialize umh client tracking in a container ignored.\\n\""
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_grace_start",
          "args": [
            "nn->boot_time"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_grace_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1172-1195",
          "snippet": "static char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\"\n\nstatic char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_umh_cltrack_init(struct net *net)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tchar *grace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\t/* XXX: The usermode helper s not working in container yet. */\n\tif (net != &init_net) {\n\t\tpr_warn(\"NFSD: attempt to initialize umh client tracking in a container ignored.\\n\");\n\t\tkfree(grace_start);\n\t\treturn -EINVAL;\n\t}\n\n\tret = nfsd4_umh_cltrack_upcall(\"init\", NULL, grace_start, NULL);\n\tkfree(grace_start);\n\treturn ret;\n}"
  },
  {
    "function_name": "bin_to_hex_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1240-1257",
    "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "hex",
            "\"%2.2x\"",
            "*src++"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(srclen * 2) + 1",
            "GFP_KERNEL"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1197-1238",
    "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: %s return value: %d\\n\"",
            "__func__",
            "cltrack_prog",
            "ret"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\"",
            "cltrack_prog",
            "ret"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_usermodehelper",
          "args": [
            "argv[0]",
            "argv",
            "envp",
            "UMH_WAIT_PROC"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: env1: %s\\n\"",
            "__func__",
            "env1 ? env1 : \"(null)\""
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: env0: %s\\n\"",
            "__func__",
            "env0 ? env0 : \"(null)\""
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: arg: %s\\n\"",
            "__func__",
            "arg ? arg : \"(null)\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: cmd: %s\\n\"",
            "__func__",
            "cmd"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: cltrack_prog is disabled\\n\"",
            "__func__"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cltrack_prog[0]"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_grace_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1172-1195",
    "snippet": "static char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [
      "#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "GRACE_START_ENV_PREFIX \"%ld\"",
            "grace_start"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GRACE_START_ENV_PREFIX"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\"\n\nstatic char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_client_has_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1147-1170",
    "snippet": "static char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [
      "#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "HAS_SESSION_ENV_PREFIX \"%c\"",
            "clp->cl_minorversion ? 'Y' : 'N'"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HAS_SESSION_ENV_PREFIX"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\"\n\nstatic char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_legacy_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1112-1145",
    "snippet": "static char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [
      "#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\""
    ],
    "globals_used": [
      "static bool cltrack_legacy_disable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "result + copied",
            "name"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-147",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "LEGACY_RECDIR_ENV_PREFIX \"%s/\"",
            "nfs4_recoverydir()"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_recoverydir",
          "args": [],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "605-609",
          "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nfs4_recoverydir()"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "LEGACY_RECDIR_ENV_PREFIX"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_legacy_topdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1084-1110",
    "snippet": "static char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [
      "#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\""
    ],
    "globals_used": [
      "static bool cltrack_legacy_disable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "LEGACY_TOPDIR_ENV_PREFIX \"%s\"",
            "nfs4_recoverydir()"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_recoverydir",
          "args": [],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "605-609",
          "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nfs4_recoverydir()"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "LEGACY_TOPDIR_ENV_PREFIX"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cld_grace_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1034-1057",
    "snippet": "static void\nnfsd4_cld_grace_done(struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_GraceDone;\n\tcup->cu_msg.cm_u.cm_gracetime = (int64_t)nn->boot_time;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret)\n\t\tret = cup->cu_msg.cm_status;\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to end grace period: %d\\n\", ret);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to end grace period: %d\\n\"",
            "ret"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "914-923",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "697-711",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "883-912",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_grace_done(struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_GraceDone;\n\tcup->cu_msg.cm_u.cm_gracetime = (int64_t)nn->boot_time;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret)\n\t\tret = cup->cu_msg.cm_status;\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to end grace period: %d\\n\", ret);\n}"
  },
  {
    "function_name": "nfsd4_cld_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "1000-1032",
    "snippet": "static int\nnfsd4_cld_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if one was already stored during this grace pd */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tprintk(KERN_ERR \"NFSD: Unable to check client record on \"\n\t\t\t\t\"stable storage: %d\\n\", -ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Check;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "914-923",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "697-711",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cup->cu_msg.cm_u.cm_name.cn_id",
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to check client record on \"\n\t\t\t\t\"stable storage: %d\\n\"",
            "-ENOMEM"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "883-912",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_cld_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if one was already stored during this grace pd */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tprintk(KERN_ERR \"NFSD: Unable to check client record on \"\n\t\t\t\t\"stable storage: %d\\n\", -ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Check;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_cld_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "963-997",
    "snippet": "static void\nnfsd4_cld_remove(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already removed */\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Remove;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to remove client \"\n\t\t\t\t\"record from stable storage: %d\\n\", ret);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to remove client \"\n\t\t\t\t\"record from stable storage: %d\\n\"",
            "ret"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "914-923",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "697-711",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cup->cu_msg.cm_u.cm_name.cn_id",
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "883-912",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_remove(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already removed */\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Remove;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to remove client \"\n\t\t\t\t\"record from stable storage: %d\\n\", ret);\n}"
  },
  {
    "function_name": "nfsd4_cld_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "926-960",
    "snippet": "static void\nnfsd4_cld_create(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already stored */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Create;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to create client \"\n\t\t\t\t\"record on stable storage: %d\\n\", ret);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to create client \"\n\t\t\t\t\"record on stable storage: %d\\n\"",
            "ret"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "914-923",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "697-711",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cup->cu_msg.cm_u.cm_name.cn_id",
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "883-912",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_create(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already stored */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Create;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to create client \"\n\t\t\t\t\"record on stable storage: %d\\n\", ret);\n}"
  },
  {
    "function_name": "free_cld_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "914-923",
    "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "victim"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&victim->cu_list"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
  },
  {
    "function_name": "alloc_cld_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "883-912",
    "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: allocated xid %u\\n\"",
            "__func__",
            "new->cu_msg.cm_xid"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->cu_list",
            "&cn->cn_list"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_unaligned",
          "args": [
            "cn->cn_xid++",
            "&new->cu_msg.cm_xid"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&cn->cn_list",
            "cu_list"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_KERNEL"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
  },
  {
    "function_name": "nfsd4_remove_cld_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "871-881",
    "snippet": "static void\nnfsd4_remove_cld_pipe(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tnfsd4_cld_unregister_net(net, cn->cn_pipe);\n\trpc_destroy_pipe_data(cn->cn_pipe);\n\tkfree(nn->cld_net);\n\tnn->cld_net = NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->cld_net"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_destroy_pipe_data",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_unregister_net",
          "args": [
            "net",
            "cn->cn_pipe"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_unregister_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "814-824",
          "snippet": "static void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_remove_cld_pipe(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tnfsd4_cld_unregister_net(net, cn->cn_pipe);\n\trpc_destroy_pipe_data(cn->cn_pipe);\n\tkfree(nn->cld_net);\n\tnn->cld_net = NULL;\n}"
  },
  {
    "function_name": "nfsd4_init_cld_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "827-869",
    "snippet": "static int\nnfsd4_init_cld_pipe(struct net *net)\n{\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn;\n\n\tif (nn->cld_net)\n\t\treturn 0;\n\n\tcn = kzalloc(sizeof(*cn), GFP_KERNEL);\n\tif (!cn) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tcn->cn_pipe = rpc_mkpipe_data(&cld_upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\n\tif (IS_ERR(cn->cn_pipe)) {\n\t\tret = PTR_ERR(cn->cn_pipe);\n\t\tgoto err;\n\t}\n\tspin_lock_init(&cn->cn_lock);\n\tINIT_LIST_HEAD(&cn->cn_list);\n\n\tdentry = nfsd4_cld_register_net(net, cn->cn_pipe);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err_destroy_data;\n\t}\n\n\tcn->cn_pipe->dentry = dentry;\n\tnn->cld_net = cn;\n\treturn 0;\n\nerr_destroy_data:\n\trpc_destroy_pipe_data(cn->cn_pipe);\nerr:\n\tkfree(cn);\n\tprintk(KERN_ERR \"NFSD: unable to create nfsdcld upcall pipe (%d)\\n\",\n\t\t\tret);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_pipe_ops cld_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= cld_pipe_downcall,\n\t.destroy_msg\t= cld_pipe_destroy_msg,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: unable to create nfsdcld upcall pipe (%d)\\n\"",
            "ret"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cn"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_destroy_pipe_data",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_register_net",
          "args": [
            "net",
            "cn->cn_pipe"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_register_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "800-812",
          "snippet": "static struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cn->cn_list"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_mkpipe_data",
          "args": [
            "&cld_upcall_ops",
            "RPC_PIPE_WAIT_FOR_OPEN"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cn)",
            "GFP_KERNEL"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic const struct rpc_pipe_ops cld_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= cld_pipe_downcall,\n\t.destroy_msg\t= cld_pipe_destroy_msg,\n};\n\nstatic int\nnfsd4_init_cld_pipe(struct net *net)\n{\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn;\n\n\tif (nn->cld_net)\n\t\treturn 0;\n\n\tcn = kzalloc(sizeof(*cn), GFP_KERNEL);\n\tif (!cn) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tcn->cn_pipe = rpc_mkpipe_data(&cld_upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\n\tif (IS_ERR(cn->cn_pipe)) {\n\t\tret = PTR_ERR(cn->cn_pipe);\n\t\tgoto err;\n\t}\n\tspin_lock_init(&cn->cn_lock);\n\tINIT_LIST_HEAD(&cn->cn_list);\n\n\tdentry = nfsd4_cld_register_net(net, cn->cn_pipe);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err_destroy_data;\n\t}\n\n\tcn->cn_pipe->dentry = dentry;\n\tnn->cld_net = cn;\n\treturn 0;\n\nerr_destroy_data:\n\trpc_destroy_pipe_data(cn->cn_pipe);\nerr:\n\tkfree(cn);\n\tprintk(KERN_ERR \"NFSD: unable to create nfsdcld upcall pipe (%d)\\n\",\n\t\t\tret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_cld_unregister_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "814-824",
    "snippet": "static void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_sb_net",
          "args": [
            "net"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_unregister_sb",
          "args": [
            "pipe"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_unregister_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "793-798",
          "snippet": "static void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_get_sb_net",
          "args": [
            "net"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cld_register_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "800-812",
    "snippet": "static struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_sb_net",
          "args": [
            "net"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_register_sb",
          "args": [
            "sb",
            "pipe"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_register_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "780-791",
          "snippet": "static struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [
            "#define NFSD_CLD_PIPE\t\t\"cld\"",
            "#define NFSD_PIPE_DIR\t\t\"nfsd\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define NFSD_CLD_PIPE\t\t\"cld\"\n#define NFSD_PIPE_DIR\t\t\"nfsd\"\n\nstatic struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_get_sb_net",
          "args": [
            "net"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}"
  },
  {
    "function_name": "nfsd4_cld_unregister_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "793-798",
    "snippet": "static void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_unlink",
          "args": [
            "pipe->dentry"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
  },
  {
    "function_name": "nfsd4_cld_register_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "780-791",
    "snippet": "static struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [
      "#define NFSD_CLD_PIPE\t\t\"cld\"",
      "#define NFSD_PIPE_DIR\t\t\"nfsd\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_mkpipe_dentry",
          "args": [
            "dir",
            "NFSD_CLD_PIPE",
            "NULL",
            "pipe"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_d_lookup_sb",
          "args": [
            "sb",
            "NFSD_PIPE_DIR"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\n#define NFSD_CLD_PIPE\t\t\"cld\"\n#define NFSD_PIPE_DIR\t\t\"nfsd\"\n\nstatic struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
  },
  {
    "function_name": "cld_pipe_destroy_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "760-772",
    "snippet": "static void\ncld_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct cld_msg *cmsg = msg->data;\n\tstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall,\n\t\t\t\t\t\t cu_msg);\n\n\t/* errno >= 0 means we got a downcall */\n\tif (msg->errno >= 0)\n\t\treturn;\n\n\twake_up_process(cup->cu_task);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "cup->cu_task"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cmsg",
            "structcld_upcall",
            "cu_msg"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\ncld_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct cld_msg *cmsg = msg->data;\n\tstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall,\n\t\t\t\t\t\t cu_msg);\n\n\t/* errno >= 0 means we got a downcall */\n\tif (msg->errno >= 0)\n\t\treturn;\n\n\twake_up_process(cup->cu_task);\n}"
  },
  {
    "function_name": "cld_pipe_downcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "713-758",
    "snippet": "static ssize_t\ncld_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct cld_upcall *tmp, *cup;\n\tstruct cld_msg __user *cmsg = (struct cld_msg __user *)src;\n\tuint32_t xid;\n\tstruct nfsd_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t\tnfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tif (mlen != sizeof(*cmsg)) {\n\t\tdprintk(\"%s: got %zu bytes, expected %zu\\n\", __func__, mlen,\n\t\t\tsizeof(*cmsg));\n\t\treturn -EINVAL;\n\t}\n\n\t/* copy just the xid so we can try to find that */\n\tif (copy_from_user(&xid, &cmsg->cm_xid, sizeof(xid)) != 0) {\n\t\tdprintk(\"%s: error when copying xid from userspace\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* walk the list and find corresponding xid */\n\tcup = NULL;\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (get_unaligned(&tmp->cu_msg.cm_xid) == xid) {\n\t\t\tcup = tmp;\n\t\t\tlist_del_init(&cup->cu_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cn->cn_lock);\n\n\t/* couldn't find upcall? */\n\tif (!cup) {\n\t\tdprintk(\"%s: couldn't find upcall -- xid=%u\\n\", __func__, xid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&cup->cu_msg, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\twake_up_process(cup->cu_task);\n\treturn mlen;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "cup->cu_task"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cup->cu_msg",
            "src",
            "mlen"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: couldn't find upcall -- xid=%u\\n\"",
            "__func__",
            "xid"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cup->cu_list"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "&tmp->cu_msg.cm_xid"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&cn->cn_list",
            "cu_list"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: error when copying xid from userspace\"",
            "__func__"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&xid",
            "&cmsg->cm_xid",
            "sizeof(xid)"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: got %zu bytes, expected %zu\\n\"",
            "__func__",
            "mlen",
            "sizeof(*cmsg)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "file_inode(filp)->i_sb->s_fs_info",
            "nfsd_net_id"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic ssize_t\ncld_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct cld_upcall *tmp, *cup;\n\tstruct cld_msg __user *cmsg = (struct cld_msg __user *)src;\n\tuint32_t xid;\n\tstruct nfsd_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t\tnfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tif (mlen != sizeof(*cmsg)) {\n\t\tdprintk(\"%s: got %zu bytes, expected %zu\\n\", __func__, mlen,\n\t\t\tsizeof(*cmsg));\n\t\treturn -EINVAL;\n\t}\n\n\t/* copy just the xid so we can try to find that */\n\tif (copy_from_user(&xid, &cmsg->cm_xid, sizeof(xid)) != 0) {\n\t\tdprintk(\"%s: error when copying xid from userspace\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* walk the list and find corresponding xid */\n\tcup = NULL;\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (get_unaligned(&tmp->cu_msg.cm_xid) == xid) {\n\t\t\tcup = tmp;\n\t\t\tlist_del_init(&cup->cu_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cn->cn_lock);\n\n\t/* couldn't find upcall? */\n\tif (!cup) {\n\t\tdprintk(\"%s: couldn't find upcall -- xid=%u\\n\", __func__, xid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&cup->cu_msg, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\twake_up_process(cup->cu_task);\n\treturn mlen;\n}"
  },
  {
    "function_name": "cld_pipe_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "697-711",
    "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cld_pipe_upcall",
          "args": [
            "pipe",
            "cmsg"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "__cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "668-695",
          "snippet": "static int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__cld_pipe_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "668-695",
    "snippet": "static int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_queue_upcall",
          "args": [
            "pipe",
            "&msg"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_check_legacy_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "611-638",
    "snippet": "static int\nnfsd4_check_legacy_client(struct nfs4_client *clp)\n{\n\tint status;\n\tchar dname[HEXDIR_LEN];\n\tstruct nfs4_client_reclaim *crp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/* did we already find that this client is stable? */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status) {\n\t\tlegacy_recdir_name_error(clp, status);\n\t\treturn status;\n\t}\n\n\t/* look for it in the reclaim hashtable otherwise */\n\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\tif (crp) {\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t\tcrp->cr_clp = clp;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_find_reclaim_client",
          "args": [
            "dname",
            "nn"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_reclaim_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6047-6062",
          "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "legacy_recdir_name_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_recdir_name_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "154-170",
          "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "dname",
            "&clp->cl_name"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-147",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_check_legacy_client(struct nfs4_client *clp)\n{\n\tint status;\n\tchar dname[HEXDIR_LEN];\n\tstruct nfs4_client_reclaim *crp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/* did we already find that this client is stable? */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status) {\n\t\tlegacy_recdir_name_error(clp, status);\n\t\treturn status;\n\t}\n\n\t/* look for it in the reclaim hashtable otherwise */\n\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\tif (crp) {\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t\tcrp->cr_clp = clp;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "nfs4_recoverydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "605-609",
    "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
  },
  {
    "function_name": "nfs4_reset_recoverydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "587-603",
    "snippet": "int\nnfs4_reset_recoverydir(char *recdir)\n{\n\tint status;\n\tstruct path path;\n\n\tstatus = kern_path(recdir, LOOKUP_FOLLOW, &path);\n\tif (status)\n\t\treturn status;\n\tstatus = -ENOTDIR;\n\tif (d_is_dir(path.dentry)) {\n\t\tstrcpy(user_recovery_dirname, recdir);\n\t\tstatus = 0;\n\t}\n\tpath_put(&path);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "user_recovery_dirname",
            "recdir"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "path.dentry"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "recdir",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nint\nnfs4_reset_recoverydir(char *recdir)\n{\n\tint status;\n\tstruct path path;\n\n\tstatus = kern_path(recdir, LOOKUP_FOLLOW, &path);\n\tif (status)\n\t\treturn status;\n\tstatus = -ENOTDIR;\n\tif (d_is_dir(path.dentry)) {\n\t\tstrcpy(user_recovery_dirname, recdir);\n\t\tstatus = 0;\n\t}\n\tpath_put(&path);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_legacy_tracking_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "574-582",
    "snippet": "static void\nnfsd4_legacy_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_release_reclaim(nn);\n\tnfsd4_shutdown_recdir(net);\n\tnfs4_legacy_state_shutdown(net);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_legacy_state_shutdown",
          "args": [
            "net"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_legacy_state_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "525-531",
          "snippet": "static void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_shutdown_recdir",
          "args": [
            "net"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_shutdown_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "496-505",
          "snippet": "static void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_release_reclaim",
          "args": [
            "nn"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_release_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6029-6043",
          "snippet": "void\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_legacy_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_release_reclaim(nn);\n\tnfsd4_shutdown_recdir(net);\n\tnfs4_legacy_state_shutdown(net);\n}"
  },
  {
    "function_name": "nfsd4_legacy_tracking_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "549-572",
    "snippet": "static int\nnfsd4_legacy_tracking_init(struct net *net)\n{\n\tint status;\n\n\t/* XXX: The legacy code won't work in a container */\n\tif (net != &init_net) {\n\t\tpr_warn(\"NFSD: attempt to initialize legacy client tracking in a container ignored.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = nfs4_legacy_state_init(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_load_reboot_recovery_data(net);\n\tif (status)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tnfs4_legacy_state_shutdown(net);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_legacy_state_shutdown",
          "args": [
            "net"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_legacy_state_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "525-531",
          "snippet": "static void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_load_reboot_recovery_data",
          "args": [
            "net"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_load_reboot_recovery_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "533-547",
          "snippet": "static int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_legacy_state_init",
          "args": [
            "net"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_legacy_state_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "507-523",
          "snippet": "static int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"NFSD: attempt to initialize legacy client tracking in a container ignored.\\n\""
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_legacy_tracking_init(struct net *net)\n{\n\tint status;\n\n\t/* XXX: The legacy code won't work in a container */\n\tif (net != &init_net) {\n\t\tpr_warn(\"NFSD: attempt to initialize legacy client tracking in a container ignored.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = nfs4_legacy_state_init(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_load_reboot_recovery_data(net);\n\tif (status)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tnfs4_legacy_state_shutdown(net);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_load_reboot_recovery_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "533-547",
    "snippet": "static int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_shutdown_recdir",
          "args": [
            "net"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_shutdown_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "496-505",
          "snippet": "static void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_recdir_load",
          "args": [
            "net"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recdir_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "443-456",
          "snippet": "static int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_recdir",
          "args": [
            "net"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "462-494",
          "snippet": "static int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nstatic int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_legacy_state_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "525-531",
    "snippet": "static void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->reclaim_str_hashtbl"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}"
  },
  {
    "function_name": "nfs4_legacy_state_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "507-523",
    "snippet": "static int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->reclaim_str_hashtbl[i]"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_shutdown_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "496-505",
    "snippet": "static void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "nn->rec_file"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}"
  },
  {
    "function_name": "nfsd4_init_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "462-494",
    "snippet": "static int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nn->rec_file"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NFSD: unable to find recovery directory %s\\n\"",
            "user_recovery_dirname"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nn->rec_file"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_open",
          "args": [
            "user_recovery_dirname",
            "O_RDONLY | O_DIRECTORY",
            "0"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\"",
            "status"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nn->rec_file"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NFSD: Using %s as the NFSv4 state recovery directory\\n\"",
            "user_recovery_dirname"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nstatic int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_recdir_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "443-456",
    "snippet": "static int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\"",
            "nn->rec_file"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_list_rec_dir",
          "args": [
            "load_recdir",
            "nn"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_list_rec_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "272-320",
          "snippet": "static int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tstruct name_list *entry, *tmp;\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tinode_unlock(d_inode(dir));\n\tnfs4_reset_creds(original_cred);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tdprintk(\"NFSD: %s. Left entry %s\\n\", __func__, entry->name);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tstruct name_list *entry, *tmp;\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tinode_unlock(d_inode(dir));\n\tnfs4_reset_creds(original_cred);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tdprintk(\"NFSD: %s. Left entry %s\\n\", __func__, entry->name);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}"
  },
  {
    "function_name": "load_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "430-441",
    "snippet": "static int\nload_recdir(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tif (child->d_name.len != HEXDIR_LEN - 1) {\n\t\tprintk(\"nfsd4: illegal name %pd in recovery directory\\n\",\n\t\t\t\tchild);\n\t\t/* Keep trying; maybe the others are OK: */\n\t\treturn 0;\n\t}\n\tnfs4_client_to_reclaim(child->d_name.name, nn);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_client_to_reclaim",
          "args": [
            "child->d_name.name",
            "nn"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_client_to_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6002-6019",
          "snippet": "struct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd4: illegal name %pd in recovery directory\\n\"",
            "child"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nload_recdir(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tif (child->d_name.len != HEXDIR_LEN - 1) {\n\t\tprintk(\"nfsd4: illegal name %pd in recovery directory\\n\",\n\t\t\t\tchild);\n\t\t/* Keep trying; maybe the others are OK: */\n\t\treturn 0;\n\t}\n\tnfs4_client_to_reclaim(child->d_name.name, nn);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_recdir_purge_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "408-428",
    "snippet": "static void\nnfsd4_recdir_purge_old(struct nfsd_net *nn)\n{\n\tint status;\n\n\tnn->in_grace = false;\n\tif (!nn->rec_file)\n\t\treturn;\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd4_list_rec_dir(purge_old, nn);\n\tif (status == 0)\n\t\tvfs_fsync(nn->rec_file, 0);\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tnfs4_release_reclaim(nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed to purge old clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd4: failed to purge old clients from recovery\"\n\t\t\t\" directory %pD\\n\"",
            "nn->rec_file"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_release_reclaim",
          "args": [
            "nn"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_release_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6029-6043",
          "snippet": "void\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "nn->rec_file",
            "0"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_list_rec_dir",
          "args": [
            "purge_old",
            "nn"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_list_rec_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "272-320",
          "snippet": "static int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tstruct name_list *entry, *tmp;\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tinode_unlock(d_inode(dir));\n\tnfs4_reset_creds(original_cred);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tdprintk(\"NFSD: %s. Left entry %s\\n\", __func__, entry->name);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tstruct name_list *entry, *tmp;\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tinode_unlock(d_inode(dir));\n\tnfs4_reset_creds(original_cred);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tdprintk(\"NFSD: %s. Left entry %s\\n\", __func__, entry->name);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_recdir_purge_old(struct nfsd_net *nn)\n{\n\tint status;\n\n\tnn->in_grace = false;\n\tif (!nn->rec_file)\n\t\treturn;\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd4_list_rec_dir(purge_old, nn);\n\tif (status == 0)\n\t\tvfs_fsync(nn->rec_file, 0);\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tnfs4_release_reclaim(nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed to purge old clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n}"
  },
  {
    "function_name": "purge_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "392-406",
    "snippet": "static int\npurge_old(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tint status;\n\n\tif (nfs4_has_reclaimed_state(child->d_name.name, nn))\n\t\treturn 0;\n\n\tstatus = vfs_rmdir(d_inode(parent), child);\n\tif (status)\n\t\tprintk(\"failed to remove client recovery directory %pd\\n\",\n\t\t\t\tchild);\n\t/* Keep trying, success or failure: */\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"failed to remove client recovery directory %pd\\n\"",
            "child"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_rmdir",
          "args": [
            "d_inode(parent)",
            "child"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "parent"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_has_reclaimed_state",
          "args": [
            "child->d_name.name",
            "nn"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_has_reclaimed_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "5990-5997",
          "snippet": "bool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nbool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\npurge_old(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tint status;\n\n\tif (nfs4_has_reclaimed_state(child->d_name.name, nn))\n\t\treturn 0;\n\n\tstatus = vfs_rmdir(d_inode(parent), child);\n\tif (status)\n\t\tprintk(\"failed to remove client recovery directory %pd\\n\",\n\t\t\t\tchild);\n\t/* Keep trying, success or failure: */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_remove_clid_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "348-390",
    "snippet": "static void\nnfsd4_remove_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tstruct nfs4_client_reclaim *crp;\n\tchar dname[HEXDIR_LEN];\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!nn->rec_file || !test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\tgoto out_drop_write;\n\n\tstatus = nfsd4_unlink_clid_dir(dname, HEXDIR_LEN-1, nn);\n\tnfs4_reset_creds(original_cred);\n\tif (status == 0) {\n\t\tvfs_fsync(nn->rec_file, 0);\n\t\tif (nn->in_grace) {\n\t\t\t/* remove reclaim record */\n\t\t\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\nout_drop_write:\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tif (status)\n\t\tprintk(\"NFSD: Failed to remove expired client state directory\"\n\t\t\t\t\" %.*s\\n\", HEXDIR_LEN, dname);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NFSD: Failed to remove expired client state directory\"\n\t\t\t\t\" %.*s\\n\"",
            "HEXDIR_LEN",
            "dname"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_remove_reclaim_record",
          "args": [
            "crp",
            "nn"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_remove_reclaim_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6021-6027",
          "snippet": "void\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_find_reclaim_client",
          "args": [
            "dname",
            "nn"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_reclaim_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6047-6062",
          "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "nn->rec_file",
            "0"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_unlink_clid_dir",
          "args": [
            "dname",
            "HEXDIR_LEN-1",
            "nn"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_unlink_clid_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "322-346",
          "snippet": "static int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out;\n\tstatus = vfs_rmdir(d_inode(dir), dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out;\n\tstatus = vfs_rmdir(d_inode(dir), dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "legacy_recdir_name_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_recdir_name_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "154-170",
          "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "dname",
            "&clp->cl_name"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-147",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfsd4_remove_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tstruct nfs4_client_reclaim *crp;\n\tchar dname[HEXDIR_LEN];\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!nn->rec_file || !test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\tgoto out_drop_write;\n\n\tstatus = nfsd4_unlink_clid_dir(dname, HEXDIR_LEN-1, nn);\n\tnfs4_reset_creds(original_cred);\n\tif (status == 0) {\n\t\tvfs_fsync(nn->rec_file, 0);\n\t\tif (nn->in_grace) {\n\t\t\t/* remove reclaim record */\n\t\t\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\nout_drop_write:\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tif (status)\n\t\tprintk(\"NFSD: Failed to remove expired client state directory\"\n\t\t\t\t\" %.*s\\n\", HEXDIR_LEN, dname);\n}"
  },
  {
    "function_name": "nfsd4_unlink_clid_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "322-346",
    "snippet": "static int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out;\n\tstatus = vfs_rmdir(d_inode(dir), dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_inode(dir)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_rmdir",
          "args": [
            "d_inode(dir)",
            "dentry"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_negative",
          "args": [
            "dentry"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "dir",
            "namlen"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock_nested",
          "args": [
            "d_inode(dir)",
            "I_MUTEX_PARENT"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\"",
            "namlen",
            "name"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (d_really_is_negative(dentry))\n\t\tgoto out;\n\tstatus = vfs_rmdir(d_inode(dir), dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_list_rec_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "272-320",
    "snippet": "static int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tstruct name_list *entry, *tmp;\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tinode_unlock(d_inode(dir));\n\tnfs4_reset_creds(original_cred);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tdprintk(\"NFSD: %s. Left entry %s\\n\", __func__, entry->name);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s. Left entry %s\\n\"",
            "__func__",
            "entry->name"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&ctx.names",
            "list"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_inode(dir)"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "dir",
            "dentry",
            "nn"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "rpc_pipefs_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1509-1546",
          "snippet": "static int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "entry->name",
            "dir",
            "HEXDIR_LEN-1"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&ctx.names",
            "list"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock_nested",
          "args": [
            "d_inode(dir)",
            "I_MUTEX_PARENT"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "nn->rec_file",
            "&ctx.ctx"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_llseek",
          "args": [
            "nn->rec_file",
            "0",
            "SEEK_SET"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "ctx.names"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tstruct name_list *entry, *tmp;\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tinode_lock_nested(d_inode(dir), I_MUTEX_PARENT);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tinode_unlock(d_inode(dir));\n\tnfs4_reset_creds(original_cred);\n\n\tlist_for_each_entry_safe(entry, tmp, &ctx.names, list) {\n\t\tdprintk(\"NFSD: %s. Left entry %s\\n\", __func__, entry->name);\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_build_namelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "253-270",
    "snippet": "static int\nnfsd4_build_namelist(struct dir_context *__ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct nfs4_dir_ctx *ctx =\n\t\tcontainer_of(__ctx, struct nfs4_dir_ctx, ctx);\n\tstruct name_list *entry;\n\n\tif (namlen != HEXDIR_LEN - 1)\n\t\treturn 0;\n\tentry = kmalloc(sizeof(struct name_list), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\tmemcpy(entry->name, name, HEXDIR_LEN - 1);\n\tentry->name[HEXDIR_LEN - 1] = '\\0';\n\tlist_add(&entry->list, &ctx->names);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->list",
            "&ctx->names"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->name",
            "name",
            "HEXDIR_LEN - 1"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct name_list)",
            "GFP_KERNEL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "__ctx",
            "structnfs4_dir_ctx",
            "ctx"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfsd4_build_namelist(struct dir_context *__ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct nfs4_dir_ctx *ctx =\n\t\tcontainer_of(__ctx, struct nfs4_dir_ctx, ctx);\n\tstruct name_list *entry;\n\n\tif (namlen != HEXDIR_LEN - 1)\n\t\treturn 0;\n\tentry = kmalloc(sizeof(struct name_list), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\tmemcpy(entry->name, name, HEXDIR_LEN - 1);\n\tentry->name[HEXDIR_LEN - 1] = '\\0';\n\tlist_add(&entry->list, &ctx->names);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_create_clid_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "172-239",
    "snippet": "static void\nnfsd4_create_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tchar dname[HEXDIR_LEN];\n\tstruct dentry *dir, *dentry;\n\tstruct nfs4_client_reclaim *crp;\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (test_and_set_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\tif (!nn->rec_file)\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn;\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out_creds;\n\n\tdir = nn->rec_file->f_path.dentry;\n\t/* lock the parent */\n\tinode_lock(d_inode(dir));\n\n\tdentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (d_really_is_positive(dentry))\n\t\t/*\n\t\t * In the 4.1 case, where we're called from\n\t\t * reclaim_complete(), records from the previous reboot\n\t\t * may still be left, so this is OK.\n\t\t *\n\t\t * In the 4.0 case, we should never get here; but we may\n\t\t * as well be forgiving and just succeed silently.\n\t\t */\n\t\tgoto out_put;\n\tstatus = vfs_mkdir(d_inode(dir), dentry, S_IRWXU);\nout_put:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\tif (status == 0) {\n\t\tif (nn->in_grace) {\n\t\t\tcrp = nfs4_client_to_reclaim(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tcrp->cr_clp = clp;\n\t\t}\n\t\tvfs_fsync(nn->rec_file, 0);\n\t} else {\n\t\tprintk(KERN_ERR \"NFSD: failed to write recovery record\"\n\t\t\t\t\" (err %d); please check that %s exists\"\n\t\t\t\t\" and is writeable\", status,\n\t\t\t\tuser_recovery_dirname);\n\t}\n\tmnt_drop_write_file(nn->rec_file);\nout_creds:\n\tnfs4_reset_creds(original_cred);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: failed to write recovery record\"\n\t\t\t\t\" (err %d); please check that %s exists\"\n\t\t\t\t\" and is writeable\"",
            "status",
            "user_recovery_dirname"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "nn->rec_file",
            "0"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_client_to_reclaim",
          "args": [
            "dname",
            "nn"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_client_to_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4state.c",
          "lines": "6002-6019",
          "snippet": "struct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "d_inode(dir)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mkdir",
          "args": [
            "d_inode(dir)",
            "dentry",
            "S_IRWXU"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "dentry"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "dname",
            "dir",
            "HEXDIR_LEN-1"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "d_inode(dir)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dir"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "legacy_recdir_name_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_recdir_name_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "154-170",
          "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "dname",
            "&clp->cl_name"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-147",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nstatic void\nnfsd4_create_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tchar dname[HEXDIR_LEN];\n\tstruct dentry *dir, *dentry;\n\tstruct nfs4_client_reclaim *crp;\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (test_and_set_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\tif (!nn->rec_file)\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn;\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out_creds;\n\n\tdir = nn->rec_file->f_path.dentry;\n\t/* lock the parent */\n\tinode_lock(d_inode(dir));\n\n\tdentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (d_really_is_positive(dentry))\n\t\t/*\n\t\t * In the 4.1 case, where we're called from\n\t\t * reclaim_complete(), records from the previous reboot\n\t\t * may still be left, so this is OK.\n\t\t *\n\t\t * In the 4.0 case, we should never get here; but we may\n\t\t * as well be forgiving and just succeed silently.\n\t\t */\n\t\tgoto out_put;\n\tstatus = vfs_mkdir(d_inode(dir), dentry, S_IRWXU);\nout_put:\n\tdput(dentry);\nout_unlock:\n\tinode_unlock(d_inode(dir));\n\tif (status == 0) {\n\t\tif (nn->in_grace) {\n\t\t\tcrp = nfs4_client_to_reclaim(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tcrp->cr_clp = clp;\n\t\t}\n\t\tvfs_fsync(nn->rec_file, 0);\n\t} else {\n\t\tprintk(KERN_ERR \"NFSD: failed to write recovery record\"\n\t\t\t\t\" (err %d); please check that %s exists\"\n\t\t\t\t\" and is writeable\", status,\n\t\t\t\tuser_recovery_dirname);\n\t}\n\tmnt_drop_write_file(nn->rec_file);\nout_creds:\n\tnfs4_reset_creds(original_cred);\n}"
  },
  {
    "function_name": "legacy_recdir_name_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "154-170",
    "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_client_tracking_exit",
          "args": [
            "clp->net"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_tracking_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "1461-1471",
          "snippet": "void\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nvoid\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\"",
            "error"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
  },
  {
    "function_name": "nfs4_make_rec_clidname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "103-147",
    "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "tfm"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cksum.data"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md5_to_hex",
          "args": [
            "dname",
            "cksum.data"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "md5_to_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
          "lines": "89-101",
          "snippet": "static void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "shash_desc_zero",
          "args": [
            "desc"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digest",
          "args": [
            "desc",
            "clname->data",
            "clname->len",
            "cksum.data"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHASH_DESC_ON_STACK",
          "args": [
            "desc",
            "tfm"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "cksum.len",
            "GFP_KERNEL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"md5\"",
            "0",
            "0"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_make_rec_clidname for %.*s\\n\"",
            "clname->len",
            "clname->data"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct crypto_shash *tfm;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\ttfm = crypto_alloc_shash(\"md5\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tstatus = PTR_ERR(tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_shash_digestsize(tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\t{\n\t\tSHASH_DESC_ON_STACK(desc, tfm);\n\n\t\tdesc->tfm = tfm;\n\t\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\t\tstatus = crypto_shash_digest(desc, clname->data, clname->len,\n\t\t\t\t\t     cksum.data);\n\t\tshash_desc_zero(desc);\n\t}\n\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_shash(tfm);\nout_no_tfm:\n\treturn status;\n}"
  },
  {
    "function_name": "md5_to_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "89-101",
    "snippet": "static void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}"
  },
  {
    "function_name": "nfs4_reset_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "83-87",
    "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "original"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
  },
  {
    "function_name": "nfs4_save_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfs4recover.c",
    "lines": "67-81",
    "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>",
      "#include <crypto/hash.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "new"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "new"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <crypto/hash.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
  }
]