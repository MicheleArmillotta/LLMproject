[
  {
    "function_name": "nfsd_eof_on_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
    "lines": "142-159",
    "snippet": "static inline bool nfsd_eof_on_read(long requested, long read,\n\t\t\t\tloff_t offset, loff_t size)\n{\n\t/* We assume a short read means eof: */\n\tif (requested > read)\n\t\treturn true;\n\t/*\n\t * A non-short read might also reach end of file.  The spec\n\t * still requires us to set eof in that case.\n\t *\n\t * Further operations may have modified the file size since\n\t * the read, so the following check is not atomic with the read.\n\t * We've only seen that cause a problem for a client in the case\n\t * where the read returned a count of 0 without setting eof.\n\t * That case was fixed by the addition of the above check.\n\t */\n\treturn (offset + read >= size);\n}",
    "includes": [
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline bool nfsd_eof_on_read(long requested, long read,\n\t\t\t\tloff_t offset, loff_t size)\n{\n\t/* We assume a short read means eof: */\n\tif (requested > read)\n\t\treturn true;\n\t/*\n\t * A non-short read might also reach end of file.  The spec\n\t * still requires us to set eof in that case.\n\t *\n\t * Further operations may have modified the file size since\n\t * the read, so the following check is not atomic with the read.\n\t * We've only seen that cause a problem for a client in the case\n\t * where the read returned a count of 0 without setting eof.\n\t * That case was fixed by the addition of the above check.\n\t */\n\treturn (offset + read >= size);\n}"
  },
  {
    "function_name": "nfsd_create_is_exclusive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
    "lines": "136-140",
    "snippet": "static inline int nfsd_create_is_exclusive(int createmode)\n{\n\treturn createmode == NFS3_CREATE_EXCLUSIVE\n\t       || createmode == NFS4_CREATE_EXCLUSIVE4_1;\n}",
    "includes": [
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline int nfsd_create_is_exclusive(int createmode)\n{\n\treturn createmode == NFS3_CREATE_EXCLUSIVE\n\t       || createmode == NFS4_CREATE_EXCLUSIVE4_1;\n}"
  },
  {
    "function_name": "fh_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
    "lines": "129-134",
    "snippet": "static inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}",
    "includes": [
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfserrno",
          "args": [
            "vfs_getattr(&p, stat)"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "nfserrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/nfsproc.c",
          "lines": "756-806",
          "snippet": "__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}",
          "includes": [
            "#include \"vfs.h\"",
            "#include \"xdr.h\"",
            "#include \"cache.h\"",
            "#include <linux/namei.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"cache.h\"\n#include <linux/namei.h>\n\n__be32\nnfserrno (int errno)\n{\n\tstatic struct {\n\t\t__be32\tnfserr;\n\t\tint\tsyserr;\n\t} nfs_errtbl[] = {\n\t\t{ nfs_ok, 0 },\n\t\t{ nfserr_perm, -EPERM },\n\t\t{ nfserr_noent, -ENOENT },\n\t\t{ nfserr_io, -EIO },\n\t\t{ nfserr_nxio, -ENXIO },\n\t\t{ nfserr_fbig, -E2BIG },\n\t\t{ nfserr_acces, -EACCES },\n\t\t{ nfserr_exist, -EEXIST },\n\t\t{ nfserr_xdev, -EXDEV },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nodev, -ENODEV },\n\t\t{ nfserr_notdir, -ENOTDIR },\n\t\t{ nfserr_isdir, -EISDIR },\n\t\t{ nfserr_inval, -EINVAL },\n\t\t{ nfserr_fbig, -EFBIG },\n\t\t{ nfserr_nospc, -ENOSPC },\n\t\t{ nfserr_rofs, -EROFS },\n\t\t{ nfserr_mlink, -EMLINK },\n\t\t{ nfserr_nametoolong, -ENAMETOOLONG },\n\t\t{ nfserr_notempty, -ENOTEMPTY },\n#ifdef EDQUOT\n\t\t{ nfserr_dquot, -EDQUOT },\n#endif\n\t\t{ nfserr_stale, -ESTALE },\n\t\t{ nfserr_jukebox, -ETIMEDOUT },\n\t\t{ nfserr_jukebox, -ERESTARTSYS },\n\t\t{ nfserr_jukebox, -EAGAIN },\n\t\t{ nfserr_jukebox, -EWOULDBLOCK },\n\t\t{ nfserr_jukebox, -ENOMEM },\n\t\t{ nfserr_io, -ETXTBSY },\n\t\t{ nfserr_notsupp, -EOPNOTSUPP },\n\t\t{ nfserr_toosmall, -ETOOSMALL },\n\t\t{ nfserr_serverfault, -ESERVERFAULT },\n\t\t{ nfserr_serverfault, -ENFILE },\n\t};\n\tint\ti;\n\n\tfor (i = 0; i < ARRAY_SIZE(nfs_errtbl); i++) {\n\t\tif (nfs_errtbl[i].syserr == errno)\n\t\t\treturn nfs_errtbl[i].nfserr;\n\t}\n\tWARN(1, \"nfsd: non-standard errno: %d\\n\", errno);\n\treturn nfserr_io;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getattr",
          "args": [
            "&p",
            "stat"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline __be32 fh_getattr(struct svc_fh *fh, struct kstat *stat)\n{\n\tstruct path p = {.mnt = fh->fh_export->ex_path.mnt,\n\t\t\t .dentry = fh->fh_dentry};\n\treturn nfserrno(vfs_getattr(&p, stat));\n}"
  },
  {
    "function_name": "fh_drop_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
    "lines": "121-127",
    "snippet": "static inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}",
    "includes": [
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "fh->fh_export->ex_path.mnt"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline void fh_drop_write(struct svc_fh *fh)\n{\n\tif (fh->fh_want_write) {\n\t\tfh->fh_want_write = false;\n\t\tmnt_drop_write(fh->fh_export->ex_path.mnt);\n\t}\n}"
  },
  {
    "function_name": "fh_want_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-1237/repo/fs/nfsd/vfs.h",
    "lines": "112-119",
    "snippet": "static inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = true;\n\treturn ret;\n}",
    "includes": [
      "#include \"nfsd.h\"",
      "#include \"nfsfh.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "fh->fh_export->ex_path.mnt"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"nfsd.h\"\n#include \"nfsfh.h\"\n\nstatic inline int fh_want_write(struct svc_fh *fh)\n{\n\tint ret = mnt_want_write(fh->fh_export->ex_path.mnt);\n\n\tif (!ret)\n\t\tfh->fh_want_write = true;\n\treturn ret;\n}"
  }
]