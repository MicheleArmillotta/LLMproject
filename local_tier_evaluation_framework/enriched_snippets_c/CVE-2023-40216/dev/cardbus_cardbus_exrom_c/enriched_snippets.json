[
  {
    "function_name": "cardbus_read_exrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/cardbus_exrom.c",
    "lines": "90-143",
    "snippet": "int\ncardbus_read_exrom(romt, romh, head)\n     bus_space_tag_t romt;\n     bus_space_handle_t romh;\n     struct cardbus_rom_image_head *head;\n{\n    static const char func[] = \"cardbus_read_exrom\";\n\n    size_t addr = 0; /* offset of current rom image */\n    size_t dataptr;\n    unsigned int rom_image = 0;\n    \n    SIMPLEQ_INIT(head);\n    do {\n\tsize_t image_size;\n\tstruct cardbus_rom_image *image;\n\tu_int16_t val;\n\n\tval = READ_INT16(romt, romh, addr + CARDBUS_EXROM_SIGNATURE);\n\tif(val != 0xaa55) {\n\t    printf(\"%s: bad header signature in ROM image %u: 0x%04x\\n\", \n\t\t   func, rom_image, val);\n\t    return 1;\n\t}\n\tdataptr = addr + READ_INT16(romt, romh, addr + CARDBUS_EXROM_DATA_PTR);\n\t/* get the ROM image size, in blocks */\n\timage_size = READ_INT16(romt, romh, \n\t\t         dataptr + CARDBUS_EXROM_DATA_IMAGE_LENGTH);\n\tif(image_size == 0) \n\t    /* XXX some ROMs seem to have this as zero, can we assume\n               this means 1 block? */\n\t    image_size = 1;\n\timage_size <<= 9;\n\timage = malloc(sizeof(*image), M_DEVBUF, M_NOWAIT);\n\tif(image == NULL) {\n\t    printf(\"%s: out of memory\\n\", func);\n\t    return 1;\n\t}\n\timage->rom_image = rom_image;\n\timage->image_size = image_size;\n\timage->romt = romt;\n\tif(bus_space_subregion(romt, romh, addr, \n\t\t\t       image_size, &image->romh)) {\n\t    printf(\"%s: bus_space_subregion failed\", func);\n\t    free(image, M_DEVBUF);\n\t    return 1;\n\t}\n\tSIMPLEQ_INSERT_TAIL(head, image, next);\n\taddr += image_size;\n\trom_image++;\n    } while ((bus_space_read_1(romt, romh, \n                  dataptr + CARDBUS_EXROM_DATA_INDICATOR) & 0x80) == 0);\n    return 0;\n}",
    "includes": [
      "#include <dev/cardbus/cardbus_exrom.h>",
      "#include <machine/bus.h>",
      "#include <sys/malloc.h>",
      "#include <sys/queue.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bus_space_read_1",
          "args": [
            "romt",
            "romh",
            "dataptr + CARDBUS_EXROM_DATA_INDICATOR"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INSERT_TAIL",
          "args": [
            "head",
            "image",
            "next"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "image",
            "M_DEVBUF"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "rbus_space_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/cardbus/rbus.c",
          "lines": "179-207",
          "snippet": "int\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}",
          "includes": [
            "#include <dev/cardbus/rbus.h>",
            "#include <machine/bus.h>",
            "#include <sys/extent.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/cardbus/rbus.h>\n#include <machine/bus.h>\n#include <sys/extent.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\nrbus_space_free(rbt, bsh, size, addrp)\n     rbus_tag_t rbt;\n     bus_space_handle_t bsh;\n     bus_size_t size;\n     bus_addr_t *addrp;\n{\n  int exflags = EX_FAST | EX_NOWAIT;\n  bus_addr_t addr;\n  int status = 1;\n\n  if (rbt->rb_flags == RBUS_SPACE_ASK_PARENT) {\n    status = rbus_space_free(rbt->rb_parent, bsh, size, &addr);\n  } else if (rbt->rb_flags == RBUS_SPACE_SHARE ||\n\t     rbt->rb_flags == RBUS_SPACE_DEDICATE) {\n    md_space_unmap(rbt->rb_bt, bsh, size, &addr);\n\n    extent_free(rbt->rb_ext, addr, size, exflags);\n\n    status = 0;\n  } else {\n    /* error. INVALID rbustag */\n    status = 1;\n  }\n  if (addrp != NULL) {\n    *addrp = addr;\n  }\n  return status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: bus_space_subregion failed\"",
            "func"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bus_space_subregion",
          "args": [
            "romt",
            "romh",
            "addr",
            "image_size",
            "&image->romh"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*image)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_INT16",
          "args": [
            "romt",
            "romh",
            "dataptr + CARDBUS_EXROM_DATA_IMAGE_LENGTH"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_INT16",
          "args": [
            "romt",
            "romh",
            "addr + CARDBUS_EXROM_DATA_PTR"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_INT16",
          "args": [
            "romt",
            "romh",
            "addr + CARDBUS_EXROM_SIGNATURE"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIMPLEQ_INIT",
          "args": [
            "head"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/cardbus/cardbus_exrom.h>\n#include <machine/bus.h>\n#include <sys/malloc.h>\n#include <sys/queue.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\ncardbus_read_exrom(romt, romh, head)\n     bus_space_tag_t romt;\n     bus_space_handle_t romh;\n     struct cardbus_rom_image_head *head;\n{\n    static const char func[] = \"cardbus_read_exrom\";\n\n    size_t addr = 0; /* offset of current rom image */\n    size_t dataptr;\n    unsigned int rom_image = 0;\n    \n    SIMPLEQ_INIT(head);\n    do {\n\tsize_t image_size;\n\tstruct cardbus_rom_image *image;\n\tu_int16_t val;\n\n\tval = READ_INT16(romt, romh, addr + CARDBUS_EXROM_SIGNATURE);\n\tif(val != 0xaa55) {\n\t    printf(\"%s: bad header signature in ROM image %u: 0x%04x\\n\", \n\t\t   func, rom_image, val);\n\t    return 1;\n\t}\n\tdataptr = addr + READ_INT16(romt, romh, addr + CARDBUS_EXROM_DATA_PTR);\n\t/* get the ROM image size, in blocks */\n\timage_size = READ_INT16(romt, romh, \n\t\t         dataptr + CARDBUS_EXROM_DATA_IMAGE_LENGTH);\n\tif(image_size == 0) \n\t    /* XXX some ROMs seem to have this as zero, can we assume\n               this means 1 block? */\n\t    image_size = 1;\n\timage_size <<= 9;\n\timage = malloc(sizeof(*image), M_DEVBUF, M_NOWAIT);\n\tif(image == NULL) {\n\t    printf(\"%s: out of memory\\n\", func);\n\t    return 1;\n\t}\n\timage->rom_image = rom_image;\n\timage->image_size = image_size;\n\timage->romt = romt;\n\tif(bus_space_subregion(romt, romh, addr, \n\t\t\t       image_size, &image->romh)) {\n\t    printf(\"%s: bus_space_subregion failed\", func);\n\t    free(image, M_DEVBUF);\n\t    return 1;\n\t}\n\tSIMPLEQ_INSERT_TAIL(head, image, next);\n\taddr += image_size;\n\trom_image++;\n    } while ((bus_space_read_1(romt, romh, \n                  dataptr + CARDBUS_EXROM_DATA_INDICATOR) & 0x80) == 0);\n    return 0;\n}"
  }
]