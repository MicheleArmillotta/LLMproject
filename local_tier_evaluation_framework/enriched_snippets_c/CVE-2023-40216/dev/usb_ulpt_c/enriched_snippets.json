[
  {
    "function_name": "ieee1284_print_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "572-589",
    "snippet": "void\nieee1284_print_id(str)\n\tchar *str;\n{\n\tchar *p, *q;\n\n\tfor (p = str-1; p; p = strchr(p, ';')) {\n\t\tp++;\t\t/* skip ';' */\n\t\tif (strncmp(p, \"MFG:\", 4) == 0 ||\n\t\t    strncmp(p, \"MANUFACTURER:\", 14) == 0 ||\n\t\t    strncmp(p, \"MDL:\", 4) == 0 ||\n\t\t    strncmp(p, \"MODEL:\", 6) == 0) {\n\t\t\tq = strchr(p, ';');\n\t\t\tif (q)\n\t\t\t\tprintf(\"%.*s\", (int)(q - p + 1), p);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void ieee1284_print_id"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%.*s\"",
            "(int)(q - p + 1)",
            "p"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "';'"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"MODEL:\"",
            "6"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"MDL:\"",
            "4"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"MANUFACTURER:\"",
            "14"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p",
            "\"MFG:\"",
            "4"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "';'"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid ieee1284_print_id;\n\nvoid\nieee1284_print_id(str)\n\tchar *str;\n{\n\tchar *p, *q;\n\n\tfor (p = str-1; p; p = strchr(p, ';')) {\n\t\tp++;\t\t/* skip ';' */\n\t\tif (strncmp(p, \"MFG:\", 4) == 0 ||\n\t\t    strncmp(p, \"MANUFACTURER:\", 14) == 0 ||\n\t\t    strncmp(p, \"MDL:\", 4) == 0 ||\n\t\t    strncmp(p, \"MODEL:\", 6) == 0) {\n\t\t\tq = strchr(p, ';');\n\t\t\tif (q)\n\t\t\t\tprintf(\"%.*s\", (int)(q - p + 1), p);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ulptioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "549-565",
    "snippet": "int\nulptioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\tdefault:\n\t\terror = ENODEV;\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nulptioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\tdefault:\n\t\terror = ENODEV;\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "ulptwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "528-547",
    "snippet": "int\nulptwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct ulpt_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ulpt, ULPTUNIT(dev), sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsc->sc_refcnt++;\n\terror = ulpt_do_write(sc, uio, flags);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ulpt_do_write"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usb_detach_wakeup",
          "args": [
            "USBDEV(sc->sc_dev)"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "usb_detach_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "548-554",
          "snippet": "void\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nusb_detach_wakeup(dv)\n\tdevice_ptr_t dv;\n{\n\tDPRINTF((\"usb_detach_wakeup: for %s\\n\", USBDEVPTRNAME(dv)));\n\twakeup(dv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEV",
          "args": [
            "sc->sc_dev"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulpt_do_write",
          "args": [
            "sc",
            "uio",
            "flags"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "ulpt_do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
          "lines": "488-526",
          "snippet": "int\nulpt_do_write(sc, uio, flags)\n\tstruct ulpt_softc *sc;\n\tstruct uio *uio;\n\tint flags;\n{\n\tu_int32_t n;\n\tint error = 0;\n\tvoid *bufp;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTF((\"ulptwrite\\n\"));\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, ULPT_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\twhile ((n = min(ULPT_BSIZE, uio->uio_resid)) != 0) {\n\t\tulpt_statusmsg(ulpt_status(sc), sc);\n\t\terror = uiomove(bufp, n, uio);\n\t\tif (error)\n\t\t\tbreak;\n\t\tDPRINTFN(1, (\"ulptwrite: transfer %d bytes\\n\", n));\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_bulkpipe, USBD_NO_COPY, \n\t\t\t  USBD_NO_TIMEOUT, bufp, &n, \"ulptwr\");\n\t\tif (err) {\n\t\t\tDPRINTF((\"ulptwrite: error=%d\\n\", err));\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tusbd_free_xfer(xfer);\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/syslog.h>",
            "#include <sys/vnode.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tULPT_BSIZE\t16384"
          ],
          "globals_used": [
            "int ulpt_do_write",
            "int ulpt_status",
            "int ulpt_statusmsg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tULPT_BSIZE\t16384\n\nint ulpt_do_write;\nint ulpt_status;\nint ulpt_statusmsg;\n\nint\nulpt_do_write(sc, uio, flags)\n\tstruct ulpt_softc *sc;\n\tstruct uio *uio;\n\tint flags;\n{\n\tu_int32_t n;\n\tint error = 0;\n\tvoid *bufp;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTF((\"ulptwrite\\n\"));\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, ULPT_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\twhile ((n = min(ULPT_BSIZE, uio->uio_resid)) != 0) {\n\t\tulpt_statusmsg(ulpt_status(sc), sc);\n\t\terror = uiomove(bufp, n, uio);\n\t\tif (error)\n\t\t\tbreak;\n\t\tDPRINTFN(1, (\"ulptwrite: transfer %d bytes\\n\", n));\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_bulkpipe, USBD_NO_COPY, \n\t\t\t  USBD_NO_TIMEOUT, bufp, &n, \"ulptwr\");\n\t\tif (err) {\n\t\t\tDPRINTF((\"ulptwrite: error=%d\\n\", err));\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tusbd_free_xfer(xfer);\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "ulpt",
            "ULPTUNIT(dev)",
            "sc"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULPTUNIT",
          "args": [
            "dev"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint ulpt_do_write;\n\nint\nulptwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct ulpt_softc *sc;\n\tint error;\n\n\tUSB_GET_SC(ulpt, ULPTUNIT(dev), sc);\n\n\tif (sc->sc_dying)\n\t\treturn (EIO);\n\n\tsc->sc_refcnt++;\n\terror = ulpt_do_write(sc, uio, flags);\n\tif (--sc->sc_refcnt < 0)\n\t\tusb_detach_wakeup(USBDEV(sc->sc_dev));\n\treturn (error);\n}"
  },
  {
    "function_name": "ulpt_do_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "488-526",
    "snippet": "int\nulpt_do_write(sc, uio, flags)\n\tstruct ulpt_softc *sc;\n\tstruct uio *uio;\n\tint flags;\n{\n\tu_int32_t n;\n\tint error = 0;\n\tvoid *bufp;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTF((\"ulptwrite\\n\"));\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, ULPT_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\twhile ((n = min(ULPT_BSIZE, uio->uio_resid)) != 0) {\n\t\tulpt_statusmsg(ulpt_status(sc), sc);\n\t\terror = uiomove(bufp, n, uio);\n\t\tif (error)\n\t\t\tbreak;\n\t\tDPRINTFN(1, (\"ulptwrite: transfer %d bytes\\n\", n));\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_bulkpipe, USBD_NO_COPY, \n\t\t\t  USBD_NO_TIMEOUT, bufp, &n, \"ulptwr\");\n\t\tif (err) {\n\t\t\tDPRINTF((\"ulptwrite: error=%d\\n\", err));\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tusbd_free_xfer(xfer);\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tULPT_BSIZE\t16384"
    ],
    "globals_used": [
      "int ulpt_do_write",
      "int ulpt_status",
      "int ulpt_statusmsg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_free_xfer",
          "args": [
            "xfer"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_free_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "403-418",
          "snippet": "usbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\n\nusbd_status \nusbd_free_xfer(xfer)\n\tusbd_xfer_handle xfer;\n{\n\tDPRINTFN(5,(\"usbd_free_xfer: %p\\n\", xfer));\n\tif (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))\n\t\tusbd_free_buffer(xfer);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&xfer->timeout_handle)) {\n\t\tcallout_stop(&xfer->timeout_handle);\n\t\tprintf(\"usbd_free_xfer: timout_handle pending\");\n\t}\n#endif\n\txfer->device->bus->methods->freex(xfer->device->bus, xfer);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ulptwrite: error=%d\\n\", err)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_bulk_transfer",
          "args": [
            "xfer",
            "sc->sc_bulkpipe",
            "USBD_NO_COPY",
            "USBD_NO_TIMEOUT",
            "bufp",
            "&n",
            "\"ulptwr\""
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_bulk_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi_util.c",
          "lines": "499-535",
          "snippet": "usbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}",
          "includes": [
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usbhid.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/bus.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usbhid.h>\n#include <dev/usb/usb.h>\n#include <sys/bus.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_status\nusbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle pipe;\n\tu_int16_t flags;\n\tu_int32_t timeout;\n\tvoid *buf;\n\tu_int32_t *size;\n\tchar *lbl;\n{\n\tusbd_status err;\n\tint s, error;\n\n\tusbd_setup_xfer(xfer, pipe, 0, buf, *size,\n\t\t\tflags, timeout, usbd_bulk_transfer_cb);\n\tDPRINTFN(1, (\"usbd_bulk_transfer: start transfer %d bytes\\n\", *size));\n\ts = splusb();\t\t/* don't want callback until tsleep() */\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tsplx(s);\n\t\treturn (err);\n\t}\n\terror = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);\n\tsplx(s);\n\tif (error) {\n\t\tDPRINTF((\"usbd_bulk_transfer: tsleep=%d\\n\", error));\n\t\tusbd_abort_pipe(pipe);\n\t\treturn (USBD_INTERRUPTED);\n\t}\n\tusbd_get_xfer_status(xfer, NULL, NULL, size, &err);\n\tDPRINTFN(1,(\"usbd_bulk_transfer: transferred %d\\n\", *size));\n\tif (err) {\n\t\tDPRINTF((\"usbd_bulk_transfer: error=%d\\n\", err));\n\t\tusbd_clear_endpoint_stall(pipe);\n\t}\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ulptwrite: transfer %d bytes\\n\", n)"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiomove",
          "args": [
            "bufp",
            "n",
            "uio"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulpt_statusmsg",
          "args": [
            "ulpt_status(sc)",
            "sc"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ulpt_statusmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
          "lines": "443-462",
          "snippet": "int\nulpt_statusmsg(status, sc)\n\tu_char status;\n\tstruct ulpt_softc *sc;\n{\n\tu_char new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", USBDEVNAME(sc->sc_dev));\n\n\treturn (status);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/syslog.h>",
            "#include <sys/vnode.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define LPS_MASK        (LPS_SELECT|LPS_NERR|LPS_NOPAPER)",
            "#define LPS_INVERT      (LPS_SELECT|LPS_NERR)",
            "#define\tLPS_NOPAPER\t\t0x20\t/* printer out of paper */",
            "#define\tLPS_SELECT\t\t0x10\t/* printer selected */",
            "#define\tLPS_NERR\t\t0x08\t/* printer no error */"
          ],
          "globals_used": [
            "int ulpt_statusmsg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define LPS_MASK        (LPS_SELECT|LPS_NERR|LPS_NOPAPER)\n#define LPS_INVERT      (LPS_SELECT|LPS_NERR)\n#define\tLPS_NOPAPER\t\t0x20\t/* printer out of paper */\n#define\tLPS_SELECT\t\t0x10\t/* printer selected */\n#define\tLPS_NERR\t\t0x08\t/* printer no error */\n\nint ulpt_statusmsg;\n\nint\nulpt_statusmsg(status, sc)\n\tu_char status;\n\tstruct ulpt_softc *sc;\n{\n\tu_char new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", USBDEVNAME(sc->sc_dev));\n\n\treturn (status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ULPT_BSIZE",
            "uio->uio_resid"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "umass_scsipi_minphys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/umass.c",
          "lines": "3240-3247",
          "snippet": "Static void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}",
          "includes": [
            "#include <machine/bus.h>",
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/ata/atavar.h>\t/* XXX */",
            "#include <dev/scsipi/scsi_changer.h>",
            "#include <dev/scsipi/scsi_disk.h>",
            "#include <dev/scsipi/scsipi_disk.h>",
            "#include <dev/scsipi/atapiconf.h>",
            "#include <dev/scsipi/scsiconf.h>",
            "#include <dev/scsipi/scsipi_all.h>",
            "#include <dev/scsipi/scsi_all.h>",
            "#include <sys/scsiio.h>",
            "#include <cam/cam_periph.h>",
            "#include <sys/devicestat.h>",
            "#include <cam/scsi/scsi_da.h>",
            "#include <cam/scsi/scsi_all.h>",
            "#include <cam/cam_xpt_sim.h>",
            "#include <cam/cam_sim.h>",
            "#include <cam/cam_ccb.h>",
            "#include <cam/cam.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/clock.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/malloc.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/buf.h>",
            "#include <sys/conf.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"atapibus.h\""
          ],
          "macros_used": [
            "#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE",
            "#define UMASS_MAX_TRANSFER_SIZE\t\t65536"
          ],
          "globals_used": [
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static void",
            "Static int",
            "Static void",
            "Static void",
            "Static void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <machine/bus.h>\n#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/ata/atavar.h>\t/* XXX */\n#include <dev/scsipi/scsi_changer.h>\n#include <dev/scsipi/scsi_disk.h>\n#include <dev/scsipi/scsipi_disk.h>\n#include <dev/scsipi/atapiconf.h>\n#include <dev/scsipi/scsiconf.h>\n#include <dev/scsipi/scsipi_all.h>\n#include <dev/scsipi/scsi_all.h>\n#include <sys/scsiio.h>\n#include <cam/cam_periph.h>\n#include <sys/devicestat.h>\n#include <cam/scsi/scsi_da.h>\n#include <cam/scsi/scsi_all.h>\n#include <cam/cam_xpt_sim.h>\n#include <cam/cam_sim.h>\n#include <cam/cam_ccb.h>\n#include <cam/cam.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/clock.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/malloc.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/buf.h>\n#include <sys/conf.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"atapibus.h\"\n\n#define UMASS_MAX_TRANSFER_SIZE\tMAXBSIZE\n#define UMASS_MAX_TRANSFER_SIZE\t\t65536\n\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic void;\nStatic int;\nStatic void;\nStatic void;\nStatic void;\n\nStatic void\numass_scsipi_minphys(bp)\n\tstruct buf *bp;\n{\n\tif (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)\n\t\tbp->b_bcount = UMASS_MAX_TRANSFER_SIZE;\n\tminphys(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "usbd_alloc_buffer",
          "args": [
            "xfer",
            "ULPT_BSIZE"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_alloc_xfer",
          "args": [
            "sc->sc_udev"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_alloc_xfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "388-401",
          "snippet": "usbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_xfer_handle \nusbd_alloc_xfer(dev)\n\tusbd_device_handle dev;\n{\n\tusbd_xfer_handle xfer;\n\n\txfer = dev->bus->methods->allocx(dev->bus);\n\tif (xfer == NULL)\n\t\treturn (NULL);\n\txfer->device = dev;\n\tusb_callout_init(xfer->timeout_handle);\n\tDPRINTFN(5,(\"usbd_alloc_xfer() = %p\\n\", xfer));\n\treturn (xfer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ulptwrite\\n\")"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tULPT_BSIZE\t16384\n\nint ulpt_do_write;\nint ulpt_status;\nint ulpt_statusmsg;\n\nint\nulpt_do_write(sc, uio, flags)\n\tstruct ulpt_softc *sc;\n\tstruct uio *uio;\n\tint flags;\n{\n\tu_int32_t n;\n\tint error = 0;\n\tvoid *bufp;\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\tDPRINTF((\"ulptwrite\\n\"));\n\txfer = usbd_alloc_xfer(sc->sc_udev);\n\tif (xfer == NULL)\n\t\treturn (ENOMEM);\n\tbufp = usbd_alloc_buffer(xfer, ULPT_BSIZE);\n\tif (bufp == NULL) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (ENOMEM);\n\t}\n\twhile ((n = min(ULPT_BSIZE, uio->uio_resid)) != 0) {\n\t\tulpt_statusmsg(ulpt_status(sc), sc);\n\t\terror = uiomove(bufp, n, uio);\n\t\tif (error)\n\t\t\tbreak;\n\t\tDPRINTFN(1, (\"ulptwrite: transfer %d bytes\\n\", n));\n\t\terr = usbd_bulk_transfer(xfer, sc->sc_bulkpipe, USBD_NO_COPY, \n\t\t\t  USBD_NO_TIMEOUT, bufp, &n, \"ulptwr\");\n\t\tif (err) {\n\t\t\tDPRINTF((\"ulptwrite: error=%d\\n\", err));\n\t\t\terror = EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tusbd_free_xfer(xfer);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "ulptclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "464-486",
    "snippet": "int\nulptclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct ulpt_softc *sc;\n\n\tUSB_GET_SC(ulpt, ULPTUNIT(dev), sc);\n\n\tif (sc->sc_state != ULPT_OPEN)\n\t\t/* We are being forced to close before the open completed. */\n\t\treturn (0);\n\n\tusbd_close_pipe(sc->sc_bulkpipe);\n\tsc->sc_bulkpipe = 0;\n\n\tsc->sc_state = 0;\n\n\tDPRINTF((\"ulptclose: closed\\n\"));\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tULPT_OPEN\t0x01\t/* device is open */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ulptclose: closed\\n\")"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_close_pipe",
          "args": [
            "sc->sc_bulkpipe"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_close_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "224-252",
          "snippet": "usbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\n\nusbd_status\nusbd_close_pipe(pipe)\n\tusbd_pipe_handle pipe;\n{\n#ifdef DIAGNOSTIC\n\tif (pipe == NULL) {\n\t\tprintf(\"usbd_close_pipe: pipe==NULL\\n\");\n\t\treturn (USBD_NORMAL_COMPLETION);\n\t}\n#endif\n\n\tif (--pipe->refcnt != 0)\n\t\treturn (USBD_NORMAL_COMPLETION);\n\tif (SIMPLEQ_FIRST(&pipe->queue) != 0)\n\t\treturn (USBD_PENDING_REQUESTS);\n\tLIST_REMOVE(pipe, next);\n\tpipe->endpoint->refcnt--;\n\tpipe->methods->close(pipe);\n#if defined(__NetBSD__) && defined(DIAGNOSTIC)\n\tif (callout_pending(&pipe->abort_handle)) {\n\t\tcallout_stop(&pipe->abort_handle);\n\t\tprintf(\"usbd_close_pipe: abort_handle pending\");\n\t}\n#endif\n\tif (pipe->intrxfer != NULL)\n\t\tusbd_free_xfer(pipe->intrxfer);\n\tfree(pipe, M_USB);\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USB_GET_SC",
          "args": [
            "ulpt",
            "ULPTUNIT(dev)",
            "sc"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULPTUNIT",
          "args": [
            "dev"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tULPT_OPEN\t0x01\t/* device is open */\n\nint\nulptclose(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tstruct ulpt_softc *sc;\n\n\tUSB_GET_SC(ulpt, ULPTUNIT(dev), sc);\n\n\tif (sc->sc_state != ULPT_OPEN)\n\t\t/* We are being forced to close before the open completed. */\n\t\treturn (0);\n\n\tusbd_close_pipe(sc->sc_bulkpipe);\n\tsc->sc_bulkpipe = 0;\n\n\tsc->sc_state = 0;\n\n\tDPRINTF((\"ulptclose: closed\\n\"));\n\treturn (0);\n}"
  },
  {
    "function_name": "ulpt_statusmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "443-462",
    "snippet": "int\nulpt_statusmsg(status, sc)\n\tu_char status;\n\tstruct ulpt_softc *sc;\n{\n\tu_char new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", USBDEVNAME(sc->sc_dev));\n\n\treturn (status);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define LPS_MASK        (LPS_SELECT|LPS_NERR|LPS_NOPAPER)",
      "#define LPS_INVERT      (LPS_SELECT|LPS_NERR)",
      "#define\tLPS_NOPAPER\t\t0x20\t/* printer out of paper */",
      "#define\tLPS_SELECT\t\t0x10\t/* printer selected */",
      "#define\tLPS_NERR\t\t0x08\t/* printer no error */"
    ],
    "globals_used": [
      "int ulpt_statusmsg"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_NOTICE",
            "\"%s: output error\\n\"",
            "USBDEVNAME(sc->sc_dev)"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USBDEVNAME",
          "args": [
            "sc->sc_dev"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define LPS_MASK        (LPS_SELECT|LPS_NERR|LPS_NOPAPER)\n#define LPS_INVERT      (LPS_SELECT|LPS_NERR)\n#define\tLPS_NOPAPER\t\t0x20\t/* printer out of paper */\n#define\tLPS_SELECT\t\t0x10\t/* printer selected */\n#define\tLPS_NERR\t\t0x08\t/* printer no error */\n\nint ulpt_statusmsg;\n\nint\nulpt_statusmsg(status, sc)\n\tu_char status;\n\tstruct ulpt_softc *sc;\n{\n\tu_char new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", USBDEVNAME(sc->sc_dev));\n\n\treturn (status);\n}"
  },
  {
    "function_name": "ulptopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "382-441",
    "snippet": "int\nulptopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tu_char flags = ULPTFLAGS(dev);\n\tstruct ulpt_softc *sc;\n\tusbd_status err;\n\tint spin, error;\n\n\tUSB_GET_SC_OPEN(ulpt, ULPTUNIT(dev), sc);\n\n\tif (sc == NULL || sc->sc_iface == NULL || sc->sc_dying)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_state)\n\t\treturn (EBUSY);\n\n\tsc->sc_state = ULPT_INIT;\n\tsc->sc_flags = flags;\n\tDPRINTF((\"ulptopen: flags=0x%x\\n\", (unsigned)flags));\n\n#if defined(ULPT_DEBUG) && defined(__FreeBSD__)\n\t/* Ignoring these flags might not be a good idea */\n\tif ((flags & ~ULPT_NOPRIME) != 0)\n\t\tprintf(\"ulptopen: flags ignored: %b\\n\", flags,\n\t\t\t\"\\20\\3POS_INIT\\4POS_ACK\\6PRIME_OPEN\\7AUTOLF\\10BYPASS\");\n#endif\n\n\n\tif ((flags & ULPT_NOPRIME) == 0)\n\t\tulpt_reset(sc);\n\n\tfor (spin = 0; (ulpt_status(sc) & LPS_SELECT) == 0; spin += STEP) {\n\t\tif (spin >= TIMEOUT) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\t/* wait 1/4 second, give up if we get a signal */\n\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH, \"ulptop\", STEP);\n\t\tif (error != EWOULDBLOCK) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\terr = usbd_open_pipe(sc->sc_iface, sc->sc_bulk, 0, &sc->sc_bulkpipe);\n\tif (err) {\n\t\tsc->sc_state = 0;\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_state = ULPT_OPEN;\n\n\tDPRINTF((\"ulptopen: done\\n\"));\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tULPT_NOPRIME\t0x40\t/* don't prime on open */",
      "#define\tULPT_INIT\t0x04\t/* waiting to initialize for open */",
      "#define\tULPT_OPEN\t0x01\t/* device is open */",
      "#define\tLPS_SELECT\t\t0x10\t/* printer selected */",
      "#define\tLPTPRI\t\t(PZERO+8)",
      "#define\tSTEP\t\thz/4",
      "#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */"
    ],
    "globals_used": [
      "int ulpt_status",
      "void ulpt_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ulptopen: done\\n\")"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_open_pipe",
          "args": [
            "sc->sc_iface",
            "sc->sc_bulk",
            "0",
            "&sc->sc_bulkpipe"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_open_pipe_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "177-222",
          "snippet": "usbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_ar_pipe  __P((usbd_pipe_handle pipe));",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "usbd_start_next __P((usbd_pipe_handle pipe));",
            "Static usbd_status",
            "usbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;",
            "usb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;",
            "void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);",
            "usb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;",
            "u_int8_t address;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_ar_pipe  __P((usbd_pipe_handle pipe));\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nusbd_start_next __P((usbd_pipe_handle pipe));\nStatic usbd_status;\nusbd_open_pipe_ival\n    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_interface_descriptor_t *\nusbd_get_interface_descriptor(iface)\n\tusbd_interface_handle iface;\nusb_endpoint_descriptor_t *\nusbd_interface2endpoint_descriptor(iface, index)\n\tusbd_interface_handle iface;\nvoid usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);\nusb_endpoint_descriptor_t *\nusbd_get_endpoint_descriptor(iface, address)\n\tusbd_interface_handle iface;\nu_int8_t address;\n\nusbd_status \nusbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)\n\tusbd_interface_handle iface;\n\tu_int8_t address;\n\tu_int8_t flags;\n\tusbd_pipe_handle *pipe;\n\tusbd_private_handle priv;\n\tvoid *buffer;\n\tu_int32_t len;\n\tusbd_callback cb;\n\tint ival;\n{\n\tusbd_status err;\n\tusbd_xfer_handle xfer;\n\tusbd_pipe_handle ipipe;\n\n\tDPRINTFN(3,(\"usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\\n\",\n\t\t    address, flags, len));\n\n\terr = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, \n\t\t\t\t  &ipipe, ival);\n\tif (err)\n\t\treturn (err);\n\txfer = usbd_alloc_xfer(iface->device);\n\tif (xfer == NULL) {\n\t\terr = USBD_NOMEM;\n\t\tgoto bad1;\n\t}\n\tusbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,\n\t    USBD_NO_TIMEOUT, cb);\n\tipipe->intrxfer = xfer;\n\tipipe->repeat = 1;\n\terr = usbd_transfer(xfer);\n\t*pipe = ipipe;\n\tif (err != USBD_IN_PROGRESS)\n\t\tgoto bad2;\n\treturn (USBD_NORMAL_COMPLETION);\n\n bad2:\n\tipipe->intrxfer = NULL;\n\tipipe->repeat = 0;\n\tusbd_free_xfer(xfer);\n bad1:\n\tusbd_close_pipe(ipipe);\n\treturn (err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)sc",
            "LPTPRI | PCATCH",
            "\"ulptop\"",
            "STEP"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulpt_status",
          "args": [
            "sc"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "ulpt_statusmsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
          "lines": "443-462",
          "snippet": "int\nulpt_statusmsg(status, sc)\n\tu_char status;\n\tstruct ulpt_softc *sc;\n{\n\tu_char new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", USBDEVNAME(sc->sc_dev));\n\n\treturn (status);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/syslog.h>",
            "#include <sys/vnode.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define LPS_MASK        (LPS_SELECT|LPS_NERR|LPS_NOPAPER)",
            "#define LPS_INVERT      (LPS_SELECT|LPS_NERR)",
            "#define\tLPS_NOPAPER\t\t0x20\t/* printer out of paper */",
            "#define\tLPS_SELECT\t\t0x10\t/* printer selected */",
            "#define\tLPS_NERR\t\t0x08\t/* printer no error */"
          ],
          "globals_used": [
            "int ulpt_statusmsg"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define LPS_MASK        (LPS_SELECT|LPS_NERR|LPS_NOPAPER)\n#define LPS_INVERT      (LPS_SELECT|LPS_NERR)\n#define\tLPS_NOPAPER\t\t0x20\t/* printer out of paper */\n#define\tLPS_SELECT\t\t0x10\t/* printer selected */\n#define\tLPS_NERR\t\t0x08\t/* printer no error */\n\nint ulpt_statusmsg;\n\nint\nulpt_statusmsg(status, sc)\n\tu_char status;\n\tstruct ulpt_softc *sc;\n{\n\tu_char new;\n\n\tstatus = (status ^ LPS_INVERT) & LPS_MASK;\n\tnew = status & ~sc->sc_laststatus;\n\tsc->sc_laststatus = status;\n\n\tif (new & LPS_SELECT)\n\t\tlog(LOG_NOTICE, \"%s: offline\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NOPAPER)\n\t\tlog(LOG_NOTICE, \"%s: out of paper\\n\", USBDEVNAME(sc->sc_dev));\n\telse if (new & LPS_NERR)\n\t\tlog(LOG_NOTICE, \"%s: output error\\n\", USBDEVNAME(sc->sc_dev));\n\n\treturn (status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulpt_reset",
          "args": [
            "sc"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ulpt_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
          "lines": "364-377",
          "snippet": "void\nulpt_reset(sc)\n\tstruct ulpt_softc *sc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(1, (\"ulpt_reset\\n\"));\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SOFT_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->sc_ifaceno);\n\tUSETW(req.wLength, 0);\n\t(void)usbd_do_request(sc->sc_udev, &req, 0);\n}",
          "includes": [
            "#include <dev/usb/usb_quirks.h>",
            "#include <dev/usb/usbdevs.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <sys/syslog.h>",
            "#include <sys/vnode.h>",
            "#include <sys/conf.h>",
            "#include <sys/uio.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/ioccom.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define UR_SOFT_RESET 2"
          ],
          "globals_used": [
            "void ulpt_reset"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UR_SOFT_RESET 2\n\nvoid ulpt_reset;\n\nvoid\nulpt_reset(sc)\n\tstruct ulpt_softc *sc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(1, (\"ulpt_reset\\n\"));\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SOFT_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->sc_ifaceno);\n\tUSETW(req.wLength, 0);\n\t(void)usbd_do_request(sc->sc_udev, &req, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ulptopen: flags ignored: %b\\n\"",
            "flags",
            "\"\\20\\3POS_INIT\\4POS_ACK\\6PRIME_OPEN\\7AUTOLF\\10BYPASS\""
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"ulptopen: flags=0x%x\\n\", (unsigned)flags)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USB_GET_SC_OPEN",
          "args": [
            "ulpt",
            "ULPTUNIT(dev)",
            "sc"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULPTUNIT",
          "args": [
            "dev"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULPTFLAGS",
          "args": [
            "dev"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tULPT_NOPRIME\t0x40\t/* don't prime on open */\n#define\tULPT_INIT\t0x04\t/* waiting to initialize for open */\n#define\tULPT_OPEN\t0x01\t/* device is open */\n#define\tLPS_SELECT\t\t0x10\t/* printer selected */\n#define\tLPTPRI\t\t(PZERO+8)\n#define\tSTEP\t\thz/4\n#define\tTIMEOUT\t\thz*16\t/* wait up to 16 seconds for a ready */\n\nint ulpt_status;\nvoid ulpt_reset;\n\nint\nulptopen(dev, flag, mode, p)\n\tdev_t dev;\n\tint flag;\n\tint mode;\n\tstruct proc *p;\n{\n\tu_char flags = ULPTFLAGS(dev);\n\tstruct ulpt_softc *sc;\n\tusbd_status err;\n\tint spin, error;\n\n\tUSB_GET_SC_OPEN(ulpt, ULPTUNIT(dev), sc);\n\n\tif (sc == NULL || sc->sc_iface == NULL || sc->sc_dying)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_state)\n\t\treturn (EBUSY);\n\n\tsc->sc_state = ULPT_INIT;\n\tsc->sc_flags = flags;\n\tDPRINTF((\"ulptopen: flags=0x%x\\n\", (unsigned)flags));\n\n#if defined(ULPT_DEBUG) && defined(__FreeBSD__)\n\t/* Ignoring these flags might not be a good idea */\n\tif ((flags & ~ULPT_NOPRIME) != 0)\n\t\tprintf(\"ulptopen: flags ignored: %b\\n\", flags,\n\t\t\t\"\\20\\3POS_INIT\\4POS_ACK\\6PRIME_OPEN\\7AUTOLF\\10BYPASS\");\n#endif\n\n\n\tif ((flags & ULPT_NOPRIME) == 0)\n\t\tulpt_reset(sc);\n\n\tfor (spin = 0; (ulpt_status(sc) & LPS_SELECT) == 0; spin += STEP) {\n\t\tif (spin >= TIMEOUT) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn (EBUSY);\n\t\t}\n\n\t\t/* wait 1/4 second, give up if we get a signal */\n\t\terror = tsleep((caddr_t)sc, LPTPRI | PCATCH, \"ulptop\", STEP);\n\t\tif (error != EWOULDBLOCK) {\n\t\t\tsc->sc_state = 0;\n\t\t\treturn (error);\n\t\t}\n\t}\n\n\terr = usbd_open_pipe(sc->sc_iface, sc->sc_bulk, 0, &sc->sc_bulkpipe);\n\tif (err) {\n\t\tsc->sc_state = 0;\n\t\treturn (EIO);\n\t}\n\n\tsc->sc_state = ULPT_OPEN;\n\n\tDPRINTF((\"ulptopen: done\\n\"));\n\treturn (0);\n}"
  },
  {
    "function_name": "ulpt_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "364-377",
    "snippet": "void\nulpt_reset(sc)\n\tstruct ulpt_softc *sc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(1, (\"ulpt_reset\\n\"));\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SOFT_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->sc_ifaceno);\n\tUSETW(req.wLength, 0);\n\t(void)usbd_do_request(sc->sc_udev, &req, 0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UR_SOFT_RESET 2"
    ],
    "globals_used": [
      "void ulpt_reset"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "sc->sc_udev",
            "&req",
            "0"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "0"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "sc->sc_ifaceno"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ulpt_reset\\n\")"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UR_SOFT_RESET 2\n\nvoid ulpt_reset;\n\nvoid\nulpt_reset(sc)\n\tstruct ulpt_softc *sc;\n{\n\tusb_device_request_t req;\n\n\tDPRINTFN(1, (\"ulpt_reset\\n\"));\n\treq.bmRequestType = UT_WRITE_CLASS_OTHER;\n\treq.bRequest = UR_SOFT_RESET;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->sc_ifaceno);\n\tUSETW(req.wLength, 0);\n\t(void)usbd_do_request(sc->sc_udev, &req, 0);\n}"
  },
  {
    "function_name": "ulpt_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "343-362",
    "snippet": "int\nulpt_status(sc)\n\tstruct ulpt_softc *sc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\tu_char status;\n\n\treq.bmRequestType = UT_READ_CLASS_INTERFACE;\n\treq.bRequest = UR_GET_PORT_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->sc_ifaceno);\n\tUSETW(req.wLength, 1);\n\terr = usbd_do_request(sc->sc_udev, &req, &status);\n\tDPRINTFN(1, (\"ulpt_status: status=0x%02x err=%d\\n\", status, err));\n\tif (!err)\n\t\treturn (status);\n\telse\n\t\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define UR_GET_PORT_STATUS 1"
    ],
    "globals_used": [
      "int ulpt_status"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTFN",
          "args": [
            "1",
            "(\"ulpt_status: status=0x%02x err=%d\\n\", status, err)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usbd_do_request",
          "args": [
            "sc->sc_udev",
            "&req",
            "&status"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "usbd_do_request_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/usbdi.c",
          "lines": "1059-1079",
          "snippet": "usbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}",
          "includes": [
            "#include \"usb_if.h\"",
            "#include <dev/usb/usb_mem.h>",
            "#include <dev/usb/usbdivar.h>",
            "#include <dev/usb/usbdi_util.h>",
            "#include <dev/usb/usbdi.h>",
            "#include <dev/usb/usb.h>",
            "#include <machine/bus.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <machine/cpu.h>",
            "#include \"usb_if.h\"",
            "#include <sys/conf.h>",
            "#include <sys/bus.h>",
            "#include <sys/module.h>",
            "#include <sys/device.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "Static usbd_status",
            "usbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));",
            "Static usbd_status",
            "usbd_xfer_isread __P((usbd_xfer_handle xfer));",
            "void *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;",
            "void *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;",
            "usb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;",
            "usb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;",
            "struct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"usb_if.h\"\n#include <dev/usb/usb_mem.h>\n#include <dev/usb/usbdivar.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <machine/bus.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <machine/cpu.h>\n#include \"usb_if.h\"\n#include <sys/conf.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nStatic usbd_status;\nusbd_do_request_async_cb \n    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));\nStatic usbd_status;\nusbd_xfer_isread __P((usbd_xfer_handle xfer));\nvoid *\nusbd_alloc_buffer(xfer, size)\n\tusbd_xfer_handle xfer;\nvoid *\nusbd_get_buffer(xfer)\n\tusbd_xfer_handle xfer;\nusb_config_descriptor_t *\nusbd_get_config_descriptor(dev)\n\tusbd_device_handle dev;\nusb_device_descriptor_t *\nusbd_get_device_descriptor(dev)\n\tusbd_device_handle dev;\nstruct usbd_quirks *\nusbd_get_quirks(dev)\n\tusbd_device_handle dev;\n\nusbd_status\nusbd_do_request_async(dev, req, data)\n\tusbd_device_handle dev;\n\tusb_device_request_t *req;\n\tvoid *data;\n{\n\tusbd_xfer_handle xfer;\n\tusbd_status err;\n\n\txfer = usbd_alloc_xfer(dev);\n\tif (xfer == NULL)\n\t\treturn (USBD_NOMEM);\n\tusbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,\n\t    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);\n\terr = usbd_transfer(xfer);\n\tif (err != USBD_IN_PROGRESS) {\n\t\tusbd_free_xfer(xfer);\n\t\treturn (err);\n\t}\n\treturn (USBD_NORMAL_COMPLETION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wLength",
            "1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wIndex",
            "sc->sc_ifaceno"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "USETW",
          "args": [
            "req.wValue",
            "0"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define UR_GET_PORT_STATUS 1\n\nint ulpt_status;\n\nint\nulpt_status(sc)\n\tstruct ulpt_softc *sc;\n{\n\tusb_device_request_t req;\n\tusbd_status err;\n\tu_char status;\n\n\treq.bmRequestType = UT_READ_CLASS_INTERFACE;\n\treq.bRequest = UR_GET_PORT_STATUS;\n\tUSETW(req.wValue, 0);\n\tUSETW(req.wIndex, sc->sc_ifaceno);\n\tUSETW(req.wLength, 1);\n\terr = usbd_do_request(sc->sc_udev, &req, &status);\n\tDPRINTFN(1, (\"ulpt_status: status=0x%02x err=%d\\n\", status, err));\n\tif (!err)\n\t\treturn (status);\n\telse\n\t\treturn (0);\n}"
  },
  {
    "function_name": "ulpt_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/usb/ulpt.c",
    "lines": "277-294",
    "snippet": "int\nulpt_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ulpt_softc *sc = (struct ulpt_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include <dev/usb/usb_quirks.h>",
      "#include <dev/usb/usbdevs.h>",
      "#include <dev/usb/usbdi_util.h>",
      "#include <dev/usb/usbdi.h>",
      "#include <dev/usb/usb.h>",
      "#include <sys/syslog.h>",
      "#include <sys/vnode.h>",
      "#include <sys/conf.h>",
      "#include <sys/uio.h>",
      "#include <sys/bus.h>",
      "#include <sys/module.h>",
      "#include <sys/ioccom.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/kernel.h>",
      "#include <sys/proc.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <dev/usb/usb_quirks.h>\n#include <dev/usb/usbdevs.h>\n#include <dev/usb/usbdi_util.h>\n#include <dev/usb/usbdi.h>\n#include <dev/usb/usb.h>\n#include <sys/syslog.h>\n#include <sys/vnode.h>\n#include <sys/conf.h>\n#include <sys/uio.h>\n#include <sys/bus.h>\n#include <sys/module.h>\n#include <sys/ioccom.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/kernel.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nulpt_activate(self, act)\n\tdevice_ptr_t self;\n\tenum devact act;\n{\n\tstruct ulpt_softc *sc = (struct ulpt_softc *)self;\n\n\tswitch (act) {\n\tcase DVACT_ACTIVATE:\n\t\treturn (EOPNOTSUPP);\n\t\tbreak;\n\n\tcase DVACT_DEACTIVATE:\n\t\tsc->sc_dying = 1;\n\t\tbreak;\n\t}\n\treturn (0);\n}"
  }
]