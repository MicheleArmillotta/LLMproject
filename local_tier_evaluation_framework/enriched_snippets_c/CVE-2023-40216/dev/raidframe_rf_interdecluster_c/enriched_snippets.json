[
  {
    "function_name": "rf_RAIDIDagSelect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "257-279",
    "snippet": "void \nrf_RAIDIDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (asmap->numDataFailed + asmap->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t*createFunc = NULL;\n\t\treturn;\n\t}\n\t*createFunc = (type == RF_IO_TYPE_READ) ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n\tif (type == RF_IO_TYPE_READ) {\n\t\tif (asmap->numDataFailed == 0)\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateMirrorPartitionReadDAG;\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneDegradedReadDAG;\n\t} else\n\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ERRORMSG",
          "args": [
            "\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_RAIDIDagSelect(\n    RF_Raid_t * raidPtr,\n    RF_IoType_t type,\n    RF_AccessStripeMap_t * asmap,\n    RF_VoidFuncPtr * createFunc)\n{\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (asmap->numDataFailed + asmap->numParityFailed > 1) {\n\t\tRF_ERRORMSG(\"Multiple disks failed in a single group!  Aborting I/O operation.\\n\");\n\t\t*createFunc = NULL;\n\t\treturn;\n\t}\n\t*createFunc = (type == RF_IO_TYPE_READ) ? (RF_VoidFuncPtr) rf_CreateFaultFreeReadDAG : (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n\tif (type == RF_IO_TYPE_READ) {\n\t\tif (asmap->numDataFailed == 0)\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateMirrorPartitionReadDAG;\n\t\telse\n\t\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneDegradedReadDAG;\n\t} else\n\t\t*createFunc = (RF_VoidFuncPtr) rf_CreateRaidOneWriteDAG;\n}"
  },
  {
    "function_name": "rf_MapSIDToPSIDInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "238-247",
    "snippet": "void \nrf_MapSIDToPSIDInterDecluster(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapSIDToPSIDInterDecluster(\n    RF_RaidLayout_t * layoutPtr,\n    RF_StripeNum_t stripeID,\n    RF_StripeNum_t * psID,\n    RF_ReconUnitNum_t * which_ru)\n{\n\t*which_ru = 0;\n\t*psID = stripeID;\n}"
  },
  {
    "function_name": "rf_IdentifyStripeInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "221-236",
    "snippet": "void \nrf_IdentifyStripeInterDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID;\n\n\tSUID = addr / raidPtr->Layout.sectorsPerStripeUnit;\n\tSUID = SUID % info->stripeUnitsPerSparingRegion;\n\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[SUID];\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_IdentifyStripeInterDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t addr,\n    RF_RowCol_t ** diskids,\n    RF_RowCol_t * outRow)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID;\n\n\tSUID = addr / raidPtr->Layout.sectorsPerStripeUnit;\n\tSUID = SUID % info->stripeUnitsPerSparingRegion;\n\n\t*outRow = 0;\n\t*diskids = info->stripeIdentifier[SUID];\n}"
  },
  {
    "function_name": "rf_MapParityInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "183-219",
    "snippet": "void \nrf_MapParityInterDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t sparing_region_id, index_within_region, mirror_su_offset_into_disk;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tint     col_before_remap;\n\n\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\tmirror_su_offset_into_disk = index_within_region / raidPtr->numCol;\n\tcol_before_remap = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;\n\n\t*row = 0;\n\tif (!remap) {\n\t\t*col = col_before_remap;\n\t\t*diskSector = info->mirrorStripeOffset * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += sparing_region_id * (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += mirror_su_offset_into_disk * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap parity to spare space ... */\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\t*col = index_within_region / (raidPtr->numCol - 1);\n\t\t*col = (*col + 1) % raidPtr->numCol;\n\t\tif (*col == col_before_remap)\n\t\t\t*col = (*col + 1) % raidPtr->numCol;\n\t}\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapParityInterDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t sparing_region_id, index_within_region, mirror_su_offset_into_disk;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tint     col_before_remap;\n\n\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\tmirror_su_offset_into_disk = index_within_region / raidPtr->numCol;\n\tcol_before_remap = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;\n\n\t*row = 0;\n\tif (!remap) {\n\t\t*col = col_before_remap;\n\t\t*diskSector = info->mirrorStripeOffset * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += sparing_region_id * (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += mirror_su_offset_into_disk * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap parity to spare space ... */\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\t*col = index_within_region / (raidPtr->numCol - 1);\n\t\t*col = (*col + 1) % raidPtr->numCol;\n\t\tif (*col == col_before_remap)\n\t\t\t*col = (*col + 1) % raidPtr->numCol;\n\t}\n}"
  },
  {
    "function_name": "rf_MapSectorInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "144-181",
    "snippet": "void \nrf_MapSectorInterDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_StripeNum_t su_offset_into_disk, mirror_su_offset_into_disk;\n\tRF_StripeNum_t sparing_region_id, index_within_region;\n\tint     col_before_remap;\n\n\t*row = 0;\n\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\tsu_offset_into_disk = index_within_region % (raidPtr->numCol - 1);\n\tmirror_su_offset_into_disk = index_within_region / raidPtr->numCol;\n\tcol_before_remap = index_within_region / (raidPtr->numCol - 1);\n\n\tif (!remap) {\n\t\t*col = col_before_remap;;\n\t\t*diskSector = (su_offset_into_disk + ((raidPtr->numCol - 1) * sparing_region_id)) *\n\t\t    raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap sector to spare space... */\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\t*col = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;\n\t\t*col = (*col + 1) % raidPtr->numCol;\n\t\tif (*col == col_before_remap)\n\t\t\t*col = (*col + 1) % raidPtr->numCol;\n\t}\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nvoid \nrf_MapSectorInterDecluster(\n    RF_Raid_t * raidPtr,\n    RF_RaidAddr_t raidSector,\n    RF_RowCol_t * row,\n    RF_RowCol_t * col,\n    RF_SectorNum_t * diskSector,\n    int remap)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\tRF_StripeNum_t SUID = raidSector / raidPtr->Layout.sectorsPerStripeUnit;\n\tRF_StripeNum_t su_offset_into_disk, mirror_su_offset_into_disk;\n\tRF_StripeNum_t sparing_region_id, index_within_region;\n\tint     col_before_remap;\n\n\t*row = 0;\n\tsparing_region_id = SUID / info->stripeUnitsPerSparingRegion;\n\tindex_within_region = SUID % info->stripeUnitsPerSparingRegion;\n\tsu_offset_into_disk = index_within_region % (raidPtr->numCol - 1);\n\tmirror_su_offset_into_disk = index_within_region / raidPtr->numCol;\n\tcol_before_remap = index_within_region / (raidPtr->numCol - 1);\n\n\tif (!remap) {\n\t\t*col = col_before_remap;;\n\t\t*diskSector = (su_offset_into_disk + ((raidPtr->numCol - 1) * sparing_region_id)) *\n\t\t    raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t} else {\n\t\t/* remap sector to spare space... */\n\t\t*diskSector = sparing_region_id * (raidPtr->numCol + 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidPtr->numCol - 1) * raidPtr->Layout.sectorsPerStripeUnit;\n\t\t*diskSector += (raidSector % raidPtr->Layout.sectorsPerStripeUnit);\n\t\t*col = (index_within_region + 1 + mirror_su_offset_into_disk) % raidPtr->numCol;\n\t\t*col = (*col + 1) % raidPtr->numCol;\n\t\tif (*col == col_before_remap)\n\t\t\t*col = (*col + 1) % raidPtr->numCol;\n\t}\n}"
  },
  {
    "function_name": "rf_GetNumSpareRUsInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "133-142",
    "snippet": "RF_ReconUnitCount_t \nrf_GetNumSpareRUsInterDecluster(\n    RF_Raid_t * raidPtr)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\treturn (2 * ((RF_ReconUnitCount_t) info->numSparingRegions));\n\t/* the layout uses two stripe units per disk as spare within each\n\t * sparing region */\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_ReconUnitCount_t \nrf_GetNumSpareRUsInterDecluster(\n    RF_Raid_t * raidPtr)\n{\n\tRF_InterdeclusterConfigInfo_t *info = (RF_InterdeclusterConfigInfo_t *) raidPtr->Layout.layoutSpecificInfo;\n\n\treturn (2 * ((RF_ReconUnitCount_t) info->numSparingRegions));\n\t/* the layout uses two stripe units per disk as spare within each\n\t * sparing region */\n}"
  },
  {
    "function_name": "rf_GetDefaultHeadSepLimitInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "127-131",
    "snippet": "RF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitInterDecluster(RF_Raid_t * raidPtr)\n{\n\treturn (raidPtr->sectorsPerDisk);\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nRF_HeadSepLimit_t \nrf_GetDefaultHeadSepLimitInterDecluster(RF_Raid_t * raidPtr)\n{\n\treturn (raidPtr->sectorsPerDisk);\n}"
  },
  {
    "function_name": "rf_GetDefaultNumFloatingReconBuffersInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "121-125",
    "snippet": "int \nrf_GetDefaultNumFloatingReconBuffersInterDecluster(RF_Raid_t * raidPtr)\n{\n\treturn (30);\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_GetDefaultNumFloatingReconBuffersInterDecluster(RF_Raid_t * raidPtr)\n{\n\treturn (30);\n}"
  },
  {
    "function_name": "rf_ConfigureInterDecluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_interdecluster.c",
    "lines": "58-119",
    "snippet": "int \nrf_ConfigureInterDecluster(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t num_used_stripeUnitsPerDisk;\n\tRF_InterdeclusterConfigInfo_t *info;\n\tRF_RowCol_t i, tmp, SUs_per_region;\n\n\t/* create an Interleaved Declustering configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_InterdeclusterConfigInfo_t), (RF_InterdeclusterConfigInfo_t *),\n\t    raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\t/* fill in the config structure.  */\n\tSUs_per_region = raidPtr->numCol * (raidPtr->numCol - 1);\n\tinfo->stripeIdentifier = rf_make_2d_array(SUs_per_region, 2, raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\tfor (i = 0; i < SUs_per_region; i++) {\n\t\tinfo->stripeIdentifier[i][0] = i / (raidPtr->numCol - 1);\n\t\ttmp = i / raidPtr->numCol;\n\t\tinfo->stripeIdentifier[i][1] = (i + 1 + tmp) % raidPtr->numCol;\n\t}\n\n\t/* no spare tables */\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* fill in the remaining layout parameters */\n\n\t/* total number of stripes should a multiple of 2*numCol: Each sparing\n\t * region consists of 2*numCol stripes: n-1 primary copy, n-1\n\t * secondary copy and 2 for spare .. */\n\tnum_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk - (layoutPtr->stripeUnitsPerDisk %\n\t    (2 * raidPtr->numCol));\n\tinfo->numSparingRegions = num_used_stripeUnitsPerDisk / (2 * raidPtr->numCol);\n\t/* this is in fact the number of stripe units (that are primary data\n\t * copies) in the sparing region */\n\tinfo->stripeUnitsPerSparingRegion = raidPtr->numCol * (raidPtr->numCol - 1);\n\tinfo->mirrorStripeOffset = info->numSparingRegions * (raidPtr->numCol + 1);\n\tlayoutPtr->numStripe = info->numSparingRegions * info->stripeUnitsPerSparingRegion;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = 1;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 1;\n\n\tlayoutPtr->dataStripeUnitsPerDisk = num_used_stripeUnitsPerDisk;\n\n\traidPtr->sectorsPerDisk =\n\t    num_used_stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors =\n\t    (layoutPtr->numStripe) * layoutPtr->sectorsPerStripeUnit;\n\n\tlayoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_dagdegwr.h\"",
      "#include \"rf_dagffwr.h\"",
      "#include \"rf_dagdegrd.h\"",
      "#include \"rf_dagffrd.h\"",
      "#include \"rf_utils.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_dagfuncs.h\"",
      "#include \"rf_dagutils.h\"",
      "#include \"rf_dag.h\"",
      "#include \"rf_interdecluster.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "raidPtr->numRow == 1"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_make_2d_array",
          "args": [
            "SUs_per_region",
            "2",
            "raidPtr->cleanupList"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_MallocAndAdd",
          "args": [
            "info",
            "sizeof(RF_InterdeclusterConfigInfo_t)",
            "(RF_InterdeclusterConfigInfo_t *),\n\t    raidPtr->cleanupList"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_dagdegwr.h\"\n#include \"rf_dagffwr.h\"\n#include \"rf_dagdegrd.h\"\n#include \"rf_dagffrd.h\"\n#include \"rf_utils.h\"\n#include \"rf_general.h\"\n#include \"rf_dagfuncs.h\"\n#include \"rf_dagutils.h\"\n#include \"rf_dag.h\"\n#include \"rf_interdecluster.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nint \nrf_ConfigureInterDecluster(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tRF_RaidLayout_t *layoutPtr = &raidPtr->Layout;\n\tRF_StripeCount_t num_used_stripeUnitsPerDisk;\n\tRF_InterdeclusterConfigInfo_t *info;\n\tRF_RowCol_t i, tmp, SUs_per_region;\n\n\t/* create an Interleaved Declustering configuration structure */\n\tRF_MallocAndAdd(info, sizeof(RF_InterdeclusterConfigInfo_t), (RF_InterdeclusterConfigInfo_t *),\n\t    raidPtr->cleanupList);\n\tif (info == NULL)\n\t\treturn (ENOMEM);\n\tlayoutPtr->layoutSpecificInfo = (void *) info;\n\n\t/* fill in the config structure.  */\n\tSUs_per_region = raidPtr->numCol * (raidPtr->numCol - 1);\n\tinfo->stripeIdentifier = rf_make_2d_array(SUs_per_region, 2, raidPtr->cleanupList);\n\tif (info->stripeIdentifier == NULL)\n\t\treturn (ENOMEM);\n\tfor (i = 0; i < SUs_per_region; i++) {\n\t\tinfo->stripeIdentifier[i][0] = i / (raidPtr->numCol - 1);\n\t\ttmp = i / raidPtr->numCol;\n\t\tinfo->stripeIdentifier[i][1] = (i + 1 + tmp) % raidPtr->numCol;\n\t}\n\n\t/* no spare tables */\n\tRF_ASSERT(raidPtr->numRow == 1);\n\n\t/* fill in the remaining layout parameters */\n\n\t/* total number of stripes should a multiple of 2*numCol: Each sparing\n\t * region consists of 2*numCol stripes: n-1 primary copy, n-1\n\t * secondary copy and 2 for spare .. */\n\tnum_used_stripeUnitsPerDisk = layoutPtr->stripeUnitsPerDisk - (layoutPtr->stripeUnitsPerDisk %\n\t    (2 * raidPtr->numCol));\n\tinfo->numSparingRegions = num_used_stripeUnitsPerDisk / (2 * raidPtr->numCol);\n\t/* this is in fact the number of stripe units (that are primary data\n\t * copies) in the sparing region */\n\tinfo->stripeUnitsPerSparingRegion = raidPtr->numCol * (raidPtr->numCol - 1);\n\tinfo->mirrorStripeOffset = info->numSparingRegions * (raidPtr->numCol + 1);\n\tlayoutPtr->numStripe = info->numSparingRegions * info->stripeUnitsPerSparingRegion;\n\tlayoutPtr->bytesPerStripeUnit = layoutPtr->sectorsPerStripeUnit << raidPtr->logBytesPerSector;\n\tlayoutPtr->numDataCol = 1;\n\tlayoutPtr->dataSectorsPerStripe = layoutPtr->numDataCol * layoutPtr->sectorsPerStripeUnit;\n\tlayoutPtr->numParityCol = 1;\n\n\tlayoutPtr->dataStripeUnitsPerDisk = num_used_stripeUnitsPerDisk;\n\n\traidPtr->sectorsPerDisk =\n\t    num_used_stripeUnitsPerDisk * layoutPtr->sectorsPerStripeUnit;\n\n\traidPtr->totalSectors =\n\t    (layoutPtr->numStripe) * layoutPtr->sectorsPerStripeUnit;\n\n\tlayoutPtr->stripeUnitsPerDisk = raidPtr->sectorsPerDisk / layoutPtr->sectorsPerStripeUnit;\n\n\treturn (0);\n}"
  }
]