[
  {
    "function_name": "wsmux_set_display",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "677-737",
    "snippet": "int\nwsmux_set_display(dv, muxsc)\n\tstruct device *dv;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsmux_softc *nsc = muxsc ? sc : 0;\n\tstruct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;\n\tstruct device *odisplaydv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_set_display: %s: displaydv=%p\\n\",\n\t\t sc->sc_dv.dv_xname, displaydv));\n\n\tif (displaydv) {\n\t\tif (sc->sc_displaydv)\n\t\t\treturn (EBUSY);\n\t} else {\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (ENXIO);\n\t}\n\n\todisplaydv = sc->sc_displaydv;\n\tsc->sc_displaydv = displaydv;\n\n\tif (displaydv)\n\t\tprintf(\"%s: connecting to %s\\n\",\n\t\t       sc->sc_dv.dv_xname, displaydv->dv_xname);\n\tok = 0;\n\terror = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc_ops->dsetdisplay &&\n\t\t    (nsc ? m->sc_mevents->io == 0 && *m->sc_muxp == 0 : \n\t\t           *m->sc_muxp == sc)) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, nsc);\n\t\t\tDPRINTF((\"wsmux_set_display: m=%p dev=%s error=%d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error) {\n\t\t\t\tok = 1;\n\t\t\t\t*m->sc_muxp = nsc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_set_display: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\tif (displaydv == NULL)\n\t\tprintf(\"%s: disconnecting from %s\\n\", \n\t\t       sc->sc_dv.dv_xname, odisplaydv->dv_xname);\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s: disconnecting from %s\\n\"",
            "sc->sc_dv.dv_xname",
            "odisplaydv->dv_xname"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dioctl",
          "args": [
            "m->sc",
            "WSKBDIO_SETMODE",
            "(caddr_t)&sc->sc_rawkbd",
            "0",
            "0"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_set_display: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_set_display: m=%p dev=%s error=%d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dsetdisplay",
          "args": [
            "m->sc",
            "nsc"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "m",
            "next"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_reals"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_set_display: %s: displaydv=%p\\n\",\n\t\t sc->sc_dv.dv_xname, displaydv)"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_set_display(dv, muxsc)\n\tstruct device *dv;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsmux_softc *nsc = muxsc ? sc : 0;\n\tstruct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;\n\tstruct device *odisplaydv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_set_display: %s: displaydv=%p\\n\",\n\t\t sc->sc_dv.dv_xname, displaydv));\n\n\tif (displaydv) {\n\t\tif (sc->sc_displaydv)\n\t\t\treturn (EBUSY);\n\t} else {\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (ENXIO);\n\t}\n\n\todisplaydv = sc->sc_displaydv;\n\tsc->sc_displaydv = displaydv;\n\n\tif (displaydv)\n\t\tprintf(\"%s: connecting to %s\\n\",\n\t\t       sc->sc_dv.dv_xname, displaydv->dv_xname);\n\tok = 0;\n\terror = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc_ops->dsetdisplay &&\n\t\t    (nsc ? m->sc_mevents->io == 0 && *m->sc_muxp == 0 : \n\t\t           *m->sc_muxp == sc)) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, nsc);\n\t\t\tDPRINTF((\"wsmux_set_display: m=%p dev=%s error=%d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error) {\n\t\t\t\tok = 1;\n\t\t\t\t*m->sc_muxp = nsc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_set_display: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\tif (displaydv == NULL)\n\t\tprintf(\"%s: disconnecting from %s\\n\", \n\t\t       sc->sc_dv.dv_xname, odisplaydv->dv_xname);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "wsmux_displayioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "631-675",
    "snippet": "int\nwsmux_displayioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_displayioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (cmd == WSKBDIO_SETMODE) {\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmux_displayioctl: rawkbd = %d\\n\", sc->sc_rawkbd));\n\t}\t\t\n#endif\n\n\t/* \n\t * Return 0 if any of the ioctl() succeeds, otherwise the last error.\n\t * Return -1 if no mux component accepts the ioctl.\n\t */\n\terror = -1;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\\n\", \n\t\t\t m, sc, *m->sc_muxp));\n\t\tif (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {\n\t\t\terror = m->sc_ops->ddispioctl(m->sc, cmd, data,\n\t\t\t\t\t\t      flag, p);\n\t\t\tDPRINTF((\"wsmux_displayioctl: m=%p dev=%s ==> %d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_displayioctl: m=%p dev=%s ==> %d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->ddispioctl",
          "args": [
            "m->sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\\n\", \n\t\t\t m, sc, *m->sc_muxp)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "m",
            "next"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_reals"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_displayioctl: rawkbd = %d\\n\", sc->sc_rawkbd)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_displayioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_displayioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\n\tDPRINTF((\"wsmux_displayioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tif (cmd == WSKBDIO_SETMODE) {\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmux_displayioctl: rawkbd = %d\\n\", sc->sc_rawkbd));\n\t}\t\t\n#endif\n\n\t/* \n\t * Return 0 if any of the ioctl() succeeds, otherwise the last error.\n\t * Return -1 if no mux component accepts the ioctl.\n\t */\n\terror = -1;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\\n\", \n\t\t\t m, sc, *m->sc_muxp));\n\t\tif (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {\n\t\t\terror = m->sc_ops->ddispioctl(m->sc, cmd, data,\n\t\t\t\t\t\t      flag, p);\n\t\t\tDPRINTF((\"wsmux_displayioctl: m=%p dev=%s ==> %d\\n\", \n\t\t\t\t m, m->sc->dv_xname, error));\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}"
  },
  {
    "function_name": "wsmuxdoioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "506-629",
    "snippet": "int\nwsmuxdoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\tint s, put, get, n;\n\tstruct wseventvar *evar;\n\tstruct wscons_event *ev;\n\tstruct timeval xxxtime;\n\tstruct wsmux_device_list *l;\n\n\tDPRINTF((\"wsmuxdoioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n\tswitch (cmd) {\n\tcase WSMUX_INJECTEVENT:\n\t\t/* Inject an event, e.g., from moused. */\n\t\tif (!sc->sc_events.io)\n\t\t\treturn (EACCES);\n\n\t\tevar = &sc->sc_events;\n\t\ts = spltty();\n\t\tget = evar->get;\n\t\tput = evar->put;\n\t\tif (++put % WSEVENT_QSIZE == get) {\n\t\t\tput--;\n\t\t\tsplx(s);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tif (put >= WSEVENT_QSIZE)\n\t\t\tput = 0;\n\t\tev = &evar->q[put];\n\t\t*ev = *(struct wscons_event *)data;\n\t\tmicrotime(&xxxtime);\n\t\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t\tsplx(s);\n\t\treturn (0);\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_add_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_add_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_add_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\tcase WSMUX_REMOVE_DEVICE:\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_rem_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_rem_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_rem_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\tcase WSMUX_LIST_DEVICES:\n\t\tl = (struct wsmux_device_list *)data;\n\t\tfor (n = 0, m = LIST_FIRST(&sc->sc_reals);\n\t\t     n < WSMUX_MAXDEV && m != NULL;\n\t\t     m = LIST_NEXT(m, next)) {\n\t\t\tl->devices[n].type = m->type;\n\t\t\tl->devices[n].idx = m->sc->dv_unit;\n\t\t\tn++;\n\t\t}\n\t\tl->ndevices = n;\n\t\treturn (0);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tcase WSKBDIO_SETMODE:\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmuxdoioctl: save rawkbd = %d\\n\", sc->sc_rawkbd));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)\n\t\treturn (EACCES);\n\n\t/* Return 0 if any of the ioctl() succeeds, otherwise the last error */\n\terror = 0;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\\n\",\n\t\t\t m, *m->sc_muxp, sc));\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxdoioctl: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "m->sc_ops->dioctl",
          "args": [
            "m->sc",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxdoioctl: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\\n\",\n\t\t\t m, *m->sc_muxp, sc)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "m",
            "next"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_reals"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxdoioctl: save rawkbd = %d\\n\", sc->sc_rawkbd)"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "m",
            "next"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_reals"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_rem_mux",
          "args": [
            "d->idx",
            "sc"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_rem_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "327-341",
          "snippet": "int\nwsmux_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\t\n\tDPRINTF((\"wsmux_rem_mux: %s from %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\t\n\tDPRINTF((\"wsmux_rem_mux: %s from %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_rem_mux",
          "args": [
            "d->idx",
            "sc"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_rem_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1151-1164",
          "snippet": "int\nwskbd_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_rem_mux: %d %s\\n\", unit, muxsc->sc_dv.dv_xname));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_rem_mux: %d %s\\n\", unit, muxsc->sc_dv.dv_xname));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmouse_rem_mux",
          "args": [
            "d->idx",
            "sc"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "wsmouse_rem_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
          "lines": "662-674",
          "snippet": "int\nwsmouse_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\"",
            "#include \"wsmouse.h\"",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsmousevar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouse_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmux_add_mux",
          "args": [
            "d->idx",
            "sc"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_add_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "302-325",
          "snippet": "int\nwsmux_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc, *m;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"wsmux_add_mux: %s to %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\t/* The mux we are adding must not be an ancestor of it. */\n\tfor (m = muxsc->sc_mux; m; m = m->sc_mux)\n\t\tif (m == sc)\n\t\t\treturn (EINVAL);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_MUX, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmux_muxops));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc, *m;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"wsmux_add_mux: %s to %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\t/* The mux we are adding must not be an ancestor of it. */\n\tfor (m = muxsc->sc_mux; m; m = m->sc_mux)\n\t\tif (m == sc)\n\t\t\treturn (EINVAL);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_MUX, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmux_muxops));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wskbd_add_mux",
          "args": [
            "d->idx",
            "sc"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_add_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1131-1149",
          "snippet": "int\nwskbd_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_add_mux: %d %s %p\\n\", unit, muxsc->sc_dv.dv_xname,\n\t\t muxsc->sc_displaydv));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wskbd_muxops));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wskbd_softc *sc;\n\n\tDPRINTF((\"wskbd_add_mux: %d %s %p\\n\", unit, muxsc->sc_dv.dv_xname,\n\t\t muxsc->sc_displaydv));\n\tif (unit < 0 || unit >= wskbd_cd.cd_ndevs ||\n\t    (sc = wskbd_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wskbd_muxops));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmouse_add_mux",
          "args": [
            "d->idx",
            "sc"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "wsmouse_add_mux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmouse.c",
          "lines": "644-660",
          "snippet": "int\nwsmouse_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmouse_muxops));\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\"",
            "#include \"wsmouse.h\"",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsmousevar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n#include \"wsmouse.h\"\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsmousevar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wsmouse_cd = {\n\tNULL, \"wsmouse\", DV_TTY\n};\n\nint\nwsmouse_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmouse_softc *sc;\n\n\tif (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||\n\t    (sc = wsmouse_cd.cd_devs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmouse_muxops));\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSEVENT_WAKEUP",
          "args": [
            "evar"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TIMEVAL_TO_TIMESPEC",
          "args": [
            "&xxxtime",
            "&ev->time"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "microtime",
          "args": [
            "&xxxtime"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxdoioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmuxdoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\tint s, put, get, n;\n\tstruct wseventvar *evar;\n\tstruct wscons_event *ev;\n\tstruct timeval xxxtime;\n\tstruct wsmux_device_list *l;\n\n\tDPRINTF((\"wsmuxdoioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n\tswitch (cmd) {\n\tcase WSMUX_INJECTEVENT:\n\t\t/* Inject an event, e.g., from moused. */\n\t\tif (!sc->sc_events.io)\n\t\t\treturn (EACCES);\n\n\t\tevar = &sc->sc_events;\n\t\ts = spltty();\n\t\tget = evar->get;\n\t\tput = evar->put;\n\t\tif (++put % WSEVENT_QSIZE == get) {\n\t\t\tput--;\n\t\t\tsplx(s);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tif (put >= WSEVENT_QSIZE)\n\t\t\tput = 0;\n\t\tev = &evar->q[put];\n\t\t*ev = *(struct wscons_event *)data;\n\t\tmicrotime(&xxxtime);\n\t\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t\tsplx(s);\n\t\treturn (0);\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_add_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_add_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_add_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\tcase WSMUX_REMOVE_DEVICE:\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_rem_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_rem_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_rem_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\tcase WSMUX_LIST_DEVICES:\n\t\tl = (struct wsmux_device_list *)data;\n\t\tfor (n = 0, m = LIST_FIRST(&sc->sc_reals);\n\t\t     n < WSMUX_MAXDEV && m != NULL;\n\t\t     m = LIST_NEXT(m, next)) {\n\t\t\tl->devices[n].type = m->type;\n\t\t\tl->devices[n].idx = m->sc->dv_unit;\n\t\t\tn++;\n\t\t}\n\t\tl->ndevices = n;\n\t\treturn (0);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tcase WSKBDIO_SETMODE:\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmuxdoioctl: save rawkbd = %d\\n\", sc->sc_rawkbd));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)\n\t\treturn (EACCES);\n\n\t/* Return 0 if any of the ioctl() succeeds, otherwise the last error */\n\terror = 0;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\\n\",\n\t\t\t m, *m->sc_muxp, sc));\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxdoioctl: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}"
  },
  {
    "function_name": "wsmuxdoclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "477-504",
    "snippet": "int wsmuxdoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\n\tDPRINTF((\"wsmuxclose: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc));\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxclose %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\tm->sc_ops->dclose(m->sc, flags, mode, p);\n\t\t\t*m->sc_muxp = 0;\n\t\t}\n\t}\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_fini",
          "args": [
            "&sc->sc_events"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "113-119",
          "snippet": "void\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dclose",
          "args": [
            "m->sc",
            "flags",
            "mode",
            "p"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxclose %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "m",
            "next"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_reals"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxclose: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint wsmuxdoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\n\tDPRINTF((\"wsmuxclose: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc));\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxclose %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\tm->sc_ops->dclose(m->sc, flags, mode, p);\n\t\t\t*m->sc_muxp = 0;\n\t\t}\n\t}\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wsmux_detach_sc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "431-475",
    "snippet": "int\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_detach_sc: done sc=%p\\n\", sc)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "m",
            "M_DEVBUF"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "wskbd_pickfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wskbd.c",
          "lines": "1057-1070",
          "snippet": "int\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include \"wsmux.h\"",
            "#include \"wsdisplay.h\"",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsksymvar.h>",
            "#include <dev/wscons/wsksymdef.h>",
            "#include <dev/wscons/wskbdvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/errno.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/malloc.h>",
            "#include <sys/timeout.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include \"wsmux.h\"\n#include \"wsdisplay.h\"\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsksymvar.h>\n#include <dev/wscons/wsksymdef.h>\n#include <dev/wscons/wskbdvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/errno.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/malloc.h>\n#include <sys/timeout.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nstruct cfdriver wskbd_cd = {\n\tNULL, \"wskbd\", DV_TTY\n};\n\nint\nwskbd_pickfree()\n{\n\tint i;\n\tstruct wskbd_softc *sc;\n\n\tfor (i = 0; i < wskbd_cd.cd_ndevs; i++) {\n\t\tif ((sc = wskbd_cd.cd_devs[i]) == NULL)\n\t\t\tcontinue;\n\t\tif (sc->sc_displaydv == NULL)\n\t\t\treturn (i);\n\t}\n\treturn (-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_REMOVE",
          "args": [
            "m",
            "next"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dclose",
          "args": [
            "m->sc",
            "FREAD",
            "0",
            "0"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_detach_sc: close\\n\")"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dsetdisplay",
          "args": [
            "m->sc",
            "0"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsmux_detach_sc: not found\\n\""
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "m",
            "next"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_reals"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}"
  },
  {
    "function_name": "wsmux_attach_sc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "364-429",
    "snippet": "int\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname)"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dopen",
          "args": [
            "makedev(0, m->sc->dv_unit)",
            "sc->sc_flags",
            "sc->sc_mode",
            "sc->sc_p"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makedev",
          "args": [
            "0",
            "m->sc->dv_unit"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname)"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dioctl",
          "args": [
            "m->sc",
            "WSKBDIO_SETMODE",
            "(caddr_t)&sc->sc_rawkbd",
            "0",
            "0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dsetdisplay",
          "args": [
            "m->sc",
            "sc"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_INSERT_HEAD",
          "args": [
            "&sc->sc_reals",
            "m",
            "next"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *m",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}"
  },
  {
    "function_name": "wsmux_rem_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "327-341",
    "snippet": "int\nwsmux_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\t\n\tDPRINTF((\"wsmux_rem_mux: %s from %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_detach_sc",
          "args": [
            "muxsc",
            "&sc->sc_dv"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_detach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "431-475",
          "snippet": "int\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_rem_mux: %s from %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_rem_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\t\n\tDPRINTF((\"wsmux_rem_mux: %s from %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\treturn (wsmux_detach_sc(muxsc, &sc->sc_dv));\n}"
  },
  {
    "function_name": "wsmux_add_mux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "302-325",
    "snippet": "int\nwsmux_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc, *m;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"wsmux_add_mux: %s to %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\t/* The mux we are adding must not be an ancestor of it. */\n\tfor (m = muxsc->sc_mux; m; m = m->sc_mux)\n\t\tif (m == sc)\n\t\t\treturn (EINVAL);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_MUX, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmux_muxops));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_attach_sc",
          "args": [
            "muxsc",
            "WSMUX_MUX",
            "&sc->sc_dv",
            "&sc->sc_events",
            "&sc->sc_mux",
            "&wsmux_muxops"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_attach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "364-429",
          "snippet": "int\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_add_mux: %s to %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname)"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_add_mux(unit, muxsc)\n\tint unit;\n\tstruct wsmux_softc *muxsc;\n{\n\tstruct wsmux_softc *sc, *m;\n\n\tif (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"wsmux_add_mux: %s to %s\\n\", sc->sc_dv.dv_xname,\n\t\t muxsc->sc_dv.dv_xname));\n\n\tif (sc->sc_mux || sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\t/* The mux we are adding must not be an ancestor of it. */\n\tfor (m = muxsc->sc_mux; m; m = m->sc_mux)\n\t\tif (m == sc)\n\t\t\treturn (EINVAL);\n\n\treturn (wsmux_attach_sc(muxsc, WSMUX_MUX, &sc->sc_dv, &sc->sc_events, \n\t\t\t\t&sc->sc_mux, &wsmux_muxops));\n}"
  },
  {
    "function_name": "wsmuxpoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "288-300",
    "snippet": "int\nwsmuxpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = wsmuxdevs[minor(dev)];\n\n\tif (!sc->sc_events.io)\n\t\treturn (EACCES);\n\n\treturn (wsevent_poll(&sc->sc_events, events, p));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_poll",
          "args": [
            "&sc->sc_events",
            "events",
            "p"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "183-201",
          "snippet": "int\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_poll(ev, events, p)\n\tstruct wseventvar *ev;\n\tint events;\n\tstruct proc *p;\n{\n\tint revents = 0;\n\tint s = splwsevent();\n\n        if (events & (POLLIN | POLLRDNORM)) {\n\t\tif (ev->get != ev->put)\n\t\t\trevents |= events & (POLLIN | POLLRDNORM);\n\t\telse\n\t\t\tselrecord(p, &ev->sel);\n\t}\n\n\tsplx(s);\n\treturn (revents);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmuxpoll(dev, events, p)\n\tdev_t dev;\n\tint events;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = wsmuxdevs[minor(dev)];\n\n\tif (!sc->sc_events.io)\n\t\treturn (EACCES);\n\n\treturn (wsevent_poll(&sc->sc_events, events, p));\n}"
  },
  {
    "function_name": "wsmuxioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "277-286",
    "snippet": "int\nwsmuxioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\treturn wsmuxdoioctl(&wsmuxdevs[minor(dev)]->sc_dv, cmd, data, flag, p);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmuxdoioctl",
          "args": [
            "&wsmuxdevs[minor(dev)]->sc_dv",
            "cmd",
            "data",
            "flag",
            "p"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "wsmuxdoioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "506-629",
          "snippet": "int\nwsmuxdoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\tint s, put, get, n;\n\tstruct wseventvar *evar;\n\tstruct wscons_event *ev;\n\tstruct timeval xxxtime;\n\tstruct wsmux_device_list *l;\n\n\tDPRINTF((\"wsmuxdoioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n\tswitch (cmd) {\n\tcase WSMUX_INJECTEVENT:\n\t\t/* Inject an event, e.g., from moused. */\n\t\tif (!sc->sc_events.io)\n\t\t\treturn (EACCES);\n\n\t\tevar = &sc->sc_events;\n\t\ts = spltty();\n\t\tget = evar->get;\n\t\tput = evar->put;\n\t\tif (++put % WSEVENT_QSIZE == get) {\n\t\t\tput--;\n\t\t\tsplx(s);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tif (put >= WSEVENT_QSIZE)\n\t\t\tput = 0;\n\t\tev = &evar->q[put];\n\t\t*ev = *(struct wscons_event *)data;\n\t\tmicrotime(&xxxtime);\n\t\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t\tsplx(s);\n\t\treturn (0);\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_add_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_add_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_add_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\tcase WSMUX_REMOVE_DEVICE:\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_rem_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_rem_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_rem_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\tcase WSMUX_LIST_DEVICES:\n\t\tl = (struct wsmux_device_list *)data;\n\t\tfor (n = 0, m = LIST_FIRST(&sc->sc_reals);\n\t\t     n < WSMUX_MAXDEV && m != NULL;\n\t\t     m = LIST_NEXT(m, next)) {\n\t\t\tl->devices[n].type = m->type;\n\t\t\tl->devices[n].idx = m->sc->dv_unit;\n\t\t\tn++;\n\t\t}\n\t\tl->ndevices = n;\n\t\treturn (0);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tcase WSKBDIO_SETMODE:\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmuxdoioctl: save rawkbd = %d\\n\", sc->sc_rawkbd));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)\n\t\treturn (EACCES);\n\n\t/* Return 0 if any of the ioctl() succeeds, otherwise the last error */\n\terror = 0;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\\n\",\n\t\t\t m, *m->sc_muxp, sc));\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxdoioctl: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmuxdoioctl(dv, cmd, data, flag, p)\n\tstruct device *dv;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\tint error, ok;\n\tint s, put, get, n;\n\tstruct wseventvar *evar;\n\tstruct wscons_event *ev;\n\tstruct timeval xxxtime;\n\tstruct wsmux_device_list *l;\n\n\tDPRINTF((\"wsmuxdoioctl: %s: sc=%p, cmd=%08lx\\n\", \n\t\t sc->sc_dv.dv_xname, sc, cmd));\n\n\tswitch (cmd) {\n\tcase WSMUX_INJECTEVENT:\n\t\t/* Inject an event, e.g., from moused. */\n\t\tif (!sc->sc_events.io)\n\t\t\treturn (EACCES);\n\n\t\tevar = &sc->sc_events;\n\t\ts = spltty();\n\t\tget = evar->get;\n\t\tput = evar->put;\n\t\tif (++put % WSEVENT_QSIZE == get) {\n\t\t\tput--;\n\t\t\tsplx(s);\n\t\t\treturn (ENOSPC);\n\t\t}\n\t\tif (put >= WSEVENT_QSIZE)\n\t\t\tput = 0;\n\t\tev = &evar->q[put];\n\t\t*ev = *(struct wscons_event *)data;\n\t\tmicrotime(&xxxtime);\n\t\tTIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);\n\t\tevar->put = put;\n\t\tWSEVENT_WAKEUP(evar);\n\t\tsplx(s);\n\t\treturn (0);\n\tcase WSMUX_ADD_DEVICE:\n#define d ((struct wsmux_device *)data)\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_add_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_add_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_add_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n\tcase WSMUX_REMOVE_DEVICE:\n\t\tswitch (d->type) {\n#if NWSMOUSE > 0\n\t\tcase WSMUX_MOUSE:\n\t\t\treturn (wsmouse_rem_mux(d->idx, sc));\n#endif\n#if NWSKBD > 0\n\t\tcase WSMUX_KBD:\n\t\t\treturn (wskbd_rem_mux(d->idx, sc));\n#endif\n#if NWSMUX > 0\n\t\tcase WSMUX_MUX:\n\t\t\treturn (wsmux_rem_mux(d->idx, sc));\n#endif\n\t\tdefault:\n\t\t\treturn (EINVAL);\n\t\t}\n#undef d\n\tcase WSMUX_LIST_DEVICES:\n\t\tl = (struct wsmux_device_list *)data;\n\t\tfor (n = 0, m = LIST_FIRST(&sc->sc_reals);\n\t\t     n < WSMUX_MAXDEV && m != NULL;\n\t\t     m = LIST_NEXT(m, next)) {\n\t\t\tl->devices[n].type = m->type;\n\t\t\tl->devices[n].idx = m->sc->dv_unit;\n\t\t\tn++;\n\t\t}\n\t\tl->ndevices = n;\n\t\treturn (0);\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\tcase WSKBDIO_SETMODE:\n\t\tsc->sc_rawkbd = *(int *)data;\n\t\tDPRINTF((\"wsmuxdoioctl: save rawkbd = %d\\n\", sc->sc_rawkbd));\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)\n\t\treturn (EACCES);\n\n\t/* Return 0 if any of the ioctl() succeeds, otherwise the last error */\n\terror = 0;\n\tok = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tDPRINTF((\"wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\\n\",\n\t\t\t m, *m->sc_muxp, sc));\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxdoioctl: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);\n\t\t\tif (!error)\n\t\t\t\tok = 1;\n\t\t}\n\t}\n\tif (ok)\n\t\terror = 0;\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmuxioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tcaddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\treturn wsmuxdoioctl(&wsmuxdevs[minor(dev)]->sc_dv, cmd, data, flag, p);\n}"
  },
  {
    "function_name": "wsmuxread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "263-275",
    "snippet": "int\nwsmuxread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct wsmux_softc *sc = wsmuxdevs[minor(dev)];\n\n\tif (!sc->sc_events.io)\n\t\treturn (EACCES);\n\n\treturn (wsevent_read(&sc->sc_events, uio, flags));\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_read",
          "args": [
            "&sc->sc_events",
            "uio",
            "flags"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "125-181",
          "snippet": "int\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nint\nwsevent_read(ev, uio, flags)\n\tstruct wseventvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct wscons_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splwsevent();\n\twhile (ev->get == ev->put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PWSEVENT | PCATCH,\n\t\t    \"wsevent_read\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move wscons_event from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->put < ev->get)\n\t\tcnt = WSEVENT_QSIZE - ev->get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->put - ev->get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct wscons_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[ev->get],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->get = (ev->get + cnt) % WSEVENT_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->q[0],\n\t    cnt * sizeof(struct wscons_event), uio);\n\tev->get = cnt;\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmuxread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct wsmux_softc *sc = wsmuxdevs[minor(dev)];\n\n\tif (!sc->sc_events.io)\n\t\treturn (EACCES);\n\n\treturn (wsevent_read(&sc->sc_events, uio, flags));\n}"
  },
  {
    "function_name": "wsmuxclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "254-261",
    "snippet": "int\nwsmuxclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\treturn wsmuxdoclose(&wsmuxdevs[minor(dev)]->sc_dv, flags, mode, p);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmuxdoclose",
          "args": [
            "&wsmuxdevs[minor(dev)]->sc_dv",
            "flags",
            "mode",
            "p"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "wsmuxdoclose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "477-504",
          "snippet": "int wsmuxdoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\n\tDPRINTF((\"wsmuxclose: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc));\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxclose %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\tm->sc_ops->dclose(m->sc, flags, mode, p);\n\t\t\t*m->sc_muxp = 0;\n\t\t}\n\t}\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint wsmuxdoclose(dv, flags, mode, p)\n\tstruct device *dv;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc = (struct wsmux_softc *)dv;\n\tstruct wsplink *m;\n\n\tDPRINTF((\"wsmuxclose: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc));\n\tif (!(flags & FREAD)) {\n\t\t/* Nothing to do, because open didn't do anything. */\n\t\treturn (0);\n\t}\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (*m->sc_muxp == sc) {\n\t\t\tDPRINTF((\"wsmuxclose %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\tm->sc_ops->dclose(m->sc, flags, mode, p);\n\t\t\t*m->sc_muxp = 0;\n\t\t}\n\t}\n\n\twsevent_fini(&sc->sc_events);\n\tsc->sc_events.io = NULL;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmuxclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\treturn wsmuxdoclose(&wsmuxdevs[minor(dev)]->sc_dv, flags, mode, p);\n}"
  },
  {
    "function_name": "wsmuxopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "195-252",
    "snippet": "int\nwsmuxopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc;\n\tstruct wsplink *m;\n\tint unit, error, nopen, lasterror;\n\n\tunit = minor(dev);\n\tif (unit >= nwsmux ||\t/* make sure it was attached */\n\t    (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"wsmuxopen: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc));\n\tif (!(flags & FREAD)) {\n\t\t/* Not opening for read, only ioctl is available. */\n\t\treturn (0);\n\t}\n\n\tif (sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\tsc->sc_events.io = p;\n\tsc->sc_flags = flags;\n\tsc->sc_mode = mode;\n\tsc->sc_p = p;\n\twsevent_init(&sc->sc_events);\t\t/* may cause sleep */\n\n\tnopen = 0;\n\tlasterror = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (!m->sc_mevents->io && !*m->sc_muxp) {\n\t\t\tDPRINTF((\"wsmuxopen: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t\t flags, mode, p);\n\t\t\tif (error) {\n\t\t\t\t/* Ignore opens that fail */\n\t\t\t\tlasterror = error;\n\t\t\t\tDPRINTF((\"wsmuxopen: open failed %d\\n\", \n\t\t\t\t\t error));\n\t\t\t} else {\n\t\t\t\tnopen++;\n\t\t\t\t*m->sc_muxp = sc;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nopen == 0 && lasterror != 0) {\n\t\twsevent_fini(&sc->sc_events);\n\t\tsc->sc_events.io = NULL;\n\t\treturn (lasterror);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsevent_fini",
          "args": [
            "&sc->sc_events"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "113-119",
          "snippet": "void\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_fini(ev)\n\tstruct wseventvar *ev;\n{\n\n\tfree(ev->q, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxopen: open failed %d\\n\", \n\t\t\t\t\t error)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->sc_ops->dopen",
          "args": [
            "makedev(0, m->sc->dv_unit)",
            "flags",
            "mode",
            "p"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "makedev",
          "args": [
            "0",
            "m->sc->dv_unit"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxopen: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_NEXT",
          "args": [
            "m",
            "next"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_FIRST",
          "args": [
            "&sc->sc_reals"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsevent_init",
          "args": [
            "&sc->sc_events"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "wsevent_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsevent.c",
          "lines": "99-108",
          "snippet": "void\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}",
          "includes": [
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/cdefs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n#include <sys/cdefs.h>\n\nvoid\nwsevent_init(ev)\n\tstruct wseventvar *ev;\n{\n\n\tev->get = ev->put = 0;\n\tev->q = malloc((u_long)WSEVENT_QSIZE * sizeof(struct wscons_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->q, WSEVENT_QSIZE * sizeof(struct wscons_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmuxopen: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmuxopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct wsmux_softc *sc;\n\tstruct wsplink *m;\n\tint unit, error, nopen, lasterror;\n\n\tunit = minor(dev);\n\tif (unit >= nwsmux ||\t/* make sure it was attached */\n\t    (sc = wsmuxdevs[unit]) == NULL)\n\t\treturn (ENXIO);\n\n\tDPRINTF((\"wsmuxopen: %s: sc=%p\\n\", sc->sc_dv.dv_xname, sc));\n\tif (!(flags & FREAD)) {\n\t\t/* Not opening for read, only ioctl is available. */\n\t\treturn (0);\n\t}\n\n\tif (sc->sc_events.io)\n\t\treturn (EBUSY);\n\n\tsc->sc_events.io = p;\n\tsc->sc_flags = flags;\n\tsc->sc_mode = mode;\n\tsc->sc_p = p;\n\twsevent_init(&sc->sc_events);\t\t/* may cause sleep */\n\n\tnopen = 0;\n\tlasterror = 0;\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (!m->sc_mevents->io && !*m->sc_muxp) {\n\t\t\tDPRINTF((\"wsmuxopen: %s: m=%p dev=%s\\n\", \n\t\t\t\t sc->sc_dv.dv_xname, m, m->sc->dv_xname));\n\t\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t\t flags, mode, p);\n\t\t\tif (error) {\n\t\t\t\t/* Ignore opens that fail */\n\t\t\t\tlasterror = error;\n\t\t\t\tDPRINTF((\"wsmuxopen: open failed %d\\n\", \n\t\t\t\t\t error));\n\t\t\t} else {\n\t\t\t\tnopen++;\n\t\t\t\t*m->sc_muxp = sc;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nopen == 0 && lasterror != 0) {\n\t\twsevent_fini(&sc->sc_events);\n\t\tsc->sc_events.io = NULL;\n\t\treturn (lasterror);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "wsmux_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "176-193",
    "snippet": "void\nwsmux_detach(n, dsc)\n\tint n;\n        struct device *dsc;\n{\n#ifdef DIAGNOSTIC\n\tint error;\n\n\tif (n >= nwsmux || n < 0) {\n\t\tprintf(\"wsmux_detach: detach is out of range\\n\");\n\t\treturn;\n\t}\n\tif ((error = wsmux_detach_sc(wsmuxdevs[n], dsc)))\n\t\tprintf(\"wsmux_detach: error=%d\\n\", error);\n#else\n\t(void)wsmux_detach_sc(wsmuxdevs[n], dsc);\n#endif\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_detach_sc",
          "args": [
            "wsmuxdevs[n]",
            "dsc"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_detach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "431-475",
          "snippet": "int\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nint\nwsmux_detach_sc(sc, dsc)\n\tstruct wsmux_softc *sc;\n        struct device *dsc;\n{\n\tstruct wsplink *m;\n\tint error = 0;\n\n\tDPRINTF((\"wsmux_detach_sc: %s: dsc=%p\\n\", sc->sc_dv.dv_xname, dsc));\n#ifdef DIAGNOSTIC\n\tif (sc == 0) {\n\t\tprintf(\"wsmux_detach_sc: not allocated\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\n\tfor (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {\n\t\tif (m->sc == dsc)\n\t\t\tbreak;\n\t}\n#ifdef DIAGNOSTIC\n\tif (!m) {\n\t\tprintf(\"wsmux_detach_sc: not found\\n\");\n\t\treturn (ENXIO);\n\t}\n#endif\n\tif (sc->sc_displaydv) {\n\t\tif (m->sc_ops->dsetdisplay)\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, 0);\n\t\tif (error)\n\t\t\treturn (error);\n\t\t*m->sc_muxp = 0;\n\t} else if (*m->sc_muxp) {\n\t\tDPRINTF((\"wsmux_detach_sc: close\\n\"));\n\t\t/* mux device is open, so close multiplexee */\n\t\tm->sc_ops->dclose(m->sc, FREAD, 0, 0);\n\t\t*m->sc_muxp = 0;\n\t}\n\n\tLIST_REMOVE(m, next);\n\n\tfree(m, M_DEVBUF);\n\tDPRINTF((\"wsmux_detach_sc: done sc=%p\\n\", sc));\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsmux_detach: error=%d\\n\"",
            "error"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nvoid\nwsmux_detach(n, dsc)\n\tint n;\n        struct device *dsc;\n{\n#ifdef DIAGNOSTIC\n\tint error;\n\n\tif (n >= nwsmux || n < 0) {\n\t\tprintf(\"wsmux_detach: detach is out of range\\n\");\n\t\treturn;\n\t}\n\tif ((error = wsmux_detach_sc(wsmuxdevs[n], dsc)))\n\t\tprintf(\"wsmux_detach: error=%d\\n\", error);\n#else\n\t(void)wsmux_detach_sc(wsmuxdevs[n], dsc);\n#endif\n}"
  },
  {
    "function_name": "wsmux_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "147-173",
    "snippet": "void\nwsmux_attach(n, type, dsc, ev, psp, ops)\n\tint n;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsmux_softc *sc;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach: n=%d\\n\", n));\n\twsmux_setmax(n);\n\tsc = wsmuxdevs[n];\n\tif (sc == 0) {\n\t\tsc = wsmux_create(\"wsmux\", n);\n\t\tif (sc == 0) {\n\t\t\tprintf(\"wsmux: attach out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t\twsmuxdevs[n] = sc;\n\t}\n\terror = wsmux_attach_sc(sc, type, dsc, ev, psp, ops);\n\tif (error)\n\t\tprintf(\"wsmux_attach: error=%d\\n\", error);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [
      "#define d ((struct wsmux_device *)data)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"wsmux_attach: error=%d\\n\"",
            "error"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmux_attach_sc",
          "args": [
            "sc",
            "type",
            "dsc",
            "ev",
            "psp",
            "ops"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_attach_sc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "364-429",
          "snippet": "int\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [
            "#define d ((struct wsmux_device *)data)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nint\nwsmux_attach_sc(sc, type, dsc, ev, psp, ops)\n\tstruct wsmux_softc *sc;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsplink *m;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\\n\",\n\t\t sc->sc_dv.dv_xname, type, dsc, *psp));\n\tm = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);\n\tif (m == 0)\n\t\treturn (ENOMEM);\n\tm->type = type;\n\tm->mux = sc;\n\tm->sc = dsc;\n\tm->sc_mevents = ev;\n\tm->sc_muxp = psp;\n\tm->sc_ops = ops;\n\tLIST_INSERT_HEAD(&sc->sc_reals, m, next);\n\n\tif (sc->sc_displaydv) {\n\t\t/* This is a display mux, so attach the new device to it. */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: set display %p\\n\", \n\t\t\t sc->sc_dv.dv_xname, sc->sc_displaydv));\n\t\terror = 0;\n\t\tif (m->sc_ops->dsetdisplay) {\n\t\t\terror = m->sc_ops->dsetdisplay(m->sc, sc);\n\t\t\t/* Ignore that the console already has a display. */\n\t\t\tif (error == EBUSY)\n\t\t\t\terror = 0;\n\t\t\tif (!error) {\n\t\t\t\t*m->sc_muxp = sc;\n#ifdef WSDISPLAY_COMPAT_RAWKBD\n\t\t\t\tDPRINTF((\"wsmux_attach_sc: on %s set rawkbd=%d\\n\",\n\t\t\t\t\t m->sc->dv_xname, sc->sc_rawkbd));\n\t\t\t\t(void)m->sc_ops->dioctl(m->sc, \n\t\t\t\t\t     WSKBDIO_SETMODE, \n\t\t\t\t\t     (caddr_t)&sc->sc_rawkbd,\n\t\t\t\t\t     0, 0);\n#endif\n\t\t\t}\n\t\t}\n\t} else if (sc->sc_events.io) {\n\t\t/* Mux is open, so open the new subdevice */\n\t\tDPRINTF((\"wsmux_attach_sc: %s: calling open of %s\\n\",\n\t\t\t sc->sc_dv.dv_xname, m->sc->dv_xname));\n\t\t/* mux already open, join in */\n\t\terror = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),\n\t\t\t\t\t sc->sc_flags, sc->sc_mode, sc->sc_p);\n\t\tif (!error)\n\t\t\t*m->sc_muxp = sc;\n\t} else {\n\t\tDPRINTF((\"wsmux_attach_sc: %s not open\\n\",\n\t\t\t sc->sc_dv.dv_xname));\n\t\terror = 0;\n\t}\n\tDPRINTF((\"wsmux_attach_sc: done sc=%p psp=%p *psp=%p\\n\", \n\t\t sc, psp, *psp));\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wsmux_create",
          "args": [
            "\"wsmux\"",
            "n"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_setmax",
          "args": [
            "n"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_setmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "108-129",
          "snippet": "void\nwsmux_setmax(n)\n\tint n;\n{\n\tint i;\n\n\tif (n >= nwsmux) {\n\t\ti = nwsmux;\n\t\tnwsmux = n + 1;\n\t\tif (nwsmux != 0)\n\t\t\twsmuxdevs = realloc(wsmuxdevs, \n\t\t\t\t\t    nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\telse\n\t\t\twsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t   M_DEVBUF, M_NOWAIT);\n\t\tif (wsmuxdevs == 0)\n\t\t\tpanic(\"wsmux_setmax: no memory\\n\");\n\t\tfor (; i < nwsmux; i++)\n\t\t\twsmuxdevs[i] = 0;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nvoid\nwsmux_setmax(n)\n\tint n;\n{\n\tint i;\n\n\tif (n >= nwsmux) {\n\t\ti = nwsmux;\n\t\tnwsmux = n + 1;\n\t\tif (nwsmux != 0)\n\t\t\twsmuxdevs = realloc(wsmuxdevs, \n\t\t\t\t\t    nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\telse\n\t\t\twsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t   M_DEVBUF, M_NOWAIT);\n\t\tif (wsmuxdevs == 0)\n\t\t\tpanic(\"wsmux_setmax: no memory\\n\");\n\t\tfor (; i < nwsmux; i++)\n\t\t\twsmuxdevs[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "DPRINTF",
          "args": [
            "(\"wsmux_attach: n=%d\\n\", n)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\n#define d ((struct wsmux_device *)data)\n\nvoid\nwsmux_attach(n, type, dsc, ev, psp, ops)\n\tint n;\n\tint type;\n        struct device *dsc;\n\tstruct wseventvar *ev;\n\tstruct wsmux_softc **psp;\n\tstruct wsmuxops *ops;\n{\n\tstruct wsmux_softc *sc;\n\tint error;\n\n\tDPRINTF((\"wsmux_attach: n=%d\\n\", n));\n\twsmux_setmax(n);\n\tsc = wsmuxdevs[n];\n\tif (sc == 0) {\n\t\tsc = wsmux_create(\"wsmux\", n);\n\t\tif (sc == 0) {\n\t\t\tprintf(\"wsmux: attach out of memory\\n\");\n\t\t\treturn;\n\t\t}\n\t\twsmuxdevs[n] = sc;\n\t}\n\terror = wsmux_attach_sc(sc, type, dsc, ev, psp, ops);\n\tif (error)\n\t\tprintf(\"wsmux_attach: error=%d\\n\", error);\n}"
  },
  {
    "function_name": "wsmuxattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "132-144",
    "snippet": "void\nwsmuxattach(n)\n\tint n;\n{\n\tint i;\n\n\twsmux_setmax(n);\t/* Make sure we have room for all muxes. */\n\n\t/* Make sure all muxes are there. */\n\tfor (i = 0; i < nwsmux; i++)\n\t\tif (!wsmuxdevs[i])\n\t\t\twsmuxdevs[i] = wsmux_create(\"wsmux\", i);\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wsmux_create",
          "args": [
            "\"wsmux\"",
            "i"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wsmux_setmax",
          "args": [
            "n"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "wsmux_setmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
          "lines": "108-129",
          "snippet": "void\nwsmux_setmax(n)\n\tint n;\n{\n\tint i;\n\n\tif (n >= nwsmux) {\n\t\ti = nwsmux;\n\t\tnwsmux = n + 1;\n\t\tif (nwsmux != 0)\n\t\t\twsmuxdevs = realloc(wsmuxdevs, \n\t\t\t\t\t    nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\telse\n\t\t\twsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t   M_DEVBUF, M_NOWAIT);\n\t\tif (wsmuxdevs == 0)\n\t\t\tpanic(\"wsmux_setmax: no memory\\n\");\n\t\tfor (; i < nwsmux; i++)\n\t\t\twsmuxdevs[i] = 0;\n\t}\n}",
          "includes": [
            "#include <dev/wscons/wsmuxvar.h>",
            "#include <dev/wscons/wscons_callbacks.h>",
            "#include <dev/wscons/wseventvar.h>",
            "#include <dev/wscons/wsconsio.h>",
            "#include <sys/device.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/tty.h>",
            "#include <sys/systm.h>",
            "#include <sys/syslog.h>",
            "#include <sys/queue.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/conf.h>",
            "#include <sys/param.h>",
            "#include \"wskbd.h\"",
            "#include \"wsdisplay.h\"",
            "#include \"wsmux.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nvoid\nwsmux_setmax(n)\n\tint n;\n{\n\tint i;\n\n\tif (n >= nwsmux) {\n\t\ti = nwsmux;\n\t\tnwsmux = n + 1;\n\t\tif (nwsmux != 0)\n\t\t\twsmuxdevs = realloc(wsmuxdevs, \n\t\t\t\t\t    nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\telse\n\t\t\twsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t   M_DEVBUF, M_NOWAIT);\n\t\tif (wsmuxdevs == 0)\n\t\t\tpanic(\"wsmux_setmax: no memory\\n\");\n\t\tfor (; i < nwsmux; i++)\n\t\t\twsmuxdevs[i] = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nvoid\nwsmuxattach(n)\n\tint n;\n{\n\tint i;\n\n\twsmux_setmax(n);\t/* Make sure we have room for all muxes. */\n\n\t/* Make sure all muxes are there. */\n\tfor (i = 0; i < nwsmux; i++)\n\t\tif (!wsmuxdevs[i])\n\t\t\twsmuxdevs[i] = wsmux_create(\"wsmux\", i);\n}"
  },
  {
    "function_name": "wsmux_setmax",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/wscons/wsmux.c",
    "lines": "108-129",
    "snippet": "void\nwsmux_setmax(n)\n\tint n;\n{\n\tint i;\n\n\tif (n >= nwsmux) {\n\t\ti = nwsmux;\n\t\tnwsmux = n + 1;\n\t\tif (nwsmux != 0)\n\t\t\twsmuxdevs = realloc(wsmuxdevs, \n\t\t\t\t\t    nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\telse\n\t\t\twsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t   M_DEVBUF, M_NOWAIT);\n\t\tif (wsmuxdevs == 0)\n\t\t\tpanic(\"wsmux_setmax: no memory\\n\");\n\t\tfor (; i < nwsmux; i++)\n\t\t\twsmuxdevs[i] = 0;\n\t}\n}",
    "includes": [
      "#include <dev/wscons/wsmuxvar.h>",
      "#include <dev/wscons/wscons_callbacks.h>",
      "#include <dev/wscons/wseventvar.h>",
      "#include <dev/wscons/wsconsio.h>",
      "#include <sys/device.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/tty.h>",
      "#include <sys/systm.h>",
      "#include <sys/syslog.h>",
      "#include <sys/queue.h>",
      "#include <sys/proc.h>",
      "#include <sys/malloc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/fcntl.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/conf.h>",
      "#include <sys/param.h>",
      "#include \"wskbd.h\"",
      "#include \"wsdisplay.h\"",
      "#include \"wsmux.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"wsmux_setmax: no memory\\n\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "nwsmux * sizeof (*wsmuxdevs)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "wsmuxdevs",
            "nwsmux * sizeof (*wsmuxdevs)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <dev/wscons/wsmuxvar.h>\n#include <dev/wscons/wscons_callbacks.h>\n#include <dev/wscons/wseventvar.h>\n#include <dev/wscons/wsconsio.h>\n#include <sys/device.h>\n#include <sys/signalvar.h>\n#include <sys/tty.h>\n#include <sys/systm.h>\n#include <sys/syslog.h>\n#include <sys/queue.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/kernel.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/conf.h>\n#include <sys/param.h>\n#include \"wskbd.h\"\n#include \"wsdisplay.h\"\n#include \"wsmux.h\"\n\nvoid\nwsmux_setmax(n)\n\tint n;\n{\n\tint i;\n\n\tif (n >= nwsmux) {\n\t\ti = nwsmux;\n\t\tnwsmux = n + 1;\n\t\tif (nwsmux != 0)\n\t\t\twsmuxdevs = realloc(wsmuxdevs, \n\t\t\t\t\t    nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t    M_DEVBUF, M_NOWAIT);\n\t\telse\n\t\t\twsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), \n\t\t\t\t\t   M_DEVBUF, M_NOWAIT);\n\t\tif (wsmuxdevs == 0)\n\t\t\tpanic(\"wsmux_setmax: no memory\\n\");\n\t\tfor (; i < nwsmux; i++)\n\t\t\twsmuxdevs[i] = 0;\n\t}\n}"
  }
]