[
  {
    "function_name": "kbd_update_leds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1412-1428",
    "snippet": "static void\nkbd_update_leds(k)\n    struct kbd_softc *k;\n{\n    struct kbd_state *ks = &k->k_state;\n    register char leds;\n\n\tleds = ks->kbd_leds;\n\tleds &= ~(LED_CAPS_LOCK|LED_NUM_LOCK);\n\n\tif (ks->kbd_modbits & (1 << KBMOD_CAPSLOCK))\n\t\tleds |= LED_CAPS_LOCK;\n\tif (ks->kbd_modbits & (1 << KBMOD_NUMLOCK))\n\t\tleds |= LED_NUM_LOCK;\n\n\tkbd_set_leds(k, leds);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_set_leds(struct kbd_softc *k, int leds);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kbd_set_leds",
          "args": [
            "k",
            "leds"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_set_leds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1386-1406",
          "snippet": "static void\nkbd_set_leds(k, new_leds)\n\tstruct kbd_softc *k;\n\tint new_leds;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/* Don't send unless state changes. */\n\tif (ks->kbd_leds == new_leds)\n\t\treturn;\n\n\tks->kbd_leds = new_leds;\n\n\t/* Only type 4 and later has LEDs anyway. */\n\tif (ks->kbd_id < 4)\n\t\treturn;\n\n\tkbd_output(k, KBD_CMD_SETLED);\n\tkbd_output(k, new_leds);\n\tkbd_start_tx(k);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_set_leds(k, new_leds)\n\tstruct kbd_softc *k;\n\tint new_leds;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/* Don't send unless state changes. */\n\tif (ks->kbd_leds == new_leds)\n\t\treturn;\n\n\tks->kbd_leds = new_leds;\n\n\t/* Only type 4 and later has LEDs anyway. */\n\tif (ks->kbd_id < 4)\n\t\treturn;\n\n\tkbd_output(k, KBD_CMD_SETLED);\n\tkbd_output(k, new_leds);\n\tkbd_start_tx(k);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_set_leds(struct kbd_softc *k, int leds);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_update_leds(k)\n    struct kbd_softc *k;\n{\n    struct kbd_state *ks = &k->k_state;\n    register char leds;\n\n\tleds = ks->kbd_leds;\n\tleds &= ~(LED_CAPS_LOCK|LED_NUM_LOCK);\n\n\tif (ks->kbd_modbits & (1 << KBMOD_CAPSLOCK))\n\t\tleds |= LED_CAPS_LOCK;\n\tif (ks->kbd_modbits & (1 << KBMOD_NUMLOCK))\n\t\tleds |= LED_NUM_LOCK;\n\n\tkbd_set_leds(k, leds);\n}"
  },
  {
    "function_name": "kbd_set_leds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1386-1406",
    "snippet": "static void\nkbd_set_leds(k, new_leds)\n\tstruct kbd_softc *k;\n\tint new_leds;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/* Don't send unless state changes. */\n\tif (ks->kbd_leds == new_leds)\n\t\treturn;\n\n\tks->kbd_leds = new_leds;\n\n\t/* Only type 4 and later has LEDs anyway. */\n\tif (ks->kbd_id < 4)\n\t\treturn;\n\n\tkbd_output(k, KBD_CMD_SETLED);\n\tkbd_output(k, new_leds);\n\tkbd_start_tx(k);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kbd_start_tx",
          "args": [
            "k"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_start_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1348-1380",
          "snippet": "static void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1",
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_output",
          "args": [
            "k",
            "new_leds"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1323-1342",
          "snippet": "static void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_set_leds(k, new_leds)\n\tstruct kbd_softc *k;\n\tint new_leds;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/* Don't send unless state changes. */\n\tif (ks->kbd_leds == new_leds)\n\t\treturn;\n\n\tks->kbd_leds = new_leds;\n\n\t/* Only type 4 and later has LEDs anyway. */\n\tif (ks->kbd_id < 4)\n\t\treturn;\n\n\tkbd_output(k, KBD_CMD_SETLED);\n\tkbd_output(k, new_leds);\n\tkbd_start_tx(k);\n}"
  },
  {
    "function_name": "kbd_start_tx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1348-1380",
    "snippet": "static void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define K_TXWANT 2",
      "#define\tK_TXBUSY 1",
      "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_output(struct kbd_softc *k, int c);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_data",
          "args": [
            "cs",
            "c"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)&k->k_txflags"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}"
  },
  {
    "function_name": "kbd_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1323-1342",
    "snippet": "static void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_output(struct kbd_softc *k, int c);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
      "static int kbd_iocsled(struct kbd_softc *k, int *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: output overrun\\n\"",
            "k->k_dev.dv_xname"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}"
  },
  {
    "function_name": "kbd_drain_tx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1302-1317",
    "snippet": "static int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define K_TXWANT 2",
      "#define\tK_TXBUSY 1"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)&k->k_txflags",
            "PZERO | PCATCH",
            "\"kbdout\"",
            "0"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "kbd_new_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1282-1295",
    "snippet": "static void\nkbd_new_layout(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_layout);\n\n\t/* XXX: switch decoding tables? */\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)&ks->kbd_layout"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_new_layout(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_layout);\n\n\t/* XXX: switch decoding tables? */\n}"
  },
  {
    "function_name": "kbd_was_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1237-1277",
    "snippet": "static void\nkbd_was_reset(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_id);\n\n\t/* Restore keyclick, if necessary */\n\tswitch (ks->kbd_id) {\n\n\tcase KB_SUN2:\n\t\t/* Type 2 keyboards don't support keyclick */\n\t\tbreak;\n\n\tcase KB_SUN3:\n\t\t/* Type 3 keyboards come up with keyclick on */\n\t\tif (!ks->kbd_click) {\n\t\t\t/* turn off the click */\n\t\t\tkbd_output(k, KBD_CMD_NOCLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\n\tcase KB_SUN4:\n\t\t/* Type 4 keyboards come up with keyclick off */\n\t\tif (ks->kbd_click) {\n\t\t\t/* turn on the click */\n\t\t\tkbd_output(k, KBD_CMD_CLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* LEDs are off after reset. */\n\tks->kbd_leds = 0;\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kbd_start_tx",
          "args": [
            "k"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_start_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1348-1380",
          "snippet": "static void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1",
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_output",
          "args": [
            "k",
            "KBD_CMD_CLICK"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1323-1342",
          "snippet": "static void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup",
          "args": [
            "(caddr_t)&ks->kbd_id"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "audio_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "765-774",
          "snippet": "static __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nstatic __inline void\naudio_wakeup(chan)\n\tint *chan;\n{\n\tDPRINTFN(3, (\"audio_wakeup: chan=%p, *chan=%d\\n\", chan, *chan));\n\tif (*chan) {\n\t\twakeup(chan);\n\t\t*chan = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_was_reset(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_id);\n\n\t/* Restore keyclick, if necessary */\n\tswitch (ks->kbd_id) {\n\n\tcase KB_SUN2:\n\t\t/* Type 2 keyboards don't support keyclick */\n\t\tbreak;\n\n\tcase KB_SUN3:\n\t\t/* Type 3 keyboards come up with keyclick on */\n\t\tif (!ks->kbd_click) {\n\t\t\t/* turn off the click */\n\t\t\tkbd_output(k, KBD_CMD_NOCLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\n\tcase KB_SUN4:\n\t\t/* Type 4 keyboards come up with keyclick off */\n\t\tif (ks->kbd_click) {\n\t\t\t/* turn on the click */\n\t\t\tkbd_output(k, KBD_CMD_CLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* LEDs are off after reset. */\n\tks->kbd_leds = 0;\n}"
  },
  {
    "function_name": "kbd_iopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1167-1232",
    "snippet": "int\nkbd_iopen(unit)\n\tint unit;\n{\n\tstruct kbd_softc *k;\n\tstruct kbd_state *ks;\n\tint error, s;\n\n\tif (unit >= kbd_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tk = kbd_cd.cd_devs[unit];\n\tif (k == NULL)\n\t\treturn (ENXIO);\n\tks = &k->k_state;\n\terror = 0;\n\n\t/* Tolerate extra calls. */\n\tif (k->k_isopen)\n\t\treturn (error);\n\n\ts = spltty();\n\n\t/* Reset the keyboard and find out its type. */\n\tkbd_output(k, KBD_CMD_RESET);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_was_reset(). */\n\terror = tsleep((caddr_t)&ks->kbd_id,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: reset failed\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\t/*\n\t\t * Allow the open anyway (to keep getty happy)\n\t\t * but assume the \"least common denominator\".\n\t\t */\n\t\tks->kbd_id = KB_SUN2;\n\t}\n\n\t/* Earlier than type 4 does not know \"layout\". */\n\tif (ks->kbd_id < KB_SUN4)\n\t\tgoto out;\n\n\t/* Ask for the layout. */\n\tkbd_output(k, KBD_CMD_GETLAYOUT);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_new_layout(). */\n\terror = tsleep((caddr_t)&ks->kbd_layout,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: no response to get_layout\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\tks->kbd_layout = 0;\n\t}\n\nout:\n\tsplx(s);\n\n\tif (error == 0)\n\t\tk->k_isopen = 1;\n\n\treturn error;\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "struct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: no response to get_layout\\n\"",
            "k->k_dev.dv_xname"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)&ks->kbd_layout",
            "PZERO | PCATCH",
            "devopn",
            "hz"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbd_drain_tx",
          "args": [
            "k"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_drain_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1302-1317",
          "snippet": "static int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_start_tx",
          "args": [
            "k"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_start_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1348-1380",
          "snippet": "static void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1",
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_output",
          "args": [
            "k",
            "KBD_CMD_GETLAYOUT"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1323-1342",
          "snippet": "static void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tsleep",
          "args": [
            "(caddr_t)&ks->kbd_id",
            "PZERO | PCATCH",
            "devopn",
            "hz"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};\n\nint\nkbd_iopen(unit)\n\tint unit;\n{\n\tstruct kbd_softc *k;\n\tstruct kbd_state *ks;\n\tint error, s;\n\n\tif (unit >= kbd_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tk = kbd_cd.cd_devs[unit];\n\tif (k == NULL)\n\t\treturn (ENXIO);\n\tks = &k->k_state;\n\terror = 0;\n\n\t/* Tolerate extra calls. */\n\tif (k->k_isopen)\n\t\treturn (error);\n\n\ts = spltty();\n\n\t/* Reset the keyboard and find out its type. */\n\tkbd_output(k, KBD_CMD_RESET);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_was_reset(). */\n\terror = tsleep((caddr_t)&ks->kbd_id,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: reset failed\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\t/*\n\t\t * Allow the open anyway (to keep getty happy)\n\t\t * but assume the \"least common denominator\".\n\t\t */\n\t\tks->kbd_id = KB_SUN2;\n\t}\n\n\t/* Earlier than type 4 does not know \"layout\". */\n\tif (ks->kbd_id < KB_SUN4)\n\t\tgoto out;\n\n\t/* Ask for the layout. */\n\tkbd_output(k, KBD_CMD_GETLAYOUT);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_new_layout(). */\n\terror = tsleep((caddr_t)&ks->kbd_layout,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: no response to get_layout\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\tks->kbd_layout = 0;\n\t}\n\nout:\n\tsplx(s);\n\n\tif (error == 0)\n\t\tk->k_isopen = 1;\n\n\treturn error;\n}"
  },
  {
    "function_name": "kbd_softint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1074-1149",
    "snippet": "static void\nkbd_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\tregister int get, c, s;\n\tint intr_flags;\n\tregister u_short ring_data;\n\n\tk = cs->cs_private;\n\n\t/* Atomically get and clear flags. */\n\ts = splzs();\n\tintr_flags = k->k_intr_flags;\n\tk->k_intr_flags = 0;\n\n\t/* Now lower to spltty for the rest. */\n\t(void) spltty();\n\n\t/*\n\t * Copy data from the receive ring to the event layer.\n\t */\n\tget = k->k_rbget;\n\twhile (get != k->k_rbput) {\n\t\tring_data = k->k_rbuf[get];\n\t\tget = (get + 1) & KBD_RX_RING_MASK;\n\n\t\t/* low byte of ring_data is rr1 */\n\t\tc = (ring_data >> 8) & 0xff;\n\n\t\tif (ring_data & ZSRR1_DO)\n\t\t\tintr_flags |= INTR_RX_OVERRUN;\n\t\tif (ring_data & (ZSRR1_FE | ZSRR1_PE)) {\n\t\t\t/*\n\t\t\t * After garbage, flush pending input, and\n\t\t\t * send a reset to resync key translation.\n\t\t\t */\n\t\t\tlog(LOG_ERR, \"%s: input error (0x%x)\\n\",\n\t\t\t\tk->k_dev.dv_xname, ring_data);\n\t\t\tget = k->k_rbput; /* flush */\n\t\t\tgoto send_reset;\n\t\t}\n\n\t\t/* Pass this up to the \"middle\" layer. */\n\t\tkbd_input_raw(k, c);\n\t}\n\tif (intr_flags & INTR_RX_OVERRUN) {\n\t\tlog(LOG_ERR, \"%s: input overrun\\n\",\n\t\t    k->k_dev.dv_xname);\n\tsend_reset:\n\t\t/* Send a reset to resync translation. */\n\t\tkbd_output(k, KBD_CMD_RESET);\n\t\tkbd_start_tx(k);\n\t}\n\tk->k_rbget = get;\n\n\tif (intr_flags & INTR_TX_EMPTY) {\n\t\t/*\n\t\t * Transmit done.  Try to send more, or\n\t\t * clear busy and wakeup drain waiters.\n\t\t */\n\t\tk->k_txflags &= ~K_TXBUSY;\n\t\tkbd_start_tx(k);\n\t}\n\n\tif (intr_flags & INTR_ST_CHECK) {\n\t\t/*\n\t\t * Status line change.  (Not expected.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: status interrupt?\\n\",\n\t\t    k->k_dev.dv_xname);\n\t\tcs->cs_rr0_delta = 0;\n\t}\n\n\tsplx(s);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tK_TXBUSY 1",
      "#define INTR_ST_CHECK   4",
      "#define INTR_TX_EMPTY   2",
      "#define\tINTR_RX_OVERRUN 1",
      "#define KBD_RX_RING_MASK (KBD_RX_RING_SIZE-1)"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_output(struct kbd_softc *k, int c);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
      "static int kbd_iocsled(struct kbd_softc *k, int *data);",
      "static void kbd_input_raw",
      "static void kbd_softint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: status interrupt?\\n\"",
            "k->k_dev.dv_xname"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_start_tx",
          "args": [
            "k"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_start_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1348-1380",
          "snippet": "static void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1",
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_output",
          "args": [
            "k",
            "KBD_CMD_RESET"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1323-1342",
          "snippet": "static void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_input_raw",
          "args": [
            "k",
            "c"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_input_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "843-950",
          "snippet": "void\nkbd_input_raw(k, c)\n\tstruct kbd_softc *k;\n\tregister int c;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tstruct firm_event *fe;\n\tint put, keysym;\n\n\t/* XXX - Input errors already handled. */\n\n\t/* Are we expecting special input? */\n\tif (ks->kbd_expect) {\n\t\tif (ks->kbd_expect & KBD_EXPECT_IDCODE) {\n\t\t\t/* We read a KBD_RESET last time. */\n\t\t\tks->kbd_id = c;\n\t\t\tkbd_was_reset(k);\n\t\t}\n\t\tif (ks->kbd_expect & KBD_EXPECT_LAYOUT) {\n\t\t\t/* We read a KBD_LAYOUT last time. */\n\t\t\tks->kbd_layout = c;\n\t\t\tkbd_new_layout(k);\n\t\t}\n\t\tks->kbd_expect = 0;\n\t\treturn;\n\t}\n\n\t/* Is this one of the \"special\" input codes? */\n\tif (KBD_SPECIAL(c)) {\n\t\tswitch (c) {\n\t\tcase KBD_RESET:\n\t\t\tks->kbd_expect |= KBD_EXPECT_IDCODE;\n\t\t\t/* Fake an \"all-up\" to resync. translation. */\n\t\t\tc = KBD_IDLE;\n\t\t\tbreak;\n\n\t\tcase KBD_LAYOUT:\n\t\t\tks->kbd_expect |= KBD_EXPECT_LAYOUT;\n\t\t\treturn;\n\n\t\tcase KBD_ERROR:\n\t\t\tlog(LOG_WARNING, \"%s: received error indicator\\n\",\n\t\t\t\tk->k_dev.dv_xname);\n\t\t\treturn;\n\n\t\tcase KBD_IDLE:\n\t\t\t/* Let this go to the translator. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If /dev/kbd is not connected in event mode, \n\t * translate and send upstream (to console).\n\t */\n\tif (!k->k_evmode) {\n\n\t\t/* Any input stops auto-repeat (i.e. key release). */\n\t\tif (k->k_repeating) {\n\t\t\tk->k_repeating = 0;\n\t\t\tuntimeout(kbd_repeat, k);\n\t\t}\n\n\t\t/* Translate this code to a keysym */\n\t\tkeysym = kbd_code_to_keysym(ks, c);\n\n\t\t/* Pass up to the next layer. */\n\t\tkbd_input_keysym(k, keysym);\n\n\t\t/* Does this symbol get auto-repeat? */\n\t\tif (KEYSYM_NOREPEAT(keysym))\n\t\t\treturn;\n\n\t\t/* Setup for auto-repeat after initial delay. */\n\t\tk->k_repeating = 1;\n\t\tk->k_repeatsym = keysym;\n\t\ttimeout(kbd_repeat, k, k->k_repeat_start);\n\t\treturn;\n\t}\n\n\t/*\n\t * IDLEs confuse the MIT X11R4 server badly, so we must drop them.\n\t * This is bad as it means the server will not automatically resync\n\t * on all-up IDLEs, but I did not drop them before, and the server\n\t * goes crazy when it comes time to blank the screen....\n\t */\n\tif (c == KBD_IDLE)\n\t\treturn;\n\n\t/*\n\t * Keyboard is generating events.  Turn this keystroke into an\n\t * event and put it in the queue.  If the queue is full, the\n\t * keystroke is lost (sorry!).\n\t */\n\tput = k->k_events.ev_put;\n\tfe = &k->k_events.ev_q[put];\n\tput = (put + 1) % EV_QSIZE;\n\tif (put == k->k_events.ev_get) {\n\t\tlog(LOG_WARNING, \"%s: event queue overflow\\n\",\n\t\t\tk->k_dev.dv_xname); /* ??? */\n\t\treturn;\n\t}\n\tfe->id = KEY_CODE(c);\n\tfe->value = KEY_UP(c) ? VKEY_UP : VKEY_DOWN;\n\tfe->time = time;\n\tk->k_events.ev_put = put;\n\tEV_WAKEUP(&k->k_events);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static void kbd_input_keysym",
            "static void kbd_input_raw"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_keysym;\nstatic void kbd_input_raw;\n\nvoid\nkbd_input_raw(k, c)\n\tstruct kbd_softc *k;\n\tregister int c;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tstruct firm_event *fe;\n\tint put, keysym;\n\n\t/* XXX - Input errors already handled. */\n\n\t/* Are we expecting special input? */\n\tif (ks->kbd_expect) {\n\t\tif (ks->kbd_expect & KBD_EXPECT_IDCODE) {\n\t\t\t/* We read a KBD_RESET last time. */\n\t\t\tks->kbd_id = c;\n\t\t\tkbd_was_reset(k);\n\t\t}\n\t\tif (ks->kbd_expect & KBD_EXPECT_LAYOUT) {\n\t\t\t/* We read a KBD_LAYOUT last time. */\n\t\t\tks->kbd_layout = c;\n\t\t\tkbd_new_layout(k);\n\t\t}\n\t\tks->kbd_expect = 0;\n\t\treturn;\n\t}\n\n\t/* Is this one of the \"special\" input codes? */\n\tif (KBD_SPECIAL(c)) {\n\t\tswitch (c) {\n\t\tcase KBD_RESET:\n\t\t\tks->kbd_expect |= KBD_EXPECT_IDCODE;\n\t\t\t/* Fake an \"all-up\" to resync. translation. */\n\t\t\tc = KBD_IDLE;\n\t\t\tbreak;\n\n\t\tcase KBD_LAYOUT:\n\t\t\tks->kbd_expect |= KBD_EXPECT_LAYOUT;\n\t\t\treturn;\n\n\t\tcase KBD_ERROR:\n\t\t\tlog(LOG_WARNING, \"%s: received error indicator\\n\",\n\t\t\t\tk->k_dev.dv_xname);\n\t\t\treturn;\n\n\t\tcase KBD_IDLE:\n\t\t\t/* Let this go to the translator. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If /dev/kbd is not connected in event mode, \n\t * translate and send upstream (to console).\n\t */\n\tif (!k->k_evmode) {\n\n\t\t/* Any input stops auto-repeat (i.e. key release). */\n\t\tif (k->k_repeating) {\n\t\t\tk->k_repeating = 0;\n\t\t\tuntimeout(kbd_repeat, k);\n\t\t}\n\n\t\t/* Translate this code to a keysym */\n\t\tkeysym = kbd_code_to_keysym(ks, c);\n\n\t\t/* Pass up to the next layer. */\n\t\tkbd_input_keysym(k, keysym);\n\n\t\t/* Does this symbol get auto-repeat? */\n\t\tif (KEYSYM_NOREPEAT(keysym))\n\t\t\treturn;\n\n\t\t/* Setup for auto-repeat after initial delay. */\n\t\tk->k_repeating = 1;\n\t\tk->k_repeatsym = keysym;\n\t\ttimeout(kbd_repeat, k, k->k_repeat_start);\n\t\treturn;\n\t}\n\n\t/*\n\t * IDLEs confuse the MIT X11R4 server badly, so we must drop them.\n\t * This is bad as it means the server will not automatically resync\n\t * on all-up IDLEs, but I did not drop them before, and the server\n\t * goes crazy when it comes time to blank the screen....\n\t */\n\tif (c == KBD_IDLE)\n\t\treturn;\n\n\t/*\n\t * Keyboard is generating events.  Turn this keystroke into an\n\t * event and put it in the queue.  If the queue is full, the\n\t * keystroke is lost (sorry!).\n\t */\n\tput = k->k_events.ev_put;\n\tfe = &k->k_events.ev_q[put];\n\tput = (put + 1) % EV_QSIZE;\n\tif (put == k->k_events.ev_get) {\n\t\tlog(LOG_WARNING, \"%s: event queue overflow\\n\",\n\t\t\tk->k_dev.dv_xname); /* ??? */\n\t\treturn;\n\t}\n\tfe->id = KEY_CODE(c);\n\tfe->value = KEY_UP(c) ? VKEY_UP : VKEY_DOWN;\n\tfe->time = time;\n\tk->k_events.ev_put = put;\n\tEV_WAKEUP(&k->k_events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_ERR",
            "\"%s: input error (0x%x)\\n\"",
            "k->k_dev.dv_xname",
            "ring_data"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tK_TXBUSY 1\n#define INTR_ST_CHECK   4\n#define INTR_TX_EMPTY   2\n#define\tINTR_RX_OVERRUN 1\n#define KBD_RX_RING_MASK (KBD_RX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\nstatic void kbd_input_raw;\nstatic void kbd_softint;\n\nstatic void\nkbd_softint(cs)\n\tstruct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\tregister int get, c, s;\n\tint intr_flags;\n\tregister u_short ring_data;\n\n\tk = cs->cs_private;\n\n\t/* Atomically get and clear flags. */\n\ts = splzs();\n\tintr_flags = k->k_intr_flags;\n\tk->k_intr_flags = 0;\n\n\t/* Now lower to spltty for the rest. */\n\t(void) spltty();\n\n\t/*\n\t * Copy data from the receive ring to the event layer.\n\t */\n\tget = k->k_rbget;\n\twhile (get != k->k_rbput) {\n\t\tring_data = k->k_rbuf[get];\n\t\tget = (get + 1) & KBD_RX_RING_MASK;\n\n\t\t/* low byte of ring_data is rr1 */\n\t\tc = (ring_data >> 8) & 0xff;\n\n\t\tif (ring_data & ZSRR1_DO)\n\t\t\tintr_flags |= INTR_RX_OVERRUN;\n\t\tif (ring_data & (ZSRR1_FE | ZSRR1_PE)) {\n\t\t\t/*\n\t\t\t * After garbage, flush pending input, and\n\t\t\t * send a reset to resync key translation.\n\t\t\t */\n\t\t\tlog(LOG_ERR, \"%s: input error (0x%x)\\n\",\n\t\t\t\tk->k_dev.dv_xname, ring_data);\n\t\t\tget = k->k_rbput; /* flush */\n\t\t\tgoto send_reset;\n\t\t}\n\n\t\t/* Pass this up to the \"middle\" layer. */\n\t\tkbd_input_raw(k, c);\n\t}\n\tif (intr_flags & INTR_RX_OVERRUN) {\n\t\tlog(LOG_ERR, \"%s: input overrun\\n\",\n\t\t    k->k_dev.dv_xname);\n\tsend_reset:\n\t\t/* Send a reset to resync translation. */\n\t\tkbd_output(k, KBD_CMD_RESET);\n\t\tkbd_start_tx(k);\n\t}\n\tk->k_rbget = get;\n\n\tif (intr_flags & INTR_TX_EMPTY) {\n\t\t/*\n\t\t * Transmit done.  Try to send more, or\n\t\t * clear busy and wakeup drain waiters.\n\t\t */\n\t\tk->k_txflags &= ~K_TXBUSY;\n\t\tkbd_start_tx(k);\n\t}\n\n\tif (intr_flags & INTR_ST_CHECK) {\n\t\t/*\n\t\t * Status line change.  (Not expected.)\n\t\t */\n\t\tlog(LOG_ERR, \"%s: status interrupt?\\n\",\n\t\t    k->k_dev.dv_xname);\n\t\tcs->cs_rr0_delta = 0;\n\t}\n\n\tsplx(s);\n}"
  },
  {
    "function_name": "kbd_stint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1035-1068",
    "snippet": "static void\nkbd_stint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\tregister int rr0;\n\n\tk = cs->cs_private;\n\n\trr0 = zs_read_csr(cs);\n\tzs_write_csr(cs, ZSWR0_RESET_STATUS);\n\n#if 0\n\tif (rr0 & ZSRR0_BREAK) {\n\t\t/* Keyboard unplugged? */\n\t\tzs_abort(cs);\n\t\treturn (0);\n\t}\n#endif\n\n\t/*\n\t * We have to accumulate status line changes here.\n\t * Otherwise, if we get multiple status interrupts\n\t * before the softint runs, we could fail to notice\n\t * some status line changes in the softint routine.\n\t * Fix from Bill Studenmund, October 1996.\n\t */\n\tcs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);\n\tcs->cs_rr0 = rr0;\n\tk->k_intr_flags |= INTR_ST_CHECK;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define INTR_ST_CHECK   4"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static void kbd_stint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_abort",
          "args": [
            "cs"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_STATUS"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_csr",
          "args": [
            "cs"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define INTR_ST_CHECK   4\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_stint;\n\nstatic void\nkbd_stint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\tregister int rr0;\n\n\tk = cs->cs_private;\n\n\trr0 = zs_read_csr(cs);\n\tzs_write_csr(cs, ZSWR0_RESET_STATUS);\n\n#if 0\n\tif (rr0 & ZSRR0_BREAK) {\n\t\t/* Keyboard unplugged? */\n\t\tzs_abort(cs);\n\t\treturn (0);\n\t}\n#endif\n\n\t/*\n\t * We have to accumulate status line changes here.\n\t * Otherwise, if we get multiple status interrupts\n\t * before the softint runs, we could fail to notice\n\t * some status line changes in the softint routine.\n\t * Fix from Bill Studenmund, October 1996.\n\t */\n\tcs->cs_rr0_delta |= (cs->cs_rr0 ^ rr0);\n\tcs->cs_rr0 = rr0;\n\tk->k_intr_flags |= INTR_ST_CHECK;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "kbd_txint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "1021-1032",
    "snippet": "static void\nkbd_txint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\n\tk = cs->cs_private;\n\tzs_write_csr(cs, ZSWR0_RESET_TXINT);\n\tk->k_intr_flags |= INTR_TX_EMPTY;\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define INTR_TX_EMPTY   2"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static void kbd_txint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_TXINT"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define INTR_TX_EMPTY   2\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_txint;\n\nstatic void\nkbd_txint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\n\tk = cs->cs_private;\n\tzs_write_csr(cs, ZSWR0_RESET_TXINT);\n\tk->k_intr_flags |= INTR_TX_EMPTY;\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "kbd_rxint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "961-1018",
    "snippet": "static void\nkbd_rxint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\tregister int put, put_next;\n\tregister u_char c, rr1;\n\n\tk = cs->cs_private;\n\tput = k->k_rbput;\n\n\t/*\n\t * First read the status, because reading the received char\n\t * destroys the status of this char.\n\t */\n\trr1 = zs_read_reg(cs, 1);\n\tc = zs_read_data(cs);\n\n\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t/* Clear the receive error. */\n\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t}\n\n\t/*\n\t * Check NOW for a console abort sequence, so that we can\n\t * abort even when interrupts are locking up the machine.\n\t */\n\tif (k->k_magic1_down) {\n\t\t/* The last keycode was \"MAGIC1\" down. */\n\t\tk->k_magic1_down = 0;\n\t\tif ((c == k->k_magic2) && k->k_isconsole) {\n\t\t\t/* Magic \"L1-A\" sequence; enter debugger. */\n\t\t\tzs_abort(cs);\n\t\t\t/* Debugger done.  Fake L1-up to finish it. */\n\t\t\tc = k->k_magic1 | KBD_UP;\n\t\t}\n\t}\n\tif (c == k->k_magic1) {\n\t\tk->k_magic1_down = 1;\n\t}\n\n\tk->k_rbuf[put] = (c << 8) | rr1;\n\tput_next = (put + 1) & KBD_RX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put_next == k->k_rbget) {\n\t\tk->k_intr_flags |= INTR_RX_OVERRUN;\n\t} else {\n\t\t/* OK, really increment. */\n\t\tput = put_next;\n\t}\n\n\t/* Done reading. */\n\tk->k_rbput = put;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tINTR_RX_OVERRUN 1",
      "#define KBD_RX_RING_MASK (KBD_RX_RING_SIZE-1)"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_output(struct kbd_softc *k, int c);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static void kbd_rxint"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zs_abort",
          "args": [
            "cs"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_csr",
          "args": [
            "cs",
            "ZSWR0_RESET_ERRORS"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_data",
          "args": [
            "cs"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_read_reg",
          "args": [
            "cs",
            "1"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tINTR_RX_OVERRUN 1\n#define KBD_RX_RING_MASK (KBD_RX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_rxint;\n\nstatic void\nkbd_rxint(cs)\n\tregister struct zs_chanstate *cs;\n{\n\tregister struct kbd_softc *k;\n\tregister int put, put_next;\n\tregister u_char c, rr1;\n\n\tk = cs->cs_private;\n\tput = k->k_rbput;\n\n\t/*\n\t * First read the status, because reading the received char\n\t * destroys the status of this char.\n\t */\n\trr1 = zs_read_reg(cs, 1);\n\tc = zs_read_data(cs);\n\n\tif (rr1 & (ZSRR1_FE | ZSRR1_DO | ZSRR1_PE)) {\n\t\t/* Clear the receive error. */\n\t\tzs_write_csr(cs, ZSWR0_RESET_ERRORS);\n\t}\n\n\t/*\n\t * Check NOW for a console abort sequence, so that we can\n\t * abort even when interrupts are locking up the machine.\n\t */\n\tif (k->k_magic1_down) {\n\t\t/* The last keycode was \"MAGIC1\" down. */\n\t\tk->k_magic1_down = 0;\n\t\tif ((c == k->k_magic2) && k->k_isconsole) {\n\t\t\t/* Magic \"L1-A\" sequence; enter debugger. */\n\t\t\tzs_abort(cs);\n\t\t\t/* Debugger done.  Fake L1-up to finish it. */\n\t\t\tc = k->k_magic1 | KBD_UP;\n\t\t}\n\t}\n\tif (c == k->k_magic1) {\n\t\tk->k_magic1_down = 1;\n\t}\n\n\tk->k_rbuf[put] = (c << 8) | rr1;\n\tput_next = (put + 1) & KBD_RX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put_next == k->k_rbget) {\n\t\tk->k_intr_flags |= INTR_RX_OVERRUN;\n\t} else {\n\t\t/* OK, really increment. */\n\t\tput = put_next;\n\t}\n\n\t/* Done reading. */\n\tk->k_rbput = put;\n\n\t/* Ask for softint() call. */\n\tcs->cs_softreq = 1;\n}"
  },
  {
    "function_name": "kbd_input_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "843-950",
    "snippet": "void\nkbd_input_raw(k, c)\n\tstruct kbd_softc *k;\n\tregister int c;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tstruct firm_event *fe;\n\tint put, keysym;\n\n\t/* XXX - Input errors already handled. */\n\n\t/* Are we expecting special input? */\n\tif (ks->kbd_expect) {\n\t\tif (ks->kbd_expect & KBD_EXPECT_IDCODE) {\n\t\t\t/* We read a KBD_RESET last time. */\n\t\t\tks->kbd_id = c;\n\t\t\tkbd_was_reset(k);\n\t\t}\n\t\tif (ks->kbd_expect & KBD_EXPECT_LAYOUT) {\n\t\t\t/* We read a KBD_LAYOUT last time. */\n\t\t\tks->kbd_layout = c;\n\t\t\tkbd_new_layout(k);\n\t\t}\n\t\tks->kbd_expect = 0;\n\t\treturn;\n\t}\n\n\t/* Is this one of the \"special\" input codes? */\n\tif (KBD_SPECIAL(c)) {\n\t\tswitch (c) {\n\t\tcase KBD_RESET:\n\t\t\tks->kbd_expect |= KBD_EXPECT_IDCODE;\n\t\t\t/* Fake an \"all-up\" to resync. translation. */\n\t\t\tc = KBD_IDLE;\n\t\t\tbreak;\n\n\t\tcase KBD_LAYOUT:\n\t\t\tks->kbd_expect |= KBD_EXPECT_LAYOUT;\n\t\t\treturn;\n\n\t\tcase KBD_ERROR:\n\t\t\tlog(LOG_WARNING, \"%s: received error indicator\\n\",\n\t\t\t\tk->k_dev.dv_xname);\n\t\t\treturn;\n\n\t\tcase KBD_IDLE:\n\t\t\t/* Let this go to the translator. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If /dev/kbd is not connected in event mode, \n\t * translate and send upstream (to console).\n\t */\n\tif (!k->k_evmode) {\n\n\t\t/* Any input stops auto-repeat (i.e. key release). */\n\t\tif (k->k_repeating) {\n\t\t\tk->k_repeating = 0;\n\t\t\tuntimeout(kbd_repeat, k);\n\t\t}\n\n\t\t/* Translate this code to a keysym */\n\t\tkeysym = kbd_code_to_keysym(ks, c);\n\n\t\t/* Pass up to the next layer. */\n\t\tkbd_input_keysym(k, keysym);\n\n\t\t/* Does this symbol get auto-repeat? */\n\t\tif (KEYSYM_NOREPEAT(keysym))\n\t\t\treturn;\n\n\t\t/* Setup for auto-repeat after initial delay. */\n\t\tk->k_repeating = 1;\n\t\tk->k_repeatsym = keysym;\n\t\ttimeout(kbd_repeat, k, k->k_repeat_start);\n\t\treturn;\n\t}\n\n\t/*\n\t * IDLEs confuse the MIT X11R4 server badly, so we must drop them.\n\t * This is bad as it means the server will not automatically resync\n\t * on all-up IDLEs, but I did not drop them before, and the server\n\t * goes crazy when it comes time to blank the screen....\n\t */\n\tif (c == KBD_IDLE)\n\t\treturn;\n\n\t/*\n\t * Keyboard is generating events.  Turn this keystroke into an\n\t * event and put it in the queue.  If the queue is full, the\n\t * keystroke is lost (sorry!).\n\t */\n\tput = k->k_events.ev_put;\n\tfe = &k->k_events.ev_q[put];\n\tput = (put + 1) % EV_QSIZE;\n\tif (put == k->k_events.ev_get) {\n\t\tlog(LOG_WARNING, \"%s: event queue overflow\\n\",\n\t\t\tk->k_dev.dv_xname); /* ??? */\n\t\treturn;\n\t}\n\tfe->id = KEY_CODE(c);\n\tfe->value = KEY_UP(c) ? VKEY_UP : VKEY_DOWN;\n\tfe->time = time;\n\tk->k_events.ev_put = put;\n\tEV_WAKEUP(&k->k_events);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_output(struct kbd_softc *k, int c);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static void kbd_input_keysym",
      "static void kbd_input_raw"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EV_WAKEUP",
          "args": [
            "&k->k_events"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KEY_UP",
          "args": [
            "c"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KEY_CODE",
          "args": [
            "c"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: event queue overflow\\n\"",
            "k->k_dev.dv_xname"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ncr_log_hard_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/ncr.c",
          "lines": "5909-5956",
          "snippet": "static void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}",
          "includes": [
            "#include <scsi/scsiconf.h>",
            "#include <scsi/scsi_all.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/ncrreg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <sys/device.h>",
            "#include <pci/ncrreg.h>",
            "#include <pci/pcireg.h>",
            "#include <pci/pcivar.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <machine/clock.h>",
            "#include <sys/sysctl.h>",
            "#include <sys/kernel.h>",
            "#include <sys/buf.h>",
            "#include <sys/malloc.h>",
            "#include <sys/systm.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <stddef.h>",
            "#include \"opt_ncr.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "ncb_p np = (void *)self;",
            "int\ti;",
            "ncb_p np = (struct ncb*) 0;",
            "int\ti;",
            "u_int8_t\tistat, dstat;",
            "u_int16_t\tsist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <scsi/scsiconf.h>\n#include <scsi/scsi_all.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/ncrreg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <sys/device.h>\n#include <pci/ncrreg.h>\n#include <pci/pcireg.h>\n#include <pci/pcivar.h>\n#include <vm/vm_extern.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <machine/clock.h>\n#include <sys/sysctl.h>\n#include <sys/kernel.h>\n#include <sys/buf.h>\n#include <sys/malloc.h>\n#include <sys/systm.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <stddef.h>\n#include \"opt_ncr.h\"\n\nncb_p np = (void *)self;\nint\ti;\nncb_p np = (struct ncb*) 0;\nint\ti;\nu_int8_t\tistat, dstat;\nu_int16_t\tsist;\n\nstatic void ncr_log_hard_error(ncb_p np, u_short sist, u_char dstat)\n{\n\tu_int32_t dsp;\n\tint\tscript_ofs;\n\tint\tscript_size;\n\tchar\t*script_name;\n\tu_char\t*script_base;\n\tint\ti;\n\n\tdsp\t= INL (nc_dsp);\n\n\tif (np->p_script < dsp &&\n\t    dsp <= np->p_script + sizeof(struct script)) {\n\t\tscript_ofs\t= dsp - np->p_script;\n\t\tscript_size\t= sizeof(struct script);\n\t\tscript_base\t= (u_char *) np->script;\n\t\tscript_name\t= \"script\";\n\t}\n\telse if (np->p_scripth < dsp &&\n\t\t dsp <= np->p_scripth + sizeof(struct scripth)) {\n\t\tscript_ofs\t= dsp - np->p_scripth;\n\t\tscript_size\t= sizeof(struct scripth);\n\t\tscript_base\t= (u_char *) np->scripth;\n\t\tscript_name\t= \"scripth\";\n\t} else {\n\t\tscript_ofs\t= dsp;\n\t\tscript_size\t= 0;\n\t\tscript_base\t= 0;\n\t\tscript_name\t= \"mem\";\n\t}\n\n\tprintf (\"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\\n\",\n\t\tncr_name (np), (unsigned)INB (nc_sdid)&0x0f, dstat, sist,\n\t\t(unsigned)INB (nc_socl), (unsigned)INB (nc_sbcl), (unsigned)INB (nc_sbdl),\n\t\t(unsigned)INB (nc_sxfer),(unsigned)INB (nc_scntl3), script_name, script_ofs,\n\t\t(unsigned)INL (nc_dbc));\n\n\tif (((script_ofs & 3) == 0) &&\n\t    (unsigned)script_ofs < script_size) {\n\t\tprintf (\"%s: script cmd = %08x\\n\", ncr_name(np),\n\t\t    (int)READSCRIPT_OFF(script_base, script_ofs));\n\t}\n\n        printf (\"%s: regdump:\", ncr_name(np));\n        for (i=0; i<16;i++)\n            printf (\" %02x\", (unsigned)INB_OFF(i));\n        printf (\".\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "kbd_repeat",
            "k",
            "k->k_repeat_start"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KEYSYM_NOREPEAT",
          "args": [
            "keysym"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbd_input_keysym",
          "args": [
            "k",
            "keysym"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_input_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "764-819",
          "snippet": "void\nkbd_input_keysym(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tregister int data;\n\n\tswitch (KEYSYM_CLASS(keysym)) {\n\n\tcase KEYSYM_ASCII:\n\t\tdata = KEYSYM_DATA(keysym);\n\t\tif (ks->kbd_modbits & KBMOD_META_MASK)\n\t\t\tdata |= 0x80;\n\t\tkd_input(data);\n\t\tbreak;\n\n\tcase KEYSYM_STRING:\n\t\tdata = keysym & 0xF;\n\t\tkbd_input_string(k, kbd_stringtab[data]);\n\t\tbreak;\n\n\tcase KEYSYM_FUNC:\n\t\tkbd_input_funckey(k, keysym);\n\t\tbreak;\n\n\tcase KEYSYM_CLRMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits &= ~data;\n\t\tbreak;\n\n\tcase KEYSYM_SETMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits |= data;\n\t\tbreak;\n\n\tcase KEYSYM_INVMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits ^= data;\n\t\tkbd_update_leds(k);\n\t\tbreak;\n\n\tcase KEYSYM_ALL_UP:\n\t\tks->kbd_modbits &= ~0xFFFF;\n\t\tbreak;\n\n\tcase KEYSYM_SPECIAL:\n\t\tif (keysym == KEYSYM_NOP)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tlog(LOG_WARNING, \"%s: unexpected keysym 0x%x\\n\",\n\t\t\tk->k_dev.dv_xname, keysym);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);",
            "static void kbd_input_string",
            "static void kbd_input_funckey",
            "static void kbd_input_keysym"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\nstatic void kbd_input_string;\nstatic void kbd_input_funckey;\nstatic void kbd_input_keysym;\n\nvoid\nkbd_input_keysym(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tregister int data;\n\n\tswitch (KEYSYM_CLASS(keysym)) {\n\n\tcase KEYSYM_ASCII:\n\t\tdata = KEYSYM_DATA(keysym);\n\t\tif (ks->kbd_modbits & KBMOD_META_MASK)\n\t\t\tdata |= 0x80;\n\t\tkd_input(data);\n\t\tbreak;\n\n\tcase KEYSYM_STRING:\n\t\tdata = keysym & 0xF;\n\t\tkbd_input_string(k, kbd_stringtab[data]);\n\t\tbreak;\n\n\tcase KEYSYM_FUNC:\n\t\tkbd_input_funckey(k, keysym);\n\t\tbreak;\n\n\tcase KEYSYM_CLRMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits &= ~data;\n\t\tbreak;\n\n\tcase KEYSYM_SETMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits |= data;\n\t\tbreak;\n\n\tcase KEYSYM_INVMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits ^= data;\n\t\tkbd_update_leds(k);\n\t\tbreak;\n\n\tcase KEYSYM_ALL_UP:\n\t\tks->kbd_modbits &= ~0xFFFF;\n\t\tbreak;\n\n\tcase KEYSYM_SPECIAL:\n\t\tif (keysym == KEYSYM_NOP)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tlog(LOG_WARNING, \"%s: unexpected keysym 0x%x\\n\",\n\t\t\tk->k_dev.dv_xname, keysym);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_code_to_keysym",
          "args": [
            "ks",
            "c"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_code_to_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "680-730",
          "snippet": "int\nkbd_code_to_keysym(ks, c)\n\tregister struct kbd_state *ks;\n\tregister int c;\n{\n\tu_short *km;\n\tint keysym;\n\n\t/*\n\t * Get keymap pointer.  One of these:\n\t * release, control, shifted, normal, ...\n\t */\n\tif (KEY_UP(c))\n\t\tkm = ks->kbd_k.k_release;\n\telse if (ks->kbd_modbits & KBMOD_CTRL_MASK)\n\t\tkm = ks->kbd_k.k_control;\n\telse if (ks->kbd_modbits & KBMOD_SHIFT_MASK)\n\t\tkm = ks->kbd_k.k_shifted;\n\telse\n\t\tkm = ks->kbd_k.k_normal;\n\n\tif (km == NULL) {\n\t\t/*\n\t\t * Do not know how to translate yet.\n\t\t * We will find out when a RESET comes along.\n\t\t */\n\t\treturn (KEYSYM_NOP);\n\t}\n\tkeysym = km[KEY_CODE(c)];\n\n\t/*\n\t * Post-processing for Caps-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_CAPSLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_ASCII) )\n\t{\n\t\tif (('a' <= keysym) && (keysym <= 'z'))\n\t\t\tkeysym -= ('a' - 'A');\n\t}\n\n\t/*\n\t * Post-processing for Num-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_NUMLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_FUNC) )\n\t{\n\t\tkeysym = kbd_numlock_map[keysym & 0x3F];\n\t}\n\n\treturn (keysym);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_output(struct kbd_softc *k, int c);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_output(struct kbd_softc *k, int c);\n\nint\nkbd_code_to_keysym(ks, c)\n\tregister struct kbd_state *ks;\n\tregister int c;\n{\n\tu_short *km;\n\tint keysym;\n\n\t/*\n\t * Get keymap pointer.  One of these:\n\t * release, control, shifted, normal, ...\n\t */\n\tif (KEY_UP(c))\n\t\tkm = ks->kbd_k.k_release;\n\telse if (ks->kbd_modbits & KBMOD_CTRL_MASK)\n\t\tkm = ks->kbd_k.k_control;\n\telse if (ks->kbd_modbits & KBMOD_SHIFT_MASK)\n\t\tkm = ks->kbd_k.k_shifted;\n\telse\n\t\tkm = ks->kbd_k.k_normal;\n\n\tif (km == NULL) {\n\t\t/*\n\t\t * Do not know how to translate yet.\n\t\t * We will find out when a RESET comes along.\n\t\t */\n\t\treturn (KEYSYM_NOP);\n\t}\n\tkeysym = km[KEY_CODE(c)];\n\n\t/*\n\t * Post-processing for Caps-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_CAPSLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_ASCII) )\n\t{\n\t\tif (('a' <= keysym) && (keysym <= 'z'))\n\t\t\tkeysym -= ('a' - 'A');\n\t}\n\n\t/*\n\t * Post-processing for Num-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_NUMLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_FUNC) )\n\t{\n\t\tkeysym = kbd_numlock_map[keysym & 0x3F];\n\t}\n\n\treturn (keysym);\n}"
        }
      },
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "kbd_repeat",
            "k"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KBD_SPECIAL",
          "args": [
            "c"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbd_new_layout",
          "args": [
            "k"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_new_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1282-1295",
          "snippet": "static void\nkbd_new_layout(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_layout);\n\n\t/* XXX: switch decoding tables? */\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_new_layout(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_layout);\n\n\t/* XXX: switch decoding tables? */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_was_reset",
          "args": [
            "k"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_was_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1237-1277",
          "snippet": "static void\nkbd_was_reset(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_id);\n\n\t/* Restore keyclick, if necessary */\n\tswitch (ks->kbd_id) {\n\n\tcase KB_SUN2:\n\t\t/* Type 2 keyboards don't support keyclick */\n\t\tbreak;\n\n\tcase KB_SUN3:\n\t\t/* Type 3 keyboards come up with keyclick on */\n\t\tif (!ks->kbd_click) {\n\t\t\t/* turn off the click */\n\t\t\tkbd_output(k, KBD_CMD_NOCLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\n\tcase KB_SUN4:\n\t\t/* Type 4 keyboards come up with keyclick off */\n\t\tif (ks->kbd_click) {\n\t\t\t/* turn on the click */\n\t\t\tkbd_output(k, KBD_CMD_CLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* LEDs are off after reset. */\n\tks->kbd_leds = 0;\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_was_reset(k)\n\tstruct kbd_softc *k;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/*\n\t * On first identification, wake up anyone waiting for type\n\t * and set up the table pointers.\n\t */\n\twakeup((caddr_t)&ks->kbd_id);\n\n\t/* Restore keyclick, if necessary */\n\tswitch (ks->kbd_id) {\n\n\tcase KB_SUN2:\n\t\t/* Type 2 keyboards don't support keyclick */\n\t\tbreak;\n\n\tcase KB_SUN3:\n\t\t/* Type 3 keyboards come up with keyclick on */\n\t\tif (!ks->kbd_click) {\n\t\t\t/* turn off the click */\n\t\t\tkbd_output(k, KBD_CMD_NOCLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\n\tcase KB_SUN4:\n\t\t/* Type 4 keyboards come up with keyclick off */\n\t\tif (ks->kbd_click) {\n\t\t\t/* turn on the click */\n\t\t\tkbd_output(k, KBD_CMD_CLICK);\n\t\t\tkbd_start_tx(k);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* LEDs are off after reset. */\n\tks->kbd_leds = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_keysym;\nstatic void kbd_input_raw;\n\nvoid\nkbd_input_raw(k, c)\n\tstruct kbd_softc *k;\n\tregister int c;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tstruct firm_event *fe;\n\tint put, keysym;\n\n\t/* XXX - Input errors already handled. */\n\n\t/* Are we expecting special input? */\n\tif (ks->kbd_expect) {\n\t\tif (ks->kbd_expect & KBD_EXPECT_IDCODE) {\n\t\t\t/* We read a KBD_RESET last time. */\n\t\t\tks->kbd_id = c;\n\t\t\tkbd_was_reset(k);\n\t\t}\n\t\tif (ks->kbd_expect & KBD_EXPECT_LAYOUT) {\n\t\t\t/* We read a KBD_LAYOUT last time. */\n\t\t\tks->kbd_layout = c;\n\t\t\tkbd_new_layout(k);\n\t\t}\n\t\tks->kbd_expect = 0;\n\t\treturn;\n\t}\n\n\t/* Is this one of the \"special\" input codes? */\n\tif (KBD_SPECIAL(c)) {\n\t\tswitch (c) {\n\t\tcase KBD_RESET:\n\t\t\tks->kbd_expect |= KBD_EXPECT_IDCODE;\n\t\t\t/* Fake an \"all-up\" to resync. translation. */\n\t\t\tc = KBD_IDLE;\n\t\t\tbreak;\n\n\t\tcase KBD_LAYOUT:\n\t\t\tks->kbd_expect |= KBD_EXPECT_LAYOUT;\n\t\t\treturn;\n\n\t\tcase KBD_ERROR:\n\t\t\tlog(LOG_WARNING, \"%s: received error indicator\\n\",\n\t\t\t\tk->k_dev.dv_xname);\n\t\t\treturn;\n\n\t\tcase KBD_IDLE:\n\t\t\t/* Let this go to the translator. */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If /dev/kbd is not connected in event mode, \n\t * translate and send upstream (to console).\n\t */\n\tif (!k->k_evmode) {\n\n\t\t/* Any input stops auto-repeat (i.e. key release). */\n\t\tif (k->k_repeating) {\n\t\t\tk->k_repeating = 0;\n\t\t\tuntimeout(kbd_repeat, k);\n\t\t}\n\n\t\t/* Translate this code to a keysym */\n\t\tkeysym = kbd_code_to_keysym(ks, c);\n\n\t\t/* Pass up to the next layer. */\n\t\tkbd_input_keysym(k, keysym);\n\n\t\t/* Does this symbol get auto-repeat? */\n\t\tif (KEYSYM_NOREPEAT(keysym))\n\t\t\treturn;\n\n\t\t/* Setup for auto-repeat after initial delay. */\n\t\tk->k_repeating = 1;\n\t\tk->k_repeatsym = keysym;\n\t\ttimeout(kbd_repeat, k, k->k_repeat_start);\n\t\treturn;\n\t}\n\n\t/*\n\t * IDLEs confuse the MIT X11R4 server badly, so we must drop them.\n\t * This is bad as it means the server will not automatically resync\n\t * on all-up IDLEs, but I did not drop them before, and the server\n\t * goes crazy when it comes time to blank the screen....\n\t */\n\tif (c == KBD_IDLE)\n\t\treturn;\n\n\t/*\n\t * Keyboard is generating events.  Turn this keystroke into an\n\t * event and put it in the queue.  If the queue is full, the\n\t * keystroke is lost (sorry!).\n\t */\n\tput = k->k_events.ev_put;\n\tfe = &k->k_events.ev_q[put];\n\tput = (put + 1) % EV_QSIZE;\n\tif (put == k->k_events.ev_get) {\n\t\tlog(LOG_WARNING, \"%s: event queue overflow\\n\",\n\t\t\tk->k_dev.dv_xname); /* ??? */\n\t\treturn;\n\t}\n\tfe->id = KEY_CODE(c);\n\tfe->value = KEY_UP(c) ? VKEY_UP : VKEY_DOWN;\n\tfe->time = time;\n\tk->k_events.ev_put = put;\n\tEV_WAKEUP(&k->k_events);\n}"
  },
  {
    "function_name": "kbd_repeat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "825-836",
    "snippet": "static void\nkbd_repeat(void *arg)\n{\n\tstruct kbd_softc *k = (struct kbd_softc *)arg;\n\tint s = spltty();\n\n\tif (k->k_repeating && k->k_repeatsym >= 0) {\n\t\tkbd_input_keysym(k, k->k_repeatsym);\n\t\ttimeout(kbd_repeat, k, k->k_repeat_step);\n\t}\n\tsplx(s);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_repeat(void *arg);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static void kbd_input_keysym"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "kbd_repeat",
            "k",
            "k->k_repeat_step"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_input_keysym",
          "args": [
            "k",
            "k->k_repeatsym"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_input_keysym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "764-819",
          "snippet": "void\nkbd_input_keysym(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tregister int data;\n\n\tswitch (KEYSYM_CLASS(keysym)) {\n\n\tcase KEYSYM_ASCII:\n\t\tdata = KEYSYM_DATA(keysym);\n\t\tif (ks->kbd_modbits & KBMOD_META_MASK)\n\t\t\tdata |= 0x80;\n\t\tkd_input(data);\n\t\tbreak;\n\n\tcase KEYSYM_STRING:\n\t\tdata = keysym & 0xF;\n\t\tkbd_input_string(k, kbd_stringtab[data]);\n\t\tbreak;\n\n\tcase KEYSYM_FUNC:\n\t\tkbd_input_funckey(k, keysym);\n\t\tbreak;\n\n\tcase KEYSYM_CLRMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits &= ~data;\n\t\tbreak;\n\n\tcase KEYSYM_SETMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits |= data;\n\t\tbreak;\n\n\tcase KEYSYM_INVMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits ^= data;\n\t\tkbd_update_leds(k);\n\t\tbreak;\n\n\tcase KEYSYM_ALL_UP:\n\t\tks->kbd_modbits &= ~0xFFFF;\n\t\tbreak;\n\n\tcase KEYSYM_SPECIAL:\n\t\tif (keysym == KEYSYM_NOP)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tlog(LOG_WARNING, \"%s: unexpected keysym 0x%x\\n\",\n\t\t\tk->k_dev.dv_xname, keysym);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);",
            "static void kbd_input_string",
            "static void kbd_input_funckey",
            "static void kbd_input_keysym"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\nstatic void kbd_input_string;\nstatic void kbd_input_funckey;\nstatic void kbd_input_keysym;\n\nvoid\nkbd_input_keysym(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tregister int data;\n\n\tswitch (KEYSYM_CLASS(keysym)) {\n\n\tcase KEYSYM_ASCII:\n\t\tdata = KEYSYM_DATA(keysym);\n\t\tif (ks->kbd_modbits & KBMOD_META_MASK)\n\t\t\tdata |= 0x80;\n\t\tkd_input(data);\n\t\tbreak;\n\n\tcase KEYSYM_STRING:\n\t\tdata = keysym & 0xF;\n\t\tkbd_input_string(k, kbd_stringtab[data]);\n\t\tbreak;\n\n\tcase KEYSYM_FUNC:\n\t\tkbd_input_funckey(k, keysym);\n\t\tbreak;\n\n\tcase KEYSYM_CLRMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits &= ~data;\n\t\tbreak;\n\n\tcase KEYSYM_SETMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits |= data;\n\t\tbreak;\n\n\tcase KEYSYM_INVMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits ^= data;\n\t\tkbd_update_leds(k);\n\t\tbreak;\n\n\tcase KEYSYM_ALL_UP:\n\t\tks->kbd_modbits &= ~0xFFFF;\n\t\tbreak;\n\n\tcase KEYSYM_SPECIAL:\n\t\tif (keysym == KEYSYM_NOP)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tlog(LOG_WARNING, \"%s: unexpected keysym 0x%x\\n\",\n\t\t\tk->k_dev.dv_xname, keysym);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_repeat(void *arg);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_keysym;\n\nstatic void\nkbd_repeat(void *arg)\n{\n\tstruct kbd_softc *k = (struct kbd_softc *)arg;\n\tint s = spltty();\n\n\tif (k->k_repeating && k->k_repeatsym >= 0) {\n\t\tkbd_input_keysym(k, k->k_repeatsym);\n\t\ttimeout(kbd_repeat, k, k->k_repeat_step);\n\t}\n\tsplx(s);\n}"
  },
  {
    "function_name": "kbd_input_keysym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "764-819",
    "snippet": "void\nkbd_input_keysym(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tregister int data;\n\n\tswitch (KEYSYM_CLASS(keysym)) {\n\n\tcase KEYSYM_ASCII:\n\t\tdata = KEYSYM_DATA(keysym);\n\t\tif (ks->kbd_modbits & KBMOD_META_MASK)\n\t\t\tdata |= 0x80;\n\t\tkd_input(data);\n\t\tbreak;\n\n\tcase KEYSYM_STRING:\n\t\tdata = keysym & 0xF;\n\t\tkbd_input_string(k, kbd_stringtab[data]);\n\t\tbreak;\n\n\tcase KEYSYM_FUNC:\n\t\tkbd_input_funckey(k, keysym);\n\t\tbreak;\n\n\tcase KEYSYM_CLRMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits &= ~data;\n\t\tbreak;\n\n\tcase KEYSYM_SETMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits |= data;\n\t\tbreak;\n\n\tcase KEYSYM_INVMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits ^= data;\n\t\tkbd_update_leds(k);\n\t\tbreak;\n\n\tcase KEYSYM_ALL_UP:\n\t\tks->kbd_modbits &= ~0xFFFF;\n\t\tbreak;\n\n\tcase KEYSYM_SPECIAL:\n\t\tif (keysym == KEYSYM_NOP)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tlog(LOG_WARNING, \"%s: unexpected keysym 0x%x\\n\",\n\t\t\tk->k_dev.dv_xname, keysym);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
      "static int kbd_iocsled(struct kbd_softc *k, int *data);",
      "static void kbd_input_string",
      "static void kbd_input_funckey",
      "static void kbd_input_keysym"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log",
          "args": [
            "LOG_WARNING",
            "\"%s: unexpected keysym 0x%x\\n\"",
            "k->k_dev.dv_xname",
            "keysym"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "tcic_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tcic2.c",
          "lines": "1387-1401",
          "snippet": "int\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}",
          "includes": [
            "#include <dev/ic/tcic2var.h>",
            "#include <dev/ic/tcic2reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm.h>",
            "#include <sys/kthread.h>",
            "#include <sys/malloc.h>",
            "#include <sys/extent.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tcic2var.h>\n#include <dev/ic/tcic2reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <vm/vm.h>\n#include <sys/kthread.h>\n#include <sys/malloc.h>\n#include <sys/extent.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nint\ntcic_log2(val)\n\tu_int val;\n{\n\tint i, l2;\n\n\tl2 = i = 0;\n\twhile (val) {\n\t\tif (val & 1)\n\t\t\tl2 = i;\n\t\ti++;\n\t\tval >>= 1;\n\t}\n\treturn l2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_update_leds",
          "args": [
            "k"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_update_leds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1412-1428",
          "snippet": "static void\nkbd_update_leds(k)\n    struct kbd_softc *k;\n{\n    struct kbd_state *ks = &k->k_state;\n    register char leds;\n\n\tleds = ks->kbd_leds;\n\tleds &= ~(LED_CAPS_LOCK|LED_NUM_LOCK);\n\n\tif (ks->kbd_modbits & (1 << KBMOD_CAPSLOCK))\n\t\tleds |= LED_CAPS_LOCK;\n\tif (ks->kbd_modbits & (1 << KBMOD_NUMLOCK))\n\t\tleds |= LED_NUM_LOCK;\n\n\tkbd_set_leds(k, leds);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_set_leds(struct kbd_softc *k, int leds);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_set_leds(struct kbd_softc *k, int leds);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_update_leds(k)\n    struct kbd_softc *k;\n{\n    struct kbd_state *ks = &k->k_state;\n    register char leds;\n\n\tleds = ks->kbd_leds;\n\tleds &= ~(LED_CAPS_LOCK|LED_NUM_LOCK);\n\n\tif (ks->kbd_modbits & (1 << KBMOD_CAPSLOCK))\n\t\tleds |= LED_CAPS_LOCK;\n\tif (ks->kbd_modbits & (1 << KBMOD_NUMLOCK))\n\t\tleds |= LED_NUM_LOCK;\n\n\tkbd_set_leds(k, leds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_input_funckey",
          "args": [
            "k",
            "keysym"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_input_funckey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "743-758",
          "snippet": "void\nkbd_input_funckey(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tregister int n;\n\tchar str[12];\n\n\t/*\n\t * Format the F-key sequence and send as a string.\n\t * XXX: Ugly compatibility mappings.\n\t */\n\tn = 0xC0 + (keysym & 0x3F);\n\tsprintf(str, \"\\033[%dz\", n);\n\tkbd_input_string(k, str);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static void kbd_input_string",
            "static void kbd_input_funckey"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_string;\nstatic void kbd_input_funckey;\n\nvoid\nkbd_input_funckey(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tregister int n;\n\tchar str[12];\n\n\t/*\n\t * Format the F-key sequence and send as a string.\n\t * XXX: Ugly compatibility mappings.\n\t */\n\tn = 0xC0 + (keysym & 0x3F);\n\tsprintf(str, \"\\033[%dz\", n);\n\tkbd_input_string(k, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_input_string",
          "args": [
            "k",
            "kbd_stringtab[data]"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_input_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "732-741",
          "snippet": "void\nkbd_input_string(k, str)\n\tstruct kbd_softc *k;\n\tchar *str;\n{\n\twhile (*str) {\n\t\tkd_input(*str);\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static void kbd_input_string"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_string;\n\nvoid\nkbd_input_string(k, str)\n\tstruct kbd_softc *k;\n\tchar *str;\n{\n\twhile (*str) {\n\t\tkd_input(*str);\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kd_input",
          "args": [
            "data"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KEYSYM_DATA",
          "args": [
            "keysym"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KEYSYM_CLASS",
          "args": [
            "keysym"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\nstatic void kbd_input_string;\nstatic void kbd_input_funckey;\nstatic void kbd_input_keysym;\n\nvoid\nkbd_input_keysym(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tregister int data;\n\n\tswitch (KEYSYM_CLASS(keysym)) {\n\n\tcase KEYSYM_ASCII:\n\t\tdata = KEYSYM_DATA(keysym);\n\t\tif (ks->kbd_modbits & KBMOD_META_MASK)\n\t\t\tdata |= 0x80;\n\t\tkd_input(data);\n\t\tbreak;\n\n\tcase KEYSYM_STRING:\n\t\tdata = keysym & 0xF;\n\t\tkbd_input_string(k, kbd_stringtab[data]);\n\t\tbreak;\n\n\tcase KEYSYM_FUNC:\n\t\tkbd_input_funckey(k, keysym);\n\t\tbreak;\n\n\tcase KEYSYM_CLRMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits &= ~data;\n\t\tbreak;\n\n\tcase KEYSYM_SETMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits |= data;\n\t\tbreak;\n\n\tcase KEYSYM_INVMOD:\n\t\tdata = 1 << (keysym & 0x1F);\n\t\tks->kbd_modbits ^= data;\n\t\tkbd_update_leds(k);\n\t\tbreak;\n\n\tcase KEYSYM_ALL_UP:\n\t\tks->kbd_modbits &= ~0xFFFF;\n\t\tbreak;\n\n\tcase KEYSYM_SPECIAL:\n\t\tif (keysym == KEYSYM_NOP)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tlog(LOG_WARNING, \"%s: unexpected keysym 0x%x\\n\",\n\t\t\tk->k_dev.dv_xname, keysym);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "kbd_input_funckey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "743-758",
    "snippet": "void\nkbd_input_funckey(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tregister int n;\n\tchar str[12];\n\n\t/*\n\t * Format the F-key sequence and send as a string.\n\t * XXX: Ugly compatibility mappings.\n\t */\n\tn = 0xC0 + (keysym & 0x3F);\n\tsprintf(str, \"\\033[%dz\", n);\n\tkbd_input_string(k, str);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static void kbd_input_string",
      "static void kbd_input_funckey"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kbd_input_string",
          "args": [
            "k",
            "str"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_input_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "732-741",
          "snippet": "void\nkbd_input_string(k, str)\n\tstruct kbd_softc *k;\n\tchar *str;\n{\n\twhile (*str) {\n\t\tkd_input(*str);\n\t\tstr++;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static void kbd_input_string"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_string;\n\nvoid\nkbd_input_string(k, str)\n\tstruct kbd_softc *k;\n\tchar *str;\n{\n\twhile (*str) {\n\t\tkd_input(*str);\n\t\tstr++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "str",
            "\"\\033[%dz\"",
            "n"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_string;\nstatic void kbd_input_funckey;\n\nvoid\nkbd_input_funckey(k, keysym)\n\tstruct kbd_softc *k;\n\tregister int keysym;\n{\n\tregister int n;\n\tchar str[12];\n\n\t/*\n\t * Format the F-key sequence and send as a string.\n\t * XXX: Ugly compatibility mappings.\n\t */\n\tn = 0xC0 + (keysym & 0x3F);\n\tsprintf(str, \"\\033[%dz\", n);\n\tkbd_input_string(k, str);\n}"
  },
  {
    "function_name": "kbd_input_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "732-741",
    "snippet": "void\nkbd_input_string(k, str)\n\tstruct kbd_softc *k;\n\tchar *str;\n{\n\twhile (*str) {\n\t\tkd_input(*str);\n\t\tstr++;\n\t}\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static void kbd_input_string"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kd_input",
          "args": [
            "*str"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic void kbd_input_string;\n\nvoid\nkbd_input_string(k, str)\n\tstruct kbd_softc *k;\n\tchar *str;\n{\n\twhile (*str) {\n\t\tkd_input(*str);\n\t\tstr++;\n\t}\n}"
  },
  {
    "function_name": "kbd_code_to_keysym",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "680-730",
    "snippet": "int\nkbd_code_to_keysym(ks, c)\n\tregister struct kbd_state *ks;\n\tregister int c;\n{\n\tu_short *km;\n\tint keysym;\n\n\t/*\n\t * Get keymap pointer.  One of these:\n\t * release, control, shifted, normal, ...\n\t */\n\tif (KEY_UP(c))\n\t\tkm = ks->kbd_k.k_release;\n\telse if (ks->kbd_modbits & KBMOD_CTRL_MASK)\n\t\tkm = ks->kbd_k.k_control;\n\telse if (ks->kbd_modbits & KBMOD_SHIFT_MASK)\n\t\tkm = ks->kbd_k.k_shifted;\n\telse\n\t\tkm = ks->kbd_k.k_normal;\n\n\tif (km == NULL) {\n\t\t/*\n\t\t * Do not know how to translate yet.\n\t\t * We will find out when a RESET comes along.\n\t\t */\n\t\treturn (KEYSYM_NOP);\n\t}\n\tkeysym = km[KEY_CODE(c)];\n\n\t/*\n\t * Post-processing for Caps-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_CAPSLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_ASCII) )\n\t{\n\t\tif (('a' <= keysym) && (keysym <= 'z'))\n\t\t\tkeysym -= ('a' - 'A');\n\t}\n\n\t/*\n\t * Post-processing for Num-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_NUMLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_FUNC) )\n\t{\n\t\tkeysym = kbd_numlock_map[keysym & 0x3F];\n\t}\n\n\treturn (keysym);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_output(struct kbd_softc *k, int c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KEYSYM_CLASS",
          "args": [
            "keysym"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KEYSYM_CLASS",
          "args": [
            "keysym"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KEY_CODE",
          "args": [
            "c"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KEY_UP",
          "args": [
            "c"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_output(struct kbd_softc *k, int c);\n\nint\nkbd_code_to_keysym(ks, c)\n\tregister struct kbd_state *ks;\n\tregister int c;\n{\n\tu_short *km;\n\tint keysym;\n\n\t/*\n\t * Get keymap pointer.  One of these:\n\t * release, control, shifted, normal, ...\n\t */\n\tif (KEY_UP(c))\n\t\tkm = ks->kbd_k.k_release;\n\telse if (ks->kbd_modbits & KBMOD_CTRL_MASK)\n\t\tkm = ks->kbd_k.k_control;\n\telse if (ks->kbd_modbits & KBMOD_SHIFT_MASK)\n\t\tkm = ks->kbd_k.k_shifted;\n\telse\n\t\tkm = ks->kbd_k.k_normal;\n\n\tif (km == NULL) {\n\t\t/*\n\t\t * Do not know how to translate yet.\n\t\t * We will find out when a RESET comes along.\n\t\t */\n\t\treturn (KEYSYM_NOP);\n\t}\n\tkeysym = km[KEY_CODE(c)];\n\n\t/*\n\t * Post-processing for Caps-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_CAPSLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_ASCII) )\n\t{\n\t\tif (('a' <= keysym) && (keysym <= 'z'))\n\t\t\tkeysym -= ('a' - 'A');\n\t}\n\n\t/*\n\t * Post-processing for Num-lock\n\t */\n\tif ((ks->kbd_modbits & (1 << KBMOD_NUMLOCK)) &&\n\t\t(KEYSYM_CLASS(keysym) == KEYSYM_FUNC) )\n\t{\n\t\tkeysym = kbd_numlock_map[keysym & 0x3F];\n\t}\n\n\treturn (keysym);\n}"
  },
  {
    "function_name": "kbd_xlate_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "658-674",
    "snippet": "void\nkbd_xlate_init(ks)\n\tstruct kbd_state *ks;\n{\n\tstruct keyboard *ktbls;\n\tint id;\n\n\tid = ks->kbd_id;\n\tif (id < KBD_MIN_TYPE)\n\t\tid = KBD_MIN_TYPE;\n\tif (id > kbd_max_type)\n\t\tid = kbd_max_type;\n\tktbls = keyboards[id];\n\n\tks->kbd_k = *ktbls; \t/* struct assignment */\n\tks->kbd_modbits = 0;\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nkbd_xlate_init(ks)\n\tstruct kbd_state *ks;\n{\n\tstruct keyboard *ktbls;\n\tint id;\n\n\tid = ks->kbd_id;\n\tif (id < KBD_MIN_TYPE)\n\t\tid = KBD_MIN_TYPE;\n\tif (id > kbd_max_type)\n\t\tid = kbd_max_type;\n\tktbls = keyboards[id];\n\n\tks->kbd_k = *ktbls; \t/* struct assignment */\n\tks->kbd_modbits = 0;\n}"
  },
  {
    "function_name": "kbd_iocsled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "624-641",
    "snippet": "static int\nkbd_iocsled(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tint leds, error, s;\n\n\tleds = *data;\n\n\ts = spltty();\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_set_leds(k, leds);\n\t}\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_set_leds(struct kbd_softc *k, int leds);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
      "static int kbd_iocsled(struct kbd_softc *k, int *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbd_set_leds",
          "args": [
            "k",
            "leds"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_set_leds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1386-1406",
          "snippet": "static void\nkbd_set_leds(k, new_leds)\n\tstruct kbd_softc *k;\n\tint new_leds;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/* Don't send unless state changes. */\n\tif (ks->kbd_leds == new_leds)\n\t\treturn;\n\n\tks->kbd_leds = new_leds;\n\n\t/* Only type 4 and later has LEDs anyway. */\n\tif (ks->kbd_id < 4)\n\t\treturn;\n\n\tkbd_output(k, KBD_CMD_SETLED);\n\tkbd_output(k, new_leds);\n\tkbd_start_tx(k);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_set_leds(k, new_leds)\n\tstruct kbd_softc *k;\n\tint new_leds;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\n\t/* Don't send unless state changes. */\n\tif (ks->kbd_leds == new_leds)\n\t\treturn;\n\n\tks->kbd_leds = new_leds;\n\n\t/* Only type 4 and later has LEDs anyway. */\n\tif (ks->kbd_id < 4)\n\t\treturn;\n\n\tkbd_output(k, KBD_CMD_SETLED);\n\tkbd_output(k, new_leds);\n\tkbd_start_tx(k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_drain_tx",
          "args": [
            "k"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_drain_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1302-1317",
          "snippet": "static int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_set_leds(struct kbd_softc *k, int leds);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic int\nkbd_iocsled(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tint leds, error, s;\n\n\tleds = *data;\n\n\ts = spltty();\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_set_leds(k, leds);\n\t}\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "kbd_ioccmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "580-619",
    "snippet": "static int\nkbd_ioccmd(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tint cmd, error, s;\n\n\tcmd = *data;\n\tswitch (cmd) {\n\n\tcase KBD_CMD_BELL:\n\tcase KBD_CMD_NOBELL:\n\t\t/* Supported by type 2, 3, and 4 keyboards */\n\t\tbreak;\n\n\tcase KBD_CMD_CLICK:\n\tcase KBD_CMD_NOCLICK:\n\t\t/* Unsupported by type 2 keyboards */\n\t\tif (ks->kbd_id <= KB_SUN2)\n\t\t\treturn (0);\n\t\tks->kbd_click = (cmd == KBD_CMD_CLICK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\ts = spltty();\n\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_output(k, cmd);\n\t\tkbd_start_tx(k);\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
      "static int kbd_iocsled(struct kbd_softc *k, int *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbd_start_tx",
          "args": [
            "k"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_start_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1348-1380",
          "snippet": "static void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1",
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic void\nkbd_start_tx(k)\n    struct kbd_softc *k;\n{\n\tstruct zs_chanstate *cs = k->k_cs;\n\tint get, s;\n\tu_char c;\n\n\tif (k->k_txflags & K_TXBUSY)\n\t\treturn;\n\n\t/* Is there anything to send? */\n\tget = k->k_tbget;\n\tif (get == k->k_tbput) {\n\t\t/* Nothing to send.  Wake drain waiters. */\n\t\tif (k->k_txflags & K_TXWANT) {\n\t\t\tk->k_txflags &= ~K_TXWANT;\n\t\t\twakeup((caddr_t)&k->k_txflags);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Have something to send. */\n\tc = k->k_tbuf[get];\n\tget = (get + 1) & KBD_TX_RING_MASK;\n\tk->k_tbget = get;\n\tk->k_txflags |= K_TXBUSY;\n\n\t/* Need splzs to avoid interruption of the delay. */\n\ts = splzs();\n\tzs_write_data(cs, c);\n\tsplx(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_output",
          "args": [
            "k",
            "cmd"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1323-1342",
          "snippet": "static void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_output(struct kbd_softc *k, int c);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define KBD_TX_RING_MASK (KBD_TX_RING_SIZE-1)\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_output(struct kbd_softc *k, int c);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic void\nkbd_output(k, c)\n\tstruct kbd_softc *k;\n\tint c;\t/* the data */\n{\n\tint put;\n\n\tput = k->k_tbput;\n\tk->k_tbuf[put] = (u_char)c;\n\tput = (put + 1) & KBD_TX_RING_MASK;\n\n\t/* Would overrun if increment makes (put==get). */\n\tif (put == k->k_tbget) {\n\t\tlog(LOG_WARNING, \"%s: output overrun\\n\",\n            k->k_dev.dv_xname);\n\t} else {\n\t\t/* OK, really increment. */\n\t\tk->k_tbput = put;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_drain_tx",
          "args": [
            "k"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_drain_tx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1302-1317",
          "snippet": "static int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define K_TXWANT 2",
            "#define\tK_TXBUSY 1"
          ],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define K_TXWANT 2\n#define\tK_TXBUSY 1\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\n\nstatic int\nkbd_drain_tx(k)\n\tstruct kbd_softc *k;\n{\n\tint error;\n\n\terror = 0;\n\n\twhile (k->k_txflags & K_TXBUSY) {\n\t\tk->k_txflags |= K_TXWANT;\n\t\terror = tsleep((caddr_t)&k->k_txflags,\n\t\t\t\t\t   PZERO | PCATCH, \"kbdout\", 0);\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spltty",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic int\nkbd_ioccmd(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tint cmd, error, s;\n\n\tcmd = *data;\n\tswitch (cmd) {\n\n\tcase KBD_CMD_BELL:\n\tcase KBD_CMD_NOBELL:\n\t\t/* Supported by type 2, 3, and 4 keyboards */\n\t\tbreak;\n\n\tcase KBD_CMD_CLICK:\n\tcase KBD_CMD_NOCLICK:\n\t\t/* Unsupported by type 2 keyboards */\n\t\tif (ks->kbd_id <= KB_SUN2)\n\t\t\treturn (0);\n\t\tks->kbd_click = (cmd == KBD_CMD_CLICK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\ts = spltty();\n\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_output(k, cmd);\n\t\tkbd_start_tx(k);\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}"
  },
  {
    "function_name": "kbd_oldkeymap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "543-572",
    "snippet": "int\nkbd_oldkeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct okiockey *kio;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\n\tcase KIOCGETKEY:\n\t\tif (kio->kio_station == 118) {\n\t\t\t/*\n\t\t\t * This is X11 asking if a type 3 keyboard is\n\t\t\t * really a type 3 keyboard.  Say yes, it is,\n\t\t\t * by reporting key station 118 as a \"hole\".\n\t\t\t * Note old (SunOS 3.5) definition of HOLE!\n\t\t\t */\n\t\t\tkio->kio_entry = 0xA2;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nkbd_oldkeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct okiockey *kio;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\n\tcase KIOCGETKEY:\n\t\tif (kio->kio_station == 118) {\n\t\t\t/*\n\t\t\t * This is X11 asking if a type 3 keyboard is\n\t\t\t * really a type 3 keyboard.  Say yes, it is,\n\t\t\t * by reporting key station 118 as a \"hole\".\n\t\t\t * Note old (SunOS 3.5) definition of HOLE!\n\t\t\t */\n\t\t\tkio->kio_entry = 0xA2;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "kbd_iockeymap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "490-536",
    "snippet": "static int\nkbd_iockeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct kiockeymap *kio;\n{\n\tu_short *km;\n\tu_int station;\n\n\tswitch (kio->kio_tablemask) {\n\tcase KIOC_NOMASK:\n\t\tkm = ks->kbd_k.k_normal;\n\t\tbreak;\n\tcase KIOC_SHIFTMASK:\n\t\tkm = ks->kbd_k.k_shifted;\n\t\tbreak;\n\tcase KIOC_CTRLMASK:\n\t\tkm = ks->kbd_k.k_control;\n\t\tbreak;\n\tcase KIOC_UPMASK:\n\t\tkm = ks->kbd_k.k_release;\n\t\tbreak;\n\tdefault:\n\t\t/* Silently ignore unsupported masks */\n\t\treturn (0);\n\t}\n\n\t/* Range-check the table position. */\n\tstation = kio->kio_station;\n\tif (station >= KEYMAP_SIZE)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n\n\tcase KIOCGKEY:\t/* Get keymap entry */\n\t\tkio->kio_entry = km[station];\n\t\tbreak;\n\n\tcase KIOCSKEY:\t/* Set keymap entry */\n\t\tkm[station] = kio->kio_entry;\n\t\tbreak;\n\n\tdefault:\n\t\treturn(ENOTTY);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kbd_iockeymap"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int kbd_iockeymap;\n\nstatic int\nkbd_iockeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct kiockeymap *kio;\n{\n\tu_short *km;\n\tu_int station;\n\n\tswitch (kio->kio_tablemask) {\n\tcase KIOC_NOMASK:\n\t\tkm = ks->kbd_k.k_normal;\n\t\tbreak;\n\tcase KIOC_SHIFTMASK:\n\t\tkm = ks->kbd_k.k_shifted;\n\t\tbreak;\n\tcase KIOC_CTRLMASK:\n\t\tkm = ks->kbd_k.k_control;\n\t\tbreak;\n\tcase KIOC_UPMASK:\n\t\tkm = ks->kbd_k.k_release;\n\t\tbreak;\n\tdefault:\n\t\t/* Silently ignore unsupported masks */\n\t\treturn (0);\n\t}\n\n\t/* Range-check the table position. */\n\tstation = kio->kio_station;\n\tif (station >= KEYMAP_SIZE)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n\n\tcase KIOCGKEY:\t/* Get keymap entry */\n\t\tkio->kio_entry = km[station];\n\t\tbreak;\n\n\tcase KIOCSKEY:\t/* Set keymap entry */\n\t\tkm[station] = kio->kio_entry;\n\t\tbreak;\n\n\tdefault:\n\t\treturn(ENOTTY);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "kbdioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "393-481",
    "snippet": "int\nkbdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tregister caddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\tstruct kbd_state *ks;\n\tint *ip;\n\tint error = 0;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\tks = &k->k_state;\n\n\tswitch (cmd) {\n\n\tcase KIOCTRANS: \t/* Set translation mode */\n\t\tip = (int *)data;\n\t\t/* We only support \"raw\" mode on /dev/kbd */\n\t\tif (*ip != TR_UNTRANS_EVENT)\n\t\t\terror = EINVAL;\n\t\tbreak;\n\n\tcase KIOCGTRANS:\t/* Get translation mode */\n\t\tip = (int *)data;\n\t\t/* We only support \"raw\" mode on /dev/kbd */\n\t\t*ip = TR_UNTRANS_EVENT;\n\t\tbreak;\n\n#ifdef\tKIOCGETKEY\n\tcase KIOCGETKEY:\t/* Get keymap entry (old format) */\n\t\terror = kbd_oldkeymap(ks, cmd, (struct okiockey *)data);\n\t\tbreak;\n#endif\tKIOCGETKEY */\n\n\tcase KIOCSKEY:  \t/* Set keymap entry */\n\t\t/* Don't let just anyone hose the keyboard. */\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\t/* fallthrough */\n\tcase KIOCGKEY:  \t/* Get keymap entry */\n\t\terror = kbd_iockeymap(ks, cmd, (struct kiockeymap *)data);\n\t\tbreak;\n\n\tcase KIOCCMD:\t/* Send a command to the keyboard */\n\t\terror = kbd_ioccmd(k, (int *)data);\n\t\tbreak;\n\n\tcase KIOCTYPE:\t/* Get keyboard type */\n\t\tip = (int *)data;\n\t\t*ip = ks->kbd_id;\n\t\tbreak;\n\n\tcase KIOCSDIRECT:\t/* where to send input */\n\t\tip = (int *)data;\n\t\tk->k_evmode = *ip;\n\t\tbreak;\n\n\tcase KIOCLAYOUT:\t/* Get keyboard layout */\n\t\t*data = ks->kbd_layout;\n\t\tbreak;\n\n\tcase KIOCSLED:\n\t\terror = kbd_iocsled(k, (int *)data);\n\t\tbreak;\n\n\tcase KIOCGLED:\n\t\t*(char *)data = ks->kbd_leds;\n\t\tbreak;\n\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tk->k_events.ev_async = *(int *)data != 0;\n\t\tbreak;\n\n\tcase TIOCSPGRP:\n\t\tip = (int *)data;\n\t\tif (*ip != k->k_events.ev_io->p_pgid)\n\t\t\terror = EPERM;\n\t\tbreak;\n\n\t}\n\n\treturn (error);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "struct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};",
      "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
      "static int kbd_iockeymap",
      "static int kbd_iocsled(struct kbd_softc *k, int *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kbd_iocsled",
          "args": [
            "k",
            "(int *)data"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_iocsled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "624-641",
          "snippet": "static int\nkbd_iocsled(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tint leds, error, s;\n\n\tleds = *data;\n\n\ts = spltty();\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_set_leds(k, leds);\n\t}\n\tsplx(s);\n\n\treturn (error);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_set_leds(struct kbd_softc *k, int leds);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_set_leds(struct kbd_softc *k, int leds);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic int\nkbd_iocsled(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tint leds, error, s;\n\n\tleds = *data;\n\n\ts = spltty();\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_set_leds(k, leds);\n\t}\n\tsplx(s);\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_ioccmd",
          "args": [
            "k",
            "(int *)data"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_ioccmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "580-619",
          "snippet": "static int\nkbd_ioccmd(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tint cmd, error, s;\n\n\tcmd = *data;\n\tswitch (cmd) {\n\n\tcase KBD_CMD_BELL:\n\tcase KBD_CMD_NOBELL:\n\t\t/* Supported by type 2, 3, and 4 keyboards */\n\t\tbreak;\n\n\tcase KBD_CMD_CLICK:\n\tcase KBD_CMD_NOCLICK:\n\t\t/* Unsupported by type 2 keyboards */\n\t\tif (ks->kbd_id <= KB_SUN2)\n\t\t\treturn (0);\n\t\tks->kbd_click = (cmd == KBD_CMD_CLICK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\ts = spltty();\n\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_output(k, cmd);\n\t\tkbd_start_tx(k);\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "static int kbd_ioccmd(struct kbd_softc *k, int *data);",
            "static int kbd_iocsled(struct kbd_softc *k, int *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nstatic int\nkbd_ioccmd(k, data)\n\tstruct kbd_softc *k;\n\tint *data;\n{\n\tstruct kbd_state *ks = &k->k_state;\n\tint cmd, error, s;\n\n\tcmd = *data;\n\tswitch (cmd) {\n\n\tcase KBD_CMD_BELL:\n\tcase KBD_CMD_NOBELL:\n\t\t/* Supported by type 2, 3, and 4 keyboards */\n\t\tbreak;\n\n\tcase KBD_CMD_CLICK:\n\tcase KBD_CMD_NOCLICK:\n\t\t/* Unsupported by type 2 keyboards */\n\t\tif (ks->kbd_id <= KB_SUN2)\n\t\t\treturn (0);\n\t\tks->kbd_click = (cmd == KBD_CMD_CLICK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn (0);\n\t}\n\n\ts = spltty();\n\n\terror = kbd_drain_tx(k);\n\tif (error == 0) {\n\t\tkbd_output(k, cmd);\n\t\tkbd_start_tx(k);\n\t}\n\n\tsplx(s);\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_iockeymap",
          "args": [
            "ks",
            "cmd",
            "(struct kiockeymap *)data"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_iockeymap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "490-536",
          "snippet": "static int\nkbd_iockeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct kiockeymap *kio;\n{\n\tu_short *km;\n\tu_int station;\n\n\tswitch (kio->kio_tablemask) {\n\tcase KIOC_NOMASK:\n\t\tkm = ks->kbd_k.k_normal;\n\t\tbreak;\n\tcase KIOC_SHIFTMASK:\n\t\tkm = ks->kbd_k.k_shifted;\n\t\tbreak;\n\tcase KIOC_CTRLMASK:\n\t\tkm = ks->kbd_k.k_control;\n\t\tbreak;\n\tcase KIOC_UPMASK:\n\t\tkm = ks->kbd_k.k_release;\n\t\tbreak;\n\tdefault:\n\t\t/* Silently ignore unsupported masks */\n\t\treturn (0);\n\t}\n\n\t/* Range-check the table position. */\n\tstation = kio->kio_station;\n\tif (station >= KEYMAP_SIZE)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n\n\tcase KIOCGKEY:\t/* Get keymap entry */\n\t\tkio->kio_entry = km[station];\n\t\tbreak;\n\n\tcase KIOCSKEY:\t/* Set keymap entry */\n\t\tkm[station] = kio->kio_entry;\n\t\tbreak;\n\n\tdefault:\n\t\treturn(ENOTTY);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kbd_iockeymap"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int kbd_iockeymap;\n\nstatic int\nkbd_iockeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct kiockeymap *kio;\n{\n\tu_short *km;\n\tu_int station;\n\n\tswitch (kio->kio_tablemask) {\n\tcase KIOC_NOMASK:\n\t\tkm = ks->kbd_k.k_normal;\n\t\tbreak;\n\tcase KIOC_SHIFTMASK:\n\t\tkm = ks->kbd_k.k_shifted;\n\t\tbreak;\n\tcase KIOC_CTRLMASK:\n\t\tkm = ks->kbd_k.k_control;\n\t\tbreak;\n\tcase KIOC_UPMASK:\n\t\tkm = ks->kbd_k.k_release;\n\t\tbreak;\n\tdefault:\n\t\t/* Silently ignore unsupported masks */\n\t\treturn (0);\n\t}\n\n\t/* Range-check the table position. */\n\tstation = kio->kio_station;\n\tif (station >= KEYMAP_SIZE)\n\t\treturn (EINVAL);\n\n\tswitch (cmd) {\n\n\tcase KIOCGKEY:\t/* Get keymap entry */\n\t\tkio->kio_entry = km[station];\n\t\tbreak;\n\n\tcase KIOCSKEY:\t/* Set keymap entry */\n\t\tkm[station] = kio->kio_entry;\n\t\tbreak;\n\n\tdefault:\n\t\treturn(ENOTTY);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "suser",
          "args": [
            "p->p_ucred",
            "&p->p_acflag"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbd_oldkeymap",
          "args": [
            "ks",
            "cmd",
            "(struct okiockey *)data"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_oldkeymap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "543-572",
          "snippet": "int\nkbd_oldkeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct okiockey *kio;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\n\tcase KIOCGETKEY:\n\t\tif (kio->kio_station == 118) {\n\t\t\t/*\n\t\t\t * This is X11 asking if a type 3 keyboard is\n\t\t\t * really a type 3 keyboard.  Say yes, it is,\n\t\t\t * by reporting key station 118 as a \"hole\".\n\t\t\t * Note old (SunOS 3.5) definition of HOLE!\n\t\t\t */\n\t\t\tkio->kio_entry = 0xA2;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn (error);\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nkbd_oldkeymap(ks, cmd, kio)\n\tstruct kbd_state *ks;\n\tu_long cmd;\n\tstruct okiockey *kio;\n{\n\tint error = 0;\n\n\tswitch (cmd) {\n\n\tcase KIOCGETKEY:\n\t\tif (kio->kio_station == 118) {\n\t\t\t/*\n\t\t\t * This is X11 asking if a type 3 keyboard is\n\t\t\t * really a type 3 keyboard.  Say yes, it is,\n\t\t\t * by reporting key station 118 as a \"hole\".\n\t\t\t * Note old (SunOS 3.5) definition of HOLE!\n\t\t\t */\n\t\t\tkio->kio_entry = 0xA2;\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\n\tdefault:\n\t\terror = ENOTTY;\n\t\tbreak;\n\t}\n\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};\nstatic int kbd_ioccmd(struct kbd_softc *k, int *data);\nstatic int kbd_iockeymap;\nstatic int kbd_iocsled(struct kbd_softc *k, int *data);\n\nint\nkbdioctl(dev, cmd, data, flag, p)\n\tdev_t dev;\n\tu_long cmd;\n\tregister caddr_t data;\n\tint flag;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\tstruct kbd_state *ks;\n\tint *ip;\n\tint error = 0;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\tks = &k->k_state;\n\n\tswitch (cmd) {\n\n\tcase KIOCTRANS: \t/* Set translation mode */\n\t\tip = (int *)data;\n\t\t/* We only support \"raw\" mode on /dev/kbd */\n\t\tif (*ip != TR_UNTRANS_EVENT)\n\t\t\terror = EINVAL;\n\t\tbreak;\n\n\tcase KIOCGTRANS:\t/* Get translation mode */\n\t\tip = (int *)data;\n\t\t/* We only support \"raw\" mode on /dev/kbd */\n\t\t*ip = TR_UNTRANS_EVENT;\n\t\tbreak;\n\n#ifdef\tKIOCGETKEY\n\tcase KIOCGETKEY:\t/* Get keymap entry (old format) */\n\t\terror = kbd_oldkeymap(ks, cmd, (struct okiockey *)data);\n\t\tbreak;\n#endif\tKIOCGETKEY */\n\n\tcase KIOCSKEY:  \t/* Set keymap entry */\n\t\t/* Don't let just anyone hose the keyboard. */\n\t\tif ((error = suser(p->p_ucred, &p->p_acflag)) != 0)\n\t\t\treturn (error);\n\t\t/* fallthrough */\n\tcase KIOCGKEY:  \t/* Get keymap entry */\n\t\terror = kbd_iockeymap(ks, cmd, (struct kiockeymap *)data);\n\t\tbreak;\n\n\tcase KIOCCMD:\t/* Send a command to the keyboard */\n\t\terror = kbd_ioccmd(k, (int *)data);\n\t\tbreak;\n\n\tcase KIOCTYPE:\t/* Get keyboard type */\n\t\tip = (int *)data;\n\t\t*ip = ks->kbd_id;\n\t\tbreak;\n\n\tcase KIOCSDIRECT:\t/* where to send input */\n\t\tip = (int *)data;\n\t\tk->k_evmode = *ip;\n\t\tbreak;\n\n\tcase KIOCLAYOUT:\t/* Get keyboard layout */\n\t\t*data = ks->kbd_layout;\n\t\tbreak;\n\n\tcase KIOCSLED:\n\t\terror = kbd_iocsled(k, (int *)data);\n\t\tbreak;\n\n\tcase KIOCGLED:\n\t\t*(char *)data = ks->kbd_leds;\n\t\tbreak;\n\n\tcase FIONBIO:\t\t/* we will remove this someday (soon???) */\n\t\tbreak;\n\n\tcase FIOASYNC:\n\t\tk->k_events.ev_async = *(int *)data != 0;\n\t\tbreak;\n\n\tcase TIOCSPGRP:\n\t\tip = (int *)data;\n\t\tif (*ip != k->k_events.ev_io->p_pgid)\n\t\t\terror = EPERM;\n\t\tbreak;\n\n\t}\n\n\treturn (error);\n}"
  },
  {
    "function_name": "kbdselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "369-379",
    "snippet": "int\nkbdselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\treturn (ev_select(&k->k_events, rw, p));\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "struct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev_select",
          "args": [
            "&k->k_events",
            "rw",
            "p"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ev_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "148-173",
          "snippet": "int\nev_select(ev, rw, p)\n\tregister struct evvar *ev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint s = splev();\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\t/* succeed if there is something to read */\n\t\tif (ev->ev_get != ev->ev_put) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &ev->ev_sel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tsplx(s);\n\t\treturn (1);\t/* always fails => never blocks */\n\t}\n\tsplx(s);\n\treturn (0);\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nint\nev_select(ev, rw, p)\n\tregister struct evvar *ev;\n\tint rw;\n\tstruct proc *p;\n{\n\tint s = splev();\n\n\tswitch (rw) {\n\n\tcase FREAD:\n\t\t/* succeed if there is something to read */\n\t\tif (ev->ev_get != ev->ev_put) {\n\t\t\tsplx(s);\n\t\t\treturn (1);\n\t\t}\n\t\tselrecord(p, &ev->ev_sel);\n\t\tbreak;\n\n\tcase FWRITE:\n\t\tsplx(s);\n\t\treturn (1);\t/* always fails => never blocks */\n\t}\n\tsplx(s);\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};\n\nint\nkbdselect(dev, rw, p)\n\tdev_t dev;\n\tint rw;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\treturn (ev_select(&k->k_events, rw, p));\n}"
  },
  {
    "function_name": "kbdwrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "359-367",
    "snippet": "int\nkbdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (EOPNOTSUPP);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nint\nkbdwrite(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\n\treturn (EOPNOTSUPP);\n}"
  },
  {
    "function_name": "kbdread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "346-356",
    "snippet": "int\nkbdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct kbd_softc *k;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\treturn (ev_read(&k->k_events, uio, flags));\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "struct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev_read",
          "args": [
            "&k->k_events",
            "uio",
            "flags"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ev_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "91-146",
          "snippet": "int\nev_read(ev, uio, flags)\n\tregister struct evvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct firm_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splev();\n\twhile (ev->ev_get == ev->ev_put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->ev_wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PEVENT | PCATCH, \"firm_event\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move firm_events from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->ev_put < ev->ev_get)\n\t\tcnt = EV_QSIZE - ev->ev_get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->ev_put - ev->ev_get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct firm_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[ev->ev_get],\n\t    cnt * sizeof(struct firm_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->ev_get = (ev->ev_get + cnt) % EV_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->ev_put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[0],\n\t    cnt * sizeof(struct firm_event), uio);\n\tev->ev_get = cnt;\n\treturn (error);\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nint\nev_read(ev, uio, flags)\n\tregister struct evvar *ev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tint s, n, cnt, error;\n\n\t/*\n\t * Make sure we can return at least 1.\n\t */\n\tif (uio->uio_resid < sizeof(struct firm_event))\n\t\treturn (EMSGSIZE);\t/* ??? */\n\ts = splev();\n\twhile (ev->ev_get == ev->ev_put) {\n\t\tif (flags & IO_NDELAY) {\n\t\t\tsplx(s);\n\t\t\treturn (EWOULDBLOCK);\n\t\t}\n\t\tev->ev_wanted = 1;\n\t\terror = tsleep((caddr_t)ev, PEVENT | PCATCH, \"firm_event\", 0);\n\t\tif (error) {\n\t\t\tsplx(s);\n\t\t\treturn (error);\n\t\t}\n\t}\n\t/*\n\t * Move firm_events from tail end of queue (there is at least one\n\t * there).\n\t */\n\tif (ev->ev_put < ev->ev_get)\n\t\tcnt = EV_QSIZE - ev->ev_get;\t/* events in [get..QSIZE) */\n\telse\n\t\tcnt = ev->ev_put - ev->ev_get;\t/* events in [get..put) */\n\tsplx(s);\n\tn = howmany(uio->uio_resid, sizeof(struct firm_event));\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[ev->ev_get],\n\t    cnt * sizeof(struct firm_event), uio);\n\tn -= cnt;\n\t/*\n\t * If we do not wrap to 0, used up all our space, or had an error,\n\t * stop.  Otherwise move from front of queue to put index, if there\n\t * is anything there to move.\n\t */\n\tif ((ev->ev_get = (ev->ev_get + cnt) % EV_QSIZE) != 0 ||\n\t    n == 0 || error || (cnt = ev->ev_put) == 0)\n\t\treturn (error);\n\tif (cnt > n)\n\t\tcnt = n;\n\terror = uiomove((caddr_t)&ev->ev_q[0],\n\t    cnt * sizeof(struct firm_event), uio);\n\tev->ev_get = cnt;\n\treturn (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};\n\nint\nkbdread(dev, uio, flags)\n\tdev_t dev;\n\tstruct uio *uio;\n\tint flags;\n{\n\tstruct kbd_softc *k;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\treturn (ev_read(&k->k_events, uio, flags));\n}"
  },
  {
    "function_name": "kbdclose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "331-344",
    "snippet": "int\nkbdclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\tk->k_evmode = 0;\n\tev_fini(&k->k_events);\n\tk->k_events.ev_io = NULL;\n\treturn (0);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "struct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ev_fini",
          "args": [
            "&k->k_events"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ev_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "79-85",
          "snippet": "void\nev_fini(ev)\n\tregister struct evvar *ev;\n{\n\n\tfree(ev->ev_q, M_DEVBUF);\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nvoid\nev_fini(ev)\n\tregister struct evvar *ev;\n{\n\n\tfree(ev->ev_q, M_DEVBUF);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};\n\nint\nkbdclose(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\n\tk = kbd_cd.cd_devs[minor(dev)];\n\tk->k_evmode = 0;\n\tev_fini(&k->k_events);\n\tk->k_events.ev_io = NULL;\n\treturn (0);\n}"
  },
  {
    "function_name": "kbdopen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "290-324",
    "snippet": "int\nkbdopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\tint error, unit;\n\n\tunit = minor(dev);\n\tif (unit >= kbd_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tk = kbd_cd.cd_devs[unit];\n\tif (k == NULL)\n\t\treturn (ENXIO);\n\n\t/* Exclusive open required for /dev/kbd */\n\tif (k->k_events.ev_io)\n\t\treturn (EBUSY);\n\tk->k_events.ev_io = p;\n\n\tif ((error = kbd_iopen(unit)) != 0) {\n\t\tk->k_events.ev_io = NULL;\n\t\treturn (error);\n\t}\n\tev_init(&k->k_events);\n\tk->k_evmode = 1;\t/* XXX: OK? */\n\n\tif (k->k_repeating) {\n\t\tk->k_repeating = 0;\n\t\tuntimeout(kbd_repeat, k);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "struct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "untimeout",
          "args": [
            "kbd_repeat",
            "k"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ev_init",
          "args": [
            "&k->k_events"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/event.c",
          "lines": "65-74",
          "snippet": "void\nev_init(ev)\n\tregister struct evvar *ev;\n{\n\n\tev->ev_get = ev->ev_put = 0;\n\tev->ev_q = malloc((u_long)EV_QSIZE * sizeof(struct firm_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->ev_q, EV_QSIZE * sizeof(struct firm_event));\n}",
          "includes": [
            "#include <dev/sun/event_var.h>",
            "#include <machine/vuid_event.h>",
            "#include <sys/vnode.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/sun/event_var.h>\n#include <machine/vuid_event.h>\n#include <sys/vnode.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/fcntl.h>\n#include <sys/param.h>\n\nvoid\nev_init(ev)\n\tregister struct evvar *ev;\n{\n\n\tev->ev_get = ev->ev_put = 0;\n\tev->ev_q = malloc((u_long)EV_QSIZE * sizeof(struct firm_event),\n\t    M_DEVBUF, M_WAITOK);\n\tbzero((caddr_t)ev->ev_q, EV_QSIZE * sizeof(struct firm_event));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbd_iopen",
          "args": [
            "unit"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_iopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "1167-1232",
          "snippet": "int\nkbd_iopen(unit)\n\tint unit;\n{\n\tstruct kbd_softc *k;\n\tstruct kbd_state *ks;\n\tint error, s;\n\n\tif (unit >= kbd_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tk = kbd_cd.cd_devs[unit];\n\tif (k == NULL)\n\t\treturn (ENXIO);\n\tks = &k->k_state;\n\terror = 0;\n\n\t/* Tolerate extra calls. */\n\tif (k->k_isopen)\n\t\treturn (error);\n\n\ts = spltty();\n\n\t/* Reset the keyboard and find out its type. */\n\tkbd_output(k, KBD_CMD_RESET);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_was_reset(). */\n\terror = tsleep((caddr_t)&ks->kbd_id,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: reset failed\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\t/*\n\t\t * Allow the open anyway (to keep getty happy)\n\t\t * but assume the \"least common denominator\".\n\t\t */\n\t\tks->kbd_id = KB_SUN2;\n\t}\n\n\t/* Earlier than type 4 does not know \"layout\". */\n\tif (ks->kbd_id < KB_SUN4)\n\t\tgoto out;\n\n\t/* Ask for the layout. */\n\tkbd_output(k, KBD_CMD_GETLAYOUT);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_new_layout(). */\n\terror = tsleep((caddr_t)&ks->kbd_layout,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: no response to get_layout\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\tks->kbd_layout = 0;\n\t}\n\nout:\n\tsplx(s);\n\n\tif (error == 0)\n\t\tk->k_isopen = 1;\n\n\treturn error;\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\tkbd_new_layout(struct kbd_softc *k);",
            "static void\tkbd_start_tx(struct kbd_softc *k);",
            "static void\tkbd_update_leds(struct kbd_softc *k);",
            "static void\tkbd_was_reset(struct kbd_softc *k);",
            "static int \tkbd_drain_tx(struct kbd_softc *k);",
            "struct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};\n\nint\nkbd_iopen(unit)\n\tint unit;\n{\n\tstruct kbd_softc *k;\n\tstruct kbd_state *ks;\n\tint error, s;\n\n\tif (unit >= kbd_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tk = kbd_cd.cd_devs[unit];\n\tif (k == NULL)\n\t\treturn (ENXIO);\n\tks = &k->k_state;\n\terror = 0;\n\n\t/* Tolerate extra calls. */\n\tif (k->k_isopen)\n\t\treturn (error);\n\n\ts = spltty();\n\n\t/* Reset the keyboard and find out its type. */\n\tkbd_output(k, KBD_CMD_RESET);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_was_reset(). */\n\terror = tsleep((caddr_t)&ks->kbd_id,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: reset failed\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\t/*\n\t\t * Allow the open anyway (to keep getty happy)\n\t\t * but assume the \"least common denominator\".\n\t\t */\n\t\tks->kbd_id = KB_SUN2;\n\t}\n\n\t/* Earlier than type 4 does not know \"layout\". */\n\tif (ks->kbd_id < KB_SUN4)\n\t\tgoto out;\n\n\t/* Ask for the layout. */\n\tkbd_output(k, KBD_CMD_GETLAYOUT);\n\tkbd_start_tx(k);\n\tkbd_drain_tx(k);\n\t/* The wakeup for this is in kbd_new_layout(). */\n\terror = tsleep((caddr_t)&ks->kbd_layout,\n\t\t\t\t   PZERO | PCATCH, devopn, hz);\n\tif (error == EWOULDBLOCK) { \t/* no response */\n\t\terror = 0;\n\t\tlog(LOG_ERR, \"%s: no response to get_layout\\n\",\n\t\t\tk->k_dev.dv_xname);\n\t\tks->kbd_layout = 0;\n\t}\n\nout:\n\tsplx(s);\n\n\tif (error == 0)\n\t\tk->k_isopen = 1;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minor",
          "args": [
            "dev"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct cfdriver kbd_cd = {\n\tNULL, \"kbd\", DV_DULL\n};\n\nint\nkbdopen(dev, flags, mode, p)\n\tdev_t dev;\n\tint flags, mode;\n\tstruct proc *p;\n{\n\tstruct kbd_softc *k;\n\tint error, unit;\n\n\tunit = minor(dev);\n\tif (unit >= kbd_cd.cd_ndevs)\n\t\treturn (ENXIO);\n\tk = kbd_cd.cd_devs[unit];\n\tif (k == NULL)\n\t\treturn (ENXIO);\n\n\t/* Exclusive open required for /dev/kbd */\n\tif (k->k_events.ev_io)\n\t\treturn (EBUSY);\n\tk->k_events.ev_io = p;\n\n\tif ((error = kbd_iopen(unit)) != 0) {\n\t\tk->k_events.ev_io = NULL;\n\t\treturn (error);\n\t}\n\tev_init(&k->k_events);\n\tk->k_evmode = 1;\t/* XXX: OK? */\n\n\tif (k->k_repeating) {\n\t\tk->k_repeating = 0;\n\t\tuntimeout(kbd_repeat, k);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "kbd_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "221-277",
    "snippet": "void \nkbd_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct kbd_softc *k = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tint channel, kbd_unit;\n\tint reset, s;\n\n\tcf = k->k_dev.dv_cfdata;\n\tkbd_unit = k->k_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = zsc->zsc_cs[channel];\n\tcs->cs_private = k;\n\tcs->cs_ops = &zsops_kbd;\n\tk->k_cs = cs;\n\n\tif (args->hwflags & ZS_HWFLAG_CONSOLE) {\n\t\tk->k_isconsole = 1;\n\t\tprintf(\" (console)\");\n\t}\n\tprintf(\"\\n\");\n\n\t/* Initialize the speed, etc. */\n\ts = splzs();\n\tif (k->k_isconsole == 0) {\n\t\t/* Not the console; may need reset. */\n\t\treset = (channel == 0) ?\n\t\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\t\tzs_write_reg(cs, 9, reset);\n\t}\n\t/* These are OK as set by zscc: WR3, WR4, WR5 */\n\t/* We don't care about status interrupts. */\n\tcs->cs_preg[1] = ZSWR1_RIE | ZSWR1_TIE;\n\t(void) zs_set_speed(cs, KBD_BPS);\n\tzs_loadchannelregs(cs);\n\tsplx(s);\n\n\t/* Do this before any calls to kbd_rint(). */\n\tkbd_xlate_init(&k->k_state);\n\n\t/* XXX - Do this in open? */\n\tk->k_repeat_start = hz/2;\n\tk->k_repeat_step = hz/20;\n\n\t/* Magic sequence. */\n\tk->k_magic1 = KBD_L1;\n\tk->k_magic2 = KBD_A;\n\n\t/* Now attach the (kd) pseudo-driver. */\n\tkd_init(kbd_unit);\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define KBD_BPS 1200"
    ],
    "globals_used": [
      "static void\tkbd_new_layout(struct kbd_softc *k);",
      "static void\tkbd_start_tx(struct kbd_softc *k);",
      "static void\tkbd_update_leds(struct kbd_softc *k);",
      "static void\tkbd_was_reset(struct kbd_softc *k);",
      "static int \tkbd_drain_tx(struct kbd_softc *k);",
      "struct zsops zsops_kbd;",
      "static int\tkbd_match(struct device *, void *, void *);",
      "static void\tkbd_attach(struct device *, struct device *, void *);",
      "struct zsops zsops_kbd = {\n\tkbd_rxint,\t/* receive char available */\n\tkbd_stint,\t/* external/status */\n\tkbd_txint,\t/* xmit buffer empty */\n\tkbd_softint,\t/* process software interrupt */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kd_init",
          "args": [
            "kbd_unit"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kbd_xlate_init",
          "args": [
            "&k->k_state"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "kbd_xlate_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
          "lines": "658-674",
          "snippet": "void\nkbd_xlate_init(ks)\n\tstruct kbd_state *ks;\n{\n\tstruct keyboard *ktbls;\n\tint id;\n\n\tid = ks->kbd_id;\n\tif (id < KBD_MIN_TYPE)\n\t\tid = KBD_MIN_TYPE;\n\tif (id > kbd_max_type)\n\t\tid = kbd_max_type;\n\tktbls = keyboards[id];\n\n\tks->kbd_k = *ktbls; \t/* struct assignment */\n\tks->kbd_modbits = 0;\n}",
          "includes": [
            "#include \"kbd_xlate.h\"",
            "#include \"event_var.h\"",
            "#include <machine/kbio.h>",
            "#include <machine/kbd.h>",
            "#include <machine/vuid_event.h>",
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/syslog.h>",
            "#include <sys/time.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/signal.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/device.h>",
            "#include <sys/conf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nkbd_xlate_init(ks)\n\tstruct kbd_state *ks;\n{\n\tstruct keyboard *ktbls;\n\tint id;\n\n\tid = ks->kbd_id;\n\tif (id < KBD_MIN_TYPE)\n\t\tid = KBD_MIN_TYPE;\n\tif (id > kbd_max_type)\n\t\tid = kbd_max_type;\n\tktbls = keyboards[id];\n\n\tks->kbd_k = *ktbls; \t/* struct assignment */\n\tks->kbd_modbits = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splx",
          "args": [
            "s"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_loadchannelregs",
          "args": [
            "cs"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "zs_loadchannelregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/z8530sc.c",
          "lines": "144-207",
          "snippet": "void\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}",
          "includes": [
            "#include <machine/z8530var.h>",
            "#include <dev/ic/z8530reg.h>",
            "#include <sys/syslog.h>",
            "#include <sys/kernel.h>",
            "#include <sys/time.h>",
            "#include <sys/tty.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/file.h>",
            "#include <sys/conf.h>",
            "#include <sys/device.h>",
            "#include <sys/proc.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/syslog.h>\n#include <sys/kernel.h>\n#include <sys/time.h>\n#include <sys/tty.h>\n#include <sys/ioctl.h>\n#include <sys/file.h>\n#include <sys/conf.h>\n#include <sys/device.h>\n#include <sys/proc.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\nzs_loadchannelregs(cs)\n\tstruct zs_chanstate *cs;\n{\n\tu_char *reg;\n\n\t/* Copy \"pending\" regs to \"current\" */\n\tbcopy((caddr_t)cs->cs_preg, (caddr_t)cs->cs_creg, 16);\n\treg = cs->cs_creg;\t/* current regs */\n\n\tzs_write_csr(cs, ZSM_RESET_ERR);\t/* XXX: reset error condition */\n\n#if 1\n\t/*\n\t * XXX: Is this really a good idea?\n\t * XXX: Should go elsewhere! -gwr\n\t */\n\tzs_iflush(cs);\t/* XXX */\n#endif\n\n\t/* baud clock divisor, stop bits, parity */\n\tzs_write_reg(cs, 4, reg[4]);\n\n\t/* misc. TX/RX control bits */\n\tzs_write_reg(cs, 10, reg[10]);\n\n\t/* char size, enable (RX/TX) */\n\tzs_write_reg(cs, 3, reg[3] & ~ZSWR3_RX_ENABLE);\n\tzs_write_reg(cs, 5, reg[5] & ~ZSWR5_TX_ENABLE);\n\n\t/* interrupt enables: TX, TX, STATUS */\n\tzs_write_reg(cs, 1, reg[1]);\n\n#if 0\n\t/*\n\t * Registers 2 and 9 are special because they are\n\t * actually common to both channels, but must be\n\t * programmed through channel A.  The \"zsc\" attach\n\t * function takes care of setting these registers\n\t * and they should not be touched thereafter.\n\t */\n\t/* interrupt vector */\n\tzs_write_reg(cs, 2, reg[2]);\n\t/* master interrupt control */\n\tzs_write_reg(cs, 9, reg[9]);\n#endif\n\n\t/* clock mode control */\n\tzs_write_reg(cs, 11, reg[11]);\n\n\t/* baud rate (lo/hi) */\n\tzs_write_reg(cs, 12, reg[12]);\n\tzs_write_reg(cs, 13, reg[13]);\n\n\t/* Misc. control bits */\n\tzs_write_reg(cs, 14, reg[14]);\n\n\t/* which lines cause status interrupts */\n\tzs_write_reg(cs, 15, reg[15]);\n\n\t/* char size, enable (RX/TX)*/\n\tzs_write_reg(cs, 3, reg[3]);\n\tzs_write_reg(cs, 5, reg[5]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zs_set_speed",
          "args": [
            "cs",
            "KBD_BPS"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zs_write_reg",
          "args": [
            "cs",
            "9",
            "reset"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splzs",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define KBD_BPS 1200\n\nstatic void\tkbd_new_layout(struct kbd_softc *k);\nstatic void\tkbd_start_tx(struct kbd_softc *k);\nstatic void\tkbd_update_leds(struct kbd_softc *k);\nstatic void\tkbd_was_reset(struct kbd_softc *k);\nstatic int \tkbd_drain_tx(struct kbd_softc *k);\nstruct zsops zsops_kbd;\nstatic int\tkbd_match(struct device *, void *, void *);\nstatic void\tkbd_attach(struct device *, struct device *, void *);\nstruct zsops zsops_kbd = {\n\tkbd_rxint,\t/* receive char available */\n\tkbd_stint,\t/* external/status */\n\tkbd_txint,\t/* xmit buffer empty */\n\tkbd_softint,\t/* process software interrupt */\n};\n\nvoid \nkbd_attach(parent, self, aux)\n\tstruct device *parent, *self;\n\tvoid   *aux;\n\n{\n\tstruct zsc_softc *zsc = (void *) parent;\n\tstruct kbd_softc *k = (void *) self;\n\tstruct zsc_attach_args *args = aux;\n\tstruct zs_chanstate *cs;\n\tstruct cfdata *cf;\n\tint channel, kbd_unit;\n\tint reset, s;\n\n\tcf = k->k_dev.dv_cfdata;\n\tkbd_unit = k->k_dev.dv_unit;\n\tchannel = args->channel;\n\tcs = zsc->zsc_cs[channel];\n\tcs->cs_private = k;\n\tcs->cs_ops = &zsops_kbd;\n\tk->k_cs = cs;\n\n\tif (args->hwflags & ZS_HWFLAG_CONSOLE) {\n\t\tk->k_isconsole = 1;\n\t\tprintf(\" (console)\");\n\t}\n\tprintf(\"\\n\");\n\n\t/* Initialize the speed, etc. */\n\ts = splzs();\n\tif (k->k_isconsole == 0) {\n\t\t/* Not the console; may need reset. */\n\t\treset = (channel == 0) ?\n\t\t\tZSWR9_A_RESET : ZSWR9_B_RESET;\n\t\tzs_write_reg(cs, 9, reset);\n\t}\n\t/* These are OK as set by zscc: WR3, WR4, WR5 */\n\t/* We don't care about status interrupts. */\n\tcs->cs_preg[1] = ZSWR1_RIE | ZSWR1_TIE;\n\t(void) zs_set_speed(cs, KBD_BPS);\n\tzs_loadchannelregs(cs);\n\tsplx(s);\n\n\t/* Do this before any calls to kbd_rint(). */\n\tkbd_xlate_init(&k->k_state);\n\n\t/* XXX - Do this in open? */\n\tk->k_repeat_start = hz/2;\n\tk->k_repeat_step = hz/20;\n\n\t/* Magic sequence. */\n\tk->k_magic1 = KBD_L1;\n\tk->k_magic2 = KBD_A;\n\n\t/* Now attach the (kd) pseudo-driver. */\n\tkd_init(kbd_unit);\n}"
  },
  {
    "function_name": "kbd_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/sun/kbd.c",
    "lines": "206-219",
    "snippet": "int \nkbd_match(parent, vcf, aux)\n\tstruct device *parent;\n\tvoid *vcf, *aux;\n{\n\tstruct cfdata *cf = vcf;\n\tstruct zsc_attach_args *args = aux;\n\n\t/* Exact match required for keyboard. */\n\tif (cf->cf_loc[0] == args->channel)\n\t\treturn 2;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kbd_xlate.h\"",
      "#include \"event_var.h\"",
      "#include <machine/kbio.h>",
      "#include <machine/kbd.h>",
      "#include <machine/vuid_event.h>",
      "#include <machine/z8530var.h>",
      "#include <dev/ic/z8530reg.h>",
      "#include <sys/poll.h>",
      "#include <sys/select.h>",
      "#include <sys/syslog.h>",
      "#include <sys/time.h>",
      "#include <sys/signalvar.h>",
      "#include <sys/signal.h>",
      "#include <sys/proc.h>",
      "#include <sys/kernel.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/device.h>",
      "#include <sys/conf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\tkbd_match(struct device *, void *, void *);",
      "static void\tkbd_attach(struct device *, struct device *, void *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"kbd_xlate.h\"\n#include \"event_var.h\"\n#include <machine/kbio.h>\n#include <machine/kbd.h>\n#include <machine/vuid_event.h>\n#include <machine/z8530var.h>\n#include <dev/ic/z8530reg.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/syslog.h>\n#include <sys/time.h>\n#include <sys/signalvar.h>\n#include <sys/signal.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/ioctl.h>\n#include <sys/device.h>\n#include <sys/conf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int\tkbd_match(struct device *, void *, void *);\nstatic void\tkbd_attach(struct device *, struct device *, void *);\n\nint \nkbd_match(parent, vcf, aux)\n\tstruct device *parent;\n\tvoid *vcf, *aux;\n{\n\tstruct cfdata *cf = vcf;\n\tstruct zsc_attach_args *args = aux;\n\n\t/* Exact match required for keyboard. */\n\tif (cf->cf_loc[0] == args->channel)\n\t\treturn 2;\n\n\treturn 0;\n}"
  }
]