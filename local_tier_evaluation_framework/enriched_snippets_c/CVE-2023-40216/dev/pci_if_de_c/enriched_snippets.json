[
  {
    "function_name": "tulip_pci_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "5197-5533",
    "snippet": "static void\ntulip_pci_attach(\n    TULIP_PCI_ATTACH_ARGS)\n{\n#if defined(__FreeBSD__)\n    tulip_softc_t *sc;\n#define\tPCI_CONF_WRITE(r, v)\tpci_conf_write(config_id, (r), (v))\n#define\tPCI_CONF_READ(r)\tpci_conf_read(config_id, (r))\n#define\tPCI_GETBUSDEVINFO(sc)\t((void)((sc)->tulip_pci_busno = ((config_id.cfg1 >> 16) & 0xFF), /* XXX */ \\\n\t\t\t\t\t(sc)->tulip_pci_devno = ((config_id.cfg1 >> 11) & 0x1F))) /* XXX */\n#endif\n#if defined(__bsdi__)\n    tulip_softc_t * const sc = (tulip_softc_t *) self;\n    struct isa_attach_args * const ia = (struct isa_attach_args *) aux;\n    pci_devaddr_t *pa = (pci_devaddr_t *) ia->ia_aux;\n    const int unit = sc->tulip_dev.dv_unit;\n#define\tPCI_CONF_WRITE(r, v)\tpci_outl(pa, (r), (v))\n#define\tPCI_CONF_READ(r)\tpci_inl(pa, (r))\n#define\tPCI_GETBUSDEVINFO(sc)\t((void)((sc)->tulip_pci_busno = pa->d_bus, \\\n\t\t\t\t\t(sc)->tulip_pci_devno = pa->d_agent))\n#endif\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n    tulip_softc_t * const sc = (tulip_softc_t *) self;\n    struct pci_attach_args * const pa = (struct pci_attach_args *) aux;\n    const int unit = sc->tulip_dev.dv_unit;\n    bus_space_tag_t iot, memt;  \n    bus_space_handle_t ioh, memh;\n    int ioh_valid, memh_valid;\n#define\tPCI_CONF_WRITE(r, v)\tpci_conf_write(pa->pa_pc, pa->pa_tag, (r), (v))\n#define\tPCI_CONF_READ(r)\tpci_conf_read(pa->pa_pc, pa->pa_tag, (r))\n#define\tPCI_GETBUSDEVINFO(sc)\tdo { \\\n\tint busno, devno, funcno; \\\n\tpci_decompose_tag(pa->pa_pc, pa->pa_tag, &busno, &devno, &funcno); \\\n\t(sc)->tulip_pci_busno = busno; \\\n\t(sc)->tulip_pci_devno = devno; \\\n    } while (0)\n#endif /* __NetBSD__ */\n\n    int retval, idx;\n    u_int32_t revinfo, cfdainfo, id;\n#if !defined(TULIP_IOMAPPED) && defined(__FreeBSD__)\n    vm_offset_t pa_csrs;\n#endif\n    unsigned csroffset = TULIP_PCI_CSROFFSET;\n    unsigned csrsize = TULIP_PCI_CSRSIZE;\n    tulip_csrptr_t csr_base; \n    tulip_chipid_t chipid = TULIP_CHIPID_UNKNOWN;\n\n    if (unit >= TULIP_MAX_DEVICES) {\n#ifdef __FreeBSD__\n\tprintf(\"de%d\", unit);\n#endif\n\tprintf(\": not configured; limit of %d reached or exceeded\\n\",\n\t       TULIP_MAX_DEVICES);\n\treturn;\n    }\n\n#if defined(__bsdi__)\n    if (pa != NULL) {\n\trevinfo = pci_inl(pa, PCI_CFRV) & 0xFF;\n\tid = pci_inl(pa, PCI_CFID);\n\tcfdainfo = pci_inl(pa, PCI_CFDA);\n#if defined(TULIP_EISA)\n    } else {\n\trevinfo = inl(ia->ia_iobase + DE425_CFRV) & 0xFF;\n\tcsroffset = TULIP_EISA_CSROFFSET;\n\tcsrsize = TULIP_EISA_CSRSIZE;\n\tchipid = TULIP_DE425;\n\tcfdainfo = 0;\n#endif /* TULIP_EISA */\n    }\n#else /* __bsdi__ */\n    revinfo  = PCI_CONF_READ(PCI_CFRV) & 0xFF;\n    id       = PCI_CONF_READ(PCI_CFID);\n    cfdainfo = PCI_CONF_READ(PCI_CFDA);\n#endif /* __bsdi__ */\n\n    if (PCI_VENDORID(id) == DEC_VENDORID) {\n\tif (PCI_CHIPID(id) == CHIPID_21040)\n\t\tchipid = TULIP_21040;\n\telse if (PCI_CHIPID(id) == CHIPID_21041)\n\t\tchipid = TULIP_21041;\n\telse if (PCI_CHIPID(id) == CHIPID_21140)\n\t\tchipid = (revinfo >= 0x20) ? TULIP_21140A : TULIP_21140;\n\telse if (PCI_CHIPID(id) == CHIPID_21142)\n\t        chipid = (revinfo >= 0x20) ? TULIP_21143 : TULIP_21142;\n    }\n\n    if (chipid == TULIP_CHIPID_UNKNOWN)\n\treturn;\n\n    if ((chipid == TULIP_21040 || chipid == TULIP_DE425) && revinfo < 0x20) {\n#ifdef __FreeBSD__\n\tprintf(\"de%d\", unit);\n#endif\n\tprintf(\": not configured; 21040 pass 2.0 required (%d.%d found)\\n\",\n\t       revinfo >> 4, revinfo & 0x0f);\n\treturn;\n    } else if (chipid == TULIP_21140 && revinfo < 0x11) {\n#ifndef __FreeBSD__\n\tprintf(\"\\n\");\n#endif\n\tprintf(\"de%d: not configured; 21140 pass 1.1 required (%d.%d found)\\n\",\n\t       unit, revinfo >> 4, revinfo & 0x0f);\n\treturn;\n    }\n\n#if defined(__FreeBSD__)\n    sc = (tulip_softc_t *) malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);\n    if (sc == NULL)\n\treturn;\n    bzero(sc, sizeof(*sc));\t\t\t\t/* Zero out the softc*/\n#endif\n\n    PCI_GETBUSDEVINFO(sc);\n    sc->tulip_chipid = chipid;\n    sc->tulip_flags |= TULIP_DEVICEPROBE;\n    if (chipid == TULIP_21140 || chipid == TULIP_21140A)\n\tsc->tulip_features |= TULIP_HAVE_GPR|TULIP_HAVE_STOREFWD;\n    if (chipid == TULIP_21140A && revinfo <= 0x22)\n\tsc->tulip_features |= TULIP_HAVE_RXBADOVRFLW;\n    if (chipid == TULIP_21140)\n\tsc->tulip_features |= TULIP_HAVE_BROKEN_HASH;\n    if (chipid != TULIP_21040 && chipid != TULIP_DE425 && chipid != TULIP_21140)\n\tsc->tulip_features |= TULIP_HAVE_POWERMGMT;\n    if (chipid == TULIP_21041 || chipid == TULIP_21142 || chipid == TULIP_21143) {\n\tsc->tulip_features |= TULIP_HAVE_DUALSENSE;\n\tif (chipid != TULIP_21041 || revinfo >= 0x20)\n\t    sc->tulip_features |= TULIP_HAVE_SIANWAY;\n\tif (chipid != TULIP_21041)\n\t    sc->tulip_features |= TULIP_HAVE_SIAGP|TULIP_HAVE_RXBADOVRFLW|TULIP_HAVE_STOREFWD;\n\tif (chipid != TULIP_21041 && revinfo >= 0x20)\n\t    sc->tulip_features |= TULIP_HAVE_SIA100;\n    }\n\n    if (sc->tulip_features & TULIP_HAVE_POWERMGMT\n\t    && (cfdainfo & (TULIP_CFDA_SLEEP|TULIP_CFDA_SNOOZE))) {\n\tcfdainfo &= ~(TULIP_CFDA_SLEEP|TULIP_CFDA_SNOOZE);\n\tPCI_CONF_WRITE(PCI_CFDA, cfdainfo);\n\tDELAY(11*1000);\n    }\n\n#if defined(__OpenBSD__)\n    /* XXX - csapuntz@lcs.mit.edu\n       OpenBSD + our PCI motherboard underflows consistently */\n    if (sc->tulip_features & TULIP_HAVE_STOREFWD)\n\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n#endif\n\n\n#if defined(__alpha__) && defined(__NetBSD__)\n    /*\n     * The Alpha SRM console encodes a console set media in the driver\n     * part of the CFDA register.  Note that the Multia presents a\n     * problem in that its BNC mode is really EXTSIA.  So in that case\n     * force a probe.\n     */\n    switch ((cfdainfo >> 8) & 0xff) {\n    case 1: media = chipid > TULIP_DE425 ?\n        TULIP_MEDIA_AUI : TULIP_MEDIA_AUIBNC; break;\n    case 2: media = chipid > TULIP_DE425 ?\n        TULIP_MEDIA_BNC : TULIP_MEDIA_UNKNOWN; break;\n    case 3: media = TULIP_MEDIA_10BASET; break;\n    case 4: media = TULIP_MEDIA_10BASET_FD; break;\n    case 5: media = TULIP_MEDIA_100BASETX; break;\n    case 6: media = TULIP_MEDIA_100BASETX_FD; break;\n    }\n#endif\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n    bcopy(self->dv_xname, sc->tulip_if.if_xname, IFNAMSIZ);\n    sc->tulip_if.if_softc = sc;\n    sc->tulip_pc = pa->pa_pc;\n#else\n    sc->tulip_unit = unit;\n    sc->tulip_name = \"de\";\n#endif\n    sc->tulip_revinfo = revinfo;\n#if defined(__FreeBSD__)\n#if BSD >= 199506\n    sc->tulip_if.if_softc = sc;\n#endif\n#if defined(TULIP_IOMAPPED)\n    retval = pci_map_port(config_id, PCI_CBIO, &csr_base);\n#else\n    retval = pci_map_mem(config_id, PCI_CBMA, (vm_offset_t *) &csr_base, &pa_csrs);\n#endif\n    if (!retval) {\n\tfree((caddr_t) sc, M_DEVBUF);\n\treturn;\n    }\n    tulips[unit] = sc;\n#endif /* __FreeBSD__ */\n\n#if defined(__bsdi__)\n    sc->tulip_pf = printf;\n#if defined(TULIP_IOMAPPED)\n    csr_base = ia->ia_iobase;\n#else\n    csr_base = (vm_offset_t) mapphys((vm_offset_t) ia->ia_maddr, ia->ia_msize);\n#endif\n#endif /* __bsdi__ */\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n    csr_base = 0;\n\n    ioh_valid = (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,\n\t\t &iot, &ioh, NULL, NULL) == 0);\n    memh_valid = (pci_mapreg_map(pa, PCI_CBMA,\n    \t\t  PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,\n\t\t  &memt, &memh, NULL, NULL) == 0);\n#endif\n\n#if defined(__OpenBSD__) || defined(__NetBSD__)\n#if defined(TULIP_IOMAPPED)\n    if (ioh_valid) {\n\tsc->tulip_bustag = iot;\n\tsc->tulip_bushandle = ioh;\n    } else if (memh_valid) {\n\tsc->tulip_bustag = memt;\n\tsc->tulip_bushandle = memh;\n    }\n#else /* defined(TULIP_IOMAPPED) */\n    if (memh_valid) {\n\tsc->tulip_bustag = memt;\n\tsc->tulip_bushandle = memh;\n    } else if (ioh_valid) {\n\tsc->tulip_bustag = iot;\n\tsc->tulip_bushandle = ioh;\n    }\n#endif /* TULIP_IOMAPPED */\n    else {\n        printf(\": unable to map device registers\\n\");\n        return;\n    }\n#endif /* __NetBSD__ */\n\n    tulip_initcsrs(sc, csr_base + csroffset, csrsize);\n    tulip_initring(sc, &sc->tulip_rxinfo, sc->tulip_rxdescs, TULIP_RXDESCS);\n    tulip_initring(sc, &sc->tulip_txinfo, sc->tulip_txdescs, TULIP_TXDESCS);\n\n    /*\n     * Make sure there won't be any interrupts or such...\n     */\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(100);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if ((retval = tulip_read_macaddr(sc)) < 0) {\n#if defined(__FreeBSD__)\n\tprintf(TULIP_PRINTF_FMT, TULIP_PRINTF_ARGS);\n#endif\n\tprintf(\": can't read ENET ROM (why=%d) (\", retval);\n\tfor (idx = 0; idx < 32; idx++)\n\t    printf(\"%02x\", sc->tulip_rombuf[idx]);\n\tprintf(\"\\n\");\n\tprintf(TULIP_PRINTF_FMT \": %s%s pass %d.%d address unknown\",\n\t       TULIP_PRINTF_ARGS,\n\t       sc->tulip_boardid, tulip_chipdescs[sc->tulip_chipid],\n\t       (sc->tulip_revinfo & 0xF0) >> 4, sc->tulip_revinfo & 0x0F);\n    } else {\n\ttulip_spl_t s;\n\ttulip_intrfunc_t (*intr_rtn)(void *) = tulip_intr_normal;\n\n\tif (sc->tulip_features & TULIP_HAVE_SHAREDINTR)\n\t    intr_rtn = tulip_intr_shared;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tif ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {\n\t    pci_intr_handle_t intrhandle;\n\t    const char *intrstr;\n\n\t    if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t     pa->pa_intrline, &intrhandle)) {\n\t\tprintf(\", couldn't map interrupt\\n\");\n\t\treturn;\n\t    }\n\t    intrstr = pci_intr_string(pa->pa_pc, intrhandle);\n\t    sc->tulip_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,\n\t\t\t\t\t      intr_rtn, sc, self->dv_xname);\n\t    if (sc->tulip_ih == NULL) {\n\t\tprintf(\", couldn't establish interrupt\",\n\t\t       sc->tulip_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t    printf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t    }\n\t    printf(\": %s\", intrstr);\n\t}\n\tprintf(\"\\n\");\n\tsc->tulip_ats = shutdownhook_establish(tulip_shutdown, sc);\n\tif (sc->tulip_ats == NULL)\n\t    printf(\"%s: warning: couldn't establish shutdown hook\\n\",\n\t\t   sc->tulip_xname);\n#endif\n#if defined(__FreeBSD__)\n\tif ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {\n\t    if (!pci_map_int (config_id, intr_rtn, (void*) sc, &net_imask)) {\n\t\tprintf(TULIP_PRINTF_FMT \": couldn't map interrupt\\n\",\n\t\t       TULIP_PRINTF_ARGS);\n\t\treturn;\n\t    }\n\t}\n#if !defined(TULIP_DEVCONF)\n\tat_shutdown(tulip_shutdown, sc, SHUTDOWN_POST_SYNC);\n#endif\n#endif\n#if defined(__bsdi__)\n\tif ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {\n\t    isa_establish(&sc->tulip_id, &sc->tulip_dev);\n\n\t    sc->tulip_ih.ih_fun = intr_rtn;\n\t    sc->tulip_ih.ih_arg = (void *) sc;\n\t    intr_establish(ia->ia_irq, &sc->tulip_ih, DV_NET);\n\t}\n\n\tsc->tulip_ats.func = tulip_shutdown;\n\tsc->tulip_ats.arg = (void *) sc;\n\tatshutdown(&sc->tulip_ats, ATSH_ADD);\n#endif\n#if defined(TULIP_USE_SOFTINTR)\n\tif (sc->tulip_unit > tulip_softintr_max_unit)\n\t    tulip_softintr_max_unit = sc->tulip_unit;\n#endif\n\n\ts = TULIP_RAISESPL();\n\ttulip_reset(sc);\n\ttulip_attach(sc);\n#if defined(__alpha__) && defined(__NetBSD__)\n\tif (media != TULIP_MEDIA_UNKNOWN)\n\t    tulip_linkup(sc, media);\n#endif\n\tTULIP_RESTORESPL(s);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_PCI_ATTACH_ARGS\tstruct device * const parent, struct device * const self, void * const aux",
      "#define\tTULIP_PCI_ATTACH_ARGS\tstruct device * const parent, struct device * const self, void * const aux",
      "#define\tTULIP_PCI_ATTACH_ARGS\tpcici_t config_id, int unit",
      "#define\tPCI_CFDA\t0x40\t/* Configuration Driver Area */",
      "#define\tPCI_CBMA\t0x14\t/* Configuration Base Memory Address */",
      "#define\tPCI_CBIO\t0x10\t/* Configuration Base IO Address */",
      "#define\tPCI_CFRV\t0x08\t/* Configuration Revision */",
      "#define\tPCI_CFID\t0x00\t/* Configuration ID */",
      "#define\tTULIP_USE_SOFTINTR",
      "#define\tTULIP_IOMAPPED",
      "#define\tTULIP_EISA"
    ],
    "globals_used": [
      "static tulip_intrfunc_t tulip_intr_shared(void *arg);",
      "static tulip_intrfunc_t tulip_intr_normal(void *arg);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct isa_attach_args * const ia = (struct isa_attach_args *) aux;",
      "pci_devaddr_t *pa;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_RESTORESPL",
          "args": [
            "s"
          ],
          "line": 5531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_linkup",
          "args": [
            "sc",
            "media"
          ],
          "line": 5529
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_linkup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "384-436",
          "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_attach",
          "args": [
            "sc"
          ],
          "line": 5526
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4737-4840",
          "snippet": "static void\ntulip_attach(\n    tulip_softc_t * const sc)\n{\n    struct ifnet * const ifp = &sc->tulip_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n    ifp->if_ioctl = tulip_ifioctl;\n    ifp->if_start = tulip_ifstart;\n    ifp->if_watchdog = tulip_ifwatchdog;\n    ifp->if_timer = 1;\n#if !defined(__bsdi__) || _BSDI_VERSION < 199401\n    ifp->if_output = ether_output;\n#endif\n#if defined(__bsdi__) && _BSDI_VERSION < 199401\n    ifp->if_mtu = ETHERMTU;\n#endif\n  \n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    aprint_naive(\": DEC Ethernet\");\n    aprint_normal(\": %s%s\", sc->tulip_boardid,\n        tulip_chipdescs[sc->tulip_chipid]);\n    aprint_verbose(\" pass %d.%d\", (sc->tulip_revinfo & 0xF0) >> 4,\n        sc->tulip_revinfo & 0x0F);\n    printf(\"\\n\");\n    sc->tulip_pf = aprint_normal;\n    aprint_normal(TULIP_PRINTF_FMT \": address \" TULIP_EADDR_FMT \"\\n\",\n\t\t  TULIP_PRINTF_ARGS,\n\t\t  TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#else\n    printf(\n#if defined(__bsdi__)\n\t   \"\\n\"\n#endif\n\t   TULIP_PRINTF_FMT \": %s%s pass %d.%d%s address \" TULIP_EADDR_FMT \"\\n\",\n\t   TULIP_PRINTF_ARGS,\n\t   sc->tulip_boardid,\n\t   tulip_chipdescs[sc->tulip_chipid],\n\t   (sc->tulip_revinfo & 0xF0) >> 4,\n\t   sc->tulip_revinfo & 0x0F,\n\t   (sc->tulip_features & (TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM))\n\t\t == TULIP_HAVE_ISVSROM ? \" (invalid EESPROM checksum)\" : \"\",\n\t   TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#endif\n\n#if defined(__alpha__)\n    /*\n     * In case the SRM console told us about a bogus media,\n     * we need to check to be safe.\n     */\n    if (sc->tulip_mediums[sc->tulip_media] == NULL)\n\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n#endif\n\n    (*sc->tulip_boardsw->bd_media_probe)(sc);\n#if defined(IFM_ETHER)\n    ifmedia_init(&sc->tulip_ifmedia, 0,\n\t\t tulip_ifmedia_change,\n\t\t tulip_ifmedia_status);\n#else\n    {\n\ttulip_media_t media;\n\tint cnt;\n\tprintf(TULIP_PRINTF_FMT \": media:\", TULIP_PRINTF_ARGS);\n\tfor (media = TULIP_MEDIA_UNKNOWN, cnt = 1; cnt < 7 && media < TULIP_MEDIA_MAX; media++) {\n\t    if (sc->tulip_mediums[media] != NULL) {\n\t\tprintf(\" %d=\\\"%s\\\"\", cnt, tulip_mediums[media]);\n\t\tcnt++;\n\t    }\n\t}\n\tif (cnt == 1) {\n\t    sc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\t    printf(\" none\\n\");\n\t} else {\n\t    printf(\"\\n\");\n\t}\n    }\n#endif\n    sc->tulip_flags &= ~TULIP_DEVICEPROBE;\n#if defined(IFM_ETHER)\n    tulip_ifmedia_add(sc);\n#endif\n\n    tulip_reset(sc);\n\n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    sc->tulip_pf = printf;\n    TULIP_ETHER_IFATTACH(sc);\n#else\n    if_attach(ifp);\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (defined(__FreeBSD__) && BSD >= 199506)\n    TULIP_ETHER_IFATTACH(sc);\n#endif\n#endif /* __bsdi__ */\n\n#if NBPFILTER > 0\n    TULIP_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n    rnd_attach_source(&sc->tulip_rndsource, sc->tulip_dev.dv_xname,\n\t\t      RND_TYPE_NET);\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define IFF_NOTRAILERS\t\t0",
            "#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
            "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "struct ifnet * const ifp = &sc->tulip_if;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IFF_NOTRAILERS\t\t0\n#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic void\ntulip_attach(\n    tulip_softc_t * const sc)\n{\n    struct ifnet * const ifp = &sc->tulip_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n    ifp->if_ioctl = tulip_ifioctl;\n    ifp->if_start = tulip_ifstart;\n    ifp->if_watchdog = tulip_ifwatchdog;\n    ifp->if_timer = 1;\n#if !defined(__bsdi__) || _BSDI_VERSION < 199401\n    ifp->if_output = ether_output;\n#endif\n#if defined(__bsdi__) && _BSDI_VERSION < 199401\n    ifp->if_mtu = ETHERMTU;\n#endif\n  \n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    aprint_naive(\": DEC Ethernet\");\n    aprint_normal(\": %s%s\", sc->tulip_boardid,\n        tulip_chipdescs[sc->tulip_chipid]);\n    aprint_verbose(\" pass %d.%d\", (sc->tulip_revinfo & 0xF0) >> 4,\n        sc->tulip_revinfo & 0x0F);\n    printf(\"\\n\");\n    sc->tulip_pf = aprint_normal;\n    aprint_normal(TULIP_PRINTF_FMT \": address \" TULIP_EADDR_FMT \"\\n\",\n\t\t  TULIP_PRINTF_ARGS,\n\t\t  TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#else\n    printf(\n#if defined(__bsdi__)\n\t   \"\\n\"\n#endif\n\t   TULIP_PRINTF_FMT \": %s%s pass %d.%d%s address \" TULIP_EADDR_FMT \"\\n\",\n\t   TULIP_PRINTF_ARGS,\n\t   sc->tulip_boardid,\n\t   tulip_chipdescs[sc->tulip_chipid],\n\t   (sc->tulip_revinfo & 0xF0) >> 4,\n\t   sc->tulip_revinfo & 0x0F,\n\t   (sc->tulip_features & (TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM))\n\t\t == TULIP_HAVE_ISVSROM ? \" (invalid EESPROM checksum)\" : \"\",\n\t   TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#endif\n\n#if defined(__alpha__)\n    /*\n     * In case the SRM console told us about a bogus media,\n     * we need to check to be safe.\n     */\n    if (sc->tulip_mediums[sc->tulip_media] == NULL)\n\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n#endif\n\n    (*sc->tulip_boardsw->bd_media_probe)(sc);\n#if defined(IFM_ETHER)\n    ifmedia_init(&sc->tulip_ifmedia, 0,\n\t\t tulip_ifmedia_change,\n\t\t tulip_ifmedia_status);\n#else\n    {\n\ttulip_media_t media;\n\tint cnt;\n\tprintf(TULIP_PRINTF_FMT \": media:\", TULIP_PRINTF_ARGS);\n\tfor (media = TULIP_MEDIA_UNKNOWN, cnt = 1; cnt < 7 && media < TULIP_MEDIA_MAX; media++) {\n\t    if (sc->tulip_mediums[media] != NULL) {\n\t\tprintf(\" %d=\\\"%s\\\"\", cnt, tulip_mediums[media]);\n\t\tcnt++;\n\t    }\n\t}\n\tif (cnt == 1) {\n\t    sc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\t    printf(\" none\\n\");\n\t} else {\n\t    printf(\"\\n\");\n\t}\n    }\n#endif\n    sc->tulip_flags &= ~TULIP_DEVICEPROBE;\n#if defined(IFM_ETHER)\n    tulip_ifmedia_add(sc);\n#endif\n\n    tulip_reset(sc);\n\n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    sc->tulip_pf = printf;\n    TULIP_ETHER_IFATTACH(sc);\n#else\n    if_attach(ifp);\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (defined(__FreeBSD__) && BSD >= 199506)\n    TULIP_ETHER_IFATTACH(sc);\n#endif\n#endif /* __bsdi__ */\n\n#if NBPFILTER > 0\n    TULIP_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n    rnd_attach_source(&sc->tulip_rndsource, sc->tulip_dev.dv_xname,\n\t\t      RND_TYPE_NET);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 5525
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_RAISESPL",
          "args": [],
          "line": 5524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atshutdown",
          "args": [
            "&sc->tulip_ats",
            "ATSH_ADD"
          ],
          "line": 5517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intr_establish",
          "args": [
            "ia->ia_irq",
            "&sc->tulip_ih",
            "DV_NET"
          ],
          "line": 5512
        },
        "resolved": true,
        "details": {
          "function_name": "tc_intr_establish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/tc/tc.c",
          "lines": "276-287",
          "snippet": "void\ntc_intr_establish(dev, cookie, level, handler, arg)\n\tstruct device *dev;\n\tvoid *cookie, *arg;\n\ttc_intrlevel_t level;\n\tint (*handler) __P((void *));\n{\n\tstruct tc_softc *sc = (struct tc_softc *)dev;\n\n\t(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level,\n\t    handler, arg);\n}",
          "includes": [
            "#include <dev/tc/tcdevs_data.h>",
            "#include <machine/autoconf.h>\t/* for the proto of badaddr() */",
            "#include <dev/tc/tcdevs.h>",
            "#include <dev/tc/tcvar.h>",
            "#include <dev/tc/tcreg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/tc/tcdevs_data.h>\n#include <machine/autoconf.h>\t/* for the proto of badaddr() */\n#include <dev/tc/tcdevs.h>\n#include <dev/tc/tcvar.h>\n#include <dev/tc/tcreg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nvoid\ntc_intr_establish(dev, cookie, level, handler, arg)\n\tstruct device *dev;\n\tvoid *cookie, *arg;\n\ttc_intrlevel_t level;\n\tint (*handler) __P((void *));\n{\n\tstruct tc_softc *sc = (struct tc_softc *)dev;\n\n\t(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level,\n\t    handler, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isa_establish",
          "args": [
            "&sc->tulip_id",
            "&sc->tulip_dev"
          ],
          "line": 5508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "at_shutdown",
          "args": [
            "tulip_shutdown",
            "sc",
            "SHUTDOWN_POST_SYNC"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": couldn't map interrupt\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 5497
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_map_int",
          "args": [
            "config_id",
            "intr_rtn",
            "(void*) sc",
            "&net_imask"
          ],
          "line": 5496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shutdownhook_establish",
          "args": [
            "tulip_shutdown",
            "sc"
          ],
          "line": 5489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_establish",
          "args": [
            "pa->pa_pc",
            "intrhandle",
            "IPL_NET",
            "intr_rtn",
            "sc",
            "self->dv_xname"
          ],
          "line": 5476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_string",
          "args": [
            "pa->pa_pc",
            "intrhandle"
          ],
          "line": 5475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_intr_map",
          "args": [
            "pa->pa_pc",
            "pa->pa_intrtag",
            "pa->pa_intrpin",
            "pa->pa_intrline",
            "&intrhandle"
          ],
          "line": 5470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_read_macaddr",
          "args": [
            "sc"
          ],
          "line": 5446
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_read_macaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2780-3006",
          "snippet": "static int\ntulip_read_macaddr(\n    tulip_softc_t * const sc)\n{\n    unsigned cksum, rom_cksum, idx;\n    u_int32_t csr;\n    unsigned char tmpbuf[8];\n    static const u_char testpat[] = { 0xFF, 0, 0x55, 0xAA, 0xFF, 0, 0x55, 0xAA };\n\n    sc->tulip_connidx = TULIP_SROM_LASTCONNIDX;\n\n    if (sc->tulip_chipid == TULIP_21040) {\n\tTULIP_CSR_WRITE(sc, csr_enetrom, 1);\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    int cnt = 0;\n\t    while (((csr = TULIP_CSR_READ(sc, csr_enetrom)) & 0x80000000L) && cnt < 10000)\n\t\tcnt++;\n\t    sc->tulip_rombuf[idx] = csr & 0xFF;\n\t}\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#if defined(TULIP_EISA)\n    } else if (sc->tulip_chipid == TULIP_DE425) {\n\tint cnt;\n\tfor (idx = 0, cnt = 0; idx < sizeof(testpat) && cnt < 32; cnt++) {\n\t    tmpbuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\t    if (tmpbuf[idx] == testpat[idx])\n\t\t++idx;\n\t    else\n\t\tidx = 0;\n\t}\n\tfor (idx = 0; idx < 32; idx++)\n\t    sc->tulip_rombuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#endif /* TULIP_EISA */\n    } else {\n\tif (sc->tulip_chipid == TULIP_21041) {\n\t    /*\n\t     * Thankfully all 21041's act the same.\n\t     */\n\t    sc->tulip_boardsw = &tulip_21041_boardsw;\n\t} else {\n\t    /*\n\t     * Assume all 21140 board are compatible with the\n\t     * DEC 10/100 evaluation board.  Not really valid but\n\t     * it's the best we can do until every one switches to\n\t     * the new SROM format.\n\t     */\n\t     \n\t    sc->tulip_boardsw = &tulip_21140_eb_boardsw;\n\t}\n#ifdef NEED_PCI_ETHER_HW_ADDR_FUNC\n\tif(pci_ether_hw_addr(sc->tulip_pc, (u_char *)(&sc->tulip_rombuf),\n\t    sc->tulip_pci_busno, sc->tulip_pci_devno)) {\n\t    \tif(sc->tulip_boardsw == &tulip_21041_boardsw)\n\t\t    sc->tulip_boardsw = &tulip_21041np_boardsw;\n\t}\n\telse {\n\t\ttulip_srom_read(sc);\n\t}\n#else\n\ttulip_srom_read(sc);\n#endif\n\tif (tulip_srom_crcok(sc->tulip_rombuf)) {\n\t    /*\n\t     * SROM CRC is valid therefore it must be in the\n\t     * new format.\n\t     */\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM;\n\t} else if (sc->tulip_rombuf[126] == 0xff && sc->tulip_rombuf[127] == 0xFF) {\n\t    /*\n\t     * No checksum is present.  See if the SROM id checks out;\n\t     * the first 18 bytes should be 0 followed by a 1 followed\n\t     * by the number of adapters (which we don't deal with yet).\n\t     */\n\t    for (idx = 0; idx < 18; idx++) {\n\t\tif (sc->tulip_rombuf[idx] != 0)\n\t\t    break;\n\t    }\n\t    if (idx == 18 && sc->tulip_rombuf[18] == 1 && sc->tulip_rombuf[19] != 0)\n\t\tsc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t} else if (sc->tulip_chipid >= TULIP_21142) {\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t    sc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\t}\n\tif ((sc->tulip_features & TULIP_HAVE_ISVSROM) && tulip_srom_decode(sc)) {\n\t    if (sc->tulip_chipid != TULIP_21041)\n\t\tsc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\n\t    /*\n\t     * If the SROM specifies more than one adapter, tag this as a\n\t     * BASE rom.\n\t     */\n\t    if (sc->tulip_rombuf[19] > 1)\n\t\tsc->tulip_features |= TULIP_HAVE_BASEROM;\n\t    if (sc->tulip_boardsw == NULL)\n\t\treturn -6;\n\t    goto check_oui;\n\t}\n    }\n\n\n    if (bcmp(&sc->tulip_rombuf[0], &sc->tulip_rombuf[16], 8) != 0) {\n\t/*\n\t * Some folks don't use the standard ethernet rom format\n\t * but instead just put the address in the first 6 bytes\n\t * of the rom and let the rest be all 0xffs.  (Can we say\n\t * ZNYX???) (well sometimes they put in a checksum so we'll\n\t * start at 8).\n\t */\n\tfor (idx = 8; idx < 32; idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0xFF)\n\t\treturn -4;\n\t}\n\t/*\n\t * Make sure the address is not multicast or locally assigned\n\t * that the OUI is not 00-00-00.\n\t */\n\tif ((sc->tulip_rombuf[0] & 3) != 0)\n\t    return -4;\n\tif (sc->tulip_rombuf[0] == 0 && sc->tulip_rombuf[1] == 0\n\t\t&& sc->tulip_rombuf[2] == 0)\n\t    return -4;\n\tbcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\tsc->tulip_features |= TULIP_HAVE_OKROM;\n\tgoto check_oui;\n    } else {\n\t/*\n\t * A number of makers of multiport boards (ZNYX and Cogent)\n\t * only put on one address ROM on their 21040 boards.  So\n\t * if the ROM is all zeros (or all 0xFFs), look at the\n\t * previous configured boards (as long as they are on the same\n\t * PCI bus and the bus number is non-zero) until we find the\n\t * master board with address ROM.  We then use its address ROM\n\t * as the base for this board.  (we add our relative board\n\t * to the last byte of its address).\n\t */\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0 && sc->tulip_rombuf[idx] != 0xFF)\n\t\tbreak;\n\t}\n\tif (idx == sizeof(sc->tulip_rombuf)) {\n\t    int root_unit;\n\t    tulip_softc_t *root_sc = NULL;\n\t    for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {\n\t\troot_sc = TULIP_UNIT_TO_SOFTC(root_unit);\n\t\tif (root_sc == NULL || (root_sc->tulip_features & (TULIP_HAVE_OKROM|TULIP_HAVE_SLAVEDROM)) == TULIP_HAVE_OKROM)\n\t\t    break;\n\t\troot_sc = NULL;\n\t    }\n\t    if (root_sc != NULL && (root_sc->tulip_features & TULIP_HAVE_BASEROM)\n\t\t    && root_sc->tulip_chipid == sc->tulip_chipid\n\t\t    && root_sc->tulip_pci_busno == sc->tulip_pci_busno) {\n\t\tsc->tulip_features |= TULIP_HAVE_SLAVEDROM;\n\t\tsc->tulip_boardsw = root_sc->tulip_boardsw;\n\t\tstrcpy(sc->tulip_boardid, root_sc->tulip_boardid);\n\t\tif (sc->tulip_boardsw->bd_type == TULIP_21140_ISV) {\n\t\t    bcopy(root_sc->tulip_rombuf, sc->tulip_rombuf,\n\t\t\t  sizeof(sc->tulip_rombuf));\n\t\t    if (!tulip_srom_decode(sc))\n\t\t\treturn -5;\n\t\t} else {\n\t\t    bcopy(root_sc->tulip_enaddr, sc->tulip_enaddr, 6);\n\t\t    sc->tulip_enaddr[5] += sc->tulip_unit - root_sc->tulip_unit;\n\t\t}\n\t\t/*\n\t\t * Now for a truly disgusting kludge: all 4 21040s on\n\t\t * the ZX314 share the same INTA line so the mapping\n\t\t * setup by the BIOS on the PCI bridge is worthless.\n\t\t * Rather than reprogramming the value in the config\n\t\t * register, we will handle this internally.\n\t\t */\n\t\tif (root_sc->tulip_features & TULIP_HAVE_SHAREDINTR) {\n\t\t    sc->tulip_slaves = root_sc->tulip_slaves;\n\t\t    root_sc->tulip_slaves = sc;\n\t\t    sc->tulip_features |= TULIP_HAVE_SLAVEDINTR;\n\t\t}\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    /*\n     * This is the standard DEC address ROM test.\n     */\n\n    if (bcmp(&sc->tulip_rombuf[24], testpat, 8) != 0)\n\treturn -3;\n\n    tmpbuf[0] = sc->tulip_rombuf[15]; tmpbuf[1] = sc->tulip_rombuf[14];\n    tmpbuf[2] = sc->tulip_rombuf[13]; tmpbuf[3] = sc->tulip_rombuf[12];\n    tmpbuf[4] = sc->tulip_rombuf[11]; tmpbuf[5] = sc->tulip_rombuf[10];\n    tmpbuf[6] = sc->tulip_rombuf[9];  tmpbuf[7] = sc->tulip_rombuf[8];\n    if (bcmp(&sc->tulip_rombuf[0], tmpbuf, 8) != 0)\n\treturn -2;\n\n    bcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\n    cksum = *(u_int16_t *) &sc->tulip_enaddr[0];\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[2];\n    if (cksum > 65535) cksum -= 65535;\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[4];\n    if (cksum >= 65535) cksum -= 65535;\n\n    rom_cksum = *(u_int16_t *) &sc->tulip_rombuf[6];\n\t\n    if (cksum != rom_cksum)\n\treturn -1;\n\n  check_oui:\n    /*\n     * Check for various boards based on OUI.  Did I say braindead?\n     */\n    for (idx = 0; tulip_vendors[idx].vendor_identify_nic != NULL; idx++) {\n\tif (bcmp((caddr_t) sc->tulip_enaddr,\n\t\t (caddr_t) tulip_vendors[idx].vendor_oui, 3) == 0) {\n\t    (*tulip_vendors[idx].vendor_identify_nic)(sc);\n\t    break;\n\t}\n    }\n\n    sc->tulip_features |= TULIP_HAVE_OKROM;\n    return 0;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_EISA"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "static const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};",
            "static const tulip_boardsw_t tulip_21041_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_probe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};",
            "static const tulip_boardsw_t tulip_21041np_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_noprobe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};",
            "static const tulip_boardsw_t tulip_21140_eb_boardsw = {\n    TULIP_21140_DEC_EB,\n    tulip_21140_evalboard_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};",
            "static const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};",
            "static const struct {\n    void (*vendor_identify_nic)(tulip_softc_t * const sc);\n    unsigned char vendor_oui[3];\n} tulip_vendors[] = {\n    { tulip_identify_dec_nic,\t\t{ 0x08, 0x00, 0x2B } },\n    { tulip_identify_dec_nic,\t\t{ 0x00, 0x00, 0xF8 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0x00, 0xC0 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0xE0, 0x29 } },\n    { tulip_identify_znyx_nic,\t\t{ 0x00, 0xC0, 0x95 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0x92 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0xD1 } },\n    { tulip_identify_asante_nic,\t{ 0x00, 0x00, 0x94 } },\n    { tulip_identify_accton_nic,\t{ 0x00, 0x00, 0xE8 } },\n    { NULL }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_EISA\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};\nstatic const tulip_boardsw_t tulip_21041_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_probe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};\nstatic const tulip_boardsw_t tulip_21041np_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_noprobe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};\nstatic const tulip_boardsw_t tulip_21140_eb_boardsw = {\n    TULIP_21140_DEC_EB,\n    tulip_21140_evalboard_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};\nstatic const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};\nstatic const struct {\n    void (*vendor_identify_nic)(tulip_softc_t * const sc);\n    unsigned char vendor_oui[3];\n} tulip_vendors[] = {\n    { tulip_identify_dec_nic,\t\t{ 0x08, 0x00, 0x2B } },\n    { tulip_identify_dec_nic,\t\t{ 0x00, 0x00, 0xF8 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0x00, 0xC0 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0xE0, 0x29 } },\n    { tulip_identify_znyx_nic,\t\t{ 0x00, 0xC0, 0x95 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0x92 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0xD1 } },\n    { tulip_identify_asante_nic,\t{ 0x00, 0x00, 0x94 } },\n    { tulip_identify_accton_nic,\t{ 0x00, 0x00, 0xE8 } },\n    { NULL }\n};\n\nstatic int\ntulip_read_macaddr(\n    tulip_softc_t * const sc)\n{\n    unsigned cksum, rom_cksum, idx;\n    u_int32_t csr;\n    unsigned char tmpbuf[8];\n    static const u_char testpat[] = { 0xFF, 0, 0x55, 0xAA, 0xFF, 0, 0x55, 0xAA };\n\n    sc->tulip_connidx = TULIP_SROM_LASTCONNIDX;\n\n    if (sc->tulip_chipid == TULIP_21040) {\n\tTULIP_CSR_WRITE(sc, csr_enetrom, 1);\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    int cnt = 0;\n\t    while (((csr = TULIP_CSR_READ(sc, csr_enetrom)) & 0x80000000L) && cnt < 10000)\n\t\tcnt++;\n\t    sc->tulip_rombuf[idx] = csr & 0xFF;\n\t}\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#if defined(TULIP_EISA)\n    } else if (sc->tulip_chipid == TULIP_DE425) {\n\tint cnt;\n\tfor (idx = 0, cnt = 0; idx < sizeof(testpat) && cnt < 32; cnt++) {\n\t    tmpbuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\t    if (tmpbuf[idx] == testpat[idx])\n\t\t++idx;\n\t    else\n\t\tidx = 0;\n\t}\n\tfor (idx = 0; idx < 32; idx++)\n\t    sc->tulip_rombuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#endif /* TULIP_EISA */\n    } else {\n\tif (sc->tulip_chipid == TULIP_21041) {\n\t    /*\n\t     * Thankfully all 21041's act the same.\n\t     */\n\t    sc->tulip_boardsw = &tulip_21041_boardsw;\n\t} else {\n\t    /*\n\t     * Assume all 21140 board are compatible with the\n\t     * DEC 10/100 evaluation board.  Not really valid but\n\t     * it's the best we can do until every one switches to\n\t     * the new SROM format.\n\t     */\n\t     \n\t    sc->tulip_boardsw = &tulip_21140_eb_boardsw;\n\t}\n#ifdef NEED_PCI_ETHER_HW_ADDR_FUNC\n\tif(pci_ether_hw_addr(sc->tulip_pc, (u_char *)(&sc->tulip_rombuf),\n\t    sc->tulip_pci_busno, sc->tulip_pci_devno)) {\n\t    \tif(sc->tulip_boardsw == &tulip_21041_boardsw)\n\t\t    sc->tulip_boardsw = &tulip_21041np_boardsw;\n\t}\n\telse {\n\t\ttulip_srom_read(sc);\n\t}\n#else\n\ttulip_srom_read(sc);\n#endif\n\tif (tulip_srom_crcok(sc->tulip_rombuf)) {\n\t    /*\n\t     * SROM CRC is valid therefore it must be in the\n\t     * new format.\n\t     */\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM;\n\t} else if (sc->tulip_rombuf[126] == 0xff && sc->tulip_rombuf[127] == 0xFF) {\n\t    /*\n\t     * No checksum is present.  See if the SROM id checks out;\n\t     * the first 18 bytes should be 0 followed by a 1 followed\n\t     * by the number of adapters (which we don't deal with yet).\n\t     */\n\t    for (idx = 0; idx < 18; idx++) {\n\t\tif (sc->tulip_rombuf[idx] != 0)\n\t\t    break;\n\t    }\n\t    if (idx == 18 && sc->tulip_rombuf[18] == 1 && sc->tulip_rombuf[19] != 0)\n\t\tsc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t} else if (sc->tulip_chipid >= TULIP_21142) {\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t    sc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\t}\n\tif ((sc->tulip_features & TULIP_HAVE_ISVSROM) && tulip_srom_decode(sc)) {\n\t    if (sc->tulip_chipid != TULIP_21041)\n\t\tsc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\n\t    /*\n\t     * If the SROM specifies more than one adapter, tag this as a\n\t     * BASE rom.\n\t     */\n\t    if (sc->tulip_rombuf[19] > 1)\n\t\tsc->tulip_features |= TULIP_HAVE_BASEROM;\n\t    if (sc->tulip_boardsw == NULL)\n\t\treturn -6;\n\t    goto check_oui;\n\t}\n    }\n\n\n    if (bcmp(&sc->tulip_rombuf[0], &sc->tulip_rombuf[16], 8) != 0) {\n\t/*\n\t * Some folks don't use the standard ethernet rom format\n\t * but instead just put the address in the first 6 bytes\n\t * of the rom and let the rest be all 0xffs.  (Can we say\n\t * ZNYX???) (well sometimes they put in a checksum so we'll\n\t * start at 8).\n\t */\n\tfor (idx = 8; idx < 32; idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0xFF)\n\t\treturn -4;\n\t}\n\t/*\n\t * Make sure the address is not multicast or locally assigned\n\t * that the OUI is not 00-00-00.\n\t */\n\tif ((sc->tulip_rombuf[0] & 3) != 0)\n\t    return -4;\n\tif (sc->tulip_rombuf[0] == 0 && sc->tulip_rombuf[1] == 0\n\t\t&& sc->tulip_rombuf[2] == 0)\n\t    return -4;\n\tbcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\tsc->tulip_features |= TULIP_HAVE_OKROM;\n\tgoto check_oui;\n    } else {\n\t/*\n\t * A number of makers of multiport boards (ZNYX and Cogent)\n\t * only put on one address ROM on their 21040 boards.  So\n\t * if the ROM is all zeros (or all 0xFFs), look at the\n\t * previous configured boards (as long as they are on the same\n\t * PCI bus and the bus number is non-zero) until we find the\n\t * master board with address ROM.  We then use its address ROM\n\t * as the base for this board.  (we add our relative board\n\t * to the last byte of its address).\n\t */\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0 && sc->tulip_rombuf[idx] != 0xFF)\n\t\tbreak;\n\t}\n\tif (idx == sizeof(sc->tulip_rombuf)) {\n\t    int root_unit;\n\t    tulip_softc_t *root_sc = NULL;\n\t    for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {\n\t\troot_sc = TULIP_UNIT_TO_SOFTC(root_unit);\n\t\tif (root_sc == NULL || (root_sc->tulip_features & (TULIP_HAVE_OKROM|TULIP_HAVE_SLAVEDROM)) == TULIP_HAVE_OKROM)\n\t\t    break;\n\t\troot_sc = NULL;\n\t    }\n\t    if (root_sc != NULL && (root_sc->tulip_features & TULIP_HAVE_BASEROM)\n\t\t    && root_sc->tulip_chipid == sc->tulip_chipid\n\t\t    && root_sc->tulip_pci_busno == sc->tulip_pci_busno) {\n\t\tsc->tulip_features |= TULIP_HAVE_SLAVEDROM;\n\t\tsc->tulip_boardsw = root_sc->tulip_boardsw;\n\t\tstrcpy(sc->tulip_boardid, root_sc->tulip_boardid);\n\t\tif (sc->tulip_boardsw->bd_type == TULIP_21140_ISV) {\n\t\t    bcopy(root_sc->tulip_rombuf, sc->tulip_rombuf,\n\t\t\t  sizeof(sc->tulip_rombuf));\n\t\t    if (!tulip_srom_decode(sc))\n\t\t\treturn -5;\n\t\t} else {\n\t\t    bcopy(root_sc->tulip_enaddr, sc->tulip_enaddr, 6);\n\t\t    sc->tulip_enaddr[5] += sc->tulip_unit - root_sc->tulip_unit;\n\t\t}\n\t\t/*\n\t\t * Now for a truly disgusting kludge: all 4 21040s on\n\t\t * the ZX314 share the same INTA line so the mapping\n\t\t * setup by the BIOS on the PCI bridge is worthless.\n\t\t * Rather than reprogramming the value in the config\n\t\t * register, we will handle this internally.\n\t\t */\n\t\tif (root_sc->tulip_features & TULIP_HAVE_SHAREDINTR) {\n\t\t    sc->tulip_slaves = root_sc->tulip_slaves;\n\t\t    root_sc->tulip_slaves = sc;\n\t\t    sc->tulip_features |= TULIP_HAVE_SLAVEDINTR;\n\t\t}\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    /*\n     * This is the standard DEC address ROM test.\n     */\n\n    if (bcmp(&sc->tulip_rombuf[24], testpat, 8) != 0)\n\treturn -3;\n\n    tmpbuf[0] = sc->tulip_rombuf[15]; tmpbuf[1] = sc->tulip_rombuf[14];\n    tmpbuf[2] = sc->tulip_rombuf[13]; tmpbuf[3] = sc->tulip_rombuf[12];\n    tmpbuf[4] = sc->tulip_rombuf[11]; tmpbuf[5] = sc->tulip_rombuf[10];\n    tmpbuf[6] = sc->tulip_rombuf[9];  tmpbuf[7] = sc->tulip_rombuf[8];\n    if (bcmp(&sc->tulip_rombuf[0], tmpbuf, 8) != 0)\n\treturn -2;\n\n    bcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\n    cksum = *(u_int16_t *) &sc->tulip_enaddr[0];\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[2];\n    if (cksum > 65535) cksum -= 65535;\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[4];\n    if (cksum >= 65535) cksum -= 65535;\n\n    rom_cksum = *(u_int16_t *) &sc->tulip_rombuf[6];\n\t\n    if (cksum != rom_cksum)\n\treturn -1;\n\n  check_oui:\n    /*\n     * Check for various boards based on OUI.  Did I say braindead?\n     */\n    for (idx = 0; tulip_vendors[idx].vendor_identify_nic != NULL; idx++) {\n\tif (bcmp((caddr_t) sc->tulip_enaddr,\n\t\t (caddr_t) tulip_vendors[idx].vendor_oui, 3) == 0) {\n\t    (*tulip_vendors[idx].vendor_identify_nic)(sc);\n\t    break;\n\t}\n    }\n\n    sc->tulip_features |= TULIP_HAVE_OKROM;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 5442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "TULIP_BUSMODE_SWRESET"
          ],
          "line": 5441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_initring",
          "args": [
            "sc",
            "&sc->tulip_txinfo",
            "sc->tulip_txdescs",
            "TULIP_TXDESCS"
          ],
          "line": 5436
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_initring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4869-4914",
          "snippet": "static void\ntulip_initring(\n    tulip_softc_t * const sc,\n    tulip_ringinfo_t * const ri,\n    tulip_desc_t *descs,\n    int ndescs)\n{\n#if defined(__mips__)\n    tulip_desc_t *xdesc = descs;\n    /*\n     * Someone moved the descriptors into the softc struct.\n     * Avoid cache line conflicts by aligning on cache line.\n     */\n    descs = (tulip_desc_t *)(roundup((int)descs, 16));\n    if(xdesc != descs) {\n\tndescs--;\n    }\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)descs, ndescs * sizeof(tulip_desc_t));\n    descs = (tulip_desc_t *)TULIP_KVATOPHYS(sc, descs);\n    descs = (tulip_desc_t *)PHYS_TO_UNCACHED((int)descs & 0x3fffffff);\n#endif\n#ifdef PPC_MPC106_BUG\n    /*\n     * This is a workaround for the powerpc MPC106 chip not snooping\n     * accesses to the descriptor area correctly.\n     */\n    tulip_desc_t *xdesc = descs;\n    xdesc = (tulip_desc_t *)(roundup((int)descs, 32) - 4);\n    if(xdesc < descs) {\n\tndescs--;\n\txdesc++;\n    }\n    descs = xdesc;\n#endif\n    ri->ri_max = ndescs;\n    ri->ri_first = descs;\n    ri->ri_last = ri->ri_first + ri->ri_max;\n    bzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n    {\n\ttulip_desc_bitfield_t u;\n\t\t\n\tu.f = DESC_BO( ri->ri_last[-1].u.f );\n\tu.bd_flag = TULIP_DFLAG_ENDRING;\n\tri->ri_last[-1].u.f = DESC_BO(u.f);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_initring(\n    tulip_softc_t * const sc,\n    tulip_ringinfo_t * const ri,\n    tulip_desc_t *descs,\n    int ndescs)\n{\n#if defined(__mips__)\n    tulip_desc_t *xdesc = descs;\n    /*\n     * Someone moved the descriptors into the softc struct.\n     * Avoid cache line conflicts by aligning on cache line.\n     */\n    descs = (tulip_desc_t *)(roundup((int)descs, 16));\n    if(xdesc != descs) {\n\tndescs--;\n    }\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)descs, ndescs * sizeof(tulip_desc_t));\n    descs = (tulip_desc_t *)TULIP_KVATOPHYS(sc, descs);\n    descs = (tulip_desc_t *)PHYS_TO_UNCACHED((int)descs & 0x3fffffff);\n#endif\n#ifdef PPC_MPC106_BUG\n    /*\n     * This is a workaround for the powerpc MPC106 chip not snooping\n     * accesses to the descriptor area correctly.\n     */\n    tulip_desc_t *xdesc = descs;\n    xdesc = (tulip_desc_t *)(roundup((int)descs, 32) - 4);\n    if(xdesc < descs) {\n\tndescs--;\n\txdesc++;\n    }\n    descs = xdesc;\n#endif\n    ri->ri_max = ndescs;\n    ri->ri_first = descs;\n    ri->ri_last = ri->ri_first + ri->ri_max;\n    bzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n    {\n\ttulip_desc_bitfield_t u;\n\t\t\n\tu.f = DESC_BO( ri->ri_last[-1].u.f );\n\tu.bd_flag = TULIP_DFLAG_ENDRING;\n\tri->ri_last[-1].u.f = DESC_BO(u.f);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_initcsrs",
          "args": [
            "sc",
            "csr_base + csroffset",
            "csrsize"
          ],
          "line": 5434
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_initcsrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4842-4867",
          "snippet": "static void\ntulip_initcsrs(\n    tulip_softc_t * const sc,\n    tulip_csrptr_t csr_base,\n    size_t csr_size)\n{\n    sc->tulip_csrs.csr_busmode\t\t= csr_base +  0 * csr_size;\n    sc->tulip_csrs.csr_txpoll\t\t= csr_base +  1 * csr_size;\n    sc->tulip_csrs.csr_rxpoll\t\t= csr_base +  2 * csr_size;\n    sc->tulip_csrs.csr_rxlist\t\t= csr_base +  3 * csr_size;\n    sc->tulip_csrs.csr_txlist\t\t= csr_base +  4 * csr_size;\n    sc->tulip_csrs.csr_status\t\t= csr_base +  5 * csr_size;\n    sc->tulip_csrs.csr_command\t\t= csr_base +  6 * csr_size;\n    sc->tulip_csrs.csr_intr\t\t= csr_base +  7 * csr_size;\n    sc->tulip_csrs.csr_missed_frames\t= csr_base +  8 * csr_size;\n    sc->tulip_csrs.csr_9\t\t= csr_base +  9 * csr_size;\n    sc->tulip_csrs.csr_10\t\t= csr_base + 10 * csr_size;\n    sc->tulip_csrs.csr_11\t\t= csr_base + 11 * csr_size;\n    sc->tulip_csrs.csr_12\t\t= csr_base + 12 * csr_size;\n    sc->tulip_csrs.csr_13\t\t= csr_base + 13 * csr_size;\n    sc->tulip_csrs.csr_14\t\t= csr_base + 14 * csr_size;\n    sc->tulip_csrs.csr_15\t\t= csr_base + 15 * csr_size;\n#if defined(TULIP_EISA)\n    sc->tulip_csrs.csr_enetrom\t\t= csr_base + DE425_ENETROM_OFFSET;\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_EISA"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_EISA\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_initcsrs(\n    tulip_softc_t * const sc,\n    tulip_csrptr_t csr_base,\n    size_t csr_size)\n{\n    sc->tulip_csrs.csr_busmode\t\t= csr_base +  0 * csr_size;\n    sc->tulip_csrs.csr_txpoll\t\t= csr_base +  1 * csr_size;\n    sc->tulip_csrs.csr_rxpoll\t\t= csr_base +  2 * csr_size;\n    sc->tulip_csrs.csr_rxlist\t\t= csr_base +  3 * csr_size;\n    sc->tulip_csrs.csr_txlist\t\t= csr_base +  4 * csr_size;\n    sc->tulip_csrs.csr_status\t\t= csr_base +  5 * csr_size;\n    sc->tulip_csrs.csr_command\t\t= csr_base +  6 * csr_size;\n    sc->tulip_csrs.csr_intr\t\t= csr_base +  7 * csr_size;\n    sc->tulip_csrs.csr_missed_frames\t= csr_base +  8 * csr_size;\n    sc->tulip_csrs.csr_9\t\t= csr_base +  9 * csr_size;\n    sc->tulip_csrs.csr_10\t\t= csr_base + 10 * csr_size;\n    sc->tulip_csrs.csr_11\t\t= csr_base + 11 * csr_size;\n    sc->tulip_csrs.csr_12\t\t= csr_base + 12 * csr_size;\n    sc->tulip_csrs.csr_13\t\t= csr_base + 13 * csr_size;\n    sc->tulip_csrs.csr_14\t\t= csr_base + 14 * csr_size;\n    sc->tulip_csrs.csr_15\t\t= csr_base + 15 * csr_size;\n#if defined(TULIP_EISA)\n    sc->tulip_csrs.csr_enetrom\t\t= csr_base + DE425_ENETROM_OFFSET;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_mapreg_map",
          "args": [
            "pa",
            "PCI_CBMA",
            "PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT",
            "0",
            "&memt",
            "&memh",
            "NULL",
            "NULL"
          ],
          "line": 5405
        },
        "resolved": true,
        "details": {
          "function_name": "pci_mapreg_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pci_map.c",
          "lines": "230-275",
          "snippet": "int\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}",
          "includes": [
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <sys/device.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nbsd_pci_io_find",
            "static int nbsd_pci_mem_find"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <sys/device.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic int nbsd_pci_io_find;\nstatic int nbsd_pci_mem_find;\n\nint\npci_mapreg_map(pa, reg, type, busflags, tagp, handlep, basep, sizep)\n\tstruct pci_attach_args *pa;\n\tint reg, busflags;\n\tpcireg_t type;\n\tbus_space_tag_t *tagp;\n\tbus_space_handle_t *handlep;\n\tbus_addr_t *basep;\n\tbus_size_t *sizep;\n{\n\tbus_space_tag_t tag;\n\tbus_space_handle_t handle;\n\tbus_addr_t base;\n\tbus_size_t size;\n\tint flags;\n\n\tif (PCI_MAPREG_TYPE(type) == PCI_MAPREG_TYPE_IO) {\n\t\tif ((pa->pa_flags & PCI_FLAGS_IO_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_io_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t     &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_iot;\n\t} else {\n\t\tif ((pa->pa_flags & PCI_FLAGS_MEM_ENABLED) == 0)\n\t\t\treturn (1);\n\t\tif (nbsd_pci_mem_find(pa->pa_pc, pa->pa_tag, reg, type, &base,\n\t\t\t\t      &size, &flags))\n\t\t\treturn (1);\n\t\ttag = pa->pa_memt;\n\t}\n\n\tif (bus_space_map(tag, base, size, busflags | flags, &handle))\n\t\treturn (1);\n\n\tif (tagp != 0)\n\t\t*tagp = tag;\n\tif (handlep != 0)\n\t\t*handlep = handle;\n\tif (basep != 0)\n\t\t*basep = base;\n\tif (sizep != 0)\n\t\t*sizep = size;\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapphys",
          "args": [
            "(vm_offset_t) ia->ia_maddr",
            "ia->ia_msize"
          ],
          "line": 5396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "(caddr_t) sc",
            "M_DEVBUF"
          ],
          "line": 5385
        },
        "resolved": true,
        "details": {
          "function_name": "epic_freebsd_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_tx.c",
          "lines": "437-614",
          "snippet": "void\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}",
          "includes": [
            "#include <pci/if_txvar.h>",
            "#include <pci/pcivar.h>",
            "#include <machine/clock.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in.h>",
            "#include <net/if_mib.h>",
            "#include <dev/pci/if_txvar.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <vm/vm.h>",
            "#include <netinet/if_ether.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netipx/ipx_if.h>",
            "#include <netipx/ipx.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_media.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/sockio.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"pci.h\"",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [
            "#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))",
            "#define EPIC_NOIFMEDIA\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <pci/if_txvar.h>\n#include <pci/pcivar.h>\n#include <machine/clock.h>\n#include <vm/pmap.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <netinet/in.h>\n#include <net/if_mib.h>\n#include <dev/pci/if_txvar.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <vm/vm.h>\n#include <netinet/if_ether.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netipx/ipx_if.h>\n#include <netipx/ipx.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_media.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/sockio.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"pci.h\"\n#include \"bpfilter.h\"\n\n#define\tEPIC_MTYPESNUM (sizeof(epic_mtypes) / sizeof(epic_mtypes[0]))\n#define EPIC_NOIFMEDIA\t1\n\nvoid\nepic_freebsd_attach(\n    pcici_t config_id,\n    int unit)\n{\n\tstruct ifnet *ifp;\n\tepic_softc_t *sc;\n#if defined(EPIC_USEIOSPACE)\n\tu_int32_t iobase;\n#else\n\tcaddr_t\tpmembase;\n#endif\n\tu_int32_t command;\n\tint i,s,tmp;\n\n\tprintf(\"tx%d\",unit);\n\n\t/* Allocate memory for softc, hardware descriptors and frag lists */\n\tsc = (epic_softc_t *) malloc( sizeof(epic_softc_t), M_DEVBUF, M_NOWAIT);\n\tif (sc == NULL)\treturn;\n\n\t/* Preinitialize softc structure */\n    \tbzero(sc, sizeof(epic_softc_t));\t\t\n\tsc->unit = unit;\n\n\t/* Fill ifnet structure */\n\tifp = &sc->sc_if;\n\tifp->if_unit = unit;\n\tifp->if_name = \"tx\";\n\tifp->if_softc = sc;\n\tifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;\n\tifp->if_ioctl = epic_ifioctl;\n\tifp->if_start = epic_ifstart;\n\tifp->if_watchdog = epic_ifwatchdog;\n\tifp->if_init = (if_init_f_t*)epic_init;\n\tifp->if_timer = 0;\n\tifp->if_output = ether_output;\n\tifp->if_snd.ifq_maxlen = TX_RING_SIZE;\n\n\t/* Get iobase or membase */\n#if defined(EPIC_USEIOSPACE)\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_IOEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_IOEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_port(config_id, PCI_CBIO,(u_short *) &(sc->iobase))) {\n\t\tprintf(\": cannot map port\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#else\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_MAEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\n\tif (!(command & PCI_CFCS_MAEN)) {\n\t\tprintf(\": failed to enable memory mapping!\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\tif (!pci_map_mem(config_id, PCI_CBMA,(vm_offset_t *) &(sc->csr),(vm_offset_t *) &pmembase)) {\n\t\tprintf(\": cannot map memory\\n\"); \n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n#endif\n\n\t/* Do OS independent part, including chip wakeup and reset */\n\tif( epic_common_attach(sc) ) return;\n\n\tcommand = PCI_CONF_READ(PCI_CFCS);\n\tcommand |= PCI_CFCS_BMEN;\n\tPCI_CONF_WRITE(PCI_CFCS, command);\n\n\t/* Display ethernet address ,... */\n\tprintf(\": address %02x:%02x:%02x:%02x:%02x:%02x,\",\n\t\tsc->sc_macaddr[0],sc->sc_macaddr[1],sc->sc_macaddr[2],\n\t\tsc->sc_macaddr[3],sc->sc_macaddr[4],sc->sc_macaddr[5]);\n\n\t/* board type and ... */\n\tprintf(\" type \");\n\tfor(i=0x2c;i<0x32;i++) {\n\t\ttmp = epic_read_eeprom( sc, i );\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t\ttmp >>= 8;\n\t\tif( ' ' == (u_int8_t)tmp ) break;\n\t\tprintf(\"%c\",(u_int8_t)tmp);\n\t}\n\n\t/* Read current media config and display it too */\n\ti = PHY_READ_2( sc, DP83840_BMCR );\n#if !defined(EPIC_NOIFMEDIA)\n\ttmp = IFM_ETHER;\n#endif\n\tif( i & BMCR_AUTONEGOTIATION ){\n\t\tprintf(\", Auto-Neg \");\n\n\t\t/* To avoid bug in QS6612 read LPAR enstead of BMSR */\n\t\ti = PHY_READ_2( sc, DP83840_LPAR );\n\t\tif( i & (ANAR_100_TX|ANAR_100_TX_FD) ) printf(\"100Mbps \");\n\t\telse printf(\"10Mbps \");\n\t\tif( i & (ANAR_10_FD|ANAR_100_TX_FD) ) printf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\ttmp |= IFM_AUTO;\n#endif\n\t} else {\n#if defined(EPIC_NOIFMEDIA)\n\t\tifp->if_flags |= IFF_LINK0;\n#endif\n\t\tif( i & BMCR_100MBPS ) {\n\t\t\tprintf(\", 100Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_100_TX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK2;\n#endif\n\t\t} else {\n\t\t\tprintf(\", 10Mbps \");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_10_T;\n#endif\n\t\t}\n\t\tif( i & BMCR_FULL_DUPLEX ) {\n\t\t\tprintf(\"FD\");\n#if !defined(EPIC_NOIFMEDIA)\n\t\t\ttmp |= IFM_FDX;\n#else\n\t\t\tifp->if_flags |= IFF_LINK1;\n#endif\n\t\t}\n\t}\n\n\t/* Init ifmedia interface */\n#if !defined(EPIC_NOIFMEDIA)\n\tifmedia_init(&sc->ifmedia,0,epic_ifmedia_change,epic_ifmedia_status);\n\n\tfor (i=0; i<EPIC_MTYPESNUM; i++)\n\t\tifmedia_add(&sc->ifmedia,epic_mtypes[i],0,NULL);\n\n\tifmedia_set(&sc->ifmedia, tmp);\n#endif\n\n\ts = splimp();\n\n\t/* Map interrupt */\n\tif( !pci_map_int(config_id, epic_intr, (void*)sc, &net_imask) ) {\n\t\tprintf(\": couldn't map interrupt\\n\");\n\t\tfree(sc, M_DEVBUF);\n\t\treturn;\n\t}\n\n\t/* Set shut down routine to stop DMA processes on reboot */\n\tat_shutdown(epic_shutdown, sc, SHUTDOWN_POST_SYNC);\n\n\t/*  Attach to if manager */\n\tif_attach(ifp);\n\tether_ifattach(ifp);\n\n#if NBPFILTER > 0\n\tbpfattach(ifp,DLT_EN10MB, sizeof(struct ether_header));\n#endif\n\n\tsplx(s);\n\n\tprintf(\"\\n\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_map_mem",
          "args": [
            "config_id",
            "PCI_CBMA",
            "(vm_offset_t *) &csr_base",
            "&pa_csrs"
          ],
          "line": 5382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_map_port",
          "args": [
            "config_id",
            "PCI_CBIO",
            "&csr_base"
          ],
          "line": 5380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "self->dv_xname",
            "sc->tulip_if.if_xname",
            "IFNAMSIZ"
          ],
          "line": 5367
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "11*1000"
          ],
          "line": 5336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_WRITE",
          "args": [
            "PCI_CFDA",
            "cfdainfo"
          ],
          "line": 5335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_GETBUSDEVINFO",
          "args": [
            "sc"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc",
            "sizeof(*sc)"
          ],
          "line": 5308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*sc)",
            "M_DEVBUF",
            "M_NOWAIT"
          ],
          "line": 5305
        },
        "resolved": true,
        "details": {
          "function_name": "rf_unrecord_malloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugMem.c",
          "lines": "84-99",
          "snippet": "void \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}",
          "includes": [
            "#include \"rf_general.h\"",
            "#include \"rf_debugMem.h\"",
            "#include \"rf_options.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static long tot_mem_in_use = 0;",
            "static int memory_hash_remove(void *addr, int sz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_general.h\"\n#include \"rf_debugMem.h\"\n#include \"rf_options.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nstatic long tot_mem_in_use = 0;\nstatic int memory_hash_remove(void *addr, int sz);\n\nvoid \nrf_unrecord_malloc(p, sz)\n\tvoid   *p;\n\tint     sz;\n{\n\tint     size;\n\n\t/* RF_LOCK_MUTEX(rf_debug_mem_mutex); */\n\tsize = memory_hash_remove(p, sz);\n\ttot_mem_in_use -= size;\n\t/* RF_UNLOCK_MUTEX(rf_debug_mem_mutex); */\n\tif ((long) p == rf_memDebugAddress) {\n\t\tprintf(\"Free: Found debug address\\n\");\t/* this is really only a\n\t\t\t\t\t\t\t * flag line for gdb */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "id"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "id"
          ],
          "line": 5279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "id"
          ],
          "line": 5277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "id"
          ],
          "line": 5275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDORID",
          "args": [
            "id"
          ],
          "line": 5274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFDA"
          ],
          "line": 5271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFID"
          ],
          "line": 5270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CONF_READ",
          "args": [
            "PCI_CFRV"
          ],
          "line": 5269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inl",
          "args": [
            "ia->ia_iobase + DE425_CFRV"
          ],
          "line": 5261
        },
        "resolved": true,
        "details": {
          "function_name": "pccbb_winlist_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/pccbb.c",
          "lines": "2906-2934",
          "snippet": "static int\npccbb_winlist_delete(head, bsh, size)\n\tstruct pccbb_win_chain_head *head;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain *chainp;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t     chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_handle != bsh)\n\t\t\tcontinue;\n\t\tif ((chainp->wc_end - chainp->wc_start) != (size - 1)) {\n\t\t\tprintf(\"pccbb_winlist_delete: window 0x%lx size \"\n\t\t\t    \"inconsistent: 0x%lx, 0x%lx\\n\",\n\t\t\t    chainp->wc_start,\n\t\t\t    chainp->wc_end - chainp->wc_start,\n\t\t\t    size - 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tTAILQ_REMOVE(head, chainp, wc_list);\n\t\tfree(chainp, M_DEVBUF);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\t       /* fail: no candidate to remove */\n}",
          "includes": [
            "#include <dev/pci/pccbbvar.h>",
            "#include <dev/ic/i82365var.h>",
            "#include <dev/ic/i82365reg.h>",
            "#include <dev/pcmcia/pcmciavar.h>",
            "#include <dev/pcmcia/pcmciareg.h>",
            "#include <dev/cardbus/cardbusvar.h>",
            "#include <dev/cardbus/cardslotvar.h>",
            "#include <dev/pci/pccbbreg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <machine/bus.h>",
            "#include <machine/intr.h>",
            "#include <sys/malloc.h>",
            "#include <sys/device.h>",
            "#include <sys/syslog.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/errno.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/pccbbvar.h>\n#include <dev/ic/i82365var.h>\n#include <dev/ic/i82365reg.h>\n#include <dev/pcmcia/pcmciavar.h>\n#include <dev/pcmcia/pcmciareg.h>\n#include <dev/cardbus/cardbusvar.h>\n#include <dev/cardbus/cardslotvar.h>\n#include <dev/pci/pccbbreg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcireg.h>\n#include <dev/pci/pcivar.h>\n#include <machine/bus.h>\n#include <machine/intr.h>\n#include <sys/malloc.h>\n#include <sys/device.h>\n#include <sys/syslog.h>\n#include <sys/ioctl.h>\n#include <sys/errno.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include <sys/types.h>\n\nstatic int\npccbb_winlist_delete(head, bsh, size)\n\tstruct pccbb_win_chain_head *head;\n\tbus_space_handle_t bsh;\n\tbus_size_t size;\n{\n\tstruct pccbb_win_chain *chainp;\n\n\tfor (chainp = TAILQ_FIRST(head); chainp != NULL;\n\t     chainp = TAILQ_NEXT(chainp, wc_list)) {\n\t\tif (chainp->wc_handle != bsh)\n\t\t\tcontinue;\n\t\tif ((chainp->wc_end - chainp->wc_start) != (size - 1)) {\n\t\t\tprintf(\"pccbb_winlist_delete: window 0x%lx size \"\n\t\t\t    \"inconsistent: 0x%lx, 0x%lx\\n\",\n\t\t\t    chainp->wc_start,\n\t\t\t    chainp->wc_end - chainp->wc_start,\n\t\t\t    size - 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tTAILQ_REMOVE(head, chainp, wc_list);\n\t\tfree(chainp, M_DEVBUF);\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\t       /* fail: no candidate to remove */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_inl",
          "args": [
            "pa",
            "PCI_CFDA"
          ],
          "line": 5258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_inl",
          "args": [
            "pa",
            "PCI_CFID"
          ],
          "line": 5257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_inl",
          "args": [
            "pa",
            "PCI_CFRV"
          ],
          "line": 5256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_PCI_ATTACH_ARGS\tstruct device * const parent, struct device * const self, void * const aux\n#define\tTULIP_PCI_ATTACH_ARGS\tstruct device * const parent, struct device * const self, void * const aux\n#define\tTULIP_PCI_ATTACH_ARGS\tpcici_t config_id, int unit\n#define\tPCI_CFDA\t0x40\t/* Configuration Driver Area */\n#define\tPCI_CBMA\t0x14\t/* Configuration Base Memory Address */\n#define\tPCI_CBIO\t0x10\t/* Configuration Base IO Address */\n#define\tPCI_CFRV\t0x08\t/* Configuration Revision */\n#define\tPCI_CFID\t0x00\t/* Configuration ID */\n#define\tTULIP_USE_SOFTINTR\n#define\tTULIP_IOMAPPED\n#define\tTULIP_EISA\n\nstatic tulip_intrfunc_t tulip_intr_shared(void *arg);\nstatic tulip_intrfunc_t tulip_intr_normal(void *arg);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct isa_attach_args * const ia = (struct isa_attach_args *) aux;\npci_devaddr_t *pa;\n\nstatic void\ntulip_pci_attach(\n    TULIP_PCI_ATTACH_ARGS)\n{\n#if defined(__FreeBSD__)\n    tulip_softc_t *sc;\n#define\tPCI_CONF_WRITE(r, v)\tpci_conf_write(config_id, (r), (v))\n#define\tPCI_CONF_READ(r)\tpci_conf_read(config_id, (r))\n#define\tPCI_GETBUSDEVINFO(sc)\t((void)((sc)->tulip_pci_busno = ((config_id.cfg1 >> 16) & 0xFF), /* XXX */ \\\n\t\t\t\t\t(sc)->tulip_pci_devno = ((config_id.cfg1 >> 11) & 0x1F))) /* XXX */\n#endif\n#if defined(__bsdi__)\n    tulip_softc_t * const sc = (tulip_softc_t *) self;\n    struct isa_attach_args * const ia = (struct isa_attach_args *) aux;\n    pci_devaddr_t *pa = (pci_devaddr_t *) ia->ia_aux;\n    const int unit = sc->tulip_dev.dv_unit;\n#define\tPCI_CONF_WRITE(r, v)\tpci_outl(pa, (r), (v))\n#define\tPCI_CONF_READ(r)\tpci_inl(pa, (r))\n#define\tPCI_GETBUSDEVINFO(sc)\t((void)((sc)->tulip_pci_busno = pa->d_bus, \\\n\t\t\t\t\t(sc)->tulip_pci_devno = pa->d_agent))\n#endif\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n    tulip_softc_t * const sc = (tulip_softc_t *) self;\n    struct pci_attach_args * const pa = (struct pci_attach_args *) aux;\n    const int unit = sc->tulip_dev.dv_unit;\n    bus_space_tag_t iot, memt;  \n    bus_space_handle_t ioh, memh;\n    int ioh_valid, memh_valid;\n#define\tPCI_CONF_WRITE(r, v)\tpci_conf_write(pa->pa_pc, pa->pa_tag, (r), (v))\n#define\tPCI_CONF_READ(r)\tpci_conf_read(pa->pa_pc, pa->pa_tag, (r))\n#define\tPCI_GETBUSDEVINFO(sc)\tdo { \\\n\tint busno, devno, funcno; \\\n\tpci_decompose_tag(pa->pa_pc, pa->pa_tag, &busno, &devno, &funcno); \\\n\t(sc)->tulip_pci_busno = busno; \\\n\t(sc)->tulip_pci_devno = devno; \\\n    } while (0)\n#endif /* __NetBSD__ */\n\n    int retval, idx;\n    u_int32_t revinfo, cfdainfo, id;\n#if !defined(TULIP_IOMAPPED) && defined(__FreeBSD__)\n    vm_offset_t pa_csrs;\n#endif\n    unsigned csroffset = TULIP_PCI_CSROFFSET;\n    unsigned csrsize = TULIP_PCI_CSRSIZE;\n    tulip_csrptr_t csr_base; \n    tulip_chipid_t chipid = TULIP_CHIPID_UNKNOWN;\n\n    if (unit >= TULIP_MAX_DEVICES) {\n#ifdef __FreeBSD__\n\tprintf(\"de%d\", unit);\n#endif\n\tprintf(\": not configured; limit of %d reached or exceeded\\n\",\n\t       TULIP_MAX_DEVICES);\n\treturn;\n    }\n\n#if defined(__bsdi__)\n    if (pa != NULL) {\n\trevinfo = pci_inl(pa, PCI_CFRV) & 0xFF;\n\tid = pci_inl(pa, PCI_CFID);\n\tcfdainfo = pci_inl(pa, PCI_CFDA);\n#if defined(TULIP_EISA)\n    } else {\n\trevinfo = inl(ia->ia_iobase + DE425_CFRV) & 0xFF;\n\tcsroffset = TULIP_EISA_CSROFFSET;\n\tcsrsize = TULIP_EISA_CSRSIZE;\n\tchipid = TULIP_DE425;\n\tcfdainfo = 0;\n#endif /* TULIP_EISA */\n    }\n#else /* __bsdi__ */\n    revinfo  = PCI_CONF_READ(PCI_CFRV) & 0xFF;\n    id       = PCI_CONF_READ(PCI_CFID);\n    cfdainfo = PCI_CONF_READ(PCI_CFDA);\n#endif /* __bsdi__ */\n\n    if (PCI_VENDORID(id) == DEC_VENDORID) {\n\tif (PCI_CHIPID(id) == CHIPID_21040)\n\t\tchipid = TULIP_21040;\n\telse if (PCI_CHIPID(id) == CHIPID_21041)\n\t\tchipid = TULIP_21041;\n\telse if (PCI_CHIPID(id) == CHIPID_21140)\n\t\tchipid = (revinfo >= 0x20) ? TULIP_21140A : TULIP_21140;\n\telse if (PCI_CHIPID(id) == CHIPID_21142)\n\t        chipid = (revinfo >= 0x20) ? TULIP_21143 : TULIP_21142;\n    }\n\n    if (chipid == TULIP_CHIPID_UNKNOWN)\n\treturn;\n\n    if ((chipid == TULIP_21040 || chipid == TULIP_DE425) && revinfo < 0x20) {\n#ifdef __FreeBSD__\n\tprintf(\"de%d\", unit);\n#endif\n\tprintf(\": not configured; 21040 pass 2.0 required (%d.%d found)\\n\",\n\t       revinfo >> 4, revinfo & 0x0f);\n\treturn;\n    } else if (chipid == TULIP_21140 && revinfo < 0x11) {\n#ifndef __FreeBSD__\n\tprintf(\"\\n\");\n#endif\n\tprintf(\"de%d: not configured; 21140 pass 1.1 required (%d.%d found)\\n\",\n\t       unit, revinfo >> 4, revinfo & 0x0f);\n\treturn;\n    }\n\n#if defined(__FreeBSD__)\n    sc = (tulip_softc_t *) malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);\n    if (sc == NULL)\n\treturn;\n    bzero(sc, sizeof(*sc));\t\t\t\t/* Zero out the softc*/\n#endif\n\n    PCI_GETBUSDEVINFO(sc);\n    sc->tulip_chipid = chipid;\n    sc->tulip_flags |= TULIP_DEVICEPROBE;\n    if (chipid == TULIP_21140 || chipid == TULIP_21140A)\n\tsc->tulip_features |= TULIP_HAVE_GPR|TULIP_HAVE_STOREFWD;\n    if (chipid == TULIP_21140A && revinfo <= 0x22)\n\tsc->tulip_features |= TULIP_HAVE_RXBADOVRFLW;\n    if (chipid == TULIP_21140)\n\tsc->tulip_features |= TULIP_HAVE_BROKEN_HASH;\n    if (chipid != TULIP_21040 && chipid != TULIP_DE425 && chipid != TULIP_21140)\n\tsc->tulip_features |= TULIP_HAVE_POWERMGMT;\n    if (chipid == TULIP_21041 || chipid == TULIP_21142 || chipid == TULIP_21143) {\n\tsc->tulip_features |= TULIP_HAVE_DUALSENSE;\n\tif (chipid != TULIP_21041 || revinfo >= 0x20)\n\t    sc->tulip_features |= TULIP_HAVE_SIANWAY;\n\tif (chipid != TULIP_21041)\n\t    sc->tulip_features |= TULIP_HAVE_SIAGP|TULIP_HAVE_RXBADOVRFLW|TULIP_HAVE_STOREFWD;\n\tif (chipid != TULIP_21041 && revinfo >= 0x20)\n\t    sc->tulip_features |= TULIP_HAVE_SIA100;\n    }\n\n    if (sc->tulip_features & TULIP_HAVE_POWERMGMT\n\t    && (cfdainfo & (TULIP_CFDA_SLEEP|TULIP_CFDA_SNOOZE))) {\n\tcfdainfo &= ~(TULIP_CFDA_SLEEP|TULIP_CFDA_SNOOZE);\n\tPCI_CONF_WRITE(PCI_CFDA, cfdainfo);\n\tDELAY(11*1000);\n    }\n\n#if defined(__OpenBSD__)\n    /* XXX - csapuntz@lcs.mit.edu\n       OpenBSD + our PCI motherboard underflows consistently */\n    if (sc->tulip_features & TULIP_HAVE_STOREFWD)\n\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n#endif\n\n\n#if defined(__alpha__) && defined(__NetBSD__)\n    /*\n     * The Alpha SRM console encodes a console set media in the driver\n     * part of the CFDA register.  Note that the Multia presents a\n     * problem in that its BNC mode is really EXTSIA.  So in that case\n     * force a probe.\n     */\n    switch ((cfdainfo >> 8) & 0xff) {\n    case 1: media = chipid > TULIP_DE425 ?\n        TULIP_MEDIA_AUI : TULIP_MEDIA_AUIBNC; break;\n    case 2: media = chipid > TULIP_DE425 ?\n        TULIP_MEDIA_BNC : TULIP_MEDIA_UNKNOWN; break;\n    case 3: media = TULIP_MEDIA_10BASET; break;\n    case 4: media = TULIP_MEDIA_10BASET_FD; break;\n    case 5: media = TULIP_MEDIA_100BASETX; break;\n    case 6: media = TULIP_MEDIA_100BASETX_FD; break;\n    }\n#endif\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n    bcopy(self->dv_xname, sc->tulip_if.if_xname, IFNAMSIZ);\n    sc->tulip_if.if_softc = sc;\n    sc->tulip_pc = pa->pa_pc;\n#else\n    sc->tulip_unit = unit;\n    sc->tulip_name = \"de\";\n#endif\n    sc->tulip_revinfo = revinfo;\n#if defined(__FreeBSD__)\n#if BSD >= 199506\n    sc->tulip_if.if_softc = sc;\n#endif\n#if defined(TULIP_IOMAPPED)\n    retval = pci_map_port(config_id, PCI_CBIO, &csr_base);\n#else\n    retval = pci_map_mem(config_id, PCI_CBMA, (vm_offset_t *) &csr_base, &pa_csrs);\n#endif\n    if (!retval) {\n\tfree((caddr_t) sc, M_DEVBUF);\n\treturn;\n    }\n    tulips[unit] = sc;\n#endif /* __FreeBSD__ */\n\n#if defined(__bsdi__)\n    sc->tulip_pf = printf;\n#if defined(TULIP_IOMAPPED)\n    csr_base = ia->ia_iobase;\n#else\n    csr_base = (vm_offset_t) mapphys((vm_offset_t) ia->ia_maddr, ia->ia_msize);\n#endif\n#endif /* __bsdi__ */\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n    csr_base = 0;\n\n    ioh_valid = (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,\n\t\t &iot, &ioh, NULL, NULL) == 0);\n    memh_valid = (pci_mapreg_map(pa, PCI_CBMA,\n    \t\t  PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,\n\t\t  &memt, &memh, NULL, NULL) == 0);\n#endif\n\n#if defined(__OpenBSD__) || defined(__NetBSD__)\n#if defined(TULIP_IOMAPPED)\n    if (ioh_valid) {\n\tsc->tulip_bustag = iot;\n\tsc->tulip_bushandle = ioh;\n    } else if (memh_valid) {\n\tsc->tulip_bustag = memt;\n\tsc->tulip_bushandle = memh;\n    }\n#else /* defined(TULIP_IOMAPPED) */\n    if (memh_valid) {\n\tsc->tulip_bustag = memt;\n\tsc->tulip_bushandle = memh;\n    } else if (ioh_valid) {\n\tsc->tulip_bustag = iot;\n\tsc->tulip_bushandle = ioh;\n    }\n#endif /* TULIP_IOMAPPED */\n    else {\n        printf(\": unable to map device registers\\n\");\n        return;\n    }\n#endif /* __NetBSD__ */\n\n    tulip_initcsrs(sc, csr_base + csroffset, csrsize);\n    tulip_initring(sc, &sc->tulip_rxinfo, sc->tulip_rxdescs, TULIP_RXDESCS);\n    tulip_initring(sc, &sc->tulip_txinfo, sc->tulip_txdescs, TULIP_TXDESCS);\n\n    /*\n     * Make sure there won't be any interrupts or such...\n     */\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(100);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if ((retval = tulip_read_macaddr(sc)) < 0) {\n#if defined(__FreeBSD__)\n\tprintf(TULIP_PRINTF_FMT, TULIP_PRINTF_ARGS);\n#endif\n\tprintf(\": can't read ENET ROM (why=%d) (\", retval);\n\tfor (idx = 0; idx < 32; idx++)\n\t    printf(\"%02x\", sc->tulip_rombuf[idx]);\n\tprintf(\"\\n\");\n\tprintf(TULIP_PRINTF_FMT \": %s%s pass %d.%d address unknown\",\n\t       TULIP_PRINTF_ARGS,\n\t       sc->tulip_boardid, tulip_chipdescs[sc->tulip_chipid],\n\t       (sc->tulip_revinfo & 0xF0) >> 4, sc->tulip_revinfo & 0x0F);\n    } else {\n\ttulip_spl_t s;\n\ttulip_intrfunc_t (*intr_rtn)(void *) = tulip_intr_normal;\n\n\tif (sc->tulip_features & TULIP_HAVE_SHAREDINTR)\n\t    intr_rtn = tulip_intr_shared;\n\n#if defined(__NetBSD__) || defined(__OpenBSD__)\n\tif ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {\n\t    pci_intr_handle_t intrhandle;\n\t    const char *intrstr;\n\n\t    if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,\n\t\t\t     pa->pa_intrline, &intrhandle)) {\n\t\tprintf(\", couldn't map interrupt\\n\");\n\t\treturn;\n\t    }\n\t    intrstr = pci_intr_string(pa->pa_pc, intrhandle);\n\t    sc->tulip_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,\n\t\t\t\t\t      intr_rtn, sc, self->dv_xname);\n\t    if (sc->tulip_ih == NULL) {\n\t\tprintf(\", couldn't establish interrupt\",\n\t\t       sc->tulip_dev.dv_xname);\n\t\tif (intrstr != NULL)\n\t\t    printf(\" at %s\", intrstr);\n\t\tprintf(\"\\n\");\n\t\treturn;\n\t    }\n\t    printf(\": %s\", intrstr);\n\t}\n\tprintf(\"\\n\");\n\tsc->tulip_ats = shutdownhook_establish(tulip_shutdown, sc);\n\tif (sc->tulip_ats == NULL)\n\t    printf(\"%s: warning: couldn't establish shutdown hook\\n\",\n\t\t   sc->tulip_xname);\n#endif\n#if defined(__FreeBSD__)\n\tif ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {\n\t    if (!pci_map_int (config_id, intr_rtn, (void*) sc, &net_imask)) {\n\t\tprintf(TULIP_PRINTF_FMT \": couldn't map interrupt\\n\",\n\t\t       TULIP_PRINTF_ARGS);\n\t\treturn;\n\t    }\n\t}\n#if !defined(TULIP_DEVCONF)\n\tat_shutdown(tulip_shutdown, sc, SHUTDOWN_POST_SYNC);\n#endif\n#endif\n#if defined(__bsdi__)\n\tif ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {\n\t    isa_establish(&sc->tulip_id, &sc->tulip_dev);\n\n\t    sc->tulip_ih.ih_fun = intr_rtn;\n\t    sc->tulip_ih.ih_arg = (void *) sc;\n\t    intr_establish(ia->ia_irq, &sc->tulip_ih, DV_NET);\n\t}\n\n\tsc->tulip_ats.func = tulip_shutdown;\n\tsc->tulip_ats.arg = (void *) sc;\n\tatshutdown(&sc->tulip_ats, ATSH_ADD);\n#endif\n#if defined(TULIP_USE_SOFTINTR)\n\tif (sc->tulip_unit > tulip_softintr_max_unit)\n\t    tulip_softintr_max_unit = sc->tulip_unit;\n#endif\n\n\ts = TULIP_RAISESPL();\n\ttulip_reset(sc);\n\ttulip_attach(sc);\n#if defined(__alpha__) && defined(__NetBSD__)\n\tif (media != TULIP_MEDIA_UNKNOWN)\n\t    tulip_linkup(sc, media);\n#endif\n\tTULIP_RESTORESPL(s);\n    }\n}"
  },
  {
    "function_name": "tulip_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "5186-5195",
    "snippet": "static void\ntulip_shutdown(\n    TULIP_SHUTDOWN_ARGS)\n{\n    tulip_softc_t * const sc = arg;\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_SHUTDOWN_ARGS\tvoid *arg",
      "#define\tTULIP_SHUTDOWN_ARGS\tvoid *arg",
      "#define\tTULIP_SHUTDOWN_ARGS\tint howto, void * arg"
    ],
    "globals_used": [
      "static tulip_intrfunc_t tulip_intr_shared(void *arg);",
      "static tulip_intrfunc_t tulip_intr_normal(void *arg);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 5192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "TULIP_BUSMODE_SWRESET"
          ],
          "line": 5191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_SHUTDOWN_ARGS\tvoid *arg\n#define\tTULIP_SHUTDOWN_ARGS\tvoid *arg\n#define\tTULIP_SHUTDOWN_ARGS\tint howto, void * arg\n\nstatic tulip_intrfunc_t tulip_intr_shared(void *arg);\nstatic tulip_intrfunc_t tulip_intr_normal(void *arg);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_shutdown(\n    TULIP_SHUTDOWN_ARGS)\n{\n    tulip_softc_t * const sc = arg;\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n}"
  },
  {
    "function_name": "tulip_pci_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "5151-5172",
    "snippet": "static int\ntulip_pci_probe(\n    struct device *parent,\n#ifdef __BROKEN_INDIRECT_CONFIG\n    void *match,\n#else\n    struct cfdata *match,\n#endif\n    void *aux)\n{\n    struct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n    if (PCI_VENDORID(pa->pa_id) != DEC_VENDORID)\n\treturn 0;\n    if (PCI_CHIPID(pa->pa_id) == CHIPID_21040\n\t    || PCI_CHIPID(pa->pa_id) == CHIPID_21041\n\t    || PCI_CHIPID(pa->pa_id) == CHIPID_21140\n\t    || PCI_CHIPID(pa->pa_id) == CHIPID_21142)\n\treturn 1;\n\n    return 0;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "pci_devaddr_t *pa;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "pa->pa_id"
          ],
          "line": 5168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "pa->pa_id"
          ],
          "line": 5167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "pa->pa_id"
          ],
          "line": 5166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "pa->pa_id"
          ],
          "line": 5165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDORID",
          "args": [
            "pa->pa_id"
          ],
          "line": 5163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\npci_devaddr_t *pa;\n\nstatic int\ntulip_pci_probe(\n    struct device *parent,\n#ifdef __BROKEN_INDIRECT_CONFIG\n    void *match,\n#else\n    struct cfdata *match,\n#endif\n    void *aux)\n{\n    struct pci_attach_args *pa = (struct pci_attach_args *) aux;\n\n    if (PCI_VENDORID(pa->pa_id) != DEC_VENDORID)\n\treturn 0;\n    if (PCI_CHIPID(pa->pa_id) == CHIPID_21040\n\t    || PCI_CHIPID(pa->pa_id) == CHIPID_21041\n\t    || PCI_CHIPID(pa->pa_id) == CHIPID_21140\n\t    || PCI_CHIPID(pa->pa_id) == CHIPID_21142)\n\treturn 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "tulip_pci_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "5006-5026",
    "snippet": "static int\ntulip_pci_match(\n    pci_devaddr_t *pa)\n{\n    int irq;\n    unsigned id;\n\n    id = pci_inl(pa, PCI_VENDOR_ID);\n    if (PCI_VENDORID(id) != DEC_VENDORID)\n\treturn 0;\n    id = PCI_CHIPID(id);\n    if (id != CHIPID_21040 && id != CHIPID_21041\n\t    && id != CHIPID_21140 && id != CHIPID_21142)\n\treturn 0;\n    irq = pci_inl(pa, PCI_I_LINE) & 0xFF;\n    if (irq == 0 || irq >= 16) {\n\tprintf(\"de?: invalid IRQ %d; skipping\\n\", irq);\n\treturn 0;\n    }\n    return 1;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "pci_devaddr_t *pa;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"de?: invalid IRQ %d; skipping\\n\"",
            "irq"
          ],
          "line": 5022
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_inl",
          "args": [
            "pa",
            "PCI_I_LINE"
          ],
          "line": 5020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "id"
          ],
          "line": 5016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDORID",
          "args": [
            "id"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_inl",
          "args": [
            "pa",
            "PCI_VENDOR_ID"
          ],
          "line": 5013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\npci_devaddr_t *pa;\n\nstatic int\ntulip_pci_match(\n    pci_devaddr_t *pa)\n{\n    int irq;\n    unsigned id;\n\n    id = pci_inl(pa, PCI_VENDOR_ID);\n    if (PCI_VENDORID(id) != DEC_VENDORID)\n\treturn 0;\n    id = PCI_CHIPID(id);\n    if (id != CHIPID_21040 && id != CHIPID_21041\n\t    && id != CHIPID_21140 && id != CHIPID_21142)\n\treturn 0;\n    irq = pci_inl(pa, PCI_I_LINE) & 0xFF;\n    if (irq == 0 || irq >= 16) {\n\tprintf(\"de?: invalid IRQ %d; skipping\\n\", irq);\n\treturn 0;\n    }\n    return 1;\n}"
  },
  {
    "function_name": "tulip_pci_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4958-4984",
    "snippet": "static char*\ntulip_pci_probe(\n    pcici_t config_id,\n    pcidi_t device_id)\n{\n    if (PCI_VENDORID(device_id) != DEC_VENDORID)\n\treturn NULL;\n    if (PCI_CHIPID(device_id) == CHIPID_21040)\n\treturn \"Digital 21040 Ethernet\";\n    if (PCI_CHIPID(device_id) == CHIPID_21041)\n\treturn \"Digital 21041 Ethernet\";\n    if (PCI_CHIPID(device_id) == CHIPID_21140) {\n\tu_int32_t revinfo = pci_conf_read(config_id, PCI_CFRV) & 0xFF;\n\tif (revinfo >= 0x20)\n\t    return \"Digital 21140A Fast Ethernet\";\n\telse\n\t    return \"Digital 21140 Fast Ethernet\";\n    }\n    if (PCI_CHIPID(device_id) == CHIPID_21142) {\n\tu_int32_t revinfo = pci_conf_read(config_id, PCI_CFRV) & 0xFF;\n\tif (revinfo >= 0x20)\n\t    return \"Digital 21143 Fast Ethernet\";\n\telse\n\t    return \"Digital 21142 Fast Ethernet\";\n    }\n    return NULL;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tPCI_CFRV\t0x08\t/* Configuration Revision */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "config_id",
            "PCI_CFRV"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "device_id"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_conf_read",
          "args": [
            "config_id",
            "PCI_CFRV"
          ],
          "line": 4970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "device_id"
          ],
          "line": 4969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "device_id"
          ],
          "line": 4967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_CHIPID",
          "args": [
            "device_id"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_VENDORID",
          "args": [
            "device_id"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tPCI_CFRV\t0x08\t/* Configuration Revision */\n\nstatic char*\ntulip_pci_probe(\n    pcici_t config_id,\n    pcidi_t device_id)\n{\n    if (PCI_VENDORID(device_id) != DEC_VENDORID)\n\treturn NULL;\n    if (PCI_CHIPID(device_id) == CHIPID_21040)\n\treturn \"Digital 21040 Ethernet\";\n    if (PCI_CHIPID(device_id) == CHIPID_21041)\n\treturn \"Digital 21041 Ethernet\";\n    if (PCI_CHIPID(device_id) == CHIPID_21140) {\n\tu_int32_t revinfo = pci_conf_read(config_id, PCI_CFRV) & 0xFF;\n\tif (revinfo >= 0x20)\n\t    return \"Digital 21140A Fast Ethernet\";\n\telse\n\t    return \"Digital 21140 Fast Ethernet\";\n    }\n    if (PCI_CHIPID(device_id) == CHIPID_21142) {\n\tu_int32_t revinfo = pci_conf_read(config_id, PCI_CFRV) & 0xFF;\n\tif (revinfo >= 0x20)\n\t    return \"Digital 21143 Fast Ethernet\";\n\telse\n\t    return \"Digital 21142 Fast Ethernet\";\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "tulip_pci_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4943-4955",
    "snippet": "static int\ntulip_pci_shutdown(\n    struct kern_devconf * const kdc,\n    int force)\n{\n    if (kdc->kdc_unit < TULIP_MAX_DEVICES) {\n\ttulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(kdc->kdc_unit);\n\tif (sc != NULL)\n\t    tulip_shutdown(0, sc);\n    }\n    (void) dev_detach(kdc);\n    return 0;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_detach",
          "args": [
            "kdc"
          ],
          "line": 4953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_shutdown",
          "args": [
            "0",
            "sc"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_UNIT_TO_SOFTC",
          "args": [
            "kdc->kdc_unit"
          ],
          "line": 4949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_pci_shutdown(\n    struct kern_devconf * const kdc,\n    int force)\n{\n    if (kdc->kdc_unit < TULIP_MAX_DEVICES) {\n\ttulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(kdc->kdc_unit);\n\tif (sc != NULL)\n\t    tulip_shutdown(0, sc);\n    }\n    (void) dev_detach(kdc);\n    return 0;\n}"
  },
  {
    "function_name": "tulip_initring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4869-4914",
    "snippet": "static void\ntulip_initring(\n    tulip_softc_t * const sc,\n    tulip_ringinfo_t * const ri,\n    tulip_desc_t *descs,\n    int ndescs)\n{\n#if defined(__mips__)\n    tulip_desc_t *xdesc = descs;\n    /*\n     * Someone moved the descriptors into the softc struct.\n     * Avoid cache line conflicts by aligning on cache line.\n     */\n    descs = (tulip_desc_t *)(roundup((int)descs, 16));\n    if(xdesc != descs) {\n\tndescs--;\n    }\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)descs, ndescs * sizeof(tulip_desc_t));\n    descs = (tulip_desc_t *)TULIP_KVATOPHYS(sc, descs);\n    descs = (tulip_desc_t *)PHYS_TO_UNCACHED((int)descs & 0x3fffffff);\n#endif\n#ifdef PPC_MPC106_BUG\n    /*\n     * This is a workaround for the powerpc MPC106 chip not snooping\n     * accesses to the descriptor area correctly.\n     */\n    tulip_desc_t *xdesc = descs;\n    xdesc = (tulip_desc_t *)(roundup((int)descs, 32) - 4);\n    if(xdesc < descs) {\n\tndescs--;\n\txdesc++;\n    }\n    descs = xdesc;\n#endif\n    ri->ri_max = ndescs;\n    ri->ri_first = descs;\n    ri->ri_last = ri->ri_first + ri->ri_max;\n    bzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n    {\n\ttulip_desc_bitfield_t u;\n\t\t\n\tu.f = DESC_BO( ri->ri_last[-1].u.f );\n\tu.bd_flag = TULIP_DFLAG_ENDRING;\n\tri->ri_last[-1].u.f = DESC_BO(u.f);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DESC_BO",
          "args": [
            "u.f"
          ],
          "line": 4912
        },
        "resolved": true,
        "details": {
          "function_name": "DESC_BO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "104-114",
          "snippet": "__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\n__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "(caddr_t) ri->ri_first",
            "sizeof(ri->ri_first[0]) * ri->ri_max"
          ],
          "line": 4906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "(int)descs",
            "32"
          ],
          "line": 4896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_TO_UNCACHED",
          "args": [
            "(int)descs & 0x3fffffff"
          ],
          "line": 4888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_KVATOPHYS",
          "args": [
            "sc",
            "descs"
          ],
          "line": 4887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "sc->tulip_pc",
            "(vm_offset_t)descs",
            "ndescs * sizeof(tulip_desc_t)"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "(int)descs",
            "16"
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_initring(\n    tulip_softc_t * const sc,\n    tulip_ringinfo_t * const ri,\n    tulip_desc_t *descs,\n    int ndescs)\n{\n#if defined(__mips__)\n    tulip_desc_t *xdesc = descs;\n    /*\n     * Someone moved the descriptors into the softc struct.\n     * Avoid cache line conflicts by aligning on cache line.\n     */\n    descs = (tulip_desc_t *)(roundup((int)descs, 16));\n    if(xdesc != descs) {\n\tndescs--;\n    }\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)descs, ndescs * sizeof(tulip_desc_t));\n    descs = (tulip_desc_t *)TULIP_KVATOPHYS(sc, descs);\n    descs = (tulip_desc_t *)PHYS_TO_UNCACHED((int)descs & 0x3fffffff);\n#endif\n#ifdef PPC_MPC106_BUG\n    /*\n     * This is a workaround for the powerpc MPC106 chip not snooping\n     * accesses to the descriptor area correctly.\n     */\n    tulip_desc_t *xdesc = descs;\n    xdesc = (tulip_desc_t *)(roundup((int)descs, 32) - 4);\n    if(xdesc < descs) {\n\tndescs--;\n\txdesc++;\n    }\n    descs = xdesc;\n#endif\n    ri->ri_max = ndescs;\n    ri->ri_first = descs;\n    ri->ri_last = ri->ri_first + ri->ri_max;\n    bzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);\n    {\n\ttulip_desc_bitfield_t u;\n\t\t\n\tu.f = DESC_BO( ri->ri_last[-1].u.f );\n\tu.bd_flag = TULIP_DFLAG_ENDRING;\n\tri->ri_last[-1].u.f = DESC_BO(u.f);\n    }\n}"
  },
  {
    "function_name": "tulip_initcsrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4842-4867",
    "snippet": "static void\ntulip_initcsrs(\n    tulip_softc_t * const sc,\n    tulip_csrptr_t csr_base,\n    size_t csr_size)\n{\n    sc->tulip_csrs.csr_busmode\t\t= csr_base +  0 * csr_size;\n    sc->tulip_csrs.csr_txpoll\t\t= csr_base +  1 * csr_size;\n    sc->tulip_csrs.csr_rxpoll\t\t= csr_base +  2 * csr_size;\n    sc->tulip_csrs.csr_rxlist\t\t= csr_base +  3 * csr_size;\n    sc->tulip_csrs.csr_txlist\t\t= csr_base +  4 * csr_size;\n    sc->tulip_csrs.csr_status\t\t= csr_base +  5 * csr_size;\n    sc->tulip_csrs.csr_command\t\t= csr_base +  6 * csr_size;\n    sc->tulip_csrs.csr_intr\t\t= csr_base +  7 * csr_size;\n    sc->tulip_csrs.csr_missed_frames\t= csr_base +  8 * csr_size;\n    sc->tulip_csrs.csr_9\t\t= csr_base +  9 * csr_size;\n    sc->tulip_csrs.csr_10\t\t= csr_base + 10 * csr_size;\n    sc->tulip_csrs.csr_11\t\t= csr_base + 11 * csr_size;\n    sc->tulip_csrs.csr_12\t\t= csr_base + 12 * csr_size;\n    sc->tulip_csrs.csr_13\t\t= csr_base + 13 * csr_size;\n    sc->tulip_csrs.csr_14\t\t= csr_base + 14 * csr_size;\n    sc->tulip_csrs.csr_15\t\t= csr_base + 15 * csr_size;\n#if defined(TULIP_EISA)\n    sc->tulip_csrs.csr_enetrom\t\t= csr_base + DE425_ENETROM_OFFSET;\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_EISA"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_EISA\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_initcsrs(\n    tulip_softc_t * const sc,\n    tulip_csrptr_t csr_base,\n    size_t csr_size)\n{\n    sc->tulip_csrs.csr_busmode\t\t= csr_base +  0 * csr_size;\n    sc->tulip_csrs.csr_txpoll\t\t= csr_base +  1 * csr_size;\n    sc->tulip_csrs.csr_rxpoll\t\t= csr_base +  2 * csr_size;\n    sc->tulip_csrs.csr_rxlist\t\t= csr_base +  3 * csr_size;\n    sc->tulip_csrs.csr_txlist\t\t= csr_base +  4 * csr_size;\n    sc->tulip_csrs.csr_status\t\t= csr_base +  5 * csr_size;\n    sc->tulip_csrs.csr_command\t\t= csr_base +  6 * csr_size;\n    sc->tulip_csrs.csr_intr\t\t= csr_base +  7 * csr_size;\n    sc->tulip_csrs.csr_missed_frames\t= csr_base +  8 * csr_size;\n    sc->tulip_csrs.csr_9\t\t= csr_base +  9 * csr_size;\n    sc->tulip_csrs.csr_10\t\t= csr_base + 10 * csr_size;\n    sc->tulip_csrs.csr_11\t\t= csr_base + 11 * csr_size;\n    sc->tulip_csrs.csr_12\t\t= csr_base + 12 * csr_size;\n    sc->tulip_csrs.csr_13\t\t= csr_base + 13 * csr_size;\n    sc->tulip_csrs.csr_14\t\t= csr_base + 14 * csr_size;\n    sc->tulip_csrs.csr_15\t\t= csr_base + 15 * csr_size;\n#if defined(TULIP_EISA)\n    sc->tulip_csrs.csr_enetrom\t\t= csr_base + DE425_ENETROM_OFFSET;\n#endif\n}"
  },
  {
    "function_name": "tulip_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4737-4840",
    "snippet": "static void\ntulip_attach(\n    tulip_softc_t * const sc)\n{\n    struct ifnet * const ifp = &sc->tulip_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n    ifp->if_ioctl = tulip_ifioctl;\n    ifp->if_start = tulip_ifstart;\n    ifp->if_watchdog = tulip_ifwatchdog;\n    ifp->if_timer = 1;\n#if !defined(__bsdi__) || _BSDI_VERSION < 199401\n    ifp->if_output = ether_output;\n#endif\n#if defined(__bsdi__) && _BSDI_VERSION < 199401\n    ifp->if_mtu = ETHERMTU;\n#endif\n  \n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    aprint_naive(\": DEC Ethernet\");\n    aprint_normal(\": %s%s\", sc->tulip_boardid,\n        tulip_chipdescs[sc->tulip_chipid]);\n    aprint_verbose(\" pass %d.%d\", (sc->tulip_revinfo & 0xF0) >> 4,\n        sc->tulip_revinfo & 0x0F);\n    printf(\"\\n\");\n    sc->tulip_pf = aprint_normal;\n    aprint_normal(TULIP_PRINTF_FMT \": address \" TULIP_EADDR_FMT \"\\n\",\n\t\t  TULIP_PRINTF_ARGS,\n\t\t  TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#else\n    printf(\n#if defined(__bsdi__)\n\t   \"\\n\"\n#endif\n\t   TULIP_PRINTF_FMT \": %s%s pass %d.%d%s address \" TULIP_EADDR_FMT \"\\n\",\n\t   TULIP_PRINTF_ARGS,\n\t   sc->tulip_boardid,\n\t   tulip_chipdescs[sc->tulip_chipid],\n\t   (sc->tulip_revinfo & 0xF0) >> 4,\n\t   sc->tulip_revinfo & 0x0F,\n\t   (sc->tulip_features & (TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM))\n\t\t == TULIP_HAVE_ISVSROM ? \" (invalid EESPROM checksum)\" : \"\",\n\t   TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#endif\n\n#if defined(__alpha__)\n    /*\n     * In case the SRM console told us about a bogus media,\n     * we need to check to be safe.\n     */\n    if (sc->tulip_mediums[sc->tulip_media] == NULL)\n\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n#endif\n\n    (*sc->tulip_boardsw->bd_media_probe)(sc);\n#if defined(IFM_ETHER)\n    ifmedia_init(&sc->tulip_ifmedia, 0,\n\t\t tulip_ifmedia_change,\n\t\t tulip_ifmedia_status);\n#else\n    {\n\ttulip_media_t media;\n\tint cnt;\n\tprintf(TULIP_PRINTF_FMT \": media:\", TULIP_PRINTF_ARGS);\n\tfor (media = TULIP_MEDIA_UNKNOWN, cnt = 1; cnt < 7 && media < TULIP_MEDIA_MAX; media++) {\n\t    if (sc->tulip_mediums[media] != NULL) {\n\t\tprintf(\" %d=\\\"%s\\\"\", cnt, tulip_mediums[media]);\n\t\tcnt++;\n\t    }\n\t}\n\tif (cnt == 1) {\n\t    sc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\t    printf(\" none\\n\");\n\t} else {\n\t    printf(\"\\n\");\n\t}\n    }\n#endif\n    sc->tulip_flags &= ~TULIP_DEVICEPROBE;\n#if defined(IFM_ETHER)\n    tulip_ifmedia_add(sc);\n#endif\n\n    tulip_reset(sc);\n\n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    sc->tulip_pf = printf;\n    TULIP_ETHER_IFATTACH(sc);\n#else\n    if_attach(ifp);\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (defined(__FreeBSD__) && BSD >= 199506)\n    TULIP_ETHER_IFATTACH(sc);\n#endif\n#endif /* __bsdi__ */\n\n#if NBPFILTER > 0\n    TULIP_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n    rnd_attach_source(&sc->tulip_rndsource, sc->tulip_dev.dv_xname,\n\t\t      RND_TYPE_NET);\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define IFF_NOTRAILERS\t\t0",
      "#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct ifnet * const ifp = &sc->tulip_if;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd_attach_source",
          "args": [
            "&sc->tulip_rndsource",
            "sc->tulip_dev.dv_xname",
            "RND_TYPE_NET"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_BPF_ATTACH",
          "args": [
            "sc"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_ETHER_IFATTACH",
          "args": [
            "sc"
          ],
          "line": 4828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if_attach",
          "args": [
            "ifp"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_ETHER_IFATTACH",
          "args": [
            "sc"
          ],
          "line": 4824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 4820
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_ifmedia_add",
          "args": [
            "sc"
          ],
          "line": 4817
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_ifmedia_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3009-3035",
          "snippet": "static void\ntulip_ifmedia_add(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t media;\n    int medias = 0;\n\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tif (sc->tulip_mediums[media] != NULL) {\n\t    ifmedia_add(&sc->tulip_ifmedia, tulip_media_to_ifmedia[media],\n\t\t\t0, 0);\n\t    medias++;\n\t}\n    }\n    if (medias == 0) {\n\tsc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE);\n    } else if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO);\n    } else {\n\tifmedia_set(&sc->tulip_ifmedia, tulip_media_to_ifmedia[sc->tulip_media]);\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\ttulip_linkup(sc, sc->tulip_media);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_ifmedia_add(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t media;\n    int medias = 0;\n\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tif (sc->tulip_mediums[media] != NULL) {\n\t    ifmedia_add(&sc->tulip_ifmedia, tulip_media_to_ifmedia[media],\n\t\t\t0, 0);\n\t    medias++;\n\t}\n    }\n    if (medias == 0) {\n\tsc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE);\n    } else if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO);\n    } else {\n\tifmedia_set(&sc->tulip_ifmedia, tulip_media_to_ifmedia[sc->tulip_media]);\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\ttulip_linkup(sc, sc->tulip_media);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 4811
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_init",
          "args": [
            "&sc->tulip_ifmedia",
            "0",
            "tulip_ifmedia_change",
            "tulip_ifmedia_status"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_EADDR_ARGS",
          "args": [
            "sc->tulip_enaddr"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aprint_normal",
          "args": [
            "TULIP_PRINTF_FMT \": address \" TULIP_EADDR_FMT \"\\n\"",
            "TULIP_PRINTF_ARGS",
            "TULIP_EADDR_ARGS(sc->tulip_enaddr)"
          ],
          "line": 4763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_EADDR_ARGS",
          "args": [
            "sc->tulip_enaddr"
          ],
          "line": 4765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aprint_verbose",
          "args": [
            "\" pass %d.%d\"",
            "(sc->tulip_revinfo & 0xF0) >> 4",
            "sc->tulip_revinfo & 0x0F"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aprint_normal",
          "args": [
            "\": %s%s\"",
            "sc->tulip_boardid",
            "tulip_chipdescs[sc->tulip_chipid]"
          ],
          "line": 4757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aprint_naive",
          "args": [
            "\": DEC Ethernet\""
          ],
          "line": 4756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define IFF_NOTRAILERS\t\t0\n#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic void\ntulip_attach(\n    tulip_softc_t * const sc)\n{\n    struct ifnet * const ifp = &sc->tulip_if;\n\n    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;\n    ifp->if_ioctl = tulip_ifioctl;\n    ifp->if_start = tulip_ifstart;\n    ifp->if_watchdog = tulip_ifwatchdog;\n    ifp->if_timer = 1;\n#if !defined(__bsdi__) || _BSDI_VERSION < 199401\n    ifp->if_output = ether_output;\n#endif\n#if defined(__bsdi__) && _BSDI_VERSION < 199401\n    ifp->if_mtu = ETHERMTU;\n#endif\n  \n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    aprint_naive(\": DEC Ethernet\");\n    aprint_normal(\": %s%s\", sc->tulip_boardid,\n        tulip_chipdescs[sc->tulip_chipid]);\n    aprint_verbose(\" pass %d.%d\", (sc->tulip_revinfo & 0xF0) >> 4,\n        sc->tulip_revinfo & 0x0F);\n    printf(\"\\n\");\n    sc->tulip_pf = aprint_normal;\n    aprint_normal(TULIP_PRINTF_FMT \": address \" TULIP_EADDR_FMT \"\\n\",\n\t\t  TULIP_PRINTF_ARGS,\n\t\t  TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#else\n    printf(\n#if defined(__bsdi__)\n\t   \"\\n\"\n#endif\n\t   TULIP_PRINTF_FMT \": %s%s pass %d.%d%s address \" TULIP_EADDR_FMT \"\\n\",\n\t   TULIP_PRINTF_ARGS,\n\t   sc->tulip_boardid,\n\t   tulip_chipdescs[sc->tulip_chipid],\n\t   (sc->tulip_revinfo & 0xF0) >> 4,\n\t   sc->tulip_revinfo & 0x0F,\n\t   (sc->tulip_features & (TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM))\n\t\t == TULIP_HAVE_ISVSROM ? \" (invalid EESPROM checksum)\" : \"\",\n\t   TULIP_EADDR_ARGS(sc->tulip_enaddr));\n#endif\n\n#if defined(__alpha__)\n    /*\n     * In case the SRM console told us about a bogus media,\n     * we need to check to be safe.\n     */\n    if (sc->tulip_mediums[sc->tulip_media] == NULL)\n\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n#endif\n\n    (*sc->tulip_boardsw->bd_media_probe)(sc);\n#if defined(IFM_ETHER)\n    ifmedia_init(&sc->tulip_ifmedia, 0,\n\t\t tulip_ifmedia_change,\n\t\t tulip_ifmedia_status);\n#else\n    {\n\ttulip_media_t media;\n\tint cnt;\n\tprintf(TULIP_PRINTF_FMT \": media:\", TULIP_PRINTF_ARGS);\n\tfor (media = TULIP_MEDIA_UNKNOWN, cnt = 1; cnt < 7 && media < TULIP_MEDIA_MAX; media++) {\n\t    if (sc->tulip_mediums[media] != NULL) {\n\t\tprintf(\" %d=\\\"%s\\\"\", cnt, tulip_mediums[media]);\n\t\tcnt++;\n\t    }\n\t}\n\tif (cnt == 1) {\n\t    sc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\t    printf(\" none\\n\");\n\t} else {\n\t    printf(\"\\n\");\n\t}\n    }\n#endif\n    sc->tulip_flags &= ~TULIP_DEVICEPROBE;\n#if defined(IFM_ETHER)\n    tulip_ifmedia_add(sc);\n#endif\n\n    tulip_reset(sc);\n\n#if defined(__bsdi__) && _BSDI_VERSION >= 199510\n    sc->tulip_pf = printf;\n    TULIP_ETHER_IFATTACH(sc);\n#else\n    if_attach(ifp);\n#if defined(__NetBSD__) || defined(__OpenBSD__) || (defined(__FreeBSD__) && BSD >= 199506)\n    TULIP_ETHER_IFATTACH(sc);\n#endif\n#endif /* __bsdi__ */\n\n#if NBPFILTER > 0\n    TULIP_BPF_ATTACH(sc);\n#endif\n\n#if defined(__NetBSD__) && NRND > 0\n    rnd_attach_source(&sc->tulip_rndsource, sc->tulip_dev.dv_xname,\n\t\t      RND_TYPE_NET);\n#endif\n}"
  },
  {
    "function_name": "tulip_ifwatchdog_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4718-4723",
    "snippet": "static ifnet_ret_t\ntulip_ifwatchdog_wrapper(\n    int unit)\n{\n    tulip_ifwatchdog(&TULIP_UNIT_TO_SOFTC(unit)->tulip_if);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_ifwatchdog",
          "args": [
            "&TULIP_UNIT_TO_SOFTC(unit)->tulip_if"
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_ifwatchdog_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4718-4723",
          "snippet": "static ifnet_ret_t\ntulip_ifwatchdog_wrapper(\n    int unit)\n{\n    tulip_ifwatchdog(&TULIP_UNIT_TO_SOFTC(unit)->tulip_if);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_UNIT_TO_SOFTC",
          "args": [
            "unit"
          ],
          "line": 4722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper\n\nstatic ifnet_ret_t\ntulip_ifwatchdog_wrapper(\n    int unit)\n{\n    tulip_ifwatchdog(&TULIP_UNIT_TO_SOFTC(unit)->tulip_if);\n}"
  },
  {
    "function_name": "tulip_ifwatchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4642-4715",
    "snippet": "static void\ntulip_ifwatchdog(\n    struct ifnet *ifp)\n{\n    TULIP_PERFSTART(ifwatchdog)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n#if defined(TULIP_DEBUG)\n    u_int32_t rxintrs = sc->tulip_dbg.dbg_rxintrs - sc->tulip_dbg.dbg_last_rxintrs;\n    if (rxintrs > sc->tulip_dbg.dbg_high_rxintrs_hz)\n\tsc->tulip_dbg.dbg_high_rxintrs_hz = rxintrs;\n    sc->tulip_dbg.dbg_last_rxintrs = sc->tulip_dbg.dbg_rxintrs;\n#endif /* TULIP_DEBUG */\n\n    sc->tulip_if.if_timer = 1;\n    /*\n     * These should be rare so do a bulk test up front so we can just skip\n     * them if needed.\n     */\n    if (sc->tulip_flags & (TULIP_SYSTEMERROR|TULIP_RXBUFSLOW|TULIP_NOMESSAGES)) {\n\t/*\n\t * If the number of receive buffer is low, try to refill\n\t */\n\tif (sc->tulip_flags & TULIP_RXBUFSLOW)\n\t    tulip_rx_intr(sc);\n\n\tif (sc->tulip_flags & TULIP_SYSTEMERROR) {\n\t    printf(TULIP_PRINTF_FMT \": %d system errors: last was %s\\n\",\n\t\t   TULIP_PRINTF_ARGS, sc->tulip_system_errors,\n\t\t   tulip_system_errors[sc->tulip_last_system_error]);\n\t}\n\tif (sc->tulip_statusbits) {\n\t    tulip_print_abnormal_interrupt(sc, sc->tulip_statusbits);\n\t    sc->tulip_statusbits = 0;\n\t}\n\n\tsc->tulip_flags &= ~(TULIP_NOMESSAGES|TULIP_SYSTEMERROR);\n    }\n\n    if (sc->tulip_txtimer)\n\ttulip_tx_intr(sc);\n    if (sc->tulip_txtimer && --sc->tulip_txtimer == 0) {\n\tprintf(TULIP_PRINTF_FMT \": transmission timeout\\n\", TULIP_PRINTF_ARGS);\n\tif (TULIP_DO_AUTOSENSE(sc)) {\n\t    sc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\t    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t    sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP);\n\t}\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n\n    TULIP_PERFEND(ifwatchdog);\n    TULIP_PERFMERGE(sc, perf_intr_cycles);\n    TULIP_PERFMERGE(sc, perf_ifstart_cycles);\n    TULIP_PERFMERGE(sc, perf_ifioctl_cycles);\n    TULIP_PERFMERGE(sc, perf_ifwatchdog_cycles);\n    TULIP_PERFMERGE(sc, perf_timeout_cycles);\n    TULIP_PERFMERGE(sc, perf_ifstart_one_cycles);\n    TULIP_PERFMERGE(sc, perf_txput_cycles);\n    TULIP_PERFMERGE(sc, perf_txintr_cycles);\n    TULIP_PERFMERGE(sc, perf_rxintr_cycles);\n    TULIP_PERFMERGE(sc, perf_rxget_cycles);\n    TULIP_PERFMERGE(sc, perf_intr);\n    TULIP_PERFMERGE(sc, perf_ifstart);\n    TULIP_PERFMERGE(sc, perf_ifioctl);\n    TULIP_PERFMERGE(sc, perf_ifwatchdog);\n    TULIP_PERFMERGE(sc, perf_timeout);\n    TULIP_PERFMERGE(sc, perf_ifstart_one);\n    TULIP_PERFMERGE(sc, perf_txput);\n    TULIP_PERFMERGE(sc, perf_txintr);\n    TULIP_PERFMERGE(sc, perf_rxintr);\n    TULIP_PERFMERGE(sc, perf_rxget);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper",
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct ifnet * const ifp = &sc->tulip_if;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_rxget"
          ],
          "line": 4714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_rxintr"
          ],
          "line": 4713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_txintr"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_txput"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifstart_one"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_timeout"
          ],
          "line": 4709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifwatchdog"
          ],
          "line": 4708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifioctl"
          ],
          "line": 4707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifstart"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_intr"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_rxget_cycles"
          ],
          "line": 4704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_rxintr_cycles"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_txintr_cycles"
          ],
          "line": 4702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_txput_cycles"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifstart_one_cycles"
          ],
          "line": 4700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_timeout_cycles"
          ],
          "line": 4699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifwatchdog_cycles"
          ],
          "line": 4698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifioctl_cycles"
          ],
          "line": 4697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_ifstart_cycles"
          ],
          "line": 4696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFMERGE",
          "args": [
            "sc",
            "perf_intr_cycles"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "ifwatchdog"
          ],
          "line": 4694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_init",
          "args": [
            "sc"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3330-3371",
          "snippet": "static void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_DO_AUTOSENSE",
          "args": [
            "sc"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": transmission timeout\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 4684
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_tx_intr",
          "args": [
            "sc"
          ],
          "line": 4682
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_tx_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3624-3752",
          "snippet": "static int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_print_abnormal_interrupt",
          "args": [
            "sc",
            "sc->tulip_statusbits"
          ],
          "line": 4674
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_print_abnormal_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3754-3782",
          "snippet": "static void\ntulip_print_abnormal_interrupt(\n    tulip_softc_t * const sc,\n    u_int32_t csr)\n{\n    const char * const *msgp = tulip_status_bits;\n    const char *sep;\n    u_int32_t mask;\n    const char thrsh[] = \"72|128\\0\\0\\0\" \"96|256\\0\\0\\0\" \"128|512\\0\\0\" \"160|1024\\0\";\n\n    csr &= (1 << (sizeof(tulip_status_bits)/sizeof(tulip_status_bits[0]))) - 1;\n    printf(TULIP_PRINTF_FMT \": abnormal interrupt:\", TULIP_PRINTF_ARGS);\n    for (sep = \" \", mask = 1; mask <= csr; mask <<= 1, msgp++) {\n\tif ((csr & mask) && *msgp != NULL) {\n\t    printf(\"%s%s\", sep, *msgp);\n\t    if (mask == TULIP_STS_TXUNDERFLOW && (sc->tulip_flags & TULIP_NEWTXTHRESH)) {\n\t\tsc->tulip_flags &= ~TULIP_NEWTXTHRESH;\n\t\tif (sc->tulip_cmdmode & TULIP_CMD_STOREFWD) {\n\t\t    printf(\" (switching to store-and-forward mode)\");\n\t\t} else {\n\t\t    printf(\" (raising TX threshold to %s)\",\n\t\t\t   &thrsh[9 * ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) >> 14)]);\n\t\t}\n\t    }\n\t    sep = \", \";\n\t}\n    }\n    printf(\"\\n\");\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_print_abnormal_interrupt(\n    tulip_softc_t * const sc,\n    u_int32_t csr)\n{\n    const char * const *msgp = tulip_status_bits;\n    const char *sep;\n    u_int32_t mask;\n    const char thrsh[] = \"72|128\\0\\0\\0\" \"96|256\\0\\0\\0\" \"128|512\\0\\0\" \"160|1024\\0\";\n\n    csr &= (1 << (sizeof(tulip_status_bits)/sizeof(tulip_status_bits[0]))) - 1;\n    printf(TULIP_PRINTF_FMT \": abnormal interrupt:\", TULIP_PRINTF_ARGS);\n    for (sep = \" \", mask = 1; mask <= csr; mask <<= 1, msgp++) {\n\tif ((csr & mask) && *msgp != NULL) {\n\t    printf(\"%s%s\", sep, *msgp);\n\t    if (mask == TULIP_STS_TXUNDERFLOW && (sc->tulip_flags & TULIP_NEWTXTHRESH)) {\n\t\tsc->tulip_flags &= ~TULIP_NEWTXTHRESH;\n\t\tif (sc->tulip_cmdmode & TULIP_CMD_STOREFWD) {\n\t\t    printf(\" (switching to store-and-forward mode)\");\n\t\t} else {\n\t\t    printf(\" (raising TX threshold to %s)\",\n\t\t\t   &thrsh[9 * ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) >> 14)]);\n\t\t}\n\t    }\n\t    sep = \", \";\n\t}\n    }\n    printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_rx_intr",
          "args": [
            "sc"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 4647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\ttulip_ifwatchdog\ttulip_ifwatchdog_wrapper\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic void\ntulip_ifwatchdog(\n    struct ifnet *ifp)\n{\n    TULIP_PERFSTART(ifwatchdog)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n#if defined(TULIP_DEBUG)\n    u_int32_t rxintrs = sc->tulip_dbg.dbg_rxintrs - sc->tulip_dbg.dbg_last_rxintrs;\n    if (rxintrs > sc->tulip_dbg.dbg_high_rxintrs_hz)\n\tsc->tulip_dbg.dbg_high_rxintrs_hz = rxintrs;\n    sc->tulip_dbg.dbg_last_rxintrs = sc->tulip_dbg.dbg_rxintrs;\n#endif /* TULIP_DEBUG */\n\n    sc->tulip_if.if_timer = 1;\n    /*\n     * These should be rare so do a bulk test up front so we can just skip\n     * them if needed.\n     */\n    if (sc->tulip_flags & (TULIP_SYSTEMERROR|TULIP_RXBUFSLOW|TULIP_NOMESSAGES)) {\n\t/*\n\t * If the number of receive buffer is low, try to refill\n\t */\n\tif (sc->tulip_flags & TULIP_RXBUFSLOW)\n\t    tulip_rx_intr(sc);\n\n\tif (sc->tulip_flags & TULIP_SYSTEMERROR) {\n\t    printf(TULIP_PRINTF_FMT \": %d system errors: last was %s\\n\",\n\t\t   TULIP_PRINTF_ARGS, sc->tulip_system_errors,\n\t\t   tulip_system_errors[sc->tulip_last_system_error]);\n\t}\n\tif (sc->tulip_statusbits) {\n\t    tulip_print_abnormal_interrupt(sc, sc->tulip_statusbits);\n\t    sc->tulip_statusbits = 0;\n\t}\n\n\tsc->tulip_flags &= ~(TULIP_NOMESSAGES|TULIP_SYSTEMERROR);\n    }\n\n    if (sc->tulip_txtimer)\n\ttulip_tx_intr(sc);\n    if (sc->tulip_txtimer && --sc->tulip_txtimer == 0) {\n\tprintf(TULIP_PRINTF_FMT \": transmission timeout\\n\", TULIP_PRINTF_ARGS);\n\tif (TULIP_DO_AUTOSENSE(sc)) {\n\t    sc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\t    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t    sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP);\n\t}\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n\n    TULIP_PERFEND(ifwatchdog);\n    TULIP_PERFMERGE(sc, perf_intr_cycles);\n    TULIP_PERFMERGE(sc, perf_ifstart_cycles);\n    TULIP_PERFMERGE(sc, perf_ifioctl_cycles);\n    TULIP_PERFMERGE(sc, perf_ifwatchdog_cycles);\n    TULIP_PERFMERGE(sc, perf_timeout_cycles);\n    TULIP_PERFMERGE(sc, perf_ifstart_one_cycles);\n    TULIP_PERFMERGE(sc, perf_txput_cycles);\n    TULIP_PERFMERGE(sc, perf_txintr_cycles);\n    TULIP_PERFMERGE(sc, perf_rxintr_cycles);\n    TULIP_PERFMERGE(sc, perf_rxget_cycles);\n    TULIP_PERFMERGE(sc, perf_intr);\n    TULIP_PERFMERGE(sc, perf_ifstart);\n    TULIP_PERFMERGE(sc, perf_ifioctl);\n    TULIP_PERFMERGE(sc, perf_ifwatchdog);\n    TULIP_PERFMERGE(sc, perf_timeout);\n    TULIP_PERFMERGE(sc, perf_ifstart_one);\n    TULIP_PERFMERGE(sc, perf_txput);\n    TULIP_PERFMERGE(sc, perf_txintr);\n    TULIP_PERFMERGE(sc, perf_rxintr);\n    TULIP_PERFMERGE(sc, perf_rxget);\n}"
  },
  {
    "function_name": "tulip_ifstart_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4618-4633",
    "snippet": "static ifnet_ret_t\ntulip_ifstart_one(\n    struct ifnet * const ifp)\n{\n    TULIP_PERFSTART(ifstart_one)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    if ((sc->tulip_if.if_flags & IFF_RUNNING)\n\t    && sc->tulip_if.if_snd.ifq_head != NULL) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_if.if_snd, m);\n\tif ((m = tulip_txput(sc, m)) != NULL)\n\t    IF_PREPEND(&sc->tulip_if.if_snd, m);\n    }\n    TULIP_PERFEND(ifstart_one);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
      "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct ifnet * const ifp = &sc->tulip_if;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "ifstart_one"
          ],
          "line": 4632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&sc->tulip_if.if_snd",
            "m"
          ],
          "line": 4630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_txput",
          "args": [
            "sc",
            "m"
          ],
          "line": 4629
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_txput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4097-4324",
          "snippet": "static struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;",
            "tulip_desc_t *eop = ri->ri_nextin;",
            "struct mbuf *m0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\ntulip_desc_t *eop = ri->ri_nextin;\nstruct mbuf *m0;\n\nstatic struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->tulip_if.if_snd",
            "m"
          ],
          "line": 4628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 4623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic ifnet_ret_t\ntulip_ifstart_one(\n    struct ifnet * const ifp)\n{\n    TULIP_PERFSTART(ifstart_one)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    if ((sc->tulip_if.if_flags & IFF_RUNNING)\n\t    && sc->tulip_if.if_snd.ifq_head != NULL) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_if.if_snd, m);\n\tif ((m = tulip_txput(sc, m)) != NULL)\n\t    IF_PREPEND(&sc->tulip_if.if_snd, m);\n    }\n    TULIP_PERFEND(ifstart_one);\n}"
  },
  {
    "function_name": "tulip_ifstart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4591-4616",
    "snippet": "static ifnet_ret_t\ntulip_ifstart(\n    struct ifnet * const ifp)\n{\n    TULIP_PERFSTART(ifstart)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    if (sc->tulip_if.if_flags & IFF_RUNNING) {\n\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n\n\twhile (sc->tulip_if.if_snd.ifq_head != NULL) {\n\t    struct mbuf *m;\n\t    IF_DEQUEUE(&sc->tulip_if.if_snd, m);\n\t    if ((m = tulip_txput(sc, m)) != NULL) {\n\t\tIF_PREPEND(&sc->tulip_if.if_snd, m);\n\t\tbreak;\n\t    }\n\t}\n\tif (sc->tulip_if.if_snd.ifq_head == NULL)\n\t    sc->tulip_if.if_start = tulip_ifstart_one;\n    }\n\n    TULIP_PERFEND(ifstart);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
      "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct ifnet * const ifp = &sc->tulip_if;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "ifstart"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_PREPEND",
          "args": [
            "&sc->tulip_if.if_snd",
            "m"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_txput",
          "args": [
            "sc",
            "m"
          ],
          "line": 4606
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_txput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4097-4324",
          "snippet": "static struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;",
            "tulip_desc_t *eop = ri->ri_nextin;",
            "struct mbuf *m0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\ntulip_desc_t *eop = ri->ri_nextin;\nstruct mbuf *m0;\n\nstatic struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->tulip_if.if_snd",
            "m"
          ],
          "line": 4605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_txput_setup",
          "args": [
            "sc"
          ],
          "line": 4601
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_txput_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4326-4411",
          "snippet": "static void\ntulip_txput_setup(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *nextout;\n\t\n    /*\n     * We will transmit, at most, one setup packet per call to ifstart.\n     */\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput_setup: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS);\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n#endif\n    /*\n     * Try to reclaim some free descriptors..\n     */\n    if (ri->ri_free < 2)\n\ttulip_tx_intr(sc);\n    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,\n\t  sizeof(sc->tulip_setupbuf));\n    /*\n     * Clear WANTSETUP and set DOINGSETUP.  Set know that WANTSETUP is\n     * set and DOINGSETUP is clear doing an XOR of the two will DTRT.\n     */\n    sc->tulip_flags ^= TULIP_WANTSETUP|TULIP_DOINGSETUP;\n    ri->ri_free--;\n#if defined(__mips__)\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));\n#endif\n    nextout = ri->ri_nextout;\n    {\n\tu_int32_t d_flag;\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(nextout->u.f); /* copy the bitfields */\n\td_flag = u.bd_flag;\n\n\td_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\td_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG\n\t    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;\n\tif (sc->tulip_flags & TULIP_WANTHASHPERFECT)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT;\n\telse if (sc->tulip_flags & TULIP_WANTHASHONLY)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;\n\n\n\tu.bd_flag = d_flag;\n\tu.bd_length1 = sizeof(sc->tulip_setupbuf);\n\tu.bd_length2 = 0;\n\n\tnextout->u.f = DESC_BO(u.f);\n\tnextout->d_addr1 = DESC_BO(TULIP_KVATOPHYS(sc, sc->tulip_setupbuf));\n\tnextout->d_addr2 = 0; /* no need to swab */\n    }\n\n    /*\n     * Advance the ring for the next transmit packet.\n     */\n    if (++ri->ri_nextout == ri->ri_last)\n\tri->ri_nextout = ri->ri_first;\n\n    /*\n     * Make sure the next descriptor is owned by us since it\n     * may have been set up above if we ran out of room in the\n     * ring.\n     */\n    ri->ri_nextout->d_status = 0; /* doesn't need swab - dsr */\n    nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n    if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\tsc->tulip_intrmask |= TULIP_STS_TXINTR;\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_txput_setup(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *nextout;\n\t\n    /*\n     * We will transmit, at most, one setup packet per call to ifstart.\n     */\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput_setup: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS);\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n#endif\n    /*\n     * Try to reclaim some free descriptors..\n     */\n    if (ri->ri_free < 2)\n\ttulip_tx_intr(sc);\n    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,\n\t  sizeof(sc->tulip_setupbuf));\n    /*\n     * Clear WANTSETUP and set DOINGSETUP.  Set know that WANTSETUP is\n     * set and DOINGSETUP is clear doing an XOR of the two will DTRT.\n     */\n    sc->tulip_flags ^= TULIP_WANTSETUP|TULIP_DOINGSETUP;\n    ri->ri_free--;\n#if defined(__mips__)\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));\n#endif\n    nextout = ri->ri_nextout;\n    {\n\tu_int32_t d_flag;\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(nextout->u.f); /* copy the bitfields */\n\td_flag = u.bd_flag;\n\n\td_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\td_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG\n\t    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;\n\tif (sc->tulip_flags & TULIP_WANTHASHPERFECT)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT;\n\telse if (sc->tulip_flags & TULIP_WANTHASHONLY)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;\n\n\n\tu.bd_flag = d_flag;\n\tu.bd_length1 = sizeof(sc->tulip_setupbuf);\n\tu.bd_length2 = 0;\n\n\tnextout->u.f = DESC_BO(u.f);\n\tnextout->d_addr1 = DESC_BO(TULIP_KVATOPHYS(sc, sc->tulip_setupbuf));\n\tnextout->d_addr2 = 0; /* no need to swab */\n    }\n\n    /*\n     * Advance the ring for the next transmit packet.\n     */\n    if (++ri->ri_nextout == ri->ri_last)\n\tri->ri_nextout = ri->ri_first;\n\n    /*\n     * Make sure the next descriptor is owned by us since it\n     * may have been set up above if we ran out of room in the\n     * ring.\n     */\n    ri->ri_nextout->d_status = 0; /* doesn't need swab - dsr */\n    nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n    if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\tsc->tulip_intrmask |= TULIP_STS_TXINTR;\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic ifnet_ret_t\ntulip_ifstart(\n    struct ifnet * const ifp)\n{\n    TULIP_PERFSTART(ifstart)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    if (sc->tulip_if.if_flags & IFF_RUNNING) {\n\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n\n\twhile (sc->tulip_if.if_snd.ifq_head != NULL) {\n\t    struct mbuf *m;\n\t    IF_DEQUEUE(&sc->tulip_if.if_snd, m);\n\t    if ((m = tulip_txput(sc, m)) != NULL) {\n\t\tIF_PREPEND(&sc->tulip_if.if_snd, m);\n\t\tbreak;\n\t    }\n\t}\n\tif (sc->tulip_if.if_snd.ifq_head == NULL)\n\t    sc->tulip_if.if_start = tulip_ifstart_one;\n    }\n\n    TULIP_PERFEND(ifstart);\n}"
  },
  {
    "function_name": "tulip_ifioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4419-4583",
    "snippet": "static int\ntulip_ifioctl(\n    struct ifnet * ifp,\n    ioctl_cmd_t cmd,\n    caddr_t data)\n{\n    TULIP_PERFSTART(ifioctl)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n    struct ifaddr *ifa = (struct ifaddr *)data;\n    struct ifreq *ifr = (struct ifreq *) data;\n    tulip_spl_t s;\n    int error = 0;\n\n#if defined(TULIP_USE_SOFTINTR)\n    s = TULIP_RAISESOFTSPL();\n#else\n    s = TULIP_RAISESPL();\n#endif\n    switch (cmd) {\n    case SIOCSIFADDR: {\n\tifp->if_flags |= IFF_UP;\n\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\tcase AF_INET: {\n\t    tulip_init(sc);\n\t    TULIP_ARP_IFINIT(sc, ifa);\n\t    break;\n\t}\n#endif /* INET */\n\n#ifdef NS\n\t    /*\n\t     * This magic copied from if_is.c; I don't use XNS,\n\t     * so I have no way of telling if this actually\n\t     * works or not.\n\t     */\n\tcase AF_NS: {\n\t    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);\n\t    if (ns_nullhost(*ina)) {\n\t\tina->x_host = *(union ns_host *)(sc->tulip_enaddr);\n\t    } else {\n\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\tbcopy((caddr_t)ina->x_host.c_host,\n\t\t      (caddr_t)sc->tulip_enaddr,\n\t\t      sizeof(sc->tulip_enaddr));\n\t    }\n\t    tulip_init(sc);\n\t    break;\n\t}\n#endif /* NS */\n\n\tdefault: {\n\t    tulip_init(sc);\n\t    break;\n\t}\n\t}\n\tbreak;\n    }\n    case SIOCGIFADDR: {\n\tbcopy((caddr_t) sc->tulip_enaddr,\n\t      (caddr_t) ((struct sockaddr *)&ifr->ifr_data)->sa_data,\n\t      6);\n\tbreak;\n    }\n\n    case SIOCSIFFLAGS: {\n#if !defined(IFM_ETHER)\n\tint flags = 0;\n\tif (ifp->if_flags & IFF_LINK0) flags |= 1;\n\tif (ifp->if_flags & IFF_LINK1) flags |= 2;\n\tif (ifp->if_flags & IFF_LINK2) flags |= 4;\n\tif (flags == 7) {\n\t    ifp->if_flags &= ~(IFF_LINK0|IFF_LINK1|IFF_LINK2);\n\t    sc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\t    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t    sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP|TULIP_NOAUTOSENSE);\n\t    tulip_reset(sc);\n\t} else if (flags) {\n\t    tulip_media_t media;\n\t    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\t\tif (sc->tulip_mediums[media] != NULL && --flags == 0) {\n\t\t    sc->tulip_flags |= TULIP_NOAUTOSENSE;\n\t\t    if (sc->tulip_media != media || (sc->tulip_flags & TULIP_DIDNWAY)) {\n\t\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\t\ttulip_linkup(sc, media);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t    if (flags)\n\t\tprintf(TULIP_PRINTF_FMT \": ignored invalid media request\\n\", TULIP_PRINTF_ARGS);\n\t}\n#endif\n\ttulip_init(sc);\n\tbreak;\n    }\n\n#if defined(SIOCSIFMEDIA)\n    case SIOCSIFMEDIA:\n    case SIOCGIFMEDIA: {\n\terror = ifmedia_ioctl(ifp, ifr, &sc->tulip_ifmedia, cmd);\n\tbreak;\n    }\n#endif\n\n    case SIOCADDMULTI:\n    case SIOCDELMULTI: {\n\t/*\n\t * Update multicast listeners\n\t */\n\tif (cmd == SIOCADDMULTI)\n\t    error = ether_addmulti(ifr, TULIP_ETHERCOM(sc));\n\telse\n\t    error = ether_delmulti(ifr, TULIP_ETHERCOM(sc));\n\n\tif (error == ENETRESET) {\n\t    tulip_addr_filter(sc); /* reset multicast filtering */\n\t    tulip_init(sc);\n\t    error = 0;\n\t}\n\tbreak;\n    }\n    case SIOCSIFMTU:\n\t/*\n\t * Set the interface MTU.\n\t */\n\tif (ifr->ifr_mtu > ETHERMTU\n#ifdef BIG_PACKET\n\t    && sc->tulip_chipid != TULIP_21140\n\t    && sc->tulip_chipid != TULIP_21140A\n\t    && sc->tulip_chipid != TULIP_21041\n#endif\n\t    ) {\n\t    error = EINVAL;\n\t    break;\n\t}\n\tifp->if_mtu = ifr->ifr_mtu;\n#ifdef BIG_PACKET\n\ttulip_reset(sc);\n\ttulip_init(sc);\n#endif\n\tbreak;\n\n#ifdef SIOCGADDRROM\n    case SIOCGADDRROM: {\n\terror = copyout(sc->tulip_rombuf, ifr->ifr_data, sizeof(sc->tulip_rombuf));\n\tbreak;\n    }\n#endif\n#ifdef SIOCGCHIPID\n    case SIOCGCHIPID: {\n\tifr->ifr_metric = (int) sc->tulip_chipid;\n\tbreak;\n    }\n#endif\n    default: {\n\terror = EINVAL;\n\tbreak;\n    }\n    }\n\n    TULIP_RESTORESPL(s);\n    TULIP_PERFEND(ifioctl);\n    return error;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_USE_SOFTINTR"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct ifnet * const ifp = &sc->tulip_if;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "ifioctl"
          ],
          "line": 4581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_RESTORESPL",
          "args": [
            "s"
          ],
          "line": 4580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copyout",
          "args": [
            "sc->tulip_rombuf",
            "ifr->ifr_data",
            "sizeof(sc->tulip_rombuf)"
          ],
          "line": 4564
        },
        "resolved": true,
        "details": {
          "function_name": "audio_silence_copyout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/audio.c",
          "lines": "1249-1268",
          "snippet": "int\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}",
          "includes": [
            "#include <machine/endian.h>",
            "#include <vm/vm_prot.h>",
            "#include <vm/vm.h>",
            "#include <dev/rndvar.h>",
            "#include <dev/audiovar.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"audio.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <machine/endian.h>\n#include <vm/vm_prot.h>\n#include <vm/vm.h>\n#include <dev/rndvar.h>\n#include <dev/audiovar.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"audio.h\"\n\nint\naudio_silence_copyout(sc, n, uio)\n\tstruct audio_softc *sc;\n\tint n;\n\tstruct uio *uio;\n{\n\tint error;\n\tint k;\n\tu_char zerobuf[128];\n\n\taudio_fill_silence(&sc->sc_rparams, zerobuf, sizeof zerobuf);\n\n\terror = 0;\n        while (n > 0 && uio->uio_resid > 0 && !error) {\n\t\tk = min(n, min(uio->uio_resid, sizeof zerobuf));\n\t\terror = uiomove(zerobuf, k, uio);\n\t\tn -= k;\n\t}\n        return (error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_init",
          "args": [
            "sc"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3330-3371",
          "snippet": "static void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_addr_filter",
          "args": [
            "sc"
          ],
          "line": 4535
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_addr_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3093-3197",
          "snippet": "static void\ntulip_addr_filter(\n    tulip_softc_t * const sc)\n{\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    sc->tulip_flags &= ~(TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY|TULIP_ALLMULTI);\n    sc->tulip_flags |= TULIP_WANTSETUP|TULIP_WANTTXSTART;\n    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n#if defined(IFF_ALLMULTI)    \n    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;\n#endif\n    sc->tulip_if.if_start = tulip_ifstart;\t/* so the setup packet gets queued */\n    if (sc->tulip_multicnt > 14) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tunsigned hash;\n\t/*\n\t * Some early passes of the 21140 have broken implementations of\n\t * hash-perfect mode.  When we get too many multicasts for perfect\n\t * filtering with these chips, we need to switch into hash-only\n\t * mode (this is better than all-multicast on network with lots\n\t * of multicast traffic).\n\t */\n\tif (sc->tulip_features & TULIP_HAVE_BROKEN_HASH)\n\t    sc->tulip_flags |= TULIP_WANTHASHONLY;\n\telse\n\t    sc->tulip_flags |= TULIP_WANTHASHPERFECT;\n\t/*\n\t * If we have more than 14 multicasts, we have\n\t * go into hash perfect mode (512 bit multicast\n\t * hash and one perfect hardware).\n\t */\n\tbzero(sc->tulip_setupdata, sizeof(sc->tulip_setupdata));\n\tETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    hash = tulip_mchash(enm->enm_addrlo);\n\t\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t/*\n\t * No reason to use a hash if we are going to be\n\t * receiving every multicast.\n\t */\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    hash = tulip_mchash(etherbroadcastaddr);\n\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    if (sc->tulip_flags & TULIP_WANTHASHONLY) {\n\t\thash = tulip_mchash(sc->tulip_enaddr);\n\t\tsp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    } else {\n\t\tsp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t\tsp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t\tsp[41] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t    }\n\t}\n    }\n    if ((sc->tulip_flags & (TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY)) == 0) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tint idx = 0;\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    /*\n\t     * Else can get perfect filtering for 16 addresses.\n\t     */\n\t    ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\t    for (; enm != NULL; idx++) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[2]);\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t    }\n\t    /*\n\t     * Add the broadcast address.\n\t     */\n\t    idx++;\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t}\n\t/*\n\t * Pad the rest with our hardware address\n\t */\n\tfor (; idx < 16; idx++) {\n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t}\n    }\n#if defined(IFF_ALLMULTI)\n    if (sc->tulip_flags & TULIP_ALLMULTI)\n\tsc->tulip_if.if_flags |= IFF_ALLMULTI;\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_addr_filter(\n    tulip_softc_t * const sc)\n{\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    sc->tulip_flags &= ~(TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY|TULIP_ALLMULTI);\n    sc->tulip_flags |= TULIP_WANTSETUP|TULIP_WANTTXSTART;\n    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n#if defined(IFF_ALLMULTI)    \n    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;\n#endif\n    sc->tulip_if.if_start = tulip_ifstart;\t/* so the setup packet gets queued */\n    if (sc->tulip_multicnt > 14) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tunsigned hash;\n\t/*\n\t * Some early passes of the 21140 have broken implementations of\n\t * hash-perfect mode.  When we get too many multicasts for perfect\n\t * filtering with these chips, we need to switch into hash-only\n\t * mode (this is better than all-multicast on network with lots\n\t * of multicast traffic).\n\t */\n\tif (sc->tulip_features & TULIP_HAVE_BROKEN_HASH)\n\t    sc->tulip_flags |= TULIP_WANTHASHONLY;\n\telse\n\t    sc->tulip_flags |= TULIP_WANTHASHPERFECT;\n\t/*\n\t * If we have more than 14 multicasts, we have\n\t * go into hash perfect mode (512 bit multicast\n\t * hash and one perfect hardware).\n\t */\n\tbzero(sc->tulip_setupdata, sizeof(sc->tulip_setupdata));\n\tETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    hash = tulip_mchash(enm->enm_addrlo);\n\t\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t/*\n\t * No reason to use a hash if we are going to be\n\t * receiving every multicast.\n\t */\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    hash = tulip_mchash(etherbroadcastaddr);\n\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    if (sc->tulip_flags & TULIP_WANTHASHONLY) {\n\t\thash = tulip_mchash(sc->tulip_enaddr);\n\t\tsp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    } else {\n\t\tsp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t\tsp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t\tsp[41] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t    }\n\t}\n    }\n    if ((sc->tulip_flags & (TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY)) == 0) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tint idx = 0;\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    /*\n\t     * Else can get perfect filtering for 16 addresses.\n\t     */\n\t    ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\t    for (; enm != NULL; idx++) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[2]);\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t    }\n\t    /*\n\t     * Add the broadcast address.\n\t     */\n\t    idx++;\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t}\n\t/*\n\t * Pad the rest with our hardware address\n\t */\n\tfor (; idx < 16; idx++) {\n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t}\n    }\n#if defined(IFF_ALLMULTI)\n    if (sc->tulip_flags & TULIP_ALLMULTI)\n\tsc->tulip_if.if_flags |= IFF_ALLMULTI;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ether_delmulti",
          "args": [
            "ifr",
            "TULIP_ETHERCOM(sc)"
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_ETHERCOM",
          "args": [
            "sc"
          ],
          "line": 4532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ether_addmulti",
          "args": [
            "ifr",
            "TULIP_ETHERCOM(sc)"
          ],
          "line": 4530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_ETHERCOM",
          "args": [
            "sc"
          ],
          "line": 4530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_ioctl",
          "args": [
            "ifp",
            "ifr",
            "&sc->tulip_ifmedia",
            "cmd"
          ],
          "line": 4519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": ignored invalid media request\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 4509
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_linkup",
          "args": [
            "sc",
            "media"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_linkup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "384-436",
          "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t) sc->tulip_enaddr",
            "(caddr_t) ((struct sockaddr *)&ifr->ifr_data)->sa_data",
            "6"
          ],
          "line": 4478
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(struct sockaddr *)&ifr->ifr_data"
          ],
          "line": 4479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_nullhost",
          "args": [
            "*ina"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IA_SNS",
          "args": [
            "ifa"
          ],
          "line": 4456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_ARP_IFINIT",
          "args": [
            "sc",
            "ifa"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_RAISESPL",
          "args": [],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_RAISESOFTSPL",
          "args": [],
          "line": 4433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_USE_SOFTINTR\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic int\ntulip_ifioctl(\n    struct ifnet * ifp,\n    ioctl_cmd_t cmd,\n    caddr_t data)\n{\n    TULIP_PERFSTART(ifioctl)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n    struct ifaddr *ifa = (struct ifaddr *)data;\n    struct ifreq *ifr = (struct ifreq *) data;\n    tulip_spl_t s;\n    int error = 0;\n\n#if defined(TULIP_USE_SOFTINTR)\n    s = TULIP_RAISESOFTSPL();\n#else\n    s = TULIP_RAISESPL();\n#endif\n    switch (cmd) {\n    case SIOCSIFADDR: {\n\tifp->if_flags |= IFF_UP;\n\tswitch(ifa->ifa_addr->sa_family) {\n#ifdef INET\n\tcase AF_INET: {\n\t    tulip_init(sc);\n\t    TULIP_ARP_IFINIT(sc, ifa);\n\t    break;\n\t}\n#endif /* INET */\n\n#ifdef NS\n\t    /*\n\t     * This magic copied from if_is.c; I don't use XNS,\n\t     * so I have no way of telling if this actually\n\t     * works or not.\n\t     */\n\tcase AF_NS: {\n\t    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);\n\t    if (ns_nullhost(*ina)) {\n\t\tina->x_host = *(union ns_host *)(sc->tulip_enaddr);\n\t    } else {\n\t\tifp->if_flags &= ~IFF_RUNNING;\n\t\tbcopy((caddr_t)ina->x_host.c_host,\n\t\t      (caddr_t)sc->tulip_enaddr,\n\t\t      sizeof(sc->tulip_enaddr));\n\t    }\n\t    tulip_init(sc);\n\t    break;\n\t}\n#endif /* NS */\n\n\tdefault: {\n\t    tulip_init(sc);\n\t    break;\n\t}\n\t}\n\tbreak;\n    }\n    case SIOCGIFADDR: {\n\tbcopy((caddr_t) sc->tulip_enaddr,\n\t      (caddr_t) ((struct sockaddr *)&ifr->ifr_data)->sa_data,\n\t      6);\n\tbreak;\n    }\n\n    case SIOCSIFFLAGS: {\n#if !defined(IFM_ETHER)\n\tint flags = 0;\n\tif (ifp->if_flags & IFF_LINK0) flags |= 1;\n\tif (ifp->if_flags & IFF_LINK1) flags |= 2;\n\tif (ifp->if_flags & IFF_LINK2) flags |= 4;\n\tif (flags == 7) {\n\t    ifp->if_flags &= ~(IFF_LINK0|IFF_LINK1|IFF_LINK2);\n\t    sc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\t    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t    sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP|TULIP_NOAUTOSENSE);\n\t    tulip_reset(sc);\n\t} else if (flags) {\n\t    tulip_media_t media;\n\t    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\t\tif (sc->tulip_mediums[media] != NULL && --flags == 0) {\n\t\t    sc->tulip_flags |= TULIP_NOAUTOSENSE;\n\t\t    if (sc->tulip_media != media || (sc->tulip_flags & TULIP_DIDNWAY)) {\n\t\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\t\ttulip_linkup(sc, media);\n\t\t    }\n\t\t    break;\n\t\t}\n\t    }\n\t    if (flags)\n\t\tprintf(TULIP_PRINTF_FMT \": ignored invalid media request\\n\", TULIP_PRINTF_ARGS);\n\t}\n#endif\n\ttulip_init(sc);\n\tbreak;\n    }\n\n#if defined(SIOCSIFMEDIA)\n    case SIOCSIFMEDIA:\n    case SIOCGIFMEDIA: {\n\terror = ifmedia_ioctl(ifp, ifr, &sc->tulip_ifmedia, cmd);\n\tbreak;\n    }\n#endif\n\n    case SIOCADDMULTI:\n    case SIOCDELMULTI: {\n\t/*\n\t * Update multicast listeners\n\t */\n\tif (cmd == SIOCADDMULTI)\n\t    error = ether_addmulti(ifr, TULIP_ETHERCOM(sc));\n\telse\n\t    error = ether_delmulti(ifr, TULIP_ETHERCOM(sc));\n\n\tif (error == ENETRESET) {\n\t    tulip_addr_filter(sc); /* reset multicast filtering */\n\t    tulip_init(sc);\n\t    error = 0;\n\t}\n\tbreak;\n    }\n    case SIOCSIFMTU:\n\t/*\n\t * Set the interface MTU.\n\t */\n\tif (ifr->ifr_mtu > ETHERMTU\n#ifdef BIG_PACKET\n\t    && sc->tulip_chipid != TULIP_21140\n\t    && sc->tulip_chipid != TULIP_21140A\n\t    && sc->tulip_chipid != TULIP_21041\n#endif\n\t    ) {\n\t    error = EINVAL;\n\t    break;\n\t}\n\tifp->if_mtu = ifr->ifr_mtu;\n#ifdef BIG_PACKET\n\ttulip_reset(sc);\n\ttulip_init(sc);\n#endif\n\tbreak;\n\n#ifdef SIOCGADDRROM\n    case SIOCGADDRROM: {\n\terror = copyout(sc->tulip_rombuf, ifr->ifr_data, sizeof(sc->tulip_rombuf));\n\tbreak;\n    }\n#endif\n#ifdef SIOCGCHIPID\n    case SIOCGCHIPID: {\n\tifr->ifr_metric = (int) sc->tulip_chipid;\n\tbreak;\n    }\n#endif\n    default: {\n\terror = EINVAL;\n\tbreak;\n    }\n    }\n\n    TULIP_RESTORESPL(s);\n    TULIP_PERFEND(ifioctl);\n    return error;\n}"
  },
  {
    "function_name": "tulip_txput_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4326-4411",
    "snippet": "static void\ntulip_txput_setup(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *nextout;\n\t\n    /*\n     * We will transmit, at most, one setup packet per call to ifstart.\n     */\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput_setup: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS);\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n#endif\n    /*\n     * Try to reclaim some free descriptors..\n     */\n    if (ri->ri_free < 2)\n\ttulip_tx_intr(sc);\n    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,\n\t  sizeof(sc->tulip_setupbuf));\n    /*\n     * Clear WANTSETUP and set DOINGSETUP.  Set know that WANTSETUP is\n     * set and DOINGSETUP is clear doing an XOR of the two will DTRT.\n     */\n    sc->tulip_flags ^= TULIP_WANTSETUP|TULIP_DOINGSETUP;\n    ri->ri_free--;\n#if defined(__mips__)\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));\n#endif\n    nextout = ri->ri_nextout;\n    {\n\tu_int32_t d_flag;\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(nextout->u.f); /* copy the bitfields */\n\td_flag = u.bd_flag;\n\n\td_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\td_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG\n\t    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;\n\tif (sc->tulip_flags & TULIP_WANTHASHPERFECT)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT;\n\telse if (sc->tulip_flags & TULIP_WANTHASHONLY)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;\n\n\n\tu.bd_flag = d_flag;\n\tu.bd_length1 = sizeof(sc->tulip_setupbuf);\n\tu.bd_length2 = 0;\n\n\tnextout->u.f = DESC_BO(u.f);\n\tnextout->d_addr1 = DESC_BO(TULIP_KVATOPHYS(sc, sc->tulip_setupbuf));\n\tnextout->d_addr2 = 0; /* no need to swab */\n    }\n\n    /*\n     * Advance the ring for the next transmit packet.\n     */\n    if (++ri->ri_nextout == ri->ri_last)\n\tri->ri_nextout = ri->ri_first;\n\n    /*\n     * Make sure the next descriptor is owned by us since it\n     * may have been set up above if we ran out of room in the\n     * ring.\n     */\n    ri->ri_nextout->d_status = 0; /* doesn't need swab - dsr */\n    nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n    if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\tsc->tulip_intrmask |= TULIP_STS_TXINTR;\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 4409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_txpoll",
            "1"
          ],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DESC_BO",
          "args": [
            "TULIP_DSTS_OWNER"
          ],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "DESC_BO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "104-114",
          "snippet": "__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\n__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_KVATOPHYS",
          "args": [
            "sc",
            "sc->tulip_setupbuf"
          ],
          "line": 4389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "sc->tulip_pc",
            "(vm_offset_t)sc->tulip_setupbuf",
            "sizeof(sc->tulip_setupbuf)"
          ],
          "line": 4365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->tulip_setupdata",
            "sc->tulip_setupbuf",
            "sizeof(sc->tulip_setupbuf)"
          ],
          "line": 4356
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_tx_intr",
          "args": [
            "sc"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_tx_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3624-3752",
          "snippet": "static int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": txput_setup: tx not running\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 4339
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_txput_setup(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *nextout;\n\t\n    /*\n     * We will transmit, at most, one setup packet per call to ifstart.\n     */\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput_setup: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS);\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n#endif\n    /*\n     * Try to reclaim some free descriptors..\n     */\n    if (ri->ri_free < 2)\n\ttulip_tx_intr(sc);\n    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,\n\t  sizeof(sc->tulip_setupbuf));\n    /*\n     * Clear WANTSETUP and set DOINGSETUP.  Set know that WANTSETUP is\n     * set and DOINGSETUP is clear doing an XOR of the two will DTRT.\n     */\n    sc->tulip_flags ^= TULIP_WANTSETUP|TULIP_DOINGSETUP;\n    ri->ri_free--;\n#if defined(__mips__)\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));\n#endif\n    nextout = ri->ri_nextout;\n    {\n\tu_int32_t d_flag;\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(nextout->u.f); /* copy the bitfields */\n\td_flag = u.bd_flag;\n\n\td_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\td_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG\n\t    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;\n\tif (sc->tulip_flags & TULIP_WANTHASHPERFECT)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT;\n\telse if (sc->tulip_flags & TULIP_WANTHASHONLY)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;\n\n\n\tu.bd_flag = d_flag;\n\tu.bd_length1 = sizeof(sc->tulip_setupbuf);\n\tu.bd_length2 = 0;\n\n\tnextout->u.f = DESC_BO(u.f);\n\tnextout->d_addr1 = DESC_BO(TULIP_KVATOPHYS(sc, sc->tulip_setupbuf));\n\tnextout->d_addr2 = 0; /* no need to swab */\n    }\n\n    /*\n     * Advance the ring for the next transmit packet.\n     */\n    if (++ri->ri_nextout == ri->ri_last)\n\tri->ri_nextout = ri->ri_first;\n\n    /*\n     * Make sure the next descriptor is owned by us since it\n     * may have been set up above if we ran out of room in the\n     * ring.\n     */\n    ri->ri_nextout->d_status = 0; /* doesn't need swab - dsr */\n    nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n    if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\tsc->tulip_intrmask |= TULIP_STS_TXINTR;\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    }\n}"
  },
  {
    "function_name": "tulip_txput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4097-4324",
    "snippet": "static struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;",
      "tulip_desc_t *eop = ri->ri_nextin;",
      "struct mbuf *m0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "txput"
          ],
          "line": 4322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "txput"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "txput"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_txpoll",
            "1"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DESC_BO",
          "args": [
            "TULIP_DSTS_OWNER"
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "DESC_BO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "104-114",
          "snippet": "__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\n__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IF_ENQUEUE",
          "args": [
            "&sc->tulip_txq",
            "m"
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_sync_cache",
          "args": [
            "sc->tulip_pc",
            "(vm_offset_t)addr",
            "slen"
          ],
          "line": 4209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_KVATOPHYS",
          "args": [
            "sc",
            "addr"
          ],
          "line": 4200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_KVATOPHYS",
          "args": [
            "sc",
            "addr"
          ],
          "line": 4193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_tx_intr",
          "args": [
            "sc"
          ],
          "line": 4172
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_tx_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3624-3752",
          "snippet": "static int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mbuf_compress",
          "args": [
            "m"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mbuf_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4040-4095",
          "snippet": "static struct mbuf *\ntulip_mbuf_compress(\n    struct mbuf *m)\n{\n    struct mbuf *m0;\n#if MCLBYTES >= ETHERMTU + 18 && !defined(BIG_PACKET)\n    MGETHDR(m0, M_DONTWAIT, MT_DATA);\n    if (m0 != NULL) {\n\tif (m->m_pkthdr.len > MHLEN) {\n\t    MCLGET(m0, M_DONTWAIT);\n\t    if ((m0->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tm_freem(m0);\n\t\treturn NULL;\n\t    }\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n    }\n#else\n    int mlen = MHLEN;\n    int len = m->m_pkthdr.len;\n    struct mbuf **mp = &m0;\n\n    while (len > 0) {\n\tif (mlen == MHLEN) {\n\t    MGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t} else {\n\t    MGET(*mp, M_DONTWAIT, MT_DATA);\n\t}\n\tif (*mp == NULL) {\n\t    m_freem(m0);\n\t    m0 = NULL;\n\t    break;\n\t}\n\tif (len > MLEN) {\n\t    MCLGET(*mp, M_DONTWAIT);\n\t    if (((*mp)->m_flags & M_EXT) == 0) {\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\t\tbreak;\n\t    }\n\t    (*mp)->m_len = len <= MCLBYTES ? len : MCLBYTES;\n\t} else {\n\t    (*mp)->m_len = len <= mlen ? len : mlen;\n\t}\n\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\tlen -= (*mp)->m_len;\n\tmp = &(*mp)->m_next;\n\tmlen = MLEN;\n    }\n#endif\n    m_freem(m);\n    return m0;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "struct mbuf *m0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstruct mbuf *m0;\n\nstatic struct mbuf *\ntulip_mbuf_compress(\n    struct mbuf *m)\n{\n    struct mbuf *m0;\n#if MCLBYTES >= ETHERMTU + 18 && !defined(BIG_PACKET)\n    MGETHDR(m0, M_DONTWAIT, MT_DATA);\n    if (m0 != NULL) {\n\tif (m->m_pkthdr.len > MHLEN) {\n\t    MCLGET(m0, M_DONTWAIT);\n\t    if ((m0->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tm_freem(m0);\n\t\treturn NULL;\n\t    }\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n    }\n#else\n    int mlen = MHLEN;\n    int len = m->m_pkthdr.len;\n    struct mbuf **mp = &m0;\n\n    while (len > 0) {\n\tif (mlen == MHLEN) {\n\t    MGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t} else {\n\t    MGET(*mp, M_DONTWAIT, MT_DATA);\n\t}\n\tif (*mp == NULL) {\n\t    m_freem(m0);\n\t    m0 = NULL;\n\t    break;\n\t}\n\tif (len > MLEN) {\n\t    MCLGET(*mp, M_DONTWAIT);\n\t    if (((*mp)->m_flags & M_EXT) == 0) {\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\t\tbreak;\n\t    }\n\t    (*mp)->m_len = len <= MCLBYTES ? len : MCLBYTES;\n\t} else {\n\t    (*mp)->m_len = len <= mlen ? len : mlen;\n\t}\n\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\tlen -= (*mp)->m_len;\n\tmp = &(*mp)->m_next;\n\tmlen = MLEN;\n    }\n#endif\n    m_freem(m);\n    return m0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "len",
            "clsize"
          ],
          "line": 4148
        },
        "resolved": true,
        "details": {
          "function_name": "ti_free_rx_ring_mini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_ti.c",
          "lines": "964-979",
          "snippet": "void ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <dev/pci/ti_fw2.h>",
            "#include <dev/pci/ti_fw.h>",
            "#include <dev/pci/if_tireg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/bus.h>",
            "#include <vm/vm_extern.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/pmap.h>            /* for vtophys */",
            "#include <vm/vm.h>              /* for vtophys */",
            "#include <net/bpf.h>",
            "#include <net/if_media.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/if_types.h>",
            "#include <net/if_dl.h>",
            "#include <net/if.h>",
            "#include <sys/queue.h>",
            "#include <sys/device.h>",
            "#include <sys/socket.h>",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/sockio.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ti_free_rx_ring_mini",
            "void *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/pci/ti_fw2.h>\n#include <dev/pci/ti_fw.h>\n#include <dev/pci/if_tireg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/bus.h>\n#include <vm/vm_extern.h>\n#include <vm/vm_kern.h>\n#include <vm/pmap.h>            /* for vtophys */\n#include <vm/vm.h>              /* for vtophys */\n#include <net/bpf.h>\n#include <net/if_media.h>\n#include <netinet/if_ether.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/if_types.h>\n#include <net/if_dl.h>\n#include <net/if.h>\n#include <sys/queue.h>\n#include <sys/device.h>\n#include <sys/socket.h>\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/mbuf.h>\n#include <sys/sockio.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid ti_free_rx_ring_mini;\nvoid *ti_jalloc(sc)\n\tstruct ti_softc\t\t*sc;\n\nvoid ti_free_rx_ring_mini(sc)\n\tstruct ti_softc\t\t*sc;\n{\n\tregister int\t\ti;\n\n\tfor (i = 0; i < TI_MINI_RX_RING_CNT; i++) {\n\t\tif (sc->ti_cdata.ti_rx_mini_chain[i] != NULL) {\n\t\t\tm_freem(sc->ti_cdata.ti_rx_mini_chain[i]);\n\t\t\tsc->ti_cdata.ti_rx_mini_chain[i] = NULL;\n\t\t}\n\t\tbzero((char *)&sc->ti_rdata->ti_rx_mini_ring[i],\n\t\t    sizeof(struct ti_rx_desc));\n\t}\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "caddr_t"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": txput%s: tx not running\\n\"",
            "TULIP_PRINTF_ARGS",
            "(sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\""
          ],
          "line": 4111
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\ntulip_desc_t *eop = ri->ri_nextin;\nstruct mbuf *m0;\n\nstatic struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}"
  },
  {
    "function_name": "tulip_mbuf_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4040-4095",
    "snippet": "static struct mbuf *\ntulip_mbuf_compress(\n    struct mbuf *m)\n{\n    struct mbuf *m0;\n#if MCLBYTES >= ETHERMTU + 18 && !defined(BIG_PACKET)\n    MGETHDR(m0, M_DONTWAIT, MT_DATA);\n    if (m0 != NULL) {\n\tif (m->m_pkthdr.len > MHLEN) {\n\t    MCLGET(m0, M_DONTWAIT);\n\t    if ((m0->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tm_freem(m0);\n\t\treturn NULL;\n\t    }\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n    }\n#else\n    int mlen = MHLEN;\n    int len = m->m_pkthdr.len;\n    struct mbuf **mp = &m0;\n\n    while (len > 0) {\n\tif (mlen == MHLEN) {\n\t    MGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t} else {\n\t    MGET(*mp, M_DONTWAIT, MT_DATA);\n\t}\n\tif (*mp == NULL) {\n\t    m_freem(m0);\n\t    m0 = NULL;\n\t    break;\n\t}\n\tif (len > MLEN) {\n\t    MCLGET(*mp, M_DONTWAIT);\n\t    if (((*mp)->m_flags & M_EXT) == 0) {\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\t\tbreak;\n\t    }\n\t    (*mp)->m_len = len <= MCLBYTES ? len : MCLBYTES;\n\t} else {\n\t    (*mp)->m_len = len <= mlen ? len : mlen;\n\t}\n\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\tlen -= (*mp)->m_len;\n\tmp = &(*mp)->m_next;\n\tmlen = MLEN;\n    }\n#endif\n    m_freem(m);\n    return m0;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
      "struct mbuf *m0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 4093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "m->m_pkthdr.len - len",
            "(*mp)->m_len",
            "mtod((*mp), caddr_t)"
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "(*mp)",
            "caddr_t"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "*mp",
            "M_DONTWAIT"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGET",
          "args": [
            "*mp",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 4068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "*mp",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 4066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_copydata",
          "args": [
            "m",
            "0",
            "m->m_pkthdr.len",
            "mtod(m0, caddr_t)"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m0",
            "caddr_t"
          ],
          "line": 4056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m0"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MCLGET",
          "args": [
            "m0",
            "M_DONTWAIT"
          ],
          "line": 4049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m0",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstruct mbuf *m0;\n\nstatic struct mbuf *\ntulip_mbuf_compress(\n    struct mbuf *m)\n{\n    struct mbuf *m0;\n#if MCLBYTES >= ETHERMTU + 18 && !defined(BIG_PACKET)\n    MGETHDR(m0, M_DONTWAIT, MT_DATA);\n    if (m0 != NULL) {\n\tif (m->m_pkthdr.len > MHLEN) {\n\t    MCLGET(m0, M_DONTWAIT);\n\t    if ((m0->m_flags & M_EXT) == 0) {\n\t\tm_freem(m);\n\t\tm_freem(m0);\n\t\treturn NULL;\n\t    }\n\t}\n\tm_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));\n\tm0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;\n    }\n#else\n    int mlen = MHLEN;\n    int len = m->m_pkthdr.len;\n    struct mbuf **mp = &m0;\n\n    while (len > 0) {\n\tif (mlen == MHLEN) {\n\t    MGETHDR(*mp, M_DONTWAIT, MT_DATA);\n\t} else {\n\t    MGET(*mp, M_DONTWAIT, MT_DATA);\n\t}\n\tif (*mp == NULL) {\n\t    m_freem(m0);\n\t    m0 = NULL;\n\t    break;\n\t}\n\tif (len > MLEN) {\n\t    MCLGET(*mp, M_DONTWAIT);\n\t    if (((*mp)->m_flags & M_EXT) == 0) {\n\t\tm_freem(m0);\n\t\tm0 = NULL;\n\t\tbreak;\n\t    }\n\t    (*mp)->m_len = len <= MCLBYTES ? len : MCLBYTES;\n\t} else {\n\t    (*mp)->m_len = len <= mlen ? len : mlen;\n\t}\n\tm_copydata(m, m->m_pkthdr.len - len,\n\t\t   (*mp)->m_len, mtod((*mp), caddr_t));\n\tlen -= (*mp)->m_len;\n\tmp = &(*mp)->m_next;\n\tmlen = MLEN;\n    }\n#endif\n    m_freem(m);\n    return m0;\n}"
  },
  {
    "function_name": "tulip_intr_normal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "4018-4038",
    "snippet": "static tulip_intrfunc_t\ntulip_intr_normal(\n    void *arg)\n{\n    tulip_softc_t * sc = (tulip_softc_t *) arg;\n    int progress = 0;\n\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_intrs++;\n#endif\n#if defined(TULIP_USE_SOFTINTR)\n    tulip_hardintr_handler(sc, &progress);\n    if (progress)\n\tschednetisr(NETISR_DE);\n#else\n    tulip_intr_handler(sc, &progress);\n#endif\n#if !defined(TULIP_VOID_INTRFUNC)\n    return progress;\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_USE_SOFTINTR",
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static tulip_intrfunc_t tulip_intr_shared(void *arg);",
      "static tulip_intrfunc_t tulip_intr_normal(void *arg);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_intr_handler",
          "args": [
            "sc",
            "&progress"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_intr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3784-3884",
          "snippet": "static void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schednetisr",
          "args": [
            "NETISR_DE"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_hardintr_handler",
          "args": [
            "sc",
            "&progress"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_hardintr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3902-3927",
          "snippet": "static void\ntulip_hardintr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    if (TULIP_CSR_READ(sc, csr_status) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR) == 0)\n\treturn;\n    *progress_p = 1;\n    /*\n     * disable interrupts\n     */\n    TULIP_CSR_WRITE(sc, csr_intr, 0);\n    /*\n     * mark it as needing a software interrupt\n     */\n    tulip_softintr_mask |= (1U << sc->tulip_unit);\n\n#if defined(__NetBSD__) && NRND > 0\n    /*\n     * This isn't all that random (the value we feed in) but it is\n     * better than a constant probably.  It isn't used in entropy\n     * calculation anyway, just to add something to the pool.\n     */\n    rnd_add_uint32(&sc->tulip_rndsource, sc->tulip_flags);\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_hardintr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    if (TULIP_CSR_READ(sc, csr_status) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR) == 0)\n\treturn;\n    *progress_p = 1;\n    /*\n     * disable interrupts\n     */\n    TULIP_CSR_WRITE(sc, csr_intr, 0);\n    /*\n     * mark it as needing a software interrupt\n     */\n    tulip_softintr_mask |= (1U << sc->tulip_unit);\n\n#if defined(__NetBSD__) && NRND > 0\n    /*\n     * This isn't all that random (the value we feed in) but it is\n     * better than a constant probably.  It isn't used in entropy\n     * calculation anyway, just to add something to the pool.\n     */\n    rnd_add_uint32(&sc->tulip_rndsource, sc->tulip_flags);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_USE_SOFTINTR\n#define TULIP_DEBUG\n\nstatic tulip_intrfunc_t tulip_intr_shared(void *arg);\nstatic tulip_intrfunc_t tulip_intr_normal(void *arg);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic tulip_intrfunc_t\ntulip_intr_normal(\n    void *arg)\n{\n    tulip_softc_t * sc = (tulip_softc_t *) arg;\n    int progress = 0;\n\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_intrs++;\n#endif\n#if defined(TULIP_USE_SOFTINTR)\n    tulip_hardintr_handler(sc, &progress);\n    if (progress)\n\tschednetisr(NETISR_DE);\n#else\n    tulip_intr_handler(sc, &progress);\n#endif\n#if !defined(TULIP_VOID_INTRFUNC)\n    return progress;\n#endif\n}"
  },
  {
    "function_name": "tulip_intr_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3992-4016",
    "snippet": "static tulip_intrfunc_t\ntulip_intr_shared(\n    void *arg)\n{\n    tulip_softc_t * sc = arg;\n    int progress = 0;\n\n    for (; sc != NULL; sc = sc->tulip_slaves) {\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_intrs++;\n#endif\n#if defined(TULIP_USE_SOFTINTR)\n\ttulip_hardintr_handler(sc, &progress);\n#else\n\ttulip_intr_handler(sc, &progress);\n#endif\n    }\n#if defined(TULIP_USE_SOFTINTR)\n    if (progress)\n\tschednetisr(NETISR_DE);\n#endif\n#if !defined(TULIP_VOID_INTRFUNC)\n    return progress;\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_USE_SOFTINTR",
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static tulip_intrfunc_t tulip_intr_shared(void *arg);",
      "static tulip_intrfunc_t tulip_intr_normal(void *arg);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schednetisr",
          "args": [
            "NETISR_DE"
          ],
          "line": 4011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_intr_handler",
          "args": [
            "sc",
            "&progress"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_intr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3784-3884",
          "snippet": "static void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_hardintr_handler",
          "args": [
            "sc",
            "&progress"
          ],
          "line": 4004
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_hardintr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3902-3927",
          "snippet": "static void\ntulip_hardintr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    if (TULIP_CSR_READ(sc, csr_status) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR) == 0)\n\treturn;\n    *progress_p = 1;\n    /*\n     * disable interrupts\n     */\n    TULIP_CSR_WRITE(sc, csr_intr, 0);\n    /*\n     * mark it as needing a software interrupt\n     */\n    tulip_softintr_mask |= (1U << sc->tulip_unit);\n\n#if defined(__NetBSD__) && NRND > 0\n    /*\n     * This isn't all that random (the value we feed in) but it is\n     * better than a constant probably.  It isn't used in entropy\n     * calculation anyway, just to add something to the pool.\n     */\n    rnd_add_uint32(&sc->tulip_rndsource, sc->tulip_flags);\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_hardintr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    if (TULIP_CSR_READ(sc, csr_status) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR) == 0)\n\treturn;\n    *progress_p = 1;\n    /*\n     * disable interrupts\n     */\n    TULIP_CSR_WRITE(sc, csr_intr, 0);\n    /*\n     * mark it as needing a software interrupt\n     */\n    tulip_softintr_mask |= (1U << sc->tulip_unit);\n\n#if defined(__NetBSD__) && NRND > 0\n    /*\n     * This isn't all that random (the value we feed in) but it is\n     * better than a constant probably.  It isn't used in entropy\n     * calculation anyway, just to add something to the pool.\n     */\n    rnd_add_uint32(&sc->tulip_rndsource, sc->tulip_flags);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_USE_SOFTINTR\n#define TULIP_DEBUG\n\nstatic tulip_intrfunc_t tulip_intr_shared(void *arg);\nstatic tulip_intrfunc_t tulip_intr_normal(void *arg);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic tulip_intrfunc_t\ntulip_intr_shared(\n    void *arg)\n{\n    tulip_softc_t * sc = arg;\n    int progress = 0;\n\n    for (; sc != NULL; sc = sc->tulip_slaves) {\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_intrs++;\n#endif\n#if defined(TULIP_USE_SOFTINTR)\n\ttulip_hardintr_handler(sc, &progress);\n#else\n\ttulip_intr_handler(sc, &progress);\n#endif\n    }\n#if defined(TULIP_USE_SOFTINTR)\n    if (progress)\n\tschednetisr(NETISR_DE);\n#endif\n#if !defined(TULIP_VOID_INTRFUNC)\n    return progress;\n#endif\n}"
  },
  {
    "function_name": "tulip_softintr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3929-3989",
    "snippet": "static void\ntulip_softintr(\n    void)\n{\n    u_int32_t softintr_mask, mask;\n    int progress = 0;\n    int unit;\n    tulip_spl_t s;\n\n    /*\n     * Copy mask to local copy and reset global one to 0.\n     */\n    s = TULIP_RAISESPL();\n    softintr_mask = tulip_softintr_mask;\n    tulip_softintr_mask = 0;\n    TULIP_RESTORESPL(s);\n\n    /*\n     * Optimize for the single unit case.\n     */\n    if (tulip_softintr_max_unit == 0) {\n\tif (softintr_mask & 1) {\n\t    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(0);\n\t    /*\n\t     * Handle the \"interrupt\" and then reenable interrupts\n\t     */\n\t    softintr_mask = 0;\n\t    tulip_intr_handler(sc, &progress);\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n\treturn;\n    }\n\n    /*\n     * Handle all \"queued\" interrupts in a round robin fashion.\n     * This is done so as not to favor a particular interface.\n     */\n    unit = tulip_softintr_last_unit;\n    mask = (1U << unit);\n    while (softintr_mask != 0) {\n\tif (tulip_softintr_max_unit == unit) {\n\t    unit  = 0; mask   = 1;\n\t} else {\n\t    unit += 1; mask <<= 1;\n\t}\n\tif (softintr_mask & mask) {\n\t    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(unit);\n\t    /*\n\t     * Handle the \"interrupt\" and then reenable interrupts\n\t     */\n\t    softintr_mask ^= mask;\n\t    tulip_intr_handler(sc, &progress);\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n\n    /*\n     * Save where we ending up.\n     */\n    tulip_softintr_last_unit = unit;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_intr_handler",
          "args": [
            "sc",
            "&progress"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_intr_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3784-3884",
          "snippet": "static void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_UNIT_TO_SOFTC",
          "args": [
            "unit"
          ],
          "line": 3975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 3957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_UNIT_TO_SOFTC",
          "args": [
            "0"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_RESTORESPL",
          "args": [
            "s"
          ],
          "line": 3944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_RAISESPL",
          "args": [],
          "line": 3941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_softintr(\n    void)\n{\n    u_int32_t softintr_mask, mask;\n    int progress = 0;\n    int unit;\n    tulip_spl_t s;\n\n    /*\n     * Copy mask to local copy and reset global one to 0.\n     */\n    s = TULIP_RAISESPL();\n    softintr_mask = tulip_softintr_mask;\n    tulip_softintr_mask = 0;\n    TULIP_RESTORESPL(s);\n\n    /*\n     * Optimize for the single unit case.\n     */\n    if (tulip_softintr_max_unit == 0) {\n\tif (softintr_mask & 1) {\n\t    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(0);\n\t    /*\n\t     * Handle the \"interrupt\" and then reenable interrupts\n\t     */\n\t    softintr_mask = 0;\n\t    tulip_intr_handler(sc, &progress);\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n\treturn;\n    }\n\n    /*\n     * Handle all \"queued\" interrupts in a round robin fashion.\n     * This is done so as not to favor a particular interface.\n     */\n    unit = tulip_softintr_last_unit;\n    mask = (1U << unit);\n    while (softintr_mask != 0) {\n\tif (tulip_softintr_max_unit == unit) {\n\t    unit  = 0; mask   = 1;\n\t} else {\n\t    unit += 1; mask <<= 1;\n\t}\n\tif (softintr_mask & mask) {\n\t    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(unit);\n\t    /*\n\t     * Handle the \"interrupt\" and then reenable interrupts\n\t     */\n\t    softintr_mask ^= mask;\n\t    tulip_intr_handler(sc, &progress);\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n\n    /*\n     * Save where we ending up.\n     */\n    tulip_softintr_last_unit = unit;\n}"
  },
  {
    "function_name": "tulip_hardintr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3902-3927",
    "snippet": "static void\ntulip_hardintr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    if (TULIP_CSR_READ(sc, csr_status) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR) == 0)\n\treturn;\n    *progress_p = 1;\n    /*\n     * disable interrupts\n     */\n    TULIP_CSR_WRITE(sc, csr_intr, 0);\n    /*\n     * mark it as needing a software interrupt\n     */\n    tulip_softintr_mask |= (1U << sc->tulip_unit);\n\n#if defined(__NetBSD__) && NRND > 0\n    /*\n     * This isn't all that random (the value we feed in) but it is\n     * better than a constant probably.  It isn't used in entropy\n     * calculation anyway, just to add something to the pool.\n     */\n    rnd_add_uint32(&sc->tulip_rndsource, sc->tulip_flags);\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd_add_uint32",
          "args": [
            "&sc->tulip_rndsource",
            "sc->tulip_flags"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "0"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_status"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_hardintr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    if (TULIP_CSR_READ(sc, csr_status) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR) == 0)\n\treturn;\n    *progress_p = 1;\n    /*\n     * disable interrupts\n     */\n    TULIP_CSR_WRITE(sc, csr_intr, 0);\n    /*\n     * mark it as needing a software interrupt\n     */\n    tulip_softintr_mask |= (1U << sc->tulip_unit);\n\n#if defined(__NetBSD__) && NRND > 0\n    /*\n     * This isn't all that random (the value we feed in) but it is\n     * better than a constant probably.  It isn't used in entropy\n     * calculation anyway, just to add something to the pool.\n     */\n    rnd_add_uint32(&sc->tulip_rndsource, sc->tulip_flags);\n#endif\n}"
  },
  {
    "function_name": "tulip_intr_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3784-3884",
    "snippet": "static void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_PERFEND",
          "args": [
            "intr"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_init",
          "args": [
            "sc"
          ],
          "line": 3881
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3330-3371",
          "snippet": "static void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 3880
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_ifstart",
          "args": [
            "&sc->tulip_if"
          ],
          "line": 3876
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_ifstart_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4618-4633",
          "snippet": "static ifnet_ret_t\ntulip_ifstart_one(\n    struct ifnet * const ifp)\n{\n    TULIP_PERFSTART(ifstart_one)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    if ((sc->tulip_if.if_flags & IFF_RUNNING)\n\t    && sc->tulip_if.if_snd.ifq_head != NULL) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_if.if_snd, m);\n\tif ((m = tulip_txput(sc, m)) != NULL)\n\t    IF_PREPEND(&sc->tulip_if.if_snd, m);\n    }\n    TULIP_PERFEND(ifstart_one);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
            "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "struct ifnet * const ifp = &sc->tulip_if;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic ifnet_ret_t\ntulip_ifstart_one(\n    struct ifnet * const ifp)\n{\n    TULIP_PERFSTART(ifstart_one)\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    if ((sc->tulip_if.if_flags & IFF_RUNNING)\n\t    && sc->tulip_if.if_snd.ifq_head != NULL) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_if.if_snd, m);\n\tif ((m = tulip_txput(sc, m)) != NULL)\n\t    IF_PREPEND(&sc->tulip_if.if_snd, m);\n    }\n    TULIP_PERFEND(ifstart_one);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_tx_intr",
          "args": [
            "sc"
          ],
          "line": 3874
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_tx_intr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3624-3752",
          "snippet": "static int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_print_abnormal_interrupt",
          "args": [
            "sc",
            "tmp"
          ],
          "line": 3868
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_print_abnormal_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3754-3782",
          "snippet": "static void\ntulip_print_abnormal_interrupt(\n    tulip_softc_t * const sc,\n    u_int32_t csr)\n{\n    const char * const *msgp = tulip_status_bits;\n    const char *sep;\n    u_int32_t mask;\n    const char thrsh[] = \"72|128\\0\\0\\0\" \"96|256\\0\\0\\0\" \"128|512\\0\\0\" \"160|1024\\0\";\n\n    csr &= (1 << (sizeof(tulip_status_bits)/sizeof(tulip_status_bits[0]))) - 1;\n    printf(TULIP_PRINTF_FMT \": abnormal interrupt:\", TULIP_PRINTF_ARGS);\n    for (sep = \" \", mask = 1; mask <= csr; mask <<= 1, msgp++) {\n\tif ((csr & mask) && *msgp != NULL) {\n\t    printf(\"%s%s\", sep, *msgp);\n\t    if (mask == TULIP_STS_TXUNDERFLOW && (sc->tulip_flags & TULIP_NEWTXTHRESH)) {\n\t\tsc->tulip_flags &= ~TULIP_NEWTXTHRESH;\n\t\tif (sc->tulip_cmdmode & TULIP_CMD_STOREFWD) {\n\t\t    printf(\" (switching to store-and-forward mode)\");\n\t\t} else {\n\t\t    printf(\" (raising TX threshold to %s)\",\n\t\t\t   &thrsh[9 * ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) >> 14)]);\n\t\t}\n\t    }\n\t    sep = \", \";\n\t}\n    }\n    printf(\"\\n\");\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_print_abnormal_interrupt(\n    tulip_softc_t * const sc,\n    u_int32_t csr)\n{\n    const char * const *msgp = tulip_status_bits;\n    const char *sep;\n    u_int32_t mask;\n    const char thrsh[] = \"72|128\\0\\0\\0\" \"96|256\\0\\0\\0\" \"128|512\\0\\0\" \"160|1024\\0\";\n\n    csr &= (1 << (sizeof(tulip_status_bits)/sizeof(tulip_status_bits[0]))) - 1;\n    printf(TULIP_PRINTF_FMT \": abnormal interrupt:\", TULIP_PRINTF_ARGS);\n    for (sep = \" \", mask = 1; mask <= csr; mask <<= 1, msgp++) {\n\tif ((csr & mask) && *msgp != NULL) {\n\t    printf(\"%s%s\", sep, *msgp);\n\t    if (mask == TULIP_STS_TXUNDERFLOW && (sc->tulip_flags & TULIP_NEWTXTHRESH)) {\n\t\tsc->tulip_flags &= ~TULIP_NEWTXTHRESH;\n\t\tif (sc->tulip_cmdmode & TULIP_CMD_STOREFWD) {\n\t\t    printf(\" (switching to store-and-forward mode)\");\n\t\t} else {\n\t\t    printf(\" (raising TX threshold to %s)\",\n\t\t\t   &thrsh[9 * ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) >> 14)]);\n\t\t}\n\t    }\n\t    sep = \", \";\n\t}\n    }\n    printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Underflow interrupt\\n\""
          ],
          "line": 3855
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_rx_intr",
          "args": [
            "sc"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_status",
            "TULIP_STS_RXSTOPPED"
          ],
          "line": 3838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_status"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode & ~TULIP_CMD_RXRUN"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_missed_frames"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_media_print",
          "args": [
            "sc"
          ],
          "line": 3819
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "438-453",
          "snippet": "static void\ntulip_media_print(\n    tulip_softc_t * const sc)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\treturn;\n    if (sc->tulip_flags & TULIP_PRINTMEDIA) {\n\tprintf(TULIP_PRINTF_FMT \": enabling %s port\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       tulip_mediums[sc->tulip_media]);\n\tsc->tulip_flags &= ~(TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n    } else if (sc->tulip_flags & TULIP_PRINTLINKUP) {\n\tprintf(TULIP_PRINTF_FMT \": link up\\n\", TULIP_PRINTF_ARGS);\n\tsc->tulip_flags &= ~TULIP_PRINTLINKUP;\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_print(\n    tulip_softc_t * const sc)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\treturn;\n    if (sc->tulip_flags & TULIP_PRINTMEDIA) {\n\tprintf(TULIP_PRINTF_FMT \": enabling %s port\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       tulip_mediums[sc->tulip_media]);\n\tsc->tulip_flags &= ~(TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n    } else if (sc->tulip_flags & TULIP_PRINTLINKUP) {\n\tprintf(TULIP_PRINTF_FMT \": link up\\n\", TULIP_PRINTF_ARGS);\n\tsc->tulip_flags &= ~TULIP_PRINTLINKUP;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_status",
            "csr"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_status"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_intr_handler(\n    tulip_softc_t * const sc,\n    int *progress_p)\n{\n    TULIP_PERFSTART(intr)\n    u_int32_t csr;\n\n    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {\n\t*progress_p = 1;\n\tTULIP_CSR_WRITE(sc, csr_status, csr);\n\n\tif (csr & TULIP_STS_SYSERROR) {\n\t    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_flags |= TULIP_SYSTEMERROR;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": system error: %s\\n\",\n\t\t       TULIP_PRINTF_ARGS,\n\t\t       tulip_system_errors[sc->tulip_last_system_error]);\n\t    }\n\t    sc->tulip_flags |= TULIP_NEEDRESET;\n\t    sc->tulip_system_errors++;\n\t    break;\n\t}\n\tif (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {\n#if defined(TULIP_DEBUG)\n\t    sc->tulip_dbg.dbg_link_intrs++;\n#endif\n\t    if (sc->tulip_boardsw->bd_media_poll != NULL) {\n\t\t(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL\n\t\t\t\t\t\t    ? TULIP_MEDIAPOLL_LINKFAIL\n\t\t\t\t\t\t    : TULIP_MEDIAPOLL_LINKPASS);\n\t\tcsr &= ~TULIP_STS_ABNRMLINTR;\n\t    }\n\t    tulip_media_print(sc);\n\t}\n\tif (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {\n\t    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);\n\t    if (csr & TULIP_STS_RXNOBUF)\n\t\tsc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;\n\t    /*\n\t     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data\n\t     * on receive overflows.\n\t     */\n\t   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {\n\t\tsc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;\n\t\t/*\n\t\t * Stop the receiver process and spin until it's stopped.\n\t\t * Tell rx_intr to drop the packets it dequeues.\n\t\t */\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);\n\t\twhile ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)\n\t\t    ;\n\t\tTULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\tsc->tulip_flags |= TULIP_RXIGNORE;\n\t    }\n\t    tulip_rx_intr(sc);\n\t    if (sc->tulip_flags & TULIP_RXIGNORE) {\n\t\t/*\n\t\t * Restart the receiver.\n\t\t */\n\t\tsc->tulip_flags &= ~TULIP_RXIGNORE;\n\t\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t    }\n\t}\n\tif (csr & TULIP_STS_ABNRMLINTR) {\n\t    u_int32_t tmp = csr & sc->tulip_intrmask\n\t\t& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);\n\t    if (csr & TULIP_STS_TXUNDERFLOW) {\n#if defined(TULIP_DEBUG)\n\t\tprintf (\"Underflow interrupt\\n\");\n#endif\n\t\tif ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {\n\t\t    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;\n\t\t    sc->tulip_flags |= TULIP_NEWTXTHRESH;\n\t\t}\n\t    }\n\t    if (sc->tulip_flags & TULIP_NOMESSAGES) {\n\t\tsc->tulip_statusbits |= tmp;\n\t    } else {\n\t\ttulip_print_abnormal_interrupt(sc, tmp);\n\t\tsc->tulip_flags |= TULIP_NOMESSAGES;\n\t    }\n\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t}\n\tif (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {\n\t    tulip_tx_intr(sc);\n\t    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t\ttulip_ifstart(&sc->tulip_if);\n\t}\n    }\n    if (sc->tulip_flags & TULIP_NEEDRESET) {\n\ttulip_reset(sc);\n\ttulip_init(sc);\n    }\n    TULIP_PERFEND(intr);\n}"
  },
  {
    "function_name": "tulip_print_abnormal_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3754-3782",
    "snippet": "static void\ntulip_print_abnormal_interrupt(\n    tulip_softc_t * const sc,\n    u_int32_t csr)\n{\n    const char * const *msgp = tulip_status_bits;\n    const char *sep;\n    u_int32_t mask;\n    const char thrsh[] = \"72|128\\0\\0\\0\" \"96|256\\0\\0\\0\" \"128|512\\0\\0\" \"160|1024\\0\";\n\n    csr &= (1 << (sizeof(tulip_status_bits)/sizeof(tulip_status_bits[0]))) - 1;\n    printf(TULIP_PRINTF_FMT \": abnormal interrupt:\", TULIP_PRINTF_ARGS);\n    for (sep = \" \", mask = 1; mask <= csr; mask <<= 1, msgp++) {\n\tif ((csr & mask) && *msgp != NULL) {\n\t    printf(\"%s%s\", sep, *msgp);\n\t    if (mask == TULIP_STS_TXUNDERFLOW && (sc->tulip_flags & TULIP_NEWTXTHRESH)) {\n\t\tsc->tulip_flags &= ~TULIP_NEWTXTHRESH;\n\t\tif (sc->tulip_cmdmode & TULIP_CMD_STOREFWD) {\n\t\t    printf(\" (switching to store-and-forward mode)\");\n\t\t} else {\n\t\t    printf(\" (raising TX threshold to %s)\",\n\t\t\t   &thrsh[9 * ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) >> 14)]);\n\t\t}\n\t    }\n\t    sep = \", \";\n\t}\n    }\n    printf(\"\\n\");\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_print_abnormal_interrupt(\n    tulip_softc_t * const sc,\n    u_int32_t csr)\n{\n    const char * const *msgp = tulip_status_bits;\n    const char *sep;\n    u_int32_t mask;\n    const char thrsh[] = \"72|128\\0\\0\\0\" \"96|256\\0\\0\\0\" \"128|512\\0\\0\" \"160|1024\\0\";\n\n    csr &= (1 << (sizeof(tulip_status_bits)/sizeof(tulip_status_bits[0]))) - 1;\n    printf(TULIP_PRINTF_FMT \": abnormal interrupt:\", TULIP_PRINTF_ARGS);\n    for (sep = \" \", mask = 1; mask <= csr; mask <<= 1, msgp++) {\n\tif ((csr & mask) && *msgp != NULL) {\n\t    printf(\"%s%s\", sep, *msgp);\n\t    if (mask == TULIP_STS_TXUNDERFLOW && (sc->tulip_flags & TULIP_NEWTXTHRESH)) {\n\t\tsc->tulip_flags &= ~TULIP_NEWTXTHRESH;\n\t\tif (sc->tulip_cmdmode & TULIP_CMD_STOREFWD) {\n\t\t    printf(\" (switching to store-and-forward mode)\");\n\t\t} else {\n\t\t    printf(\" (raising TX threshold to %s)\",\n\t\t\t   &thrsh[9 * ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) >> 14)]);\n\t\t}\n\t    }\n\t    sep = \", \";\n\t}\n    }\n    printf(\"\\n\");\n}"
  },
  {
    "function_name": "tulip_tx_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3624-3752",
    "snippet": "static int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "event"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_BPF_MTAP",
          "args": [
            "sc",
            "m"
          ],
          "line": 3670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->tulip_txq",
            "m"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DESC_BO",
          "args": [
            "ri->ri_nextin->d_status"
          ],
          "line": 3665
        },
        "resolved": true,
        "details": {
          "function_name": "DESC_BO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "104-114",
          "snippet": "__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\n__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_status",
            "TULIP_STS_RXSTOPPED"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_rx_intr",
          "args": [
            "sc"
          ],
          "line": 3657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic int\ntulip_tx_intr(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    struct mbuf *m;\n    int xmits = 0;\n    int descs = 0;\n\n    while (ri->ri_free < ri->ri_max) {\n\tu_int32_t d_flag;\n\tif (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)\n\t    break;\n\n\t{\n\t\ttulip_desc_bitfield_t u;\n\n\t\tu.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */\n\t\td_flag = u.bd_flag;\n\t}\n\tif (d_flag & TULIP_DFLAG_TxLASTSEG) {\n\t    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {\n\t\t/*\n\t\t * We've just finished processing a setup packet.\n\t\t * Mark that we finished it.  If there's not\n\t\t * another pending, startup the TULIP receiver.\n\t\t * Make sure we ack the RXSTOPPED so we won't get\n\t\t * an abormal interrupt indication.\n\t\t */\n\t\tsc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);\n\t\tif (d_flag & TULIP_DFLAG_TxINVRSFILT)\n\t\t    sc->tulip_flags |= TULIP_HASHONLY;\n\t\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {\n\t\t    tulip_rx_intr(sc);\n\t\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t\t    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);\n\t\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t\t    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\t\t}\n\t    } else {\n\t\tconst u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);\n\t\tIF_DEQUEUE(&sc->tulip_txq, m);\n\t\tif (m != NULL) {\n#if NBPFILTER > 0\n\t\t    if (sc->tulip_bpf != NULL)\n\t\t\tTULIP_BPF_MTAP(sc, m);\n#endif\n\t\tm_freem(m);\n#if defined(TULIP_DEBUG)\n\t\t} else {\n\t\t    printf(TULIP_PRINTF_FMT \": tx_intr: failed to dequeue mbuf?!?\\n\", TULIP_PRINTF_ARGS);\n#endif\n\t\t}\n\t\tif (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\t\t    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;\n\t\t    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {\n#if defined(TULIP_DEBUG)\n\t\t\tif (d_status & TULIP_DSTS_TxNOCARR)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_nocarr++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dbg.dbg_txprobe_exccoll++;\n#endif\n\t\t\tevent = TULIP_MEDIAPOLL_TXPROBE_FAILED;\n\t\t    }\n\t\t    (*sc->tulip_boardsw->bd_media_poll)(sc, event);\n\t\t    /*\n\t\t     * Escape from the loop before media poll has reset the TULIP!\n\t\t     */\n\t\t    break;\n\t\t} else {\n\t\t    xmits++;\n\t\t    if (d_status & TULIP_DSTS_ERRSUM) {\n\t\t\tsc->tulip_if.if_oerrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxEXCCOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;\n\t\t\tif (d_status & TULIP_DSTS_TxLATECOLL)\n\t\t\t    sc->tulip_dot3stats.dot3StatsLateCollisions++;\n\t\t\tif (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))\n\t\t\t    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;\n\t\t\tif (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;\n\t\t\tif (d_status & TULIP_DSTS_TxUNDERFLOW)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;\n\t\t\tif (d_status & TULIP_DSTS_TxBABBLE)\n\t\t\t    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;\n\t\t    } else {\n\t\t\tu_int32_t collisions = \n\t\t\t    (d_status & TULIP_DSTS_TxCOLLMASK)\n\t\t\t\t>> TULIP_DSTS_V_TxCOLLCNT;\n\t\t\tsc->tulip_if.if_collisions += collisions;\n\t\t\tif (collisions == 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;\n\t\t\telse if (collisions > 1)\n\t\t\t    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;\n\t\t\telse if (d_status & TULIP_DSTS_TxDEFERRED)\n\t\t\t    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;\n\t\t\t/*\n\t\t\t * SQE is only valid for 10baseT/BNC/AUI when not\n\t\t\t * running in full-duplex.  In order to speed up the\n\t\t\t * test, the corresponding bit in tulip_flags needs to\n\t\t\t * set as well to get us to count SQE Test Errors.\n\t\t\t */\n\t\t\tif (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)\n\t\t\t    sc->tulip_dot3stats.dot3StatsSQETestErrors++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (++ri->ri_nextin == ri->ri_last)\n\t    ri->ri_nextin = ri->ri_first;\n\n\tri->ri_free++;\n\tdescs++;\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)\n\t    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n    }\n    /*\n     * If nothing left to transmit, disable the timer.\n     * Else if progress, reset the timer back to 2 ticks.\n     */\n    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))\n\tsc->tulip_txtimer = 0;\n    else if (xmits > 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n    sc->tulip_if.if_opackets += xmits;\n    return descs;\n}"
  },
  {
    "function_name": "tulip_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3330-3371",
    "snippet": "static void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_txput_setup",
          "args": [
            "sc"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_txput_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4326-4411",
          "snippet": "static void\ntulip_txput_setup(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *nextout;\n\t\n    /*\n     * We will transmit, at most, one setup packet per call to ifstart.\n     */\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput_setup: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS);\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n#endif\n    /*\n     * Try to reclaim some free descriptors..\n     */\n    if (ri->ri_free < 2)\n\ttulip_tx_intr(sc);\n    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,\n\t  sizeof(sc->tulip_setupbuf));\n    /*\n     * Clear WANTSETUP and set DOINGSETUP.  Set know that WANTSETUP is\n     * set and DOINGSETUP is clear doing an XOR of the two will DTRT.\n     */\n    sc->tulip_flags ^= TULIP_WANTSETUP|TULIP_DOINGSETUP;\n    ri->ri_free--;\n#if defined(__mips__)\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));\n#endif\n    nextout = ri->ri_nextout;\n    {\n\tu_int32_t d_flag;\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(nextout->u.f); /* copy the bitfields */\n\td_flag = u.bd_flag;\n\n\td_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\td_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG\n\t    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;\n\tif (sc->tulip_flags & TULIP_WANTHASHPERFECT)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT;\n\telse if (sc->tulip_flags & TULIP_WANTHASHONLY)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;\n\n\n\tu.bd_flag = d_flag;\n\tu.bd_length1 = sizeof(sc->tulip_setupbuf);\n\tu.bd_length2 = 0;\n\n\tnextout->u.f = DESC_BO(u.f);\n\tnextout->d_addr1 = DESC_BO(TULIP_KVATOPHYS(sc, sc->tulip_setupbuf));\n\tnextout->d_addr2 = 0; /* no need to swab */\n    }\n\n    /*\n     * Advance the ring for the next transmit packet.\n     */\n    if (++ri->ri_nextout == ri->ri_last)\n\tri->ri_nextout = ri->ri_first;\n\n    /*\n     * Make sure the next descriptor is owned by us since it\n     * may have been set up above if we ran out of room in the\n     * ring.\n     */\n    ri->ri_nextout->d_status = 0; /* doesn't need swab - dsr */\n    nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n    if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\tsc->tulip_intrmask |= TULIP_STS_TXINTR;\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_txput_setup(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *nextout;\n\t\n    /*\n     * We will transmit, at most, one setup packet per call to ifstart.\n     */\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput_setup: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS);\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n#endif\n    /*\n     * Try to reclaim some free descriptors..\n     */\n    if (ri->ri_free < 2)\n\ttulip_tx_intr(sc);\n    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\treturn;\n    }\n    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,\n\t  sizeof(sc->tulip_setupbuf));\n    /*\n     * Clear WANTSETUP and set DOINGSETUP.  Set know that WANTSETUP is\n     * set and DOINGSETUP is clear doing an XOR of the two will DTRT.\n     */\n    sc->tulip_flags ^= TULIP_WANTSETUP|TULIP_DOINGSETUP;\n    ri->ri_free--;\n#if defined(__mips__)\n    pci_sync_cache(sc->tulip_pc, (vm_offset_t)sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));\n#endif\n    nextout = ri->ri_nextout;\n    {\n\tu_int32_t d_flag;\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(nextout->u.f); /* copy the bitfields */\n\td_flag = u.bd_flag;\n\n\td_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\td_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG\n\t    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;\n\tif (sc->tulip_flags & TULIP_WANTHASHPERFECT)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT;\n\telse if (sc->tulip_flags & TULIP_WANTHASHONLY)\n\t    d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;\n\n\n\tu.bd_flag = d_flag;\n\tu.bd_length1 = sizeof(sc->tulip_setupbuf);\n\tu.bd_length2 = 0;\n\n\tnextout->u.f = DESC_BO(u.f);\n\tnextout->d_addr1 = DESC_BO(TULIP_KVATOPHYS(sc, sc->tulip_setupbuf));\n\tnextout->d_addr2 = 0; /* no need to swab */\n    }\n\n    /*\n     * Advance the ring for the next transmit packet.\n     */\n    if (++ri->ri_nextout == ri->ri_last)\n\tri->ri_nextout = ri->ri_first;\n\n    /*\n     * Make sure the next descriptor is owned by us since it\n     * may have been set up above if we ran out of room in the\n     * ring.\n     */\n    ri->ri_nextout->d_status = 0; /* doesn't need swab - dsr */\n    nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n    if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\tsc->tulip_intrmask |= TULIP_STS_TXINTR;\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_rx_intr",
          "args": [
            "sc"
          ],
          "line": 3355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}"
  },
  {
    "function_name": "tulip_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3199-3328",
    "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_addr_filter",
          "args": [
            "sc"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_addr_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3093-3197",
          "snippet": "static void\ntulip_addr_filter(\n    tulip_softc_t * const sc)\n{\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    sc->tulip_flags &= ~(TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY|TULIP_ALLMULTI);\n    sc->tulip_flags |= TULIP_WANTSETUP|TULIP_WANTTXSTART;\n    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n#if defined(IFF_ALLMULTI)    \n    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;\n#endif\n    sc->tulip_if.if_start = tulip_ifstart;\t/* so the setup packet gets queued */\n    if (sc->tulip_multicnt > 14) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tunsigned hash;\n\t/*\n\t * Some early passes of the 21140 have broken implementations of\n\t * hash-perfect mode.  When we get too many multicasts for perfect\n\t * filtering with these chips, we need to switch into hash-only\n\t * mode (this is better than all-multicast on network with lots\n\t * of multicast traffic).\n\t */\n\tif (sc->tulip_features & TULIP_HAVE_BROKEN_HASH)\n\t    sc->tulip_flags |= TULIP_WANTHASHONLY;\n\telse\n\t    sc->tulip_flags |= TULIP_WANTHASHPERFECT;\n\t/*\n\t * If we have more than 14 multicasts, we have\n\t * go into hash perfect mode (512 bit multicast\n\t * hash and one perfect hardware).\n\t */\n\tbzero(sc->tulip_setupdata, sizeof(sc->tulip_setupdata));\n\tETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    hash = tulip_mchash(enm->enm_addrlo);\n\t\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t/*\n\t * No reason to use a hash if we are going to be\n\t * receiving every multicast.\n\t */\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    hash = tulip_mchash(etherbroadcastaddr);\n\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    if (sc->tulip_flags & TULIP_WANTHASHONLY) {\n\t\thash = tulip_mchash(sc->tulip_enaddr);\n\t\tsp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    } else {\n\t\tsp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t\tsp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t\tsp[41] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t    }\n\t}\n    }\n    if ((sc->tulip_flags & (TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY)) == 0) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tint idx = 0;\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    /*\n\t     * Else can get perfect filtering for 16 addresses.\n\t     */\n\t    ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\t    for (; enm != NULL; idx++) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[2]);\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t    }\n\t    /*\n\t     * Add the broadcast address.\n\t     */\n\t    idx++;\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t}\n\t/*\n\t * Pad the rest with our hardware address\n\t */\n\tfor (; idx < 16; idx++) {\n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t}\n    }\n#if defined(IFF_ALLMULTI)\n    if (sc->tulip_flags & TULIP_ALLMULTI)\n\tsc->tulip_if.if_flags |= IFF_ALLMULTI;\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_addr_filter(\n    tulip_softc_t * const sc)\n{\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    sc->tulip_flags &= ~(TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY|TULIP_ALLMULTI);\n    sc->tulip_flags |= TULIP_WANTSETUP|TULIP_WANTTXSTART;\n    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n#if defined(IFF_ALLMULTI)    \n    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;\n#endif\n    sc->tulip_if.if_start = tulip_ifstart;\t/* so the setup packet gets queued */\n    if (sc->tulip_multicnt > 14) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tunsigned hash;\n\t/*\n\t * Some early passes of the 21140 have broken implementations of\n\t * hash-perfect mode.  When we get too many multicasts for perfect\n\t * filtering with these chips, we need to switch into hash-only\n\t * mode (this is better than all-multicast on network with lots\n\t * of multicast traffic).\n\t */\n\tif (sc->tulip_features & TULIP_HAVE_BROKEN_HASH)\n\t    sc->tulip_flags |= TULIP_WANTHASHONLY;\n\telse\n\t    sc->tulip_flags |= TULIP_WANTHASHPERFECT;\n\t/*\n\t * If we have more than 14 multicasts, we have\n\t * go into hash perfect mode (512 bit multicast\n\t * hash and one perfect hardware).\n\t */\n\tbzero(sc->tulip_setupdata, sizeof(sc->tulip_setupdata));\n\tETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    hash = tulip_mchash(enm->enm_addrlo);\n\t\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t/*\n\t * No reason to use a hash if we are going to be\n\t * receiving every multicast.\n\t */\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    hash = tulip_mchash(etherbroadcastaddr);\n\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    if (sc->tulip_flags & TULIP_WANTHASHONLY) {\n\t\thash = tulip_mchash(sc->tulip_enaddr);\n\t\tsp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    } else {\n\t\tsp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t\tsp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t\tsp[41] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t    }\n\t}\n    }\n    if ((sc->tulip_flags & (TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY)) == 0) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tint idx = 0;\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    /*\n\t     * Else can get perfect filtering for 16 addresses.\n\t     */\n\t    ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\t    for (; enm != NULL; idx++) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[2]);\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t    }\n\t    /*\n\t     * Add the broadcast address.\n\t     */\n\t    idx++;\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t}\n\t/*\n\t * Pad the rest with our hardware address\n\t */\n\tfor (; idx < 16; idx++) {\n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t}\n    }\n#if defined(IFF_ALLMULTI)\n    if (sc->tulip_flags & TULIP_ALLMULTI)\n\tsc->tulip_if.if_flags |= IFF_ALLMULTI;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_status",
            "TULIP_CSR_READ(sc, csr_sia_status)"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_sia_status"
          ],
          "line": 3323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_media_print",
          "args": [
            "sc"
          ],
          "line": 3321
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "438-453",
          "snippet": "static void\ntulip_media_print(\n    tulip_softc_t * const sc)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\treturn;\n    if (sc->tulip_flags & TULIP_PRINTMEDIA) {\n\tprintf(TULIP_PRINTF_FMT \": enabling %s port\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       tulip_mediums[sc->tulip_media]);\n\tsc->tulip_flags &= ~(TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n    } else if (sc->tulip_flags & TULIP_PRINTLINKUP) {\n\tprintf(TULIP_PRINTF_FMT \": link up\\n\", TULIP_PRINTF_ARGS);\n\tsc->tulip_flags &= ~TULIP_PRINTLINKUP;\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_print(\n    tulip_softc_t * const sc)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\treturn;\n    if (sc->tulip_flags & TULIP_PRINTMEDIA) {\n\tprintf(TULIP_PRINTF_FMT \": enabling %s port\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       tulip_mediums[sc->tulip_media]);\n\tsc->tulip_flags &= ~(TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n    } else if (sc->tulip_flags & TULIP_PRINTLINKUP) {\n\tprintf(TULIP_PRINTF_FMT \": link up\\n\", TULIP_PRINTF_ARGS);\n\tsc->tulip_flags &= ~TULIP_PRINTLINKUP;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 3318
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 3315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->tulip_rxq",
            "m"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DESC_BO",
          "args": [
            "u.f"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "DESC_BO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "104-114",
          "snippet": "__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\n__inline__ static u_int32_t\nDESC_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = x;\n\tx = (((s) >> 24) | (((s) >> 8) & 0xff00) | \n             ((s) << 24) | (((s) & 0xff00) << 8));\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IF_DEQUEUE",
          "args": [
            "&sc->tulip_txq",
            "m"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "(1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0)"
          ],
          "line": 3245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_BURSTSIZE",
          "args": [
            "sc->tulip_unit"
          ],
          "line": 3246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "(4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE/*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */"
          ],
          "line": 3236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_rxlist",
            "TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0])"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_KVATOPHYS",
          "args": [
            "sc",
            "&sc->tulip_rxinfo.ri_first[0]"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_txlist",
            "TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0])"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_KVATOPHYS",
          "args": [
            "sc",
            "&sc->tulip_txinfo.ri_first[0]"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 3222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "TULIP_BUSMODE_SWRESET"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 3219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
  },
  {
    "function_name": "tulip_addr_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3093-3197",
    "snippet": "static void\ntulip_addr_filter(\n    tulip_softc_t * const sc)\n{\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    sc->tulip_flags &= ~(TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY|TULIP_ALLMULTI);\n    sc->tulip_flags |= TULIP_WANTSETUP|TULIP_WANTTXSTART;\n    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n#if defined(IFF_ALLMULTI)    \n    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;\n#endif\n    sc->tulip_if.if_start = tulip_ifstart;\t/* so the setup packet gets queued */\n    if (sc->tulip_multicnt > 14) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tunsigned hash;\n\t/*\n\t * Some early passes of the 21140 have broken implementations of\n\t * hash-perfect mode.  When we get too many multicasts for perfect\n\t * filtering with these chips, we need to switch into hash-only\n\t * mode (this is better than all-multicast on network with lots\n\t * of multicast traffic).\n\t */\n\tif (sc->tulip_features & TULIP_HAVE_BROKEN_HASH)\n\t    sc->tulip_flags |= TULIP_WANTHASHONLY;\n\telse\n\t    sc->tulip_flags |= TULIP_WANTHASHPERFECT;\n\t/*\n\t * If we have more than 14 multicasts, we have\n\t * go into hash perfect mode (512 bit multicast\n\t * hash and one perfect hardware).\n\t */\n\tbzero(sc->tulip_setupdata, sizeof(sc->tulip_setupdata));\n\tETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    hash = tulip_mchash(enm->enm_addrlo);\n\t\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t/*\n\t * No reason to use a hash if we are going to be\n\t * receiving every multicast.\n\t */\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    hash = tulip_mchash(etherbroadcastaddr);\n\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    if (sc->tulip_flags & TULIP_WANTHASHONLY) {\n\t\thash = tulip_mchash(sc->tulip_enaddr);\n\t\tsp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    } else {\n\t\tsp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t\tsp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t\tsp[41] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t    }\n\t}\n    }\n    if ((sc->tulip_flags & (TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY)) == 0) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tint idx = 0;\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    /*\n\t     * Else can get perfect filtering for 16 addresses.\n\t     */\n\t    ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\t    for (; enm != NULL; idx++) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[2]);\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t    }\n\t    /*\n\t     * Add the broadcast address.\n\t     */\n\t    idx++;\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t}\n\t/*\n\t * Pad the rest with our hardware address\n\t */\n\tfor (; idx < 16; idx++) {\n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t}\n    }\n#if defined(IFF_ALLMULTI)\n    if (sc->tulip_flags & TULIP_ALLMULTI)\n\tsc->tulip_if.if_flags |= IFF_ALLMULTI;\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FILT_BO",
          "args": [
            "((u_int16_t *) sc->tulip_enaddr)[2]"
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "FILT_BO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_devar.h",
          "lines": "94-102",
          "snippet": "__inline__ static u_int32_t\nFILT_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = (x & 0xffff) << 16 | ((x & 0xff) << 8) | ((x & 0xff00) >> 8);\n\treturn s;\n}",
          "includes": [
            "#include <sys/devconf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/devconf.h>\n\n__inline__ static u_int32_t\nFILT_BO(x)\n    u_int32_t x;\n{\n\tu_int32_t s;\n\n\ts = (x & 0xffff) << 16 | ((x & 0xff) << 8) | ((x & 0xff00) >> 8);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "6"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "TULIP_ETHERCOM(sc)",
            "enm"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_ETHERCOM",
          "args": [
            "sc"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mchash",
          "args": [
            "sc->tulip_enaddr"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mchash",
          "args": [
            "etherbroadcastaddr"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_NEXT_MULTI",
          "args": [
            "step",
            "enm"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mchash",
          "args": [
            "enm->enm_addrlo"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "enm->enm_addrlo",
            "enm->enm_addrhi",
            "6"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ETHER_FIRST_MULTI",
          "args": [
            "step",
            "TULIP_ETHERCOM(sc)",
            "enm"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_ETHERCOM",
          "args": [
            "sc"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bzero",
          "args": [
            "sc->tulip_setupdata",
            "sizeof(sc->tulip_setupdata)"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_addr_filter(\n    tulip_softc_t * const sc)\n{\n    struct ether_multistep step;\n    struct ether_multi *enm;\n\n    sc->tulip_flags &= ~(TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY|TULIP_ALLMULTI);\n    sc->tulip_flags |= TULIP_WANTSETUP|TULIP_WANTTXSTART;\n    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n#if defined(IFF_ALLMULTI)    \n    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;\n#endif\n    sc->tulip_if.if_start = tulip_ifstart;\t/* so the setup packet gets queued */\n    if (sc->tulip_multicnt > 14) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tunsigned hash;\n\t/*\n\t * Some early passes of the 21140 have broken implementations of\n\t * hash-perfect mode.  When we get too many multicasts for perfect\n\t * filtering with these chips, we need to switch into hash-only\n\t * mode (this is better than all-multicast on network with lots\n\t * of multicast traffic).\n\t */\n\tif (sc->tulip_features & TULIP_HAVE_BROKEN_HASH)\n\t    sc->tulip_flags |= TULIP_WANTHASHONLY;\n\telse\n\t    sc->tulip_flags |= TULIP_WANTHASHPERFECT;\n\t/*\n\t * If we have more than 14 multicasts, we have\n\t * go into hash perfect mode (512 bit multicast\n\t * hash and one perfect hardware).\n\t */\n\tbzero(sc->tulip_setupdata, sizeof(sc->tulip_setupdata));\n\tETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\twhile (enm != NULL) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    hash = tulip_mchash(enm->enm_addrlo);\n\t\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t}\n\t/*\n\t * No reason to use a hash if we are going to be\n\t * receiving every multicast.\n\t */\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    hash = tulip_mchash(etherbroadcastaddr);\n\t    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    if (sc->tulip_flags & TULIP_WANTHASHONLY) {\n\t\thash = tulip_mchash(sc->tulip_enaddr);\n\t\tsp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));\n\t    } else {\n\t\tsp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t\tsp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t\tsp[41] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t    }\n\t}\n    }\n    if ((sc->tulip_flags & (TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY)) == 0) {\n\tu_int32_t *sp = sc->tulip_setupdata;\n\tint idx = 0;\n\tif ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {\n\t    /*\n\t     * Else can get perfect filtering for 16 addresses.\n\t     */\n\t    ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);\n\t    for (; enm != NULL; idx++) {\n\t\tif (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {\n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]); \n\t\t    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[2]);\n\t\t} else {\n\t\t    sc->tulip_flags |= TULIP_ALLMULTI;\n\t\t    break;\n\t\t}\n\t\tETHER_NEXT_MULTI(step, enm);\n\t    }\n\t    /*\n\t     * Add the broadcast address.\n\t     */\n\t    idx++;\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t    *sp++ = FILT_BO(0xFFFF);\n\t}\n\t/*\n\t * Pad the rest with our hardware address\n\t */\n\tfor (; idx < 16; idx++) {\n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); \n\t    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);\n\t}\n    }\n#if defined(IFF_ALLMULTI)\n    if (sc->tulip_flags & TULIP_ALLMULTI)\n\tsc->tulip_if.if_flags |= IFF_ALLMULTI;\n#endif\n}"
  },
  {
    "function_name": "tulip_ifmedia_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3067-3090",
    "snippet": "static void\ntulip_ifmedia_status(\n    struct ifnet * const ifp,\n    struct ifmediareq *req)\n{\n    tulip_softc_t *sc = TULIP_IFP_TO_SOFTC(ifp);\n\n#if defined(__bsdi__)\n    if (sc->tulip_mii.mii_instance != 0) {\n\tmii_pollstat(&sc->tulip_mii);\n\treq->ifm_active = sc->tulip_mii.mii_media_active;\n\treq->ifm_status = sc->tulip_mii.mii_media_status;\n\treturn;\n    }\n#endif\n    if (sc->tulip_media == TULIP_MEDIA_UNKNOWN)\n\treturn;\n\n    req->ifm_status = IFM_AVALID;\n    if (sc->tulip_flags & TULIP_LINKUP)\n\treq->ifm_status |= IFM_ACTIVE;\n\n    req->ifm_active = tulip_media_to_ifmedia[sc->tulip_media];\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct ifnet * const ifp = &sc->tulip_if;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mii_pollstat",
          "args": [
            "&sc->tulip_mii"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "mii_pollstat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/mii/mii.c",
          "lines": "206-218",
          "snippet": "void\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}",
          "includes": [
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/socket.h>",
            "#include <sys/systm.h>",
            "#include <sys/device.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/socket.h>\n#include <sys/systm.h>\n#include <sys/device.h>\n#include <sys/param.h>\n\nvoid\nmii_pollstat(mii)\n\tstruct mii_data *mii;\n{\n\tstruct mii_softc *child;\n\n\tmii->mii_media_status = 0;\n\tmii->mii_media_active = IFM_NONE;\n\n\tfor (child = LIST_FIRST(&mii->mii_phys); child != NULL;\n\t     child = LIST_NEXT(child, mii_list))\n\t\t(void) (*child->mii_service)(child, mii, MII_POLLSTAT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic void\ntulip_ifmedia_status(\n    struct ifnet * const ifp,\n    struct ifmediareq *req)\n{\n    tulip_softc_t *sc = TULIP_IFP_TO_SOFTC(ifp);\n\n#if defined(__bsdi__)\n    if (sc->tulip_mii.mii_instance != 0) {\n\tmii_pollstat(&sc->tulip_mii);\n\treq->ifm_active = sc->tulip_mii.mii_media_active;\n\treq->ifm_status = sc->tulip_mii.mii_media_status;\n\treturn;\n    }\n#endif\n    if (sc->tulip_media == TULIP_MEDIA_UNKNOWN)\n\treturn;\n\n    req->ifm_status = IFM_AVALID;\n    if (sc->tulip_flags & TULIP_LINKUP)\n\treq->ifm_status |= IFM_ACTIVE;\n\n    req->ifm_active = tulip_media_to_ifmedia[sc->tulip_media];\n}"
  },
  {
    "function_name": "tulip_ifmedia_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3037-3062",
    "snippet": "static int\ntulip_ifmedia_change(\n    struct ifnet * const ifp)\n{\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    sc->tulip_flags |= TULIP_NEEDRESET;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_media = TULIP_MEDIA_UNKNOWN;\n    if (IFM_SUBTYPE(sc->tulip_ifmedia.ifm_media) != IFM_AUTO) {\n\ttulip_media_t media;\n\tfor (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\t    if (sc->tulip_mediums[media] != NULL\n\t\t&& sc->tulip_ifmedia.ifm_media == tulip_media_to_ifmedia[media]) {\n\t\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\ttulip_linkup(sc, media);\n\t\treturn 0;\n\t    }\n\t}\n    }\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_WANTRXACT);\n    tulip_reset(sc);\n    tulip_init(sc);\n    return 0;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);",
      "static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "struct ifnet * const ifp = &sc->tulip_if;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_init",
          "args": [
            "sc"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3330-3371",
          "snippet": "static void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_linkup",
          "args": [
            "sc",
            "media"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_linkup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "384-436",
          "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IFM_SUBTYPE",
          "args": [
            "sc->tulip_ifmedia.ifm_media"
          ],
          "line": 3046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IFP_TO_SOFTC",
          "args": [
            "ifp"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);\nstatic ifnet_ret_t tulip_ifstart(struct ifnet *ifp);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstruct ifnet * const ifp = &sc->tulip_if;\n\nstatic int\ntulip_ifmedia_change(\n    struct ifnet * const ifp)\n{\n    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);\n\n    sc->tulip_flags |= TULIP_NEEDRESET;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_media = TULIP_MEDIA_UNKNOWN;\n    if (IFM_SUBTYPE(sc->tulip_ifmedia.ifm_media) != IFM_AUTO) {\n\ttulip_media_t media;\n\tfor (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\t    if (sc->tulip_mediums[media] != NULL\n\t\t&& sc->tulip_ifmedia.ifm_media == tulip_media_to_ifmedia[media]) {\n\t\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\ttulip_linkup(sc, media);\n\t\treturn 0;\n\t    }\n\t}\n    }\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_WANTRXACT);\n    tulip_reset(sc);\n    tulip_init(sc);\n    return 0;\n}"
  },
  {
    "function_name": "tulip_ifmedia_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "3009-3035",
    "snippet": "static void\ntulip_ifmedia_add(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t media;\n    int medias = 0;\n\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tif (sc->tulip_mediums[media] != NULL) {\n\t    ifmedia_add(&sc->tulip_ifmedia, tulip_media_to_ifmedia[media],\n\t\t\t0, 0);\n\t    medias++;\n\t}\n    }\n    if (medias == 0) {\n\tsc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE);\n    } else if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO);\n    } else {\n\tifmedia_set(&sc->tulip_ifmedia, tulip_media_to_ifmedia[sc->tulip_media]);\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\ttulip_linkup(sc, sc->tulip_media);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_linkup",
          "args": [
            "sc",
            "sc->tulip_media"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_linkup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "384-436",
          "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->tulip_ifmedia",
            "tulip_media_to_ifmedia[sc->tulip_media]"
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->tulip_ifmedia",
            "IFM_ETHER | IFM_AUTO"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->tulip_ifmedia",
            "IFM_ETHER | IFM_AUTO",
            "0",
            "0"
          ],
          "line": 3028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_set",
          "args": [
            "&sc->tulip_ifmedia",
            "IFM_ETHER | IFM_NONE"
          ],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->tulip_ifmedia",
            "IFM_ETHER | IFM_NONE",
            "0",
            "0"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ifmedia_add",
          "args": [
            "&sc->tulip_ifmedia",
            "tulip_media_to_ifmedia[media]",
            "0",
            "0"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_ifmedia_add(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t media;\n    int medias = 0;\n\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tif (sc->tulip_mediums[media] != NULL) {\n\t    ifmedia_add(&sc->tulip_ifmedia, tulip_media_to_ifmedia[media],\n\t\t\t0, 0);\n\t    medias++;\n\t}\n    }\n    if (medias == 0) {\n\tsc->tulip_features |= TULIP_HAVE_NOMEDIA;\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE);\n    } else if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {\n\tifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO, 0, 0);\n\tifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO);\n    } else {\n\tifmedia_set(&sc->tulip_ifmedia, tulip_media_to_ifmedia[sc->tulip_media]);\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\ttulip_linkup(sc, sc->tulip_media);\n    }\n}"
  },
  {
    "function_name": "tulip_read_macaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2780-3006",
    "snippet": "static int\ntulip_read_macaddr(\n    tulip_softc_t * const sc)\n{\n    unsigned cksum, rom_cksum, idx;\n    u_int32_t csr;\n    unsigned char tmpbuf[8];\n    static const u_char testpat[] = { 0xFF, 0, 0x55, 0xAA, 0xFF, 0, 0x55, 0xAA };\n\n    sc->tulip_connidx = TULIP_SROM_LASTCONNIDX;\n\n    if (sc->tulip_chipid == TULIP_21040) {\n\tTULIP_CSR_WRITE(sc, csr_enetrom, 1);\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    int cnt = 0;\n\t    while (((csr = TULIP_CSR_READ(sc, csr_enetrom)) & 0x80000000L) && cnt < 10000)\n\t\tcnt++;\n\t    sc->tulip_rombuf[idx] = csr & 0xFF;\n\t}\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#if defined(TULIP_EISA)\n    } else if (sc->tulip_chipid == TULIP_DE425) {\n\tint cnt;\n\tfor (idx = 0, cnt = 0; idx < sizeof(testpat) && cnt < 32; cnt++) {\n\t    tmpbuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\t    if (tmpbuf[idx] == testpat[idx])\n\t\t++idx;\n\t    else\n\t\tidx = 0;\n\t}\n\tfor (idx = 0; idx < 32; idx++)\n\t    sc->tulip_rombuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#endif /* TULIP_EISA */\n    } else {\n\tif (sc->tulip_chipid == TULIP_21041) {\n\t    /*\n\t     * Thankfully all 21041's act the same.\n\t     */\n\t    sc->tulip_boardsw = &tulip_21041_boardsw;\n\t} else {\n\t    /*\n\t     * Assume all 21140 board are compatible with the\n\t     * DEC 10/100 evaluation board.  Not really valid but\n\t     * it's the best we can do until every one switches to\n\t     * the new SROM format.\n\t     */\n\t     \n\t    sc->tulip_boardsw = &tulip_21140_eb_boardsw;\n\t}\n#ifdef NEED_PCI_ETHER_HW_ADDR_FUNC\n\tif(pci_ether_hw_addr(sc->tulip_pc, (u_char *)(&sc->tulip_rombuf),\n\t    sc->tulip_pci_busno, sc->tulip_pci_devno)) {\n\t    \tif(sc->tulip_boardsw == &tulip_21041_boardsw)\n\t\t    sc->tulip_boardsw = &tulip_21041np_boardsw;\n\t}\n\telse {\n\t\ttulip_srom_read(sc);\n\t}\n#else\n\ttulip_srom_read(sc);\n#endif\n\tif (tulip_srom_crcok(sc->tulip_rombuf)) {\n\t    /*\n\t     * SROM CRC is valid therefore it must be in the\n\t     * new format.\n\t     */\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM;\n\t} else if (sc->tulip_rombuf[126] == 0xff && sc->tulip_rombuf[127] == 0xFF) {\n\t    /*\n\t     * No checksum is present.  See if the SROM id checks out;\n\t     * the first 18 bytes should be 0 followed by a 1 followed\n\t     * by the number of adapters (which we don't deal with yet).\n\t     */\n\t    for (idx = 0; idx < 18; idx++) {\n\t\tif (sc->tulip_rombuf[idx] != 0)\n\t\t    break;\n\t    }\n\t    if (idx == 18 && sc->tulip_rombuf[18] == 1 && sc->tulip_rombuf[19] != 0)\n\t\tsc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t} else if (sc->tulip_chipid >= TULIP_21142) {\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t    sc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\t}\n\tif ((sc->tulip_features & TULIP_HAVE_ISVSROM) && tulip_srom_decode(sc)) {\n\t    if (sc->tulip_chipid != TULIP_21041)\n\t\tsc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\n\t    /*\n\t     * If the SROM specifies more than one adapter, tag this as a\n\t     * BASE rom.\n\t     */\n\t    if (sc->tulip_rombuf[19] > 1)\n\t\tsc->tulip_features |= TULIP_HAVE_BASEROM;\n\t    if (sc->tulip_boardsw == NULL)\n\t\treturn -6;\n\t    goto check_oui;\n\t}\n    }\n\n\n    if (bcmp(&sc->tulip_rombuf[0], &sc->tulip_rombuf[16], 8) != 0) {\n\t/*\n\t * Some folks don't use the standard ethernet rom format\n\t * but instead just put the address in the first 6 bytes\n\t * of the rom and let the rest be all 0xffs.  (Can we say\n\t * ZNYX???) (well sometimes they put in a checksum so we'll\n\t * start at 8).\n\t */\n\tfor (idx = 8; idx < 32; idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0xFF)\n\t\treturn -4;\n\t}\n\t/*\n\t * Make sure the address is not multicast or locally assigned\n\t * that the OUI is not 00-00-00.\n\t */\n\tif ((sc->tulip_rombuf[0] & 3) != 0)\n\t    return -4;\n\tif (sc->tulip_rombuf[0] == 0 && sc->tulip_rombuf[1] == 0\n\t\t&& sc->tulip_rombuf[2] == 0)\n\t    return -4;\n\tbcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\tsc->tulip_features |= TULIP_HAVE_OKROM;\n\tgoto check_oui;\n    } else {\n\t/*\n\t * A number of makers of multiport boards (ZNYX and Cogent)\n\t * only put on one address ROM on their 21040 boards.  So\n\t * if the ROM is all zeros (or all 0xFFs), look at the\n\t * previous configured boards (as long as they are on the same\n\t * PCI bus and the bus number is non-zero) until we find the\n\t * master board with address ROM.  We then use its address ROM\n\t * as the base for this board.  (we add our relative board\n\t * to the last byte of its address).\n\t */\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0 && sc->tulip_rombuf[idx] != 0xFF)\n\t\tbreak;\n\t}\n\tif (idx == sizeof(sc->tulip_rombuf)) {\n\t    int root_unit;\n\t    tulip_softc_t *root_sc = NULL;\n\t    for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {\n\t\troot_sc = TULIP_UNIT_TO_SOFTC(root_unit);\n\t\tif (root_sc == NULL || (root_sc->tulip_features & (TULIP_HAVE_OKROM|TULIP_HAVE_SLAVEDROM)) == TULIP_HAVE_OKROM)\n\t\t    break;\n\t\troot_sc = NULL;\n\t    }\n\t    if (root_sc != NULL && (root_sc->tulip_features & TULIP_HAVE_BASEROM)\n\t\t    && root_sc->tulip_chipid == sc->tulip_chipid\n\t\t    && root_sc->tulip_pci_busno == sc->tulip_pci_busno) {\n\t\tsc->tulip_features |= TULIP_HAVE_SLAVEDROM;\n\t\tsc->tulip_boardsw = root_sc->tulip_boardsw;\n\t\tstrcpy(sc->tulip_boardid, root_sc->tulip_boardid);\n\t\tif (sc->tulip_boardsw->bd_type == TULIP_21140_ISV) {\n\t\t    bcopy(root_sc->tulip_rombuf, sc->tulip_rombuf,\n\t\t\t  sizeof(sc->tulip_rombuf));\n\t\t    if (!tulip_srom_decode(sc))\n\t\t\treturn -5;\n\t\t} else {\n\t\t    bcopy(root_sc->tulip_enaddr, sc->tulip_enaddr, 6);\n\t\t    sc->tulip_enaddr[5] += sc->tulip_unit - root_sc->tulip_unit;\n\t\t}\n\t\t/*\n\t\t * Now for a truly disgusting kludge: all 4 21040s on\n\t\t * the ZX314 share the same INTA line so the mapping\n\t\t * setup by the BIOS on the PCI bridge is worthless.\n\t\t * Rather than reprogramming the value in the config\n\t\t * register, we will handle this internally.\n\t\t */\n\t\tif (root_sc->tulip_features & TULIP_HAVE_SHAREDINTR) {\n\t\t    sc->tulip_slaves = root_sc->tulip_slaves;\n\t\t    root_sc->tulip_slaves = sc;\n\t\t    sc->tulip_features |= TULIP_HAVE_SLAVEDINTR;\n\t\t}\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    /*\n     * This is the standard DEC address ROM test.\n     */\n\n    if (bcmp(&sc->tulip_rombuf[24], testpat, 8) != 0)\n\treturn -3;\n\n    tmpbuf[0] = sc->tulip_rombuf[15]; tmpbuf[1] = sc->tulip_rombuf[14];\n    tmpbuf[2] = sc->tulip_rombuf[13]; tmpbuf[3] = sc->tulip_rombuf[12];\n    tmpbuf[4] = sc->tulip_rombuf[11]; tmpbuf[5] = sc->tulip_rombuf[10];\n    tmpbuf[6] = sc->tulip_rombuf[9];  tmpbuf[7] = sc->tulip_rombuf[8];\n    if (bcmp(&sc->tulip_rombuf[0], tmpbuf, 8) != 0)\n\treturn -2;\n\n    bcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\n    cksum = *(u_int16_t *) &sc->tulip_enaddr[0];\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[2];\n    if (cksum > 65535) cksum -= 65535;\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[4];\n    if (cksum >= 65535) cksum -= 65535;\n\n    rom_cksum = *(u_int16_t *) &sc->tulip_rombuf[6];\n\t\n    if (cksum != rom_cksum)\n\treturn -1;\n\n  check_oui:\n    /*\n     * Check for various boards based on OUI.  Did I say braindead?\n     */\n    for (idx = 0; tulip_vendors[idx].vendor_identify_nic != NULL; idx++) {\n\tif (bcmp((caddr_t) sc->tulip_enaddr,\n\t\t (caddr_t) tulip_vendors[idx].vendor_oui, 3) == 0) {\n\t    (*tulip_vendors[idx].vendor_identify_nic)(sc);\n\t    break;\n\t}\n    }\n\n    sc->tulip_features |= TULIP_HAVE_OKROM;\n    return 0;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_EISA"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "static const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};",
      "static const tulip_boardsw_t tulip_21041_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_probe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};",
      "static const tulip_boardsw_t tulip_21041np_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_noprobe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};",
      "static const tulip_boardsw_t tulip_21140_eb_boardsw = {\n    TULIP_21140_DEC_EB,\n    tulip_21140_evalboard_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};",
      "static const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};",
      "static const struct {\n    void (*vendor_identify_nic)(tulip_softc_t * const sc);\n    unsigned char vendor_oui[3];\n} tulip_vendors[] = {\n    { tulip_identify_dec_nic,\t\t{ 0x08, 0x00, 0x2B } },\n    { tulip_identify_dec_nic,\t\t{ 0x00, 0x00, 0xF8 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0x00, 0xC0 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0xE0, 0x29 } },\n    { tulip_identify_znyx_nic,\t\t{ 0x00, 0xC0, 0x95 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0x92 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0xD1 } },\n    { tulip_identify_asante_nic,\t{ 0x00, 0x00, 0x94 } },\n    { tulip_identify_accton_nic,\t{ 0x00, 0x00, 0xE8 } },\n    { NULL }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "(caddr_t) sc->tulip_enaddr",
            "(caddr_t) tulip_vendors[idx].vendor_oui",
            "3"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->tulip_rombuf",
            "sc->tulip_enaddr",
            "6"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "&sc->tulip_rombuf[0]",
            "tmpbuf",
            "8"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "&sc->tulip_rombuf[24]",
            "testpat",
            "8"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_srom_decode",
          "args": [
            "sc"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_srom_decode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2398-2758",
          "snippet": "static int\ntulip_srom_decode(\n    tulip_softc_t * const sc)\n{\n    unsigned idx1, idx2, idx3;\n\n    const tulip_srom_header_t *shp = (tulip_srom_header_t *) &sc->tulip_rombuf[0];\n    const tulip_srom_adapter_info_t *saip = (tulip_srom_adapter_info_t *) (shp + 1);\n    tulip_srom_media_t srom_media;\n    tulip_media_info_t *mi = sc->tulip_mediainfo;\n    const u_int8_t *dp;\n    u_int32_t leaf_offset, blocks, data;\n\n    for (idx1 = 0; idx1 < shp->sh_adapter_count; idx1++, saip++) {\n\tif (shp->sh_adapter_count == 1)\n\t    break;\n\tif (saip->sai_device == sc->tulip_pci_devno)\n\t    break;\n    }\n    /*\n     * Didn't find the right media block for this card.\n     */\n    if (idx1 == shp->sh_adapter_count)\n\treturn 0;\n\n    /*\n     * Save the hardware address.\n     */\n    bcopy((caddr_t) shp->sh_ieee802_address, (caddr_t) sc->tulip_enaddr, 6);\n    /*\n     * If this is a multiple port card, add the adapter index to the last\n     * byte of the hardware address.  (if it isn't multiport, adding 0\n     * won't hurt.\n     */\n    sc->tulip_enaddr[5] += idx1;\n\n    leaf_offset = saip->sai_leaf_offset_lowbyte\n\t+ saip->sai_leaf_offset_highbyte * 256;\n    dp = sc->tulip_rombuf + leaf_offset;\n\t\n    sc->tulip_conntype = (tulip_srom_connection_t) (dp[0] + dp[1] * 256); dp += 2;\n\n    for (idx2 = 0;; idx2++) {\n\tif (tulip_srom_conninfo[idx2].sc_type == sc->tulip_conntype\n\t        || tulip_srom_conninfo[idx2].sc_type == TULIP_SROM_CONNTYPE_NOT_USED)\n\t    break;\n    }\n    sc->tulip_connidx = idx2;\n\n    if (sc->tulip_chipid == TULIP_21041) {\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    tulip_media_t media;\n\t    data = *dp++;\n\t    srom_media = (tulip_srom_media_t) (data & 0x3F);\n\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t    break;\n\t    }\n\t    media = tulip_srom_mediums[idx3].sm_type;\n\t    if (media != TULIP_MEDIA_UNKNOWN) {\n\t\tif (data & TULIP_SROM_21041_EXTENDED) {\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_sia_connectivity = dp[0] + dp[1] * 256;\n\t\t    mi->mi_sia_tx_rx        = dp[2] + dp[3] * 256;\n\t\t    mi->mi_sia_general      = dp[4] + dp[5] * 256;\n\t\t    mi++;\n\t\t} else {\n\t\t    switch (media) {\n\t\t\tcase TULIP_MEDIA_BNC: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_AUI: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET_FD: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if (data & TULIP_SROM_21041_EXTENDED)\t\n\t\tdp += 6;\n\t}\n#ifdef notdef\n\tif (blocks == 0) {\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD); mi++;\n\t}\n#endif\n    } else {\n\tunsigned length, type;\n\ttulip_media_t gp_media = TULIP_MEDIA_UNKNOWN;\n\tif (sc->tulip_features & TULIP_HAVE_GPR)\n\t    sc->tulip_gpinit = *dp++;\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    const u_int8_t *ep;\n\t    if ((*dp & 0x80) == 0) {\n\t\tlength = 4;\n\t\ttype = 0;\n\t    } else {\n\t\tlength = (*dp++ & 0x7f) - 1;\n\t\ttype = *dp++ & 0x3f;\n\t    }\n\t    ep = dp + length;\n\t    switch (type & 0x3f) {\n\t\tcase 0: {\t/* 21140[A] GPR block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_GPR;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpdata = dp[1];\n\t\t    if (media > gp_media && !TULIP_IS_MEDIA_FD(media)) {\n\t\t\tsc->tulip_gpdata = mi->mi_gpdata;\n\t\t\tgp_media = media;\n\t\t    }\n\t\t    data = dp[2] + dp[3] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n#if 0\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n#endif\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 1: {\t/* 21140[A] MII block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_reset_length;\n\n\t\t    /*\n\t\t     * Before we probe for a PHY, use the GPR information\n\t\t     * to select it.  If we don't, it may be inaccessible.\n\t\t     */\n\t\t    TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpinit|TULIP_GP_PINSET);\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx3]);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx3]);\n\t\t    }\n\n\t\t    /*\n\t\t     * At least write something!\n\t\t     */\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 2: {\t/* 2114[23] SIA block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    if (dp[0] & 0x40) {\n\t\t\tmi->mi_sia_connectivity = dp[1] + dp[2] * 256;\n\t\t\tmi->mi_sia_tx_rx        = dp[3] + dp[4] * 256;\n\t\t\tmi->mi_sia_general      = dp[5] + dp[6] * 256;\n\t\t\tdp += 6;\n\t\t    } else {\n\t\t\tswitch (media) {\n\t\t\t    case TULIP_MEDIA_BNC: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, BNC);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_AUI: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, AUI);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET_FD: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET_FD);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    default: {\n\t\t\t\tgoto bad_media;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    mi->mi_sia_gp_control = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_sia_gp_data    = (dp[3] + dp[4] * 256) << 16;\n\t\t    mi++;\n\t\t  bad_media:\n\t\t    break;\n\t\t}\n\t\tcase 3: {\t/* 2114[23] MII PHY block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    const u_int8_t *dp0;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_mii_interrupt = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 4: {\t/* 21143 SYM block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t) dp[0];\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SYM;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpcontrol = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_gpdata    = (dp[3] + dp[4] * 256) << 16;\n\t\t    data = dp[5] + dp[6] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    if (TULIP_IS_MEDIA_TP(media))\n\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#if 0\n\t\tcase 5: {\t/* 21143 Reset block */\n\t\t    mi->mi_type = TULIP_MEDIAINFO_RESET;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#endif\n\t\tdefault: {\n\t\t}\n\t    }\n\t    dp = ep;\n\t}\n    }\n    return mi - sc->tulip_mediainfo;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_srom_decode(\n    tulip_softc_t * const sc)\n{\n    unsigned idx1, idx2, idx3;\n\n    const tulip_srom_header_t *shp = (tulip_srom_header_t *) &sc->tulip_rombuf[0];\n    const tulip_srom_adapter_info_t *saip = (tulip_srom_adapter_info_t *) (shp + 1);\n    tulip_srom_media_t srom_media;\n    tulip_media_info_t *mi = sc->tulip_mediainfo;\n    const u_int8_t *dp;\n    u_int32_t leaf_offset, blocks, data;\n\n    for (idx1 = 0; idx1 < shp->sh_adapter_count; idx1++, saip++) {\n\tif (shp->sh_adapter_count == 1)\n\t    break;\n\tif (saip->sai_device == sc->tulip_pci_devno)\n\t    break;\n    }\n    /*\n     * Didn't find the right media block for this card.\n     */\n    if (idx1 == shp->sh_adapter_count)\n\treturn 0;\n\n    /*\n     * Save the hardware address.\n     */\n    bcopy((caddr_t) shp->sh_ieee802_address, (caddr_t) sc->tulip_enaddr, 6);\n    /*\n     * If this is a multiple port card, add the adapter index to the last\n     * byte of the hardware address.  (if it isn't multiport, adding 0\n     * won't hurt.\n     */\n    sc->tulip_enaddr[5] += idx1;\n\n    leaf_offset = saip->sai_leaf_offset_lowbyte\n\t+ saip->sai_leaf_offset_highbyte * 256;\n    dp = sc->tulip_rombuf + leaf_offset;\n\t\n    sc->tulip_conntype = (tulip_srom_connection_t) (dp[0] + dp[1] * 256); dp += 2;\n\n    for (idx2 = 0;; idx2++) {\n\tif (tulip_srom_conninfo[idx2].sc_type == sc->tulip_conntype\n\t        || tulip_srom_conninfo[idx2].sc_type == TULIP_SROM_CONNTYPE_NOT_USED)\n\t    break;\n    }\n    sc->tulip_connidx = idx2;\n\n    if (sc->tulip_chipid == TULIP_21041) {\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    tulip_media_t media;\n\t    data = *dp++;\n\t    srom_media = (tulip_srom_media_t) (data & 0x3F);\n\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t    break;\n\t    }\n\t    media = tulip_srom_mediums[idx3].sm_type;\n\t    if (media != TULIP_MEDIA_UNKNOWN) {\n\t\tif (data & TULIP_SROM_21041_EXTENDED) {\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_sia_connectivity = dp[0] + dp[1] * 256;\n\t\t    mi->mi_sia_tx_rx        = dp[2] + dp[3] * 256;\n\t\t    mi->mi_sia_general      = dp[4] + dp[5] * 256;\n\t\t    mi++;\n\t\t} else {\n\t\t    switch (media) {\n\t\t\tcase TULIP_MEDIA_BNC: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_AUI: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET_FD: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if (data & TULIP_SROM_21041_EXTENDED)\t\n\t\tdp += 6;\n\t}\n#ifdef notdef\n\tif (blocks == 0) {\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD); mi++;\n\t}\n#endif\n    } else {\n\tunsigned length, type;\n\ttulip_media_t gp_media = TULIP_MEDIA_UNKNOWN;\n\tif (sc->tulip_features & TULIP_HAVE_GPR)\n\t    sc->tulip_gpinit = *dp++;\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    const u_int8_t *ep;\n\t    if ((*dp & 0x80) == 0) {\n\t\tlength = 4;\n\t\ttype = 0;\n\t    } else {\n\t\tlength = (*dp++ & 0x7f) - 1;\n\t\ttype = *dp++ & 0x3f;\n\t    }\n\t    ep = dp + length;\n\t    switch (type & 0x3f) {\n\t\tcase 0: {\t/* 21140[A] GPR block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_GPR;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpdata = dp[1];\n\t\t    if (media > gp_media && !TULIP_IS_MEDIA_FD(media)) {\n\t\t\tsc->tulip_gpdata = mi->mi_gpdata;\n\t\t\tgp_media = media;\n\t\t    }\n\t\t    data = dp[2] + dp[3] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n#if 0\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n#endif\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 1: {\t/* 21140[A] MII block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_reset_length;\n\n\t\t    /*\n\t\t     * Before we probe for a PHY, use the GPR information\n\t\t     * to select it.  If we don't, it may be inaccessible.\n\t\t     */\n\t\t    TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpinit|TULIP_GP_PINSET);\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx3]);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx3]);\n\t\t    }\n\n\t\t    /*\n\t\t     * At least write something!\n\t\t     */\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 2: {\t/* 2114[23] SIA block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    if (dp[0] & 0x40) {\n\t\t\tmi->mi_sia_connectivity = dp[1] + dp[2] * 256;\n\t\t\tmi->mi_sia_tx_rx        = dp[3] + dp[4] * 256;\n\t\t\tmi->mi_sia_general      = dp[5] + dp[6] * 256;\n\t\t\tdp += 6;\n\t\t    } else {\n\t\t\tswitch (media) {\n\t\t\t    case TULIP_MEDIA_BNC: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, BNC);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_AUI: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, AUI);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET_FD: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET_FD);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    default: {\n\t\t\t\tgoto bad_media;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    mi->mi_sia_gp_control = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_sia_gp_data    = (dp[3] + dp[4] * 256) << 16;\n\t\t    mi++;\n\t\t  bad_media:\n\t\t    break;\n\t\t}\n\t\tcase 3: {\t/* 2114[23] MII PHY block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    const u_int8_t *dp0;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_mii_interrupt = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 4: {\t/* 21143 SYM block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t) dp[0];\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SYM;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpcontrol = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_gpdata    = (dp[3] + dp[4] * 256) << 16;\n\t\t    data = dp[5] + dp[6] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    if (TULIP_IS_MEDIA_TP(media))\n\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#if 0\n\t\tcase 5: {\t/* 21143 Reset block */\n\t\t    mi->mi_type = TULIP_MEDIAINFO_RESET;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#endif\n\t\tdefault: {\n\t\t}\n\t    }\n\t    dp = ep;\n\t}\n    }\n    return mi - sc->tulip_mediainfo;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->tulip_boardid",
            "root_sc->tulip_boardid"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_UNIT_TO_SOFTC",
          "args": [
            "root_unit"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "&sc->tulip_rombuf[0]",
            "&sc->tulip_rombuf[16]",
            "8"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_srom_crcok",
          "args": [
            "sc->tulip_rombuf"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_srom_read",
          "args": [
            "sc"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_srom_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1933-1978",
          "snippet": "static void\ntulip_srom_read(\n    tulip_softc_t * const sc)\n{   \n    unsigned idx; \n    const unsigned bitwidth = SROM_BITWIDTH;\n    const unsigned cmdmask = (SROMCMD_RD << bitwidth);\n    const unsigned msb = 1 << (bitwidth + 3 - 1);\n    unsigned lastidx = (1 << bitwidth) - 1;\n\n    tulip_srom_idle(sc);\n\n    for (idx = 0; idx <= lastidx; idx++) {\n        unsigned lastbit, data, bits, bit, csr;\n\tcsr  = SROMSEL ;\t        EMIT;\n        csr  = SROMSEL | SROMRD;        EMIT;\n        csr ^= SROMCSON;                EMIT;\n        csr ^=            SROMCLKON;    EMIT;\n    \n        lastbit = 0;\n        for (bits = idx|cmdmask, bit = bitwidth + 3; bit > 0; bit--, bits <<= 1) {\n            const unsigned thisbit = bits & msb;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n            if (thisbit != lastbit) {\n                csr ^= SROMDOUT; EMIT;  /* clock low; invert data */\n            } else {\n\t\tEMIT;\n\t    }\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n            lastbit = thisbit;\n        }\n        csr ^= SROMCLKOFF; EMIT;\n\n        for (data = 0, bits = 0; bits < 16; bits++) {\n            data <<= 1;\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */ \n            data |= TULIP_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        }\n\tsc->tulip_rombuf[idx*2] = data & 0xFF;\n\tsc->tulip_rombuf[idx*2+1] = data >> 8;\n\tcsr  = SROMSEL | SROMRD; EMIT;\n\tcsr  = 0; EMIT;\n    }\n    tulip_srom_idle(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_srom_read(\n    tulip_softc_t * const sc)\n{   \n    unsigned idx; \n    const unsigned bitwidth = SROM_BITWIDTH;\n    const unsigned cmdmask = (SROMCMD_RD << bitwidth);\n    const unsigned msb = 1 << (bitwidth + 3 - 1);\n    unsigned lastidx = (1 << bitwidth) - 1;\n\n    tulip_srom_idle(sc);\n\n    for (idx = 0; idx <= lastidx; idx++) {\n        unsigned lastbit, data, bits, bit, csr;\n\tcsr  = SROMSEL ;\t        EMIT;\n        csr  = SROMSEL | SROMRD;        EMIT;\n        csr ^= SROMCSON;                EMIT;\n        csr ^=            SROMCLKON;    EMIT;\n    \n        lastbit = 0;\n        for (bits = idx|cmdmask, bit = bitwidth + 3; bit > 0; bit--, bits <<= 1) {\n            const unsigned thisbit = bits & msb;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n            if (thisbit != lastbit) {\n                csr ^= SROMDOUT; EMIT;  /* clock low; invert data */\n            } else {\n\t\tEMIT;\n\t    }\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n            lastbit = thisbit;\n        }\n        csr ^= SROMCLKOFF; EMIT;\n\n        for (data = 0, bits = 0; bits < 16; bits++) {\n            data <<= 1;\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */ \n            data |= TULIP_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        }\n\tsc->tulip_rombuf[idx*2] = data & 0xFF;\n\tsc->tulip_rombuf[idx*2+1] = data >> 8;\n\tcsr  = SROMSEL | SROMRD; EMIT;\n\tcsr  = 0; EMIT;\n    }\n    tulip_srom_idle(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_ether_hw_addr",
          "args": [
            "sc->tulip_pc",
            "(u_char *)(&sc->tulip_rombuf)",
            "sc->tulip_pci_busno",
            "sc->tulip_pci_devno"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READBYTE",
          "args": [
            "sc",
            "csr_enetrom"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READBYTE",
          "args": [
            "sc",
            "csr_enetrom"
          ],
          "line": 2804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_enetrom"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_enetrom",
            "1"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_EISA\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};\nstatic const tulip_boardsw_t tulip_21041_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_probe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};\nstatic const tulip_boardsw_t tulip_21041np_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_noprobe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};\nstatic const tulip_boardsw_t tulip_21140_eb_boardsw = {\n    TULIP_21140_DEC_EB,\n    tulip_21140_evalboard_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};\nstatic const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};\nstatic const struct {\n    void (*vendor_identify_nic)(tulip_softc_t * const sc);\n    unsigned char vendor_oui[3];\n} tulip_vendors[] = {\n    { tulip_identify_dec_nic,\t\t{ 0x08, 0x00, 0x2B } },\n    { tulip_identify_dec_nic,\t\t{ 0x00, 0x00, 0xF8 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0x00, 0xC0 } },\n    { tulip_identify_smc_nic,\t\t{ 0x00, 0xE0, 0x29 } },\n    { tulip_identify_znyx_nic,\t\t{ 0x00, 0xC0, 0x95 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0x92 } },\n    { tulip_identify_cogent_nic,\t{ 0x00, 0x00, 0xD1 } },\n    { tulip_identify_asante_nic,\t{ 0x00, 0x00, 0x94 } },\n    { tulip_identify_accton_nic,\t{ 0x00, 0x00, 0xE8 } },\n    { NULL }\n};\n\nstatic int\ntulip_read_macaddr(\n    tulip_softc_t * const sc)\n{\n    unsigned cksum, rom_cksum, idx;\n    u_int32_t csr;\n    unsigned char tmpbuf[8];\n    static const u_char testpat[] = { 0xFF, 0, 0x55, 0xAA, 0xFF, 0, 0x55, 0xAA };\n\n    sc->tulip_connidx = TULIP_SROM_LASTCONNIDX;\n\n    if (sc->tulip_chipid == TULIP_21040) {\n\tTULIP_CSR_WRITE(sc, csr_enetrom, 1);\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    int cnt = 0;\n\t    while (((csr = TULIP_CSR_READ(sc, csr_enetrom)) & 0x80000000L) && cnt < 10000)\n\t\tcnt++;\n\t    sc->tulip_rombuf[idx] = csr & 0xFF;\n\t}\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#if defined(TULIP_EISA)\n    } else if (sc->tulip_chipid == TULIP_DE425) {\n\tint cnt;\n\tfor (idx = 0, cnt = 0; idx < sizeof(testpat) && cnt < 32; cnt++) {\n\t    tmpbuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\t    if (tmpbuf[idx] == testpat[idx])\n\t\t++idx;\n\t    else\n\t\tidx = 0;\n\t}\n\tfor (idx = 0; idx < 32; idx++)\n\t    sc->tulip_rombuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);\n\tsc->tulip_boardsw = &tulip_21040_boardsw;\n#endif /* TULIP_EISA */\n    } else {\n\tif (sc->tulip_chipid == TULIP_21041) {\n\t    /*\n\t     * Thankfully all 21041's act the same.\n\t     */\n\t    sc->tulip_boardsw = &tulip_21041_boardsw;\n\t} else {\n\t    /*\n\t     * Assume all 21140 board are compatible with the\n\t     * DEC 10/100 evaluation board.  Not really valid but\n\t     * it's the best we can do until every one switches to\n\t     * the new SROM format.\n\t     */\n\t     \n\t    sc->tulip_boardsw = &tulip_21140_eb_boardsw;\n\t}\n#ifdef NEED_PCI_ETHER_HW_ADDR_FUNC\n\tif(pci_ether_hw_addr(sc->tulip_pc, (u_char *)(&sc->tulip_rombuf),\n\t    sc->tulip_pci_busno, sc->tulip_pci_devno)) {\n\t    \tif(sc->tulip_boardsw == &tulip_21041_boardsw)\n\t\t    sc->tulip_boardsw = &tulip_21041np_boardsw;\n\t}\n\telse {\n\t\ttulip_srom_read(sc);\n\t}\n#else\n\ttulip_srom_read(sc);\n#endif\n\tif (tulip_srom_crcok(sc->tulip_rombuf)) {\n\t    /*\n\t     * SROM CRC is valid therefore it must be in the\n\t     * new format.\n\t     */\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM;\n\t} else if (sc->tulip_rombuf[126] == 0xff && sc->tulip_rombuf[127] == 0xFF) {\n\t    /*\n\t     * No checksum is present.  See if the SROM id checks out;\n\t     * the first 18 bytes should be 0 followed by a 1 followed\n\t     * by the number of adapters (which we don't deal with yet).\n\t     */\n\t    for (idx = 0; idx < 18; idx++) {\n\t\tif (sc->tulip_rombuf[idx] != 0)\n\t\t    break;\n\t    }\n\t    if (idx == 18 && sc->tulip_rombuf[18] == 1 && sc->tulip_rombuf[19] != 0)\n\t\tsc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t} else if (sc->tulip_chipid >= TULIP_21142) {\n\t    sc->tulip_features |= TULIP_HAVE_ISVSROM;\n\t    sc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\t}\n\tif ((sc->tulip_features & TULIP_HAVE_ISVSROM) && tulip_srom_decode(sc)) {\n\t    if (sc->tulip_chipid != TULIP_21041)\n\t\tsc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n\n\t    /*\n\t     * If the SROM specifies more than one adapter, tag this as a\n\t     * BASE rom.\n\t     */\n\t    if (sc->tulip_rombuf[19] > 1)\n\t\tsc->tulip_features |= TULIP_HAVE_BASEROM;\n\t    if (sc->tulip_boardsw == NULL)\n\t\treturn -6;\n\t    goto check_oui;\n\t}\n    }\n\n\n    if (bcmp(&sc->tulip_rombuf[0], &sc->tulip_rombuf[16], 8) != 0) {\n\t/*\n\t * Some folks don't use the standard ethernet rom format\n\t * but instead just put the address in the first 6 bytes\n\t * of the rom and let the rest be all 0xffs.  (Can we say\n\t * ZNYX???) (well sometimes they put in a checksum so we'll\n\t * start at 8).\n\t */\n\tfor (idx = 8; idx < 32; idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0xFF)\n\t\treturn -4;\n\t}\n\t/*\n\t * Make sure the address is not multicast or locally assigned\n\t * that the OUI is not 00-00-00.\n\t */\n\tif ((sc->tulip_rombuf[0] & 3) != 0)\n\t    return -4;\n\tif (sc->tulip_rombuf[0] == 0 && sc->tulip_rombuf[1] == 0\n\t\t&& sc->tulip_rombuf[2] == 0)\n\t    return -4;\n\tbcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\tsc->tulip_features |= TULIP_HAVE_OKROM;\n\tgoto check_oui;\n    } else {\n\t/*\n\t * A number of makers of multiport boards (ZNYX and Cogent)\n\t * only put on one address ROM on their 21040 boards.  So\n\t * if the ROM is all zeros (or all 0xFFs), look at the\n\t * previous configured boards (as long as they are on the same\n\t * PCI bus and the bus number is non-zero) until we find the\n\t * master board with address ROM.  We then use its address ROM\n\t * as the base for this board.  (we add our relative board\n\t * to the last byte of its address).\n\t */\n\tfor (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {\n\t    if (sc->tulip_rombuf[idx] != 0 && sc->tulip_rombuf[idx] != 0xFF)\n\t\tbreak;\n\t}\n\tif (idx == sizeof(sc->tulip_rombuf)) {\n\t    int root_unit;\n\t    tulip_softc_t *root_sc = NULL;\n\t    for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {\n\t\troot_sc = TULIP_UNIT_TO_SOFTC(root_unit);\n\t\tif (root_sc == NULL || (root_sc->tulip_features & (TULIP_HAVE_OKROM|TULIP_HAVE_SLAVEDROM)) == TULIP_HAVE_OKROM)\n\t\t    break;\n\t\troot_sc = NULL;\n\t    }\n\t    if (root_sc != NULL && (root_sc->tulip_features & TULIP_HAVE_BASEROM)\n\t\t    && root_sc->tulip_chipid == sc->tulip_chipid\n\t\t    && root_sc->tulip_pci_busno == sc->tulip_pci_busno) {\n\t\tsc->tulip_features |= TULIP_HAVE_SLAVEDROM;\n\t\tsc->tulip_boardsw = root_sc->tulip_boardsw;\n\t\tstrcpy(sc->tulip_boardid, root_sc->tulip_boardid);\n\t\tif (sc->tulip_boardsw->bd_type == TULIP_21140_ISV) {\n\t\t    bcopy(root_sc->tulip_rombuf, sc->tulip_rombuf,\n\t\t\t  sizeof(sc->tulip_rombuf));\n\t\t    if (!tulip_srom_decode(sc))\n\t\t\treturn -5;\n\t\t} else {\n\t\t    bcopy(root_sc->tulip_enaddr, sc->tulip_enaddr, 6);\n\t\t    sc->tulip_enaddr[5] += sc->tulip_unit - root_sc->tulip_unit;\n\t\t}\n\t\t/*\n\t\t * Now for a truly disgusting kludge: all 4 21040s on\n\t\t * the ZX314 share the same INTA line so the mapping\n\t\t * setup by the BIOS on the PCI bridge is worthless.\n\t\t * Rather than reprogramming the value in the config\n\t\t * register, we will handle this internally.\n\t\t */\n\t\tif (root_sc->tulip_features & TULIP_HAVE_SHAREDINTR) {\n\t\t    sc->tulip_slaves = root_sc->tulip_slaves;\n\t\t    root_sc->tulip_slaves = sc;\n\t\t    sc->tulip_features |= TULIP_HAVE_SLAVEDINTR;\n\t\t}\n\t\treturn 0;\n\t    }\n\t}\n    }\n\n    /*\n     * This is the standard DEC address ROM test.\n     */\n\n    if (bcmp(&sc->tulip_rombuf[24], testpat, 8) != 0)\n\treturn -3;\n\n    tmpbuf[0] = sc->tulip_rombuf[15]; tmpbuf[1] = sc->tulip_rombuf[14];\n    tmpbuf[2] = sc->tulip_rombuf[13]; tmpbuf[3] = sc->tulip_rombuf[12];\n    tmpbuf[4] = sc->tulip_rombuf[11]; tmpbuf[5] = sc->tulip_rombuf[10];\n    tmpbuf[6] = sc->tulip_rombuf[9];  tmpbuf[7] = sc->tulip_rombuf[8];\n    if (bcmp(&sc->tulip_rombuf[0], tmpbuf, 8) != 0)\n\treturn -2;\n\n    bcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);\n\n    cksum = *(u_int16_t *) &sc->tulip_enaddr[0];\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[2];\n    if (cksum > 65535) cksum -= 65535;\n    cksum *= 2;\n    if (cksum > 65535) cksum -= 65535;\n    cksum += *(u_int16_t *) &sc->tulip_enaddr[4];\n    if (cksum >= 65535) cksum -= 65535;\n\n    rom_cksum = *(u_int16_t *) &sc->tulip_rombuf[6];\n\t\n    if (cksum != rom_cksum)\n\treturn -1;\n\n  check_oui:\n    /*\n     * Check for various boards based on OUI.  Did I say braindead?\n     */\n    for (idx = 0; tulip_vendors[idx].vendor_identify_nic != NULL; idx++) {\n\tif (bcmp((caddr_t) sc->tulip_enaddr,\n\t\t (caddr_t) tulip_vendors[idx].vendor_oui, 3) == 0) {\n\t    (*tulip_vendors[idx].vendor_identify_nic)(sc);\n\t    break;\n\t}\n    }\n\n    sc->tulip_features |= TULIP_HAVE_OKROM;\n    return 0;\n}"
  },
  {
    "function_name": "tulip_srom_decode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2398-2758",
    "snippet": "static int\ntulip_srom_decode(\n    tulip_softc_t * const sc)\n{\n    unsigned idx1, idx2, idx3;\n\n    const tulip_srom_header_t *shp = (tulip_srom_header_t *) &sc->tulip_rombuf[0];\n    const tulip_srom_adapter_info_t *saip = (tulip_srom_adapter_info_t *) (shp + 1);\n    tulip_srom_media_t srom_media;\n    tulip_media_info_t *mi = sc->tulip_mediainfo;\n    const u_int8_t *dp;\n    u_int32_t leaf_offset, blocks, data;\n\n    for (idx1 = 0; idx1 < shp->sh_adapter_count; idx1++, saip++) {\n\tif (shp->sh_adapter_count == 1)\n\t    break;\n\tif (saip->sai_device == sc->tulip_pci_devno)\n\t    break;\n    }\n    /*\n     * Didn't find the right media block for this card.\n     */\n    if (idx1 == shp->sh_adapter_count)\n\treturn 0;\n\n    /*\n     * Save the hardware address.\n     */\n    bcopy((caddr_t) shp->sh_ieee802_address, (caddr_t) sc->tulip_enaddr, 6);\n    /*\n     * If this is a multiple port card, add the adapter index to the last\n     * byte of the hardware address.  (if it isn't multiport, adding 0\n     * won't hurt.\n     */\n    sc->tulip_enaddr[5] += idx1;\n\n    leaf_offset = saip->sai_leaf_offset_lowbyte\n\t+ saip->sai_leaf_offset_highbyte * 256;\n    dp = sc->tulip_rombuf + leaf_offset;\n\t\n    sc->tulip_conntype = (tulip_srom_connection_t) (dp[0] + dp[1] * 256); dp += 2;\n\n    for (idx2 = 0;; idx2++) {\n\tif (tulip_srom_conninfo[idx2].sc_type == sc->tulip_conntype\n\t        || tulip_srom_conninfo[idx2].sc_type == TULIP_SROM_CONNTYPE_NOT_USED)\n\t    break;\n    }\n    sc->tulip_connidx = idx2;\n\n    if (sc->tulip_chipid == TULIP_21041) {\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    tulip_media_t media;\n\t    data = *dp++;\n\t    srom_media = (tulip_srom_media_t) (data & 0x3F);\n\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t    break;\n\t    }\n\t    media = tulip_srom_mediums[idx3].sm_type;\n\t    if (media != TULIP_MEDIA_UNKNOWN) {\n\t\tif (data & TULIP_SROM_21041_EXTENDED) {\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_sia_connectivity = dp[0] + dp[1] * 256;\n\t\t    mi->mi_sia_tx_rx        = dp[2] + dp[3] * 256;\n\t\t    mi->mi_sia_general      = dp[4] + dp[5] * 256;\n\t\t    mi++;\n\t\t} else {\n\t\t    switch (media) {\n\t\t\tcase TULIP_MEDIA_BNC: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_AUI: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET_FD: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if (data & TULIP_SROM_21041_EXTENDED)\t\n\t\tdp += 6;\n\t}\n#ifdef notdef\n\tif (blocks == 0) {\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD); mi++;\n\t}\n#endif\n    } else {\n\tunsigned length, type;\n\ttulip_media_t gp_media = TULIP_MEDIA_UNKNOWN;\n\tif (sc->tulip_features & TULIP_HAVE_GPR)\n\t    sc->tulip_gpinit = *dp++;\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    const u_int8_t *ep;\n\t    if ((*dp & 0x80) == 0) {\n\t\tlength = 4;\n\t\ttype = 0;\n\t    } else {\n\t\tlength = (*dp++ & 0x7f) - 1;\n\t\ttype = *dp++ & 0x3f;\n\t    }\n\t    ep = dp + length;\n\t    switch (type & 0x3f) {\n\t\tcase 0: {\t/* 21140[A] GPR block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_GPR;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpdata = dp[1];\n\t\t    if (media > gp_media && !TULIP_IS_MEDIA_FD(media)) {\n\t\t\tsc->tulip_gpdata = mi->mi_gpdata;\n\t\t\tgp_media = media;\n\t\t    }\n\t\t    data = dp[2] + dp[3] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n#if 0\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n#endif\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 1: {\t/* 21140[A] MII block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_reset_length;\n\n\t\t    /*\n\t\t     * Before we probe for a PHY, use the GPR information\n\t\t     * to select it.  If we don't, it may be inaccessible.\n\t\t     */\n\t\t    TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpinit|TULIP_GP_PINSET);\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx3]);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx3]);\n\t\t    }\n\n\t\t    /*\n\t\t     * At least write something!\n\t\t     */\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 2: {\t/* 2114[23] SIA block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    if (dp[0] & 0x40) {\n\t\t\tmi->mi_sia_connectivity = dp[1] + dp[2] * 256;\n\t\t\tmi->mi_sia_tx_rx        = dp[3] + dp[4] * 256;\n\t\t\tmi->mi_sia_general      = dp[5] + dp[6] * 256;\n\t\t\tdp += 6;\n\t\t    } else {\n\t\t\tswitch (media) {\n\t\t\t    case TULIP_MEDIA_BNC: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, BNC);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_AUI: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, AUI);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET_FD: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET_FD);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    default: {\n\t\t\t\tgoto bad_media;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    mi->mi_sia_gp_control = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_sia_gp_data    = (dp[3] + dp[4] * 256) << 16;\n\t\t    mi++;\n\t\t  bad_media:\n\t\t    break;\n\t\t}\n\t\tcase 3: {\t/* 2114[23] MII PHY block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    const u_int8_t *dp0;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_mii_interrupt = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 4: {\t/* 21143 SYM block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t) dp[0];\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SYM;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpcontrol = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_gpdata    = (dp[3] + dp[4] * 256) << 16;\n\t\t    data = dp[5] + dp[6] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    if (TULIP_IS_MEDIA_TP(media))\n\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#if 0\n\t\tcase 5: {\t/* 21143 Reset block */\n\t\t    mi->mi_type = TULIP_MEDIAINFO_RESET;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#endif\n\t\tdefault: {\n\t\t}\n\t    }\n\t    dp = ep;\n\t}\n    }\n    return mi - sc->tulip_mediainfo;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_TP",
          "args": [
            "media"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_SROM_2114X_BITPOS",
          "args": [
            "data"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_SROM_2114X_CMDBITS",
          "args": [
            "data"
          ],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mii_readreg",
          "args": [
            "sc",
            "mi->mi_phyaddr",
            "PHYREG_IDHIGH"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2044-2066",
          "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "10BASET"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "10BASET_FD"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASET4"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASETX"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASETX_FD"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": can't find phy %d\\n\"",
            "TULIP_PRINTF_ARGS",
            "phyno"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_get_phyaddr",
          "args": [
            "sc",
            "phyno"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_get_phyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1365-1387",
          "snippet": "static unsigned\ntulip_mii_get_phyaddr(\n    tulip_softc_t * const sc,\n    unsigned offset)\n{\n    unsigned phyaddr;\n\n    for (phyaddr = 1; phyaddr < 32; phyaddr++) {\n\tunsigned status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    continue;\n\tif (offset == 0)\n\t    return phyaddr;\n\toffset--;\n    }\n    if (offset == 0) {\n\tunsigned status = tulip_mii_readreg(sc, 0, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    return TULIP_MII_NOPHY;\n\treturn 0;\n    }\n    return TULIP_MII_NOPHY;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);",
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_get_phyaddr(\n    tulip_softc_t * const sc,\n    unsigned offset)\n{\n    unsigned phyaddr;\n\n    for (phyaddr = 1; phyaddr < 32; phyaddr++) {\n\tunsigned status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    continue;\n\tif (offset == 0)\n\t    return phyaddr;\n\toffset--;\n    }\n    if (offset == 0) {\n\tunsigned status = tulip_mii_readreg(sc, 0, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    return TULIP_MII_NOPHY;\n\treturn 0;\n    }\n    return TULIP_MII_NOPHY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10000"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "0"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "(dp0[0] + 256 * dp0[1]) << 16"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "(dp0[0] + 256 * dp0[1]) << 16"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21142",
            "10BASET_FD"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21142",
            "10BASET"
          ],
          "line": 2639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21142",
            "AUI"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21142",
            "BNC"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dp[0] & 0x3f"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "10BASET"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "10BASET_FD"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASET4"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASETX"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASETX_FD"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10000"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "0"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "sc->tulip_rombuf[mi->mi_gpr_offset + idx3]"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "sc->tulip_rombuf[mi->mi_reset_offset + idx3]"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "sc->tulip_gpinit|TULIP_GP_PINSET"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_SROM_2114X_BITPOS",
          "args": [
            "data"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_SROM_2114X_CMDBITS",
          "args": [
            "data"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_FD",
          "args": [
            "media"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dp[0] & 0x3f"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "10BASET_FD"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "10BASET"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "AUI"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "BNC"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "10BASET_FD"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "10BASET"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "AUI"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "mi",
            "21041",
            "BNC"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data & 0x3F"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dp[0] + dp[1] * 256"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "(caddr_t) shp->sh_ieee802_address",
            "(caddr_t) sc->tulip_enaddr",
            "6"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_srom_decode(\n    tulip_softc_t * const sc)\n{\n    unsigned idx1, idx2, idx3;\n\n    const tulip_srom_header_t *shp = (tulip_srom_header_t *) &sc->tulip_rombuf[0];\n    const tulip_srom_adapter_info_t *saip = (tulip_srom_adapter_info_t *) (shp + 1);\n    tulip_srom_media_t srom_media;\n    tulip_media_info_t *mi = sc->tulip_mediainfo;\n    const u_int8_t *dp;\n    u_int32_t leaf_offset, blocks, data;\n\n    for (idx1 = 0; idx1 < shp->sh_adapter_count; idx1++, saip++) {\n\tif (shp->sh_adapter_count == 1)\n\t    break;\n\tif (saip->sai_device == sc->tulip_pci_devno)\n\t    break;\n    }\n    /*\n     * Didn't find the right media block for this card.\n     */\n    if (idx1 == shp->sh_adapter_count)\n\treturn 0;\n\n    /*\n     * Save the hardware address.\n     */\n    bcopy((caddr_t) shp->sh_ieee802_address, (caddr_t) sc->tulip_enaddr, 6);\n    /*\n     * If this is a multiple port card, add the adapter index to the last\n     * byte of the hardware address.  (if it isn't multiport, adding 0\n     * won't hurt.\n     */\n    sc->tulip_enaddr[5] += idx1;\n\n    leaf_offset = saip->sai_leaf_offset_lowbyte\n\t+ saip->sai_leaf_offset_highbyte * 256;\n    dp = sc->tulip_rombuf + leaf_offset;\n\t\n    sc->tulip_conntype = (tulip_srom_connection_t) (dp[0] + dp[1] * 256); dp += 2;\n\n    for (idx2 = 0;; idx2++) {\n\tif (tulip_srom_conninfo[idx2].sc_type == sc->tulip_conntype\n\t        || tulip_srom_conninfo[idx2].sc_type == TULIP_SROM_CONNTYPE_NOT_USED)\n\t    break;\n    }\n    sc->tulip_connidx = idx2;\n\n    if (sc->tulip_chipid == TULIP_21041) {\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    tulip_media_t media;\n\t    data = *dp++;\n\t    srom_media = (tulip_srom_media_t) (data & 0x3F);\n\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t    break;\n\t    }\n\t    media = tulip_srom_mediums[idx3].sm_type;\n\t    if (media != TULIP_MEDIA_UNKNOWN) {\n\t\tif (data & TULIP_SROM_21041_EXTENDED) {\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_sia_connectivity = dp[0] + dp[1] * 256;\n\t\t    mi->mi_sia_tx_rx        = dp[2] + dp[3] * 256;\n\t\t    mi->mi_sia_general      = dp[4] + dp[5] * 256;\n\t\t    mi++;\n\t\t} else {\n\t\t    switch (media) {\n\t\t\tcase TULIP_MEDIA_BNC: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_AUI: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tcase TULIP_MEDIA_10BASET_FD: {\n\t\t\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD);\n\t\t\t    mi++;\n\t\t\t    break;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t    if (data & TULIP_SROM_21041_EXTENDED)\t\n\t\tdp += 6;\n\t}\n#ifdef notdef\n\tif (blocks == 0) {\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET); mi++;\n\t    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD); mi++;\n\t}\n#endif\n    } else {\n\tunsigned length, type;\n\ttulip_media_t gp_media = TULIP_MEDIA_UNKNOWN;\n\tif (sc->tulip_features & TULIP_HAVE_GPR)\n\t    sc->tulip_gpinit = *dp++;\n\tblocks = *dp++;\n\tfor (idx2 = 0; idx2 < blocks; idx2++) {\n\t    const u_int8_t *ep;\n\t    if ((*dp & 0x80) == 0) {\n\t\tlength = 4;\n\t\ttype = 0;\n\t    } else {\n\t\tlength = (*dp++ & 0x7f) - 1;\n\t\ttype = *dp++ & 0x3f;\n\t    }\n\t    ep = dp + length;\n\t    switch (type & 0x3f) {\n\t\tcase 0: {\t/* 21140[A] GPR block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_GPR;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpdata = dp[1];\n\t\t    if (media > gp_media && !TULIP_IS_MEDIA_FD(media)) {\n\t\t\tsc->tulip_gpdata = mi->mi_gpdata;\n\t\t\tgp_media = media;\n\t\t    }\n\t\t    data = dp[2] + dp[3] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n#if 0\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n#endif\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 1: {\t/* 21140[A] MII block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += mi->mi_reset_length;\n\n\t\t    /*\n\t\t     * Before we probe for a PHY, use the GPR information\n\t\t     * to select it.  If we don't, it may be inaccessible.\n\t\t     */\n\t\t    TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpinit|TULIP_GP_PINSET);\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx3]);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx3]);\n\t\t    }\n\n\t\t    /*\n\t\t     * At least write something!\n\t\t     */\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_gp, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 2: {\t/* 2114[23] SIA block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SIA;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    if (dp[0] & 0x40) {\n\t\t\tmi->mi_sia_connectivity = dp[1] + dp[2] * 256;\n\t\t\tmi->mi_sia_tx_rx        = dp[3] + dp[4] * 256;\n\t\t\tmi->mi_sia_general      = dp[5] + dp[6] * 256;\n\t\t\tdp += 6;\n\t\t    } else {\n\t\t\tswitch (media) {\n\t\t\t    case TULIP_MEDIA_BNC: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, BNC);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_AUI: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, AUI);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    case TULIP_MEDIA_10BASET_FD: {\n\t\t\t\tTULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET_FD);\n\t\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    default: {\n\t\t\t\tgoto bad_media;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    mi->mi_sia_gp_control = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_sia_gp_data    = (dp[3] + dp[4] * 256) << 16;\n\t\t    mi++;\n\t\t  bad_media:\n\t\t    break;\n\t\t}\n\t\tcase 3: {\t/* 2114[23] MII PHY block */\n\t\t    const unsigned phyno = *dp++;\n\t\t    const u_int8_t *dp0;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_MII;\n\t\t    mi->mi_gpr_length = *dp++;\n\t\t    mi->mi_gpr_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_gpr_length;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\t\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t\t    dp0 = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t\t    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++, dp0 += 2) {\n\t\t\tDELAY(10);\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);\n\t\t    }\n\n\t\t    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)\n\t\t\tTULIP_CSR_WRITE(sc, csr_sia_general, 0);\n\n\t\t    mi->mi_phyaddr = TULIP_MII_NOPHY;\n\t\t    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {\n\t\t\tDELAY(10000);\n\t\t\tmi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);\n\t\t    }\n\t\t    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n#if defined(TULIP_DEBUG)\n\t\t\tprintf(TULIP_PRINTF_FMT \": can't find phy %d\\n\",\n\t\t\t       TULIP_PRINTF_ARGS, phyno);\n#endif\n\t\t\tbreak;\n\t\t    }\n\t\t    sc->tulip_features |= TULIP_HAVE_MII;\n\t\t    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;\n\t\t    mi->mi_mii_interrupt = dp[0] + dp[1] * 256; dp += 2;\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\t\t    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\t\t    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t\t\ttulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\t\t    mi++;\n\t\t    break;\n\t\t}\n\t\tcase 4: {\t/* 21143 SYM block */\n\t\t    tulip_media_t media;\n\t\t    srom_media = (tulip_srom_media_t) dp[0];\n\t\t    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {\n\t\t\tif (tulip_srom_mediums[idx3].sm_srom_type == srom_media)\n\t\t\t    break;\n\t\t    }\n\t\t    media = tulip_srom_mediums[idx3].sm_type;\n\t\t    if (media == TULIP_MEDIA_UNKNOWN)\n\t\t\tbreak;\n\t\t    mi->mi_type = TULIP_MEDIAINFO_SYM;\n\t\t    sc->tulip_mediums[media] = mi;\n\t\t    mi->mi_gpcontrol = (dp[1] + dp[2] * 256) << 16;\n\t\t    mi->mi_gpdata    = (dp[3] + dp[4] * 256) << 16;\n\t\t    data = dp[5] + dp[6] * 256;\n\t\t    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);\n\t\t    if (data & TULIP_SROM_2114X_NOINDICATOR) {\n\t\t\tmi->mi_actmask = 0;\n\t\t    } else {\n\t\t\tmi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;\n\t\t\tmi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);\n\t\t\tmi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;\n\t\t    }\n\t\t    if (TULIP_IS_MEDIA_TP(media))\n\t\t\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#if 0\n\t\tcase 5: {\t/* 21143 Reset block */\n\t\t    mi->mi_type = TULIP_MEDIAINFO_RESET;\n\t\t    mi->mi_reset_length = *dp++;\n\t\t    mi->mi_reset_offset = dp - sc->tulip_rombuf;\n\t\t    dp += 2 * mi->mi_reset_length;\n\t\t    mi++;\n\t\t    break;\n\t\t}\n#endif\n\t\tdefault: {\n\t\t}\n\t    }\n\t    dp = ep;\n\t}\n    }\n    return mi - sc->tulip_mediainfo;\n}"
  },
  {
    "function_name": "tulip_identify_asante_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2342-2396",
    "snippet": "static void\ntulip_identify_asante_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"Asante \");\n    if ((sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A)\n\t    && sc->tulip_boardsw != &tulip_2114x_isv_boardsw) {\n\ttulip_media_info_t *mi = sc->tulip_mediainfo;\n\tint idx;\n\t/*\n\t * The Asante Fast Ethernet doesn't always ship with a valid\n\t * new format SROM.  So if isn't in the new format, we cheat\n\t * set it up as if we had.\n\t */\n\n\tsc->tulip_gpinit = TULIP_GP_ASANTE_PINS;\n\tsc->tulip_gpdata = 0;\n\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ASANTE_PINS|TULIP_GP_PINSET);\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ASANTE_PHYRESET);\n\tDELAY(100);\n\tTULIP_CSR_WRITE(sc, csr_gp, 0);\n\n\tmi->mi_type = TULIP_MEDIAINFO_MII;\n\tmi->mi_gpr_length = 0;\n\tmi->mi_gpr_offset = 0;\n\tmi->mi_reset_length = 0;\n\tmi->mi_reset_offset = 0;;\n\n\tmi->mi_phyaddr = TULIP_MII_NOPHY;\n\tfor (idx = 20; idx > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx--) {\n\t    DELAY(10000);\n\t    mi->mi_phyaddr = tulip_mii_get_phyaddr(sc, 0);\n\t}\n\tif (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n\t    printf(TULIP_PRINTF_FMT \": can't find phy 0\\n\", TULIP_PRINTF_ARGS);\n\t    return;\n\t}\n\n\tsc->tulip_features |= TULIP_HAVE_MII;\n\tmi->mi_capabilities  = PHYSTS_10BASET|PHYSTS_10BASET_FD|PHYSTS_100BASETX|PHYSTS_100BASETX_FD;\n\tmi->mi_advertisement = PHYSTS_10BASET|PHYSTS_10BASET_FD|PHYSTS_100BASETX|PHYSTS_100BASETX_FD;\n\tmi->mi_full_duplex   = PHYSTS_10BASET_FD|PHYSTS_100BASETX_FD;\n\tmi->mi_tx_threshold  = PHYSTS_10BASET|PHYSTS_10BASET_FD;\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\tmi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t    tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\n\tsc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "static const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_mii_readreg",
          "args": [
            "sc",
            "mi->mi_phyaddr",
            "PHYREG_IDHIGH"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2044-2066",
          "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "10BASET"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "10BASET_FD"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASET4"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASETX"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_ADD_CAPABILITY",
          "args": [
            "sc",
            "mi",
            "100BASETX_FD"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": can't find phy 0\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_get_phyaddr",
          "args": [
            "sc",
            "0"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_get_phyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1365-1387",
          "snippet": "static unsigned\ntulip_mii_get_phyaddr(\n    tulip_softc_t * const sc,\n    unsigned offset)\n{\n    unsigned phyaddr;\n\n    for (phyaddr = 1; phyaddr < 32; phyaddr++) {\n\tunsigned status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    continue;\n\tif (offset == 0)\n\t    return phyaddr;\n\toffset--;\n    }\n    if (offset == 0) {\n\tunsigned status = tulip_mii_readreg(sc, 0, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    return TULIP_MII_NOPHY;\n\treturn 0;\n    }\n    return TULIP_MII_NOPHY;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);",
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_get_phyaddr(\n    tulip_softc_t * const sc,\n    unsigned offset)\n{\n    unsigned phyaddr;\n\n    for (phyaddr = 1; phyaddr < 32; phyaddr++) {\n\tunsigned status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    continue;\n\tif (offset == 0)\n\t    return phyaddr;\n\toffset--;\n    }\n    if (offset == 0) {\n\tunsigned status = tulip_mii_readreg(sc, 0, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    return TULIP_MII_NOPHY;\n\treturn 0;\n    }\n    return TULIP_MII_NOPHY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10000"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "0"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "100"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_ASANTE_PHYRESET"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_ASANTE_PINS|TULIP_GP_PINSET"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->tulip_boardid",
            "\"Asante \""
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};\n\nstatic void\ntulip_identify_asante_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"Asante \");\n    if ((sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A)\n\t    && sc->tulip_boardsw != &tulip_2114x_isv_boardsw) {\n\ttulip_media_info_t *mi = sc->tulip_mediainfo;\n\tint idx;\n\t/*\n\t * The Asante Fast Ethernet doesn't always ship with a valid\n\t * new format SROM.  So if isn't in the new format, we cheat\n\t * set it up as if we had.\n\t */\n\n\tsc->tulip_gpinit = TULIP_GP_ASANTE_PINS;\n\tsc->tulip_gpdata = 0;\n\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ASANTE_PINS|TULIP_GP_PINSET);\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ASANTE_PHYRESET);\n\tDELAY(100);\n\tTULIP_CSR_WRITE(sc, csr_gp, 0);\n\n\tmi->mi_type = TULIP_MEDIAINFO_MII;\n\tmi->mi_gpr_length = 0;\n\tmi->mi_gpr_offset = 0;\n\tmi->mi_reset_length = 0;\n\tmi->mi_reset_offset = 0;;\n\n\tmi->mi_phyaddr = TULIP_MII_NOPHY;\n\tfor (idx = 20; idx > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx--) {\n\t    DELAY(10000);\n\t    mi->mi_phyaddr = tulip_mii_get_phyaddr(sc, 0);\n\t}\n\tif (mi->mi_phyaddr == TULIP_MII_NOPHY) {\n\t    printf(TULIP_PRINTF_FMT \": can't find phy 0\\n\", TULIP_PRINTF_ARGS);\n\t    return;\n\t}\n\n\tsc->tulip_features |= TULIP_HAVE_MII;\n\tmi->mi_capabilities  = PHYSTS_10BASET|PHYSTS_10BASET_FD|PHYSTS_100BASETX|PHYSTS_100BASETX_FD;\n\tmi->mi_advertisement = PHYSTS_10BASET|PHYSTS_10BASET_FD|PHYSTS_100BASETX|PHYSTS_100BASETX_FD;\n\tmi->mi_full_duplex   = PHYSTS_10BASET_FD|PHYSTS_100BASETX_FD;\n\tmi->mi_tx_threshold  = PHYSTS_10BASET|PHYSTS_10BASET_FD;\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);\n\tTULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);\n\tmi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |\n\t    tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);\n\n\tsc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n    }\n}"
  },
  {
    "function_name": "tulip_identify_accton_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2312-2340",
    "snippet": "static void\ntulip_identify_accton_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"ACCTON \");\n    switch (sc->tulip_chipid) {\n\tcase TULIP_21140A:\n\t    strcat(sc->tulip_boardid, \"EN1207 \");\n\t    if (sc->tulip_boardsw != &tulip_2114x_isv_boardsw)\n\t\tsc->tulip_boardsw = &tulip_21140_accton_boardsw;\n\t    break;\n\tcase TULIP_21140:\n\t    strcat(sc->tulip_boardid, \"EN1207TX \");\n\t    if (sc->tulip_boardsw != &tulip_2114x_isv_boardsw)\n\t\tsc->tulip_boardsw = &tulip_21140_eb_boardsw;\n            break;\n        case TULIP_21040:\n\t    strcat(sc->tulip_boardid, \"EN1203 \");\n            sc->tulip_boardsw = &tulip_21040_boardsw;\n            break;\n        case TULIP_21041:\n\t    strcat(sc->tulip_boardid, \"EN1203 \");\n            sc->tulip_boardsw = &tulip_21041_boardsw;\n            break;\n\tdefault:\n            sc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n            break;\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "static const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};",
      "static const tulip_boardsw_t tulip_21041_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_probe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};",
      "static const tulip_boardsw_t tulip_21140_eb_boardsw = {\n    TULIP_21140_DEC_EB,\n    tulip_21140_evalboard_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};",
      "static const tulip_boardsw_t tulip_21140_accton_boardsw = {\n    TULIP_21140_EN1207,\n    tulip_21140_accton_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};",
      "static const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EN1203 \""
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EN1203 \""
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EN1207TX \""
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EN1207 \""
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->tulip_boardid",
            "\"ACCTON \""
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};\nstatic const tulip_boardsw_t tulip_21041_boardsw = {\n    TULIP_21041_GENERIC,\n    tulip_21041_media_probe,\n    tulip_media_select,\n    tulip_21041_media_poll\n};\nstatic const tulip_boardsw_t tulip_21140_eb_boardsw = {\n    TULIP_21140_DEC_EB,\n    tulip_21140_evalboard_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};\nstatic const tulip_boardsw_t tulip_21140_accton_boardsw = {\n    TULIP_21140_EN1207,\n    tulip_21140_accton_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};\nstatic const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};\n\nstatic void\ntulip_identify_accton_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"ACCTON \");\n    switch (sc->tulip_chipid) {\n\tcase TULIP_21140A:\n\t    strcat(sc->tulip_boardid, \"EN1207 \");\n\t    if (sc->tulip_boardsw != &tulip_2114x_isv_boardsw)\n\t\tsc->tulip_boardsw = &tulip_21140_accton_boardsw;\n\t    break;\n\tcase TULIP_21140:\n\t    strcat(sc->tulip_boardid, \"EN1207TX \");\n\t    if (sc->tulip_boardsw != &tulip_2114x_isv_boardsw)\n\t\tsc->tulip_boardsw = &tulip_21140_eb_boardsw;\n            break;\n        case TULIP_21040:\n\t    strcat(sc->tulip_boardid, \"EN1203 \");\n            sc->tulip_boardsw = &tulip_21040_boardsw;\n            break;\n        case TULIP_21041:\n\t    strcat(sc->tulip_boardid, \"EN1203 \");\n            sc->tulip_boardsw = &tulip_21041_boardsw;\n            break;\n\tdefault:\n            sc->tulip_boardsw = &tulip_2114x_isv_boardsw;\n            break;\n    }\n}"
  },
  {
    "function_name": "tulip_identify_cogent_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2276-2310",
    "snippet": "static void\ntulip_identify_cogent_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"Cogent \");\n    if (sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A) {\n\tif (sc->tulip_rombuf[32] == TULIP_COGENT_EM100TX_ID) {\n\t    strcat(sc->tulip_boardid, \"EM100TX \");\n\t    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;\n#if defined(TULIP_COGENT_EM110TX_ID)\n\t} else if (sc->tulip_rombuf[32] == TULIP_COGENT_EM110TX_ID) {\n\t    strcat(sc->tulip_boardid, \"EM110TX \");\n\t    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;\n#endif\n\t} else if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100FX_ID) {\n\t    strcat(sc->tulip_boardid, \"EM100FX \");\n\t    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;\n\t}\n\t/*\n\t * Magic number (0x24001109U) is the SubVendor (0x2400) and\n\t * SubDevId (0x1109) for the ANA6944TX (EM440TX).\n\t */\n\tif (*(u_int32_t *) sc->tulip_rombuf == 0x24001109U\n\t\t&& (sc->tulip_features & TULIP_HAVE_BASEROM)) {\n\t    /*\n\t     * Cogent (Adaptec) is still mapping all INTs to INTA of\n\t     * first 21140.  Dumb!  Dumb!\n\t     */\n\t    strcat(sc->tulip_boardid, \"EM440TX \");\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR;\n\t}\n    } else if (sc->tulip_chipid == TULIP_21040) {\n\tsc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "static const tulip_boardsw_t tulip_21140_cogent_em100_boardsw = {\n    TULIP_21140_COGENT_EM100,\n    tulip_21140_cogent_em100_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EM440TX \""
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EM100FX \""
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EM110TX \""
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "sc->tulip_boardid",
            "\"EM100TX \""
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->tulip_boardid",
            "\"Cogent \""
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_boardsw_t tulip_21140_cogent_em100_boardsw = {\n    TULIP_21140_COGENT_EM100,\n    tulip_21140_cogent_em100_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset\n};\n\nstatic void\ntulip_identify_cogent_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"Cogent \");\n    if (sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A) {\n\tif (sc->tulip_rombuf[32] == TULIP_COGENT_EM100TX_ID) {\n\t    strcat(sc->tulip_boardid, \"EM100TX \");\n\t    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;\n#if defined(TULIP_COGENT_EM110TX_ID)\n\t} else if (sc->tulip_rombuf[32] == TULIP_COGENT_EM110TX_ID) {\n\t    strcat(sc->tulip_boardid, \"EM110TX \");\n\t    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;\n#endif\n\t} else if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100FX_ID) {\n\t    strcat(sc->tulip_boardid, \"EM100FX \");\n\t    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;\n\t}\n\t/*\n\t * Magic number (0x24001109U) is the SubVendor (0x2400) and\n\t * SubDevId (0x1109) for the ANA6944TX (EM440TX).\n\t */\n\tif (*(u_int32_t *) sc->tulip_rombuf == 0x24001109U\n\t\t&& (sc->tulip_features & TULIP_HAVE_BASEROM)) {\n\t    /*\n\t     * Cogent (Adaptec) is still mapping all INTs to INTA of\n\t     * first 21140.  Dumb!  Dumb!\n\t     */\n\t    strcat(sc->tulip_boardid, \"EM440TX \");\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR;\n\t}\n    } else if (sc->tulip_chipid == TULIP_21040) {\n\tsc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n    }\n}"
  },
  {
    "function_name": "tulip_identify_smc_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2227-2274",
    "snippet": "static void\ntulip_identify_smc_nic(\n    tulip_softc_t * const sc)\n{\n    u_int32_t id1, id2, ei;\n    int auibnc = 0, utp = 0;\n    char *cp;\n\n    strcpy(sc->tulip_boardid, \"SMC \");\n    if (sc->tulip_chipid == TULIP_21041)\n\treturn;\n    if (sc->tulip_chipid != TULIP_21040) {\n\tif (sc->tulip_boardsw != &tulip_2114x_isv_boardsw) {\n\t    strcpy(&sc->tulip_boardid[4], \"9332DST \");\n\t    sc->tulip_boardsw = &tulip_21140_smc9332_boardsw;\n\t} else if (sc->tulip_features & (TULIP_HAVE_BASEROM|TULIP_HAVE_SLAVEDROM)) {\n\t    strcpy(&sc->tulip_boardid[4], \"9334BDT \");\n\t} else {\n\t    strcpy(&sc->tulip_boardid[4], \"9332BDT \");\n\t}\n\treturn;\n    }\n    id1 = sc->tulip_rombuf[0x60] | (sc->tulip_rombuf[0x61] << 8);\n    id2 = sc->tulip_rombuf[0x62] | (sc->tulip_rombuf[0x63] << 8);\n    ei  = sc->tulip_rombuf[0x66] | (sc->tulip_rombuf[0x67] << 8);\n\n    strcpy(&sc->tulip_boardid[4], \"8432\");\n    cp = &sc->tulip_boardid[8];\n    if ((id1 & 1) == 0)\n\t*cp++ = 'B', auibnc = 1;\n    if ((id1 & 0xFF) > 0x32)\n\t*cp++ = 'T', utp = 1;\n    if ((id1 & 0x4000) == 0)\n\t*cp++ = 'A', auibnc = 1;\n    if (id2 == 0x15) {\n\tsc->tulip_boardid[7] = '4';\n\t*cp++ = '-';\n\t*cp++ = 'C';\n\t*cp++ = 'H';\n\t*cp++ = (ei ? '2' : '1');\n    }\n    *cp++ = ' ';\n    *cp = '\\0';\n    if (utp && !auibnc)\n\tsc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n    else if (!utp && auibnc)\n\tsc->tulip_boardsw = &tulip_21040_auibnc_only_boardsw;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "static const tulip_boardsw_t tulip_21040_10baset_only_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_10baset_only_media_probe,\n    tulip_21040_10baset_only_media_select,\n    NULL,\n};",
      "static const tulip_boardsw_t tulip_21040_auibnc_only_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_auibnc_only_media_probe,\n    tulip_21040_auibnc_only_media_select,\n    NULL,\n};",
      "static const tulip_boardsw_t tulip_21140_smc9332_boardsw = {\n    TULIP_21140_SMC_9332,\n    tulip_21140_smc9332_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};",
      "static const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "&sc->tulip_boardid[4]",
            "\"8432\""
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "&sc->tulip_boardid[4]",
            "\"9332BDT \""
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "&sc->tulip_boardid[4]",
            "\"9334BDT \""
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "&sc->tulip_boardid[4]",
            "\"9332DST \""
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->tulip_boardid",
            "\"SMC \""
          ],
          "line": 2235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_boardsw_t tulip_21040_10baset_only_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_10baset_only_media_probe,\n    tulip_21040_10baset_only_media_select,\n    NULL,\n};\nstatic const tulip_boardsw_t tulip_21040_auibnc_only_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_auibnc_only_media_probe,\n    tulip_21040_auibnc_only_media_select,\n    NULL,\n};\nstatic const tulip_boardsw_t tulip_21140_smc9332_boardsw = {\n    TULIP_21140_SMC_9332,\n    tulip_21140_smc9332_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};\nstatic const tulip_boardsw_t tulip_2114x_isv_boardsw = {\n    TULIP_21140_ISV,\n    tulip_2114x_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n    tulip_2114x_media_preset,\n};\n\nstatic void\ntulip_identify_smc_nic(\n    tulip_softc_t * const sc)\n{\n    u_int32_t id1, id2, ei;\n    int auibnc = 0, utp = 0;\n    char *cp;\n\n    strcpy(sc->tulip_boardid, \"SMC \");\n    if (sc->tulip_chipid == TULIP_21041)\n\treturn;\n    if (sc->tulip_chipid != TULIP_21040) {\n\tif (sc->tulip_boardsw != &tulip_2114x_isv_boardsw) {\n\t    strcpy(&sc->tulip_boardid[4], \"9332DST \");\n\t    sc->tulip_boardsw = &tulip_21140_smc9332_boardsw;\n\t} else if (sc->tulip_features & (TULIP_HAVE_BASEROM|TULIP_HAVE_SLAVEDROM)) {\n\t    strcpy(&sc->tulip_boardid[4], \"9334BDT \");\n\t} else {\n\t    strcpy(&sc->tulip_boardid[4], \"9332BDT \");\n\t}\n\treturn;\n    }\n    id1 = sc->tulip_rombuf[0x60] | (sc->tulip_rombuf[0x61] << 8);\n    id2 = sc->tulip_rombuf[0x62] | (sc->tulip_rombuf[0x63] << 8);\n    ei  = sc->tulip_rombuf[0x66] | (sc->tulip_rombuf[0x67] << 8);\n\n    strcpy(&sc->tulip_boardid[4], \"8432\");\n    cp = &sc->tulip_boardid[8];\n    if ((id1 & 1) == 0)\n\t*cp++ = 'B', auibnc = 1;\n    if ((id1 & 0xFF) > 0x32)\n\t*cp++ = 'T', utp = 1;\n    if ((id1 & 0x4000) == 0)\n\t*cp++ = 'A', auibnc = 1;\n    if (id2 == 0x15) {\n\tsc->tulip_boardid[7] = '4';\n\t*cp++ = '-';\n\t*cp++ = 'C';\n\t*cp++ = 'H';\n\t*cp++ = (ei ? '2' : '1');\n    }\n    *cp++ = ' ';\n    *cp = '\\0';\n    if (utp && !auibnc)\n\tsc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n    else if (!utp && auibnc)\n\tsc->tulip_boardsw = &tulip_21040_auibnc_only_boardsw;\n}"
  },
  {
    "function_name": "tulip_identify_znyx_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2134-2225",
    "snippet": "static void\ntulip_identify_znyx_nic(\n    tulip_softc_t * const sc)\n{\n    unsigned id = 0;\n    strcpy(sc->tulip_boardid, \"ZNYX ZX3XX \");\n    if (sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A) {\n\tunsigned znyx_ptr;\n\tsc->tulip_boardid[8] = '4';\n\tznyx_ptr = sc->tulip_rombuf[124] + 256 * sc->tulip_rombuf[125];\n\tif (znyx_ptr < 26 || znyx_ptr > 116) {\n\t    sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t    return;\n\t}\n\t/* ZX344 = 0010 .. 0013FF\n\t */\n\tif (sc->tulip_rombuf[znyx_ptr] == 0x4A\n\t\t&& sc->tulip_rombuf[znyx_ptr + 1] == 0x52\n\t\t&& sc->tulip_rombuf[znyx_ptr + 2] == 0x01) {\n\t    id = sc->tulip_rombuf[znyx_ptr + 5] + 256 * sc->tulip_rombuf[znyx_ptr + 4];\n\t    if ((id >> 8) == (TULIP_ZNYX_ID_ZX342 >> 8)) {\n\t\tsc->tulip_boardid[9] = '2';\n\t\tif (id == TULIP_ZNYX_ID_ZX342B) {\n\t\t    sc->tulip_boardid[10] = 'B';\n\t\t    sc->tulip_boardid[11] = ' ';\n\t\t}\n\t\tsc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t    } else if (id == TULIP_ZNYX_ID_ZX344) {\n\t\tsc->tulip_boardid[10] = '4';\n\t\tsc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t    } else if (id == TULIP_ZNYX_ID_ZX345) {\n\t\tsc->tulip_boardid[9] = (sc->tulip_rombuf[19] > 1) ? '8' : '5';\n\t    } else if (id == TULIP_ZNYX_ID_ZX346) {\n\t\tsc->tulip_boardid[9] = '6';\n\t    } else if (id == TULIP_ZNYX_ID_ZX351) {\n\t\tsc->tulip_boardid[8] = '5';\n\t\tsc->tulip_boardid[9] = '1';\n\t    }\n\t}\n\tif (id == 0) {\n\t    /*\n\t     * Assume it's a ZX342...\n\t     */\n\t    sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t}\n\treturn;\n    }\n    sc->tulip_boardid[8] = '1';\n    if (sc->tulip_chipid == TULIP_21041) {\n\tsc->tulip_boardid[10] = '1';\n\treturn;\n    }\n    if (sc->tulip_rombuf[32] == 0x4A && sc->tulip_rombuf[33] == 0x52) {\n\tid = sc->tulip_rombuf[37] + 256 * sc->tulip_rombuf[36];\n\tif (id == TULIP_ZNYX_ID_ZX312T) {\n\t    sc->tulip_boardid[9] = '2';\n\t    sc->tulip_boardid[10] = 'T';\n\t    sc->tulip_boardid[11] = ' ';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t} else if (id == TULIP_ZNYX_ID_ZX314_INTA) {\n\t    sc->tulip_boardid[9] = '4';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if (id == TULIP_ZNYX_ID_ZX314) {\n\t    sc->tulip_boardid[9] = '4';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_BASEROM;\n\t} else if (id == TULIP_ZNYX_ID_ZX315_INTA) {\n\t    sc->tulip_boardid[9] = '5';\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if (id == TULIP_ZNYX_ID_ZX315) {\n\t    sc->tulip_boardid[9] = '5';\n\t    sc->tulip_features |= TULIP_HAVE_BASEROM;\n\t} else {\n\t    id = 0;\n\t}\n    }\t\t    \n    if (id == 0) {\n\tif ((sc->tulip_enaddr[3] & ~3) == 0xF0 && (sc->tulip_enaddr[5] & 3) == 0) {\n\t    sc->tulip_boardid[9] = '4';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if ((sc->tulip_enaddr[3] & ~3) == 0xF4 && (sc->tulip_enaddr[5] & 1) == 0) {\n\t    sc->tulip_boardid[9] = '5';\n\t    sc->tulip_boardsw = &tulip_21040_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if ((sc->tulip_enaddr[3] & ~3) == 0xEC) {\n\t    sc->tulip_boardid[9] = '2';\n\t    sc->tulip_boardsw = &tulip_21040_boardsw;\n\t}\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "static const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};",
      "static const tulip_boardsw_t tulip_21040_10baset_only_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_10baset_only_media_probe,\n    tulip_21040_10baset_only_media_select,\n    NULL,\n};",
      "static const tulip_boardsw_t tulip_21140_znyx_zx34x_boardsw = {\n    TULIP_21140_ZNYX_ZX34X,\n    tulip_21140_znyx_zx34x_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->tulip_boardid",
            "\"ZNYX ZX3XX \""
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_boardsw_t tulip_21040_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_media_probe,\n    tulip_media_select,\n    tulip_media_poll,\n};\nstatic const tulip_boardsw_t tulip_21040_10baset_only_boardsw = {\n    TULIP_21040_GENERIC,\n    tulip_21040_10baset_only_media_probe,\n    tulip_21040_10baset_only_media_select,\n    NULL,\n};\nstatic const tulip_boardsw_t tulip_21140_znyx_zx34x_boardsw = {\n    TULIP_21140_ZNYX_ZX34X,\n    tulip_21140_znyx_zx34x_media_probe,\n    tulip_media_select,\n    tulip_null_media_poll,\n    tulip_2114x_media_preset,\n};\n\nstatic void\ntulip_identify_znyx_nic(\n    tulip_softc_t * const sc)\n{\n    unsigned id = 0;\n    strcpy(sc->tulip_boardid, \"ZNYX ZX3XX \");\n    if (sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A) {\n\tunsigned znyx_ptr;\n\tsc->tulip_boardid[8] = '4';\n\tznyx_ptr = sc->tulip_rombuf[124] + 256 * sc->tulip_rombuf[125];\n\tif (znyx_ptr < 26 || znyx_ptr > 116) {\n\t    sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t    return;\n\t}\n\t/* ZX344 = 0010 .. 0013FF\n\t */\n\tif (sc->tulip_rombuf[znyx_ptr] == 0x4A\n\t\t&& sc->tulip_rombuf[znyx_ptr + 1] == 0x52\n\t\t&& sc->tulip_rombuf[znyx_ptr + 2] == 0x01) {\n\t    id = sc->tulip_rombuf[znyx_ptr + 5] + 256 * sc->tulip_rombuf[znyx_ptr + 4];\n\t    if ((id >> 8) == (TULIP_ZNYX_ID_ZX342 >> 8)) {\n\t\tsc->tulip_boardid[9] = '2';\n\t\tif (id == TULIP_ZNYX_ID_ZX342B) {\n\t\t    sc->tulip_boardid[10] = 'B';\n\t\t    sc->tulip_boardid[11] = ' ';\n\t\t}\n\t\tsc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t    } else if (id == TULIP_ZNYX_ID_ZX344) {\n\t\tsc->tulip_boardid[10] = '4';\n\t\tsc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t    } else if (id == TULIP_ZNYX_ID_ZX345) {\n\t\tsc->tulip_boardid[9] = (sc->tulip_rombuf[19] > 1) ? '8' : '5';\n\t    } else if (id == TULIP_ZNYX_ID_ZX346) {\n\t\tsc->tulip_boardid[9] = '6';\n\t    } else if (id == TULIP_ZNYX_ID_ZX351) {\n\t\tsc->tulip_boardid[8] = '5';\n\t\tsc->tulip_boardid[9] = '1';\n\t    }\n\t}\n\tif (id == 0) {\n\t    /*\n\t     * Assume it's a ZX342...\n\t     */\n\t    sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;\n\t}\n\treturn;\n    }\n    sc->tulip_boardid[8] = '1';\n    if (sc->tulip_chipid == TULIP_21041) {\n\tsc->tulip_boardid[10] = '1';\n\treturn;\n    }\n    if (sc->tulip_rombuf[32] == 0x4A && sc->tulip_rombuf[33] == 0x52) {\n\tid = sc->tulip_rombuf[37] + 256 * sc->tulip_rombuf[36];\n\tif (id == TULIP_ZNYX_ID_ZX312T) {\n\t    sc->tulip_boardid[9] = '2';\n\t    sc->tulip_boardid[10] = 'T';\n\t    sc->tulip_boardid[11] = ' ';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t} else if (id == TULIP_ZNYX_ID_ZX314_INTA) {\n\t    sc->tulip_boardid[9] = '4';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if (id == TULIP_ZNYX_ID_ZX314) {\n\t    sc->tulip_boardid[9] = '4';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_BASEROM;\n\t} else if (id == TULIP_ZNYX_ID_ZX315_INTA) {\n\t    sc->tulip_boardid[9] = '5';\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if (id == TULIP_ZNYX_ID_ZX315) {\n\t    sc->tulip_boardid[9] = '5';\n\t    sc->tulip_features |= TULIP_HAVE_BASEROM;\n\t} else {\n\t    id = 0;\n\t}\n    }\t\t    \n    if (id == 0) {\n\tif ((sc->tulip_enaddr[3] & ~3) == 0xF0 && (sc->tulip_enaddr[5] & 3) == 0) {\n\t    sc->tulip_boardid[9] = '4';\n\t    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if ((sc->tulip_enaddr[3] & ~3) == 0xF4 && (sc->tulip_enaddr[5] & 1) == 0) {\n\t    sc->tulip_boardid[9] = '5';\n\t    sc->tulip_boardsw = &tulip_21040_boardsw;\n\t    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;\n\t} else if ((sc->tulip_enaddr[3] & ~3) == 0xEC) {\n\t    sc->tulip_boardid[9] = '2';\n\t    sc->tulip_boardsw = &tulip_21040_boardsw;\n\t}\n    }\n}"
  },
  {
    "function_name": "tulip_identify_dec_nic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2118-2132",
    "snippet": "static void\ntulip_identify_dec_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"DEC \");\n#define D0\t4\n    if (sc->tulip_chipid <= TULIP_DE425)\n\treturn;\n    if (bcmp(sc->tulip_rombuf + 29, \"DE500\", 5) == 0\n\t|| bcmp(sc->tulip_rombuf + 29, \"DE450\", 5) == 0) {\n\tbcopy(sc->tulip_rombuf + 29, &sc->tulip_boardid[D0], 8);\n\tsc->tulip_boardid[D0+8] = ' ';\n    }\n#undef D0\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define D0\t4"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->tulip_rombuf + 29",
            "&sc->tulip_boardid[D0]",
            "8"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "sc->tulip_rombuf + 29",
            "\"DE450\"",
            "5"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcmp",
          "args": [
            "sc->tulip_rombuf + 29",
            "\"DE500\"",
            "5"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sc->tulip_boardid",
            "\"DEC \""
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define D0\t4\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_identify_dec_nic(\n    tulip_softc_t * const sc)\n{\n    strcpy(sc->tulip_boardid, \"DEC \");\n#define D0\t4\n    if (sc->tulip_chipid <= TULIP_DE425)\n\treturn;\n    if (bcmp(sc->tulip_rombuf + 29, \"DE500\", 5) == 0\n\t|| bcmp(sc->tulip_rombuf + 29, \"DE450\", 5) == 0) {\n\tbcopy(sc->tulip_rombuf + 29, &sc->tulip_boardid[D0], 8);\n\tsc->tulip_boardid[D0+8] = ' ';\n    }\n#undef D0\n}"
  },
  {
    "function_name": "tulip_crc32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2096-2116",
    "snippet": "static unsigned\ntulip_crc32(\n    const unsigned char *databuf,\n    size_t datalen)\n{\n    u_int idx, crc = 0xFFFFFFFFUL;\n    static const u_int crctab[] = {\n\t0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,\n\t0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n\t0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,\n\t0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c\n    };\n\n    for (idx = 0; idx < datalen; idx++) {\n\tcrc ^= *databuf++;\n\tcrc = (crc >> 4) ^ crctab[crc & 0xf];\n\tcrc = (crc >> 4) ^ crctab[crc & 0xf];\n    }\n\n    return crc;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic unsigned\ntulip_crc32(\n    const unsigned char *databuf,\n    size_t datalen)\n{\n    u_int idx, crc = 0xFFFFFFFFUL;\n    static const u_int crctab[] = {\n\t0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,\n\t0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n\t0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,\n\t0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c\n    };\n\n    for (idx = 0; idx < datalen; idx++) {\n\tcrc ^= *databuf++;\n\tcrc = (crc >> 4) ^ crctab[crc & 0xf];\n\tcrc = (crc >> 4) ^ crctab[crc & 0xf];\n    }\n\n    return crc;\n}"
  },
  {
    "function_name": "tulip_mii_writereg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2068-2089",
    "snippet": "static void\ntulip_mii_writereg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno,\n    unsigned data)\n{\n    unsigned csr;\n\n    csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_WRCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_WRCMD);\n    tulip_mii_writebits(sc, data, 16);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][2] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][3]++;\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_mii_writebits",
          "args": [
            "sc",
            "data",
            "16"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_writebits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1982-2003",
          "snippet": "static void\ntulip_mii_writebits(\n    tulip_softc_t * const sc,\n    unsigned data,\n    unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_writebits(\n    tulip_softc_t * const sc,\n    unsigned data,\n    unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_turnaround",
          "args": [
            "sc",
            "MII_WRCMD"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_turnaround",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2005-2022",
          "snippet": "static void\ntulip_mii_turnaround(\n    tulip_softc_t * const sc,\n    unsigned cmd)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_turnaround(\n    tulip_softc_t * const sc,\n    unsigned cmd)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_writereg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno,\n    unsigned data)\n{\n    unsigned csr;\n\n    csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_WRCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_WRCMD);\n    tulip_mii_writebits(sc, data, 16);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][2] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][3]++;\n#endif\n}"
  },
  {
    "function_name": "tulip_mii_readreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2044-2066",
    "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_mii_readbits",
          "args": [
            "sc"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2024-2042",
          "snippet": "static unsigned\ntulip_mii_readbits(\n    tulip_softc_t * const sc)\n{\n    unsigned data;\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (TULIP_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readbits(\n    tulip_softc_t * const sc)\n{\n    unsigned data;\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (TULIP_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_turnaround",
          "args": [
            "sc",
            "MII_RDCMD"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_turnaround",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2005-2022",
          "snippet": "static void\ntulip_mii_turnaround(\n    tulip_softc_t * const sc,\n    unsigned cmd)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_turnaround(\n    tulip_softc_t * const sc,\n    unsigned cmd)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_writebits",
          "args": [
            "sc",
            "regno",
            "5"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_writebits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1982-2003",
          "snippet": "static void\ntulip_mii_writebits(\n    tulip_softc_t * const sc,\n    unsigned data,\n    unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_writebits(\n    tulip_softc_t * const sc,\n    unsigned data,\n    unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 2050
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
  },
  {
    "function_name": "tulip_mii_readbits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2024-2042",
    "snippet": "static unsigned\ntulip_mii_readbits(\n    tulip_softc_t * const sc)\n{\n    unsigned data;\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (TULIP_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readbits(\n    tulip_softc_t * const sc)\n{\n    unsigned data;\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    int idx;\n\n    for (idx = 0, data = 0; idx < 16; idx++) {\n\tdata <<= 1;\t/* this is NOOP on the first pass through */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tif (TULIP_CSR_READ(sc, csr_srom_mii) & MII_DIN)\n\t    data |= 1;\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n    }\n    csr ^= MII_RD; MII_EMIT;\t\t/* clock low; turn off read */\n\n    return data;\n}"
  },
  {
    "function_name": "tulip_mii_turnaround",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "2005-2022",
    "snippet": "static void\ntulip_mii_turnaround(\n    tulip_softc_t * const sc,\n    unsigned cmd)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_turnaround(\n    tulip_softc_t * const sc,\n    unsigned cmd)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n\n    if (cmd == MII_WRCMD) {\n\tcsr |= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n\tcsr ^= MII_CLKON; MII_EMIT;\t/* clock high; data valid */\n\tcsr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n\tcsr ^= MII_DOUT; MII_EMIT;\t/* clock low; change data */\n    } else {\n\tcsr |= MII_RD; MII_EMIT;\t/* clock low; switch to read */\n    }\n    csr ^= MII_CLKON; MII_EMIT;\t\t/* clock high; data valid */\n    csr ^= MII_CLKOFF; MII_EMIT;\t/* clock low; data not valid */\n}"
  },
  {
    "function_name": "tulip_mii_writebits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1982-2003",
    "snippet": "static void\ntulip_mii_writebits(\n    tulip_softc_t * const sc,\n    unsigned data,\n    unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_writebits(\n    tulip_softc_t * const sc,\n    unsigned data,\n    unsigned bits)\n{\n    unsigned msb = 1 << (bits - 1);\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;\n\n    csr |= MII_WR; MII_EMIT;  \t\t/* clock low; assert write */\n\n    for (; bits > 0; bits--, data <<= 1) {\n\tconst unsigned thisbit = data & msb;\n\tif (thisbit != lastbit) {\n\t    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */\n\t}\n\tcsr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */\n\tlastbit = thisbit;\n\tcsr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */\n    }\n}"
  },
  {
    "function_name": "tulip_srom_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1933-1978",
    "snippet": "static void\ntulip_srom_read(\n    tulip_softc_t * const sc)\n{   \n    unsigned idx; \n    const unsigned bitwidth = SROM_BITWIDTH;\n    const unsigned cmdmask = (SROMCMD_RD << bitwidth);\n    const unsigned msb = 1 << (bitwidth + 3 - 1);\n    unsigned lastidx = (1 << bitwidth) - 1;\n\n    tulip_srom_idle(sc);\n\n    for (idx = 0; idx <= lastidx; idx++) {\n        unsigned lastbit, data, bits, bit, csr;\n\tcsr  = SROMSEL ;\t        EMIT;\n        csr  = SROMSEL | SROMRD;        EMIT;\n        csr ^= SROMCSON;                EMIT;\n        csr ^=            SROMCLKON;    EMIT;\n    \n        lastbit = 0;\n        for (bits = idx|cmdmask, bit = bitwidth + 3; bit > 0; bit--, bits <<= 1) {\n            const unsigned thisbit = bits & msb;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n            if (thisbit != lastbit) {\n                csr ^= SROMDOUT; EMIT;  /* clock low; invert data */\n            } else {\n\t\tEMIT;\n\t    }\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n            lastbit = thisbit;\n        }\n        csr ^= SROMCLKOFF; EMIT;\n\n        for (data = 0, bits = 0; bits < 16; bits++) {\n            data <<= 1;\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */ \n            data |= TULIP_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        }\n\tsc->tulip_rombuf[idx*2] = data & 0xFF;\n\tsc->tulip_rombuf[idx*2+1] = data >> 8;\n\tcsr  = SROMSEL | SROMRD; EMIT;\n\tcsr  = 0; EMIT;\n    }\n    tulip_srom_idle(sc);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_srom_idle",
          "args": [
            "sc"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_srom_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1909-1930",
          "snippet": "static void\ntulip_srom_idle(\n    tulip_softc_t * const sc)\n{\n    unsigned bit, csr;\n    \n    csr  = SROMSEL ; EMIT;\n    csr  = SROMSEL | SROMRD; EMIT;  \n    csr ^= SROMCS; EMIT;\n    csr ^= SROMCLKON; EMIT;\n\n    /*\n     * Write 25 cycles of 0 which will force the SROM to be idle.\n     */\n    for (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n        csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n    }\n    csr ^= SROMCLKOFF; EMIT;\n    csr ^= SROMCS; EMIT;\n    csr  = 0; EMIT;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_srom_idle(\n    tulip_softc_t * const sc)\n{\n    unsigned bit, csr;\n    \n    csr  = SROMSEL ; EMIT;\n    csr  = SROMSEL | SROMRD; EMIT;  \n    csr ^= SROMCS; EMIT;\n    csr ^= SROMCLKON; EMIT;\n\n    /*\n     * Write 25 cycles of 0 which will force the SROM to be idle.\n     */\n    for (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n        csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n    }\n    csr ^= SROMCLKOFF; EMIT;\n    csr ^= SROMCS; EMIT;\n    csr  = 0; EMIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_srom_mii"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_srom_read(\n    tulip_softc_t * const sc)\n{   \n    unsigned idx; \n    const unsigned bitwidth = SROM_BITWIDTH;\n    const unsigned cmdmask = (SROMCMD_RD << bitwidth);\n    const unsigned msb = 1 << (bitwidth + 3 - 1);\n    unsigned lastidx = (1 << bitwidth) - 1;\n\n    tulip_srom_idle(sc);\n\n    for (idx = 0; idx <= lastidx; idx++) {\n        unsigned lastbit, data, bits, bit, csr;\n\tcsr  = SROMSEL ;\t        EMIT;\n        csr  = SROMSEL | SROMRD;        EMIT;\n        csr ^= SROMCSON;                EMIT;\n        csr ^=            SROMCLKON;    EMIT;\n    \n        lastbit = 0;\n        for (bits = idx|cmdmask, bit = bitwidth + 3; bit > 0; bit--, bits <<= 1) {\n            const unsigned thisbit = bits & msb;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n            if (thisbit != lastbit) {\n                csr ^= SROMDOUT; EMIT;  /* clock low; invert data */\n            } else {\n\t\tEMIT;\n\t    }\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n            lastbit = thisbit;\n        }\n        csr ^= SROMCLKOFF; EMIT;\n\n        for (data = 0, bits = 0; bits < 16; bits++) {\n            data <<= 1;\n            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */ \n            data |= TULIP_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;\n            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        }\n\tsc->tulip_rombuf[idx*2] = data & 0xFF;\n\tsc->tulip_rombuf[idx*2+1] = data >> 8;\n\tcsr  = SROMSEL | SROMRD; EMIT;\n\tcsr  = 0; EMIT;\n    }\n    tulip_srom_idle(sc);\n}"
  },
  {
    "function_name": "tulip_srom_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1909-1930",
    "snippet": "static void\ntulip_srom_idle(\n    tulip_softc_t * const sc)\n{\n    unsigned bit, csr;\n    \n    csr  = SROMSEL ; EMIT;\n    csr  = SROMSEL | SROMRD; EMIT;  \n    csr ^= SROMCS; EMIT;\n    csr ^= SROMCLKON; EMIT;\n\n    /*\n     * Write 25 cycles of 0 which will force the SROM to be idle.\n     */\n    for (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n        csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n    }\n    csr ^= SROMCLKOFF; EMIT;\n    csr ^= SROMCS; EMIT;\n    csr  = 0; EMIT;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_srom_idle(\n    tulip_softc_t * const sc)\n{\n    unsigned bit, csr;\n    \n    csr  = SROMSEL ; EMIT;\n    csr  = SROMSEL | SROMRD; EMIT;  \n    csr ^= SROMCS; EMIT;\n    csr ^= SROMCLKON; EMIT;\n\n    /*\n     * Write 25 cycles of 0 which will force the SROM to be idle.\n     */\n    for (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {\n        csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */\n        csr ^= SROMCLKON; EMIT;     /* clock high; data valid */\n    }\n    csr ^= SROMCLKOFF; EMIT;\n    csr ^= SROMCS; EMIT;\n    csr  = 0; EMIT;\n}"
  },
  {
    "function_name": "tulip_delay_300ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1898-1905",
    "snippet": "static void\ntulip_delay_300ns(\n    tulip_softc_t * const sc)\n{\n    int idx;\n    for (idx = (300 / 33) + 1; idx > 0; idx--)\n\t(void) TULIP_CSR_READ(sc, csr_busmode);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_busmode"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_delay_300ns(\n    tulip_softc_t * const sc)\n{\n    int idx;\n    for (idx = (300 / 33) + 1; idx > 0; idx--)\n\t(void) TULIP_CSR_READ(sc, csr_busmode);\n}"
  },
  {
    "function_name": "tulip_2114x_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1875-1881",
    "snippet": "static void\ntulip_2114x_media_probe(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_MUSTBEONE\n\t|TULIP_CMD_BACKOFFCTR|TULIP_CMD_THRSHLD72;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_2114x_media_probe(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_MUSTBEONE\n\t|TULIP_CMD_BACKOFFCTR|TULIP_CMD_THRSHLD72;\n}"
  },
  {
    "function_name": "tulip_21140_znyx_zx34x_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1818-1865",
    "snippet": "static void\ntulip_21140_znyx_zx34x_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    int cnt10 = 0, cnt100 = 0, idx;\n\n    sc->tulip_gpinit = TULIP_GP_ZX34X_PINS;\n    sc->tulip_gpdata = TULIP_GP_ZX34X_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ZX34X_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ZX34X_INIT);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);\n\n    DELAY(200000);\n    for (idx = 1000; idx > 0; idx--) {\n\tu_int32_t csr = TULIP_CSR_READ(sc, csr_gp);\n\tif ((csr & (TULIP_GP_ZX34X_LNKFAIL|TULIP_GP_ZX34X_SYMDET|TULIP_GP_ZX34X_SIGDET)) == (TULIP_GP_ZX34X_LNKFAIL|TULIP_GP_ZX34X_SYMDET|TULIP_GP_ZX34X_SIGDET)) {\n\t    if (++cnt100 > 100)\n\t\tbreak;\n\t} else if ((csr & TULIP_GP_ZX34X_LNKFAIL) == 0) {\n\t    if (++cnt10 > 100)\n\t\tbreak;\n\t} else {\n\t    cnt10 = 0;\n\t    cnt100 = 0;\n\t}\n\tDELAY(1000);\n    }\n    sc->tulip_media = cnt100 > 100 ? TULIP_MEDIA_100BASETX : TULIP_MEDIA_10BASET;\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_21140_mediainit",
          "args": [
            "sc",
            "mip++",
            "TULIP_MEDIA_100BASETX_FD",
            "TULIP_GP_ZX34X_INIT",
            "TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21140_mediainit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1602-1614",
          "snippet": "__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\n__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_gp"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200000"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_ZX34X_INIT"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_ZX34X_PINS"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21140_znyx_zx34x_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    int cnt10 = 0, cnt100 = 0, idx;\n\n    sc->tulip_gpinit = TULIP_GP_ZX34X_PINS;\n    sc->tulip_gpdata = TULIP_GP_ZX34X_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ZX34X_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ZX34X_INIT);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);\n\n    DELAY(200000);\n    for (idx = 1000; idx > 0; idx--) {\n\tu_int32_t csr = TULIP_CSR_READ(sc, csr_gp);\n\tif ((csr & (TULIP_GP_ZX34X_LNKFAIL|TULIP_GP_ZX34X_SYMDET|TULIP_GP_ZX34X_SIGDET)) == (TULIP_GP_ZX34X_LNKFAIL|TULIP_GP_ZX34X_SYMDET|TULIP_GP_ZX34X_SIGDET)) {\n\t    if (++cnt100 > 100)\n\t\tbreak;\n\t} else if ((csr & TULIP_GP_ZX34X_LNKFAIL) == 0) {\n\t    if (++cnt10 > 100)\n\t\tbreak;\n\t} else {\n\t    cnt10 = 0;\n\t    cnt100 = 0;\n\t}\n\tDELAY(1000);\n    }\n    sc->tulip_media = cnt100 > 100 ? TULIP_MEDIA_100BASETX : TULIP_MEDIA_10BASET;\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_ZX34X_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n}"
  },
  {
    "function_name": "tulip_21140_cogent_em100_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1771-1808",
    "snippet": "static void\ntulip_21140_cogent_em100_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    u_int32_t cmdmode = TULIP_CSR_READ(sc, csr_command);\n\n    sc->tulip_gpinit = TULIP_GP_EM100_PINS;\n    sc->tulip_gpdata = TULIP_GP_EM100_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EM100_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EM100_INIT);\n\n    cmdmode = TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_MUSTBEONE;\n    cmdmode &= ~(TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_SCRAMBLER);\n    if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100FX_ID) {\n\tTULIP_CSR_WRITE(sc, csr_command, cmdmode);\n\tsc->tulip_media = TULIP_MEDIA_100BASEFX;\n\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASEFX,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION);\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASEFX_FD,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_FULLDUPLEX);\n    } else {\n\tTULIP_CSR_WRITE(sc, csr_command, cmdmode|TULIP_CMD_SCRAMBLER);\n\tsc->tulip_media = TULIP_MEDIA_100BASETX;\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_21140_mediainit",
          "args": [
            "sc",
            "mip++",
            "TULIP_MEDIA_100BASETX_FD",
            "TULIP_GP_EM100_INIT",
            "TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21140_mediainit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1602-1614",
          "snippet": "__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\n__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "cmdmode|TULIP_CMD_SCRAMBLER"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "cmdmode"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_EM100_INIT"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_EM100_PINS"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21140_cogent_em100_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    u_int32_t cmdmode = TULIP_CSR_READ(sc, csr_command);\n\n    sc->tulip_gpinit = TULIP_GP_EM100_PINS;\n    sc->tulip_gpdata = TULIP_GP_EM100_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EM100_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EM100_INIT);\n\n    cmdmode = TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_MUSTBEONE;\n    cmdmode &= ~(TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_SCRAMBLER);\n    if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100FX_ID) {\n\tTULIP_CSR_WRITE(sc, csr_command, cmdmode);\n\tsc->tulip_media = TULIP_MEDIA_100BASEFX;\n\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASEFX,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION);\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASEFX_FD,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_FULLDUPLEX);\n    } else {\n\tTULIP_CSR_WRITE(sc, csr_command, cmdmode|TULIP_CMD_SCRAMBLER);\n\tsc->tulip_media = TULIP_MEDIA_100BASETX;\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n\ttulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_EM100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n    }\n}"
  },
  {
    "function_name": "tulip_21140_smc9332_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1715-1761",
    "snippet": "static void\ntulip_21140_smc9332_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    int idx, cnt = 0;\n\n    TULIP_CSR_WRITE(sc, csr_command, TULIP_CMD_PORTSELECT|TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n    TULIP_CSR_WRITE(sc, csr_command, TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    sc->tulip_gpinit = TULIP_GP_SMC_9332_PINS;\n    sc->tulip_gpdata = TULIP_GP_SMC_9332_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_SMC_9332_PINS|TULIP_GP_PINSET);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_SMC_9332_INIT);\n    DELAY(200000);\n    for (idx = 1000; idx > 0; idx--) {\n\tu_int32_t csr = TULIP_CSR_READ(sc, csr_gp);\n\tif ((csr & (TULIP_GP_SMC_9332_OK10|TULIP_GP_SMC_9332_OK100)) == (TULIP_GP_SMC_9332_OK10|TULIP_GP_SMC_9332_OK100)) {\n\t    if (++cnt > 100)\n\t\tbreak;\n\t} else if ((csr & TULIP_GP_SMC_9332_OK10) == 0) {\n\t    break;\n\t} else {\n\t    cnt = 0;\n\t}\n\tDELAY(1000);\n    }\n    sc->tulip_media = cnt > 100 ? TULIP_MEDIA_100BASETX : TULIP_MEDIA_10BASET;\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_21140_mediainit",
          "args": [
            "sc",
            "mip++",
            "TULIP_MEDIA_10BASET_FD",
            "TULIP_GP_SMC_9332_INIT",
            "TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21140_mediainit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1602-1614",
          "snippet": "__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\n__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_gp"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "200000"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_SMC_9332_INIT"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_SMC_9332_PINS|TULIP_GP_PINSET"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_busmode",
            "TULIP_BUSMODE_SWRESET"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CMD_PORTSELECT|TULIP_CMD_MUSTBEONE"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21140_smc9332_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    int idx, cnt = 0;\n\n    TULIP_CSR_WRITE(sc, csr_command, TULIP_CMD_PORTSELECT|TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n    TULIP_CSR_WRITE(sc, csr_command, TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    sc->tulip_gpinit = TULIP_GP_SMC_9332_PINS;\n    sc->tulip_gpdata = TULIP_GP_SMC_9332_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_SMC_9332_PINS|TULIP_GP_PINSET);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_SMC_9332_INIT);\n    DELAY(200000);\n    for (idx = 1000; idx > 0; idx--) {\n\tu_int32_t csr = TULIP_CSR_READ(sc, csr_gp);\n\tif ((csr & (TULIP_GP_SMC_9332_OK10|TULIP_GP_SMC_9332_OK100)) == (TULIP_GP_SMC_9332_OK10|TULIP_GP_SMC_9332_OK100)) {\n\t    if (++cnt > 100)\n\t\tbreak;\n\t} else if ((csr & TULIP_GP_SMC_9332_OK10) == 0) {\n\t    break;\n\t} else {\n\t    cnt = 0;\n\t}\n\tDELAY(1000);\n    }\n    sc->tulip_media = cnt > 100 ? TULIP_MEDIA_100BASETX : TULIP_MEDIA_10BASET;\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_SMC_9332_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n}"
  },
  {
    "function_name": "tulip_21140_accton_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1661-1705",
    "snippet": "static void\ntulip_21140_accton_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    unsigned gpdata;\n\n    sc->tulip_gpinit = TULIP_GP_EB_PINS;\n    sc->tulip_gpdata = TULIP_GP_EB_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_INIT);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);\n    DELAY(1000000);\n    gpdata = TULIP_CSR_READ(sc, csr_gp);\n    if ((gpdata & TULIP_GP_EN1207_UTP_INIT) == 0) {\n\tsc->tulip_media = TULIP_MEDIA_10BASET;\n    } else {\n\tif ((gpdata & TULIP_GP_EN1207_BNC_INIT) == 0) {\n\t\tsc->tulip_media = TULIP_MEDIA_BNC;\n        } else {\n\t\tsc->tulip_media = TULIP_MEDIA_100BASETX;\n        }\n    }\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_BNC,\n\t\t\t  TULIP_GP_EN1207_BNC_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_EN1207_UTP_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_EN1207_UTP_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_EN1207_100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_EN1207_100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_21140_mediainit",
          "args": [
            "sc",
            "mip++",
            "TULIP_MEDIA_100BASETX_FD",
            "TULIP_GP_EN1207_100_INIT",
            "TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21140_mediainit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1602-1614",
          "snippet": "__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\n__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_gp"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000000"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_EB_INIT"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_EB_PINS"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21140_accton_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n    unsigned gpdata;\n\n    sc->tulip_gpinit = TULIP_GP_EB_PINS;\n    sc->tulip_gpdata = TULIP_GP_EB_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_INIT);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);\n    DELAY(1000000);\n    gpdata = TULIP_CSR_READ(sc, csr_gp);\n    if ((gpdata & TULIP_GP_EN1207_UTP_INIT) == 0) {\n\tsc->tulip_media = TULIP_MEDIA_10BASET;\n    } else {\n\tif ((gpdata & TULIP_GP_EN1207_BNC_INIT) == 0) {\n\t\tsc->tulip_media = TULIP_MEDIA_BNC;\n        } else {\n\t\tsc->tulip_media = TULIP_MEDIA_100BASETX;\n        }\n    }\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_BNC,\n\t\t\t  TULIP_GP_EN1207_BNC_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_EN1207_UTP_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_EN1207_UTP_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_EN1207_100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_EN1207_100_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n}"
  },
  {
    "function_name": "tulip_21140_evalboard_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1616-1651",
    "snippet": "static void\ntulip_21140_evalboard_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n\n    sc->tulip_gpinit = TULIP_GP_EB_PINS;\n    sc->tulip_gpdata = TULIP_GP_EB_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_INIT);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);\n    DELAY(1000000);\n    if ((TULIP_CSR_READ(sc, csr_gp) & TULIP_GP_EB_OK100) != 0) {\n\tsc->tulip_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_media = TULIP_MEDIA_100BASETX;\n    }\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_21140_mediainit",
          "args": [
            "sc",
            "mip++",
            "TULIP_MEDIA_100BASETX_FD",
            "TULIP_GP_EB_INIT",
            "TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21140_mediainit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1602-1614",
          "snippet": "__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\n__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_gp"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "1000000"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "TULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_EB_INIT"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_EB_PINS"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21140_evalboard_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t *mip = sc->tulip_mediainfo;\n\n    sc->tulip_gpinit = TULIP_GP_EB_PINS;\n    sc->tulip_gpdata = TULIP_GP_EB_INIT;\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_PINS);\n    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_INIT);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |\n\tTULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);\n    TULIP_CSR_WRITE(sc, csr_command,\n\tTULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);\n    DELAY(1000000);\n    if ((TULIP_CSR_READ(sc, csr_gp) & TULIP_GP_EB_OK100) != 0) {\n\tsc->tulip_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_media = TULIP_MEDIA_100BASETX;\n    }\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER);\n    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,\n\t\t\t  TULIP_GP_EB_INIT,\n\t\t\t  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION\n\t\t\t      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);\n}"
  },
  {
    "function_name": "tulip_21140_mediainit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1602-1614",
    "snippet": "__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\n__inline__ static void\ntulip_21140_mediainit(\n    tulip_softc_t * const sc,\n    tulip_media_info_t * const mip,\n    tulip_media_t const media,\n    unsigned gpdata,\n    unsigned cmdmode)\n{\n    sc->tulip_mediums[media] = mip;\n    mip->mi_type = TULIP_MEDIAINFO_GPR;\n    mip->mi_cmdmode = cmdmode;\n    mip->mi_gpdata = gpdata;\n}"
  },
  {
    "function_name": "tulip_null_media_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1588-1600",
    "snippet": "static void\ntulip_null_media_poll(\n    tulip_softc_t * const sc,\n    tulip_mediapoll_event_t event)\n{\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_events[event]++;\n#endif\n#if defined(DIAGNOSTIC)\n    printf(TULIP_PRINTF_FMT \": botch(media_poll) at line %d\\n\",\n\t   TULIP_PRINTF_ARGS, __LINE__);\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": botch(media_poll) at line %d\\n\"",
            "TULIP_PRINTF_ARGS",
            "__LINE__"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_null_media_poll(\n    tulip_softc_t * const sc,\n    tulip_mediapoll_event_t event)\n{\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_events[event]++;\n#endif\n#if defined(DIAGNOSTIC)\n    printf(TULIP_PRINTF_FMT \": botch(media_poll) at line %d\\n\",\n\t   TULIP_PRINTF_ARGS, __LINE__);\n#endif\n}"
  },
  {
    "function_name": "tulip_2114x_media_preset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1511-1581",
    "snippet": "static void\ntulip_2114x_media_preset(\n    tulip_softc_t * const sc)\n{\n    const tulip_media_info_t *mi = NULL;\n    tulip_media_t media = sc->tulip_media;\n\n    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE)\n\tmedia = sc->tulip_media;\n    else\n\tmedia = sc->tulip_probe_media;\n    \n    sc->tulip_cmdmode &= ~TULIP_CMD_PORTSELECT;\n    sc->tulip_flags &= ~TULIP_SQETEST;\n    if (media != TULIP_MEDIA_UNKNOWN && media != TULIP_MEDIA_MAX) {\n#if defined(TULIP_DEBUG)\n\tif (media < TULIP_MEDIA_MAX && sc->tulip_mediums[media] != NULL) {\n#endif\n\t    mi = sc->tulip_mediums[media];\n\t    if (mi->mi_type == TULIP_MEDIAINFO_MII) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_PORTSELECT;\n\t    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR\n\t\t       || mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t\tsc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t\tsc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\t\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\t    }\n#if defined(TULIP_DEBUG)\n\t} else {\n\t    printf(TULIP_PRINTF_FMT \": preset: bad media %d!\\n\",\n\t\t   TULIP_PRINTF_ARGS, media);\n\t}\n#endif\n    }\n    switch (media) {\n\tcase TULIP_MEDIA_BNC:\n\tcase TULIP_MEDIA_AUI:\n\tcase TULIP_MEDIA_10BASET: {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t    sc->tulip_cmdmode |= TULIP_CMD_TXTHRSHLDCTL;\n\t    sc->tulip_if.if_baudrate = 10000000;\n\t    sc->tulip_flags |= TULIP_SQETEST;\n\t    break;\n\t}\n\tcase TULIP_MEDIA_10BASET_FD: {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX|TULIP_CMD_TXTHRSHLDCTL;\n\t    sc->tulip_if.if_baudrate = 10000000;\n\t    break;\n\t}\n\tcase TULIP_MEDIA_100BASEFX:\n\tcase TULIP_MEDIA_100BASET4:\n\tcase TULIP_MEDIA_100BASETX: {\n\t    sc->tulip_cmdmode &= ~(TULIP_CMD_FULLDUPLEX|TULIP_CMD_TXTHRSHLDCTL);\n\t    sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT;\n\t    sc->tulip_if.if_baudrate = 100000000;\n\t    break;\n\t}\n\tcase TULIP_MEDIA_100BASEFX_FD:\n\tcase TULIP_MEDIA_100BASETX_FD: {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX|TULIP_CMD_PORTSELECT;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_TXTHRSHLDCTL;\n\t    sc->tulip_if.if_baudrate = 100000000;\n\t    break;\n\t}\n\tdefault: {\n\t    break;\n\t}\n    }\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": preset: bad media %d!\\n\"",
            "TULIP_PRINTF_ARGS",
            "media"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_connectivity",
            "TULIP_SIACONN_RESET"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_2114x_media_preset(\n    tulip_softc_t * const sc)\n{\n    const tulip_media_info_t *mi = NULL;\n    tulip_media_t media = sc->tulip_media;\n\n    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE)\n\tmedia = sc->tulip_media;\n    else\n\tmedia = sc->tulip_probe_media;\n    \n    sc->tulip_cmdmode &= ~TULIP_CMD_PORTSELECT;\n    sc->tulip_flags &= ~TULIP_SQETEST;\n    if (media != TULIP_MEDIA_UNKNOWN && media != TULIP_MEDIA_MAX) {\n#if defined(TULIP_DEBUG)\n\tif (media < TULIP_MEDIA_MAX && sc->tulip_mediums[media] != NULL) {\n#endif\n\t    mi = sc->tulip_mediums[media];\n\t    if (mi->mi_type == TULIP_MEDIAINFO_MII) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_PORTSELECT;\n\t    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR\n\t\t       || mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t\tsc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t\tsc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\t\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\t    }\n#if defined(TULIP_DEBUG)\n\t} else {\n\t    printf(TULIP_PRINTF_FMT \": preset: bad media %d!\\n\",\n\t\t   TULIP_PRINTF_ARGS, media);\n\t}\n#endif\n    }\n    switch (media) {\n\tcase TULIP_MEDIA_BNC:\n\tcase TULIP_MEDIA_AUI:\n\tcase TULIP_MEDIA_10BASET: {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t    sc->tulip_cmdmode |= TULIP_CMD_TXTHRSHLDCTL;\n\t    sc->tulip_if.if_baudrate = 10000000;\n\t    sc->tulip_flags |= TULIP_SQETEST;\n\t    break;\n\t}\n\tcase TULIP_MEDIA_10BASET_FD: {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX|TULIP_CMD_TXTHRSHLDCTL;\n\t    sc->tulip_if.if_baudrate = 10000000;\n\t    break;\n\t}\n\tcase TULIP_MEDIA_100BASEFX:\n\tcase TULIP_MEDIA_100BASET4:\n\tcase TULIP_MEDIA_100BASETX: {\n\t    sc->tulip_cmdmode &= ~(TULIP_CMD_FULLDUPLEX|TULIP_CMD_TXTHRSHLDCTL);\n\t    sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT;\n\t    sc->tulip_if.if_baudrate = 100000000;\n\t    break;\n\t}\n\tcase TULIP_MEDIA_100BASEFX_FD:\n\tcase TULIP_MEDIA_100BASETX_FD: {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX|TULIP_CMD_PORTSELECT;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_TXTHRSHLDCTL;\n\t    sc->tulip_if.if_baudrate = 100000000;\n\t    break;\n\t}\n\tdefault: {\n\t    break;\n\t}\n    }\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n}"
  },
  {
    "function_name": "tulip_mii_autonegotiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1413-1509",
    "snippet": "static void\ntulip_mii_autonegotiate(\n    tulip_softc_t * const sc,\n    const unsigned phyaddr)\n{\n    switch (sc->tulip_probe_state) {\n        case TULIP_PROBE_MEDIATEST:\n        case TULIP_PROBE_INACTIVE: {\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, PHYCTL_RESET);\n\t    sc->tulip_probe_timeout = 3000;\n\t    sc->tulip_intrmask |= TULIP_STS_ABNRMLINTR|TULIP_STS_NORMALINTR;\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYRESET;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYRESET: {\n\t    u_int32_t status;\n\t    u_int32_t data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n\t    if (data & PHYCTL_RESET) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n\t\tprintf(TULIP_PRINTF_FMT \"(phy%d): error: reset of PHY never completed!\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n\t\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\t\tsc->tulip_probe_state = TULIP_PROBE_FAILED;\n\t\tsc->tulip_if.if_flags &= ~(IFF_UP|IFF_RUNNING);\n\t\treturn;\n\t    }\n\t    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    if ((status & PHYSTS_CAN_AUTONEG) == 0) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation disabled\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    if (tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT) != ((status >> 6) | 0x01))\n\t\ttulip_mii_writereg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT, (status >> 6) | 0x01);\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE);\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n#if defined(TULIP_DEBUG)\n\t    if ((data & PHYCTL_AUTONEG_ENABLE) == 0)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): oops: enable autonegotiation failed: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    else\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation restarted: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    sc->tulip_dbg.dbg_nway_starts++;\n#endif\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYAUTONEG;\n\t    sc->tulip_probe_timeout = 3000;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYAUTONEG: {\n\t    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    u_int32_t data;\n\t    if ((status & PHYSTS_AUTONEG_DONE) == 0) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, status,\n\t\t\t   tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL));\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);\n#if defined(TULIP_DEBUG)\n\t    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation complete: 0x%04x\\n\",\n\t\t       TULIP_PRINTF_ARGS, phyaddr, data);\n#endif\n\t    data = (data << 6) & status;\n\t    if (!tulip_mii_map_abilities(sc, data))\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    return;\n\t}\n\tdefault: {\n#if defined(DIAGNOSTIC)\n\t    printf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t    break;\n\t}\n    }\n#if defined(TULIP_DEBUG)\n    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation failure: state = %d\\n\",\n\t       TULIP_PRINTF_ARGS, phyaddr, sc->tulip_probe_state);\n\t    sc->tulip_dbg.dbg_nway_failures++;\n#endif\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "loudprintf",
          "args": [
            "TULIP_PRINTF_FMT \"(phy%d): autonegotiation failure: state = %d\\n\"",
            "TULIP_PRINTF_ARGS",
            "phyaddr",
            "sc->tulip_probe_state"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"tulip_media_poll: botch at line %d\\n\"",
            "__LINE__"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_map_abilities",
          "args": [
            "sc",
            "data"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_map_abilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1389-1411",
          "snippet": "static int\ntulip_mii_map_abilities(\n    tulip_softc_t * const sc,\n    unsigned abilities)\n{\n    sc->tulip_abilities = abilities;\n    if (abilities & PHYSTS_100BASETX_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX_FD;\n    } else if (abilities & PHYSTS_100BASET4) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASET4;\n    } else if (abilities & PHYSTS_100BASETX) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX;\n    } else if (abilities & PHYSTS_10BASET_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n    } else if (abilities & PHYSTS_10BASET) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\treturn 0;\n    }\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    return 1;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_mii_map_abilities(\n    tulip_softc_t * const sc,\n    unsigned abilities)\n{\n    sc->tulip_abilities = abilities;\n    if (abilities & PHYSTS_100BASETX_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX_FD;\n    } else if (abilities & PHYSTS_100BASET4) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASET4;\n    } else if (abilities & PHYSTS_100BASETX) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX;\n    } else if (abilities & PHYSTS_10BASET_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n    } else if (abilities & PHYSTS_10BASET) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\treturn 0;\n    }\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loudprintf",
          "args": [
            "TULIP_PRINTF_FMT \"(phy%d): autonegotiation complete: 0x%04x\\n\"",
            "TULIP_PRINTF_ARGS",
            "phyaddr",
            "data"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mii_readreg",
          "args": [
            "sc",
            "phyaddr",
            "PHYREG_AUTONEG_ABILITIES"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2044-2066",
          "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loudprintf",
          "args": [
            "TULIP_PRINTF_FMT \"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\\n\"",
            "TULIP_PRINTF_ARGS",
            "phyaddr",
            "status",
            "tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL)"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_timeout",
          "args": [
            "sc"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "211-219",
          "snippet": "static void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_HZ\t10"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_HZ\t10\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loudprintf",
          "args": [
            "TULIP_PRINTF_FMT \"(phy%d): autonegotiation restarted: 0x%04x\\n\"",
            "TULIP_PRINTF_ARGS",
            "phyaddr",
            "data"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loudprintf",
          "args": [
            "TULIP_PRINTF_FMT \"(phy%d): oops: enable autonegotiation failed: 0x%04x\\n\"",
            "TULIP_PRINTF_ARGS",
            "phyaddr",
            "data"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mii_writereg",
          "args": [
            "sc",
            "phyaddr",
            "PHYREG_CONTROL",
            "data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2068-2089",
          "snippet": "static void\ntulip_mii_writereg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno,\n    unsigned data)\n{\n    unsigned csr;\n\n    csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_WRCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_WRCMD);\n    tulip_mii_writebits(sc, data, 16);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][2] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][3]++;\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_writereg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno,\n    unsigned data)\n{\n    unsigned csr;\n\n    csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_WRCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_WRCMD);\n    tulip_mii_writebits(sc, data, 16);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][2] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][3]++;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "loudprintf",
          "args": [
            "TULIP_PRINTF_FMT \"(phy%d): autonegotiation disabled\\n\"",
            "TULIP_PRINTF_ARGS",
            "phyaddr"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_autonegotiate(\n    tulip_softc_t * const sc,\n    const unsigned phyaddr)\n{\n    switch (sc->tulip_probe_state) {\n        case TULIP_PROBE_MEDIATEST:\n        case TULIP_PROBE_INACTIVE: {\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, PHYCTL_RESET);\n\t    sc->tulip_probe_timeout = 3000;\n\t    sc->tulip_intrmask |= TULIP_STS_ABNRMLINTR|TULIP_STS_NORMALINTR;\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYRESET;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYRESET: {\n\t    u_int32_t status;\n\t    u_int32_t data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n\t    if (data & PHYCTL_RESET) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n\t\tprintf(TULIP_PRINTF_FMT \"(phy%d): error: reset of PHY never completed!\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n\t\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\t\tsc->tulip_probe_state = TULIP_PROBE_FAILED;\n\t\tsc->tulip_if.if_flags &= ~(IFF_UP|IFF_RUNNING);\n\t\treturn;\n\t    }\n\t    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    if ((status & PHYSTS_CAN_AUTONEG) == 0) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation disabled\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    if (tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT) != ((status >> 6) | 0x01))\n\t\ttulip_mii_writereg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT, (status >> 6) | 0x01);\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE);\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n#if defined(TULIP_DEBUG)\n\t    if ((data & PHYCTL_AUTONEG_ENABLE) == 0)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): oops: enable autonegotiation failed: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    else\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation restarted: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    sc->tulip_dbg.dbg_nway_starts++;\n#endif\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYAUTONEG;\n\t    sc->tulip_probe_timeout = 3000;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYAUTONEG: {\n\t    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    u_int32_t data;\n\t    if ((status & PHYSTS_AUTONEG_DONE) == 0) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, status,\n\t\t\t   tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL));\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);\n#if defined(TULIP_DEBUG)\n\t    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation complete: 0x%04x\\n\",\n\t\t       TULIP_PRINTF_ARGS, phyaddr, data);\n#endif\n\t    data = (data << 6) & status;\n\t    if (!tulip_mii_map_abilities(sc, data))\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    return;\n\t}\n\tdefault: {\n#if defined(DIAGNOSTIC)\n\t    printf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t    break;\n\t}\n    }\n#if defined(TULIP_DEBUG)\n    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation failure: state = %d\\n\",\n\t       TULIP_PRINTF_ARGS, phyaddr, sc->tulip_probe_state);\n\t    sc->tulip_dbg.dbg_nway_failures++;\n#endif\n}"
  },
  {
    "function_name": "tulip_mii_map_abilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1389-1411",
    "snippet": "static int\ntulip_mii_map_abilities(\n    tulip_softc_t * const sc,\n    unsigned abilities)\n{\n    sc->tulip_abilities = abilities;\n    if (abilities & PHYSTS_100BASETX_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX_FD;\n    } else if (abilities & PHYSTS_100BASET4) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASET4;\n    } else if (abilities & PHYSTS_100BASETX) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX;\n    } else if (abilities & PHYSTS_10BASET_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n    } else if (abilities & PHYSTS_10BASET) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\treturn 0;\n    }\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    return 1;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_mii_map_abilities(\n    tulip_softc_t * const sc,\n    unsigned abilities)\n{\n    sc->tulip_abilities = abilities;\n    if (abilities & PHYSTS_100BASETX_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX_FD;\n    } else if (abilities & PHYSTS_100BASET4) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASET4;\n    } else if (abilities & PHYSTS_100BASETX) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX;\n    } else if (abilities & PHYSTS_10BASET_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n    } else if (abilities & PHYSTS_10BASET) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\treturn 0;\n    }\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    return 1;\n}"
  },
  {
    "function_name": "tulip_mii_get_phyaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1365-1387",
    "snippet": "static unsigned\ntulip_mii_get_phyaddr(\n    tulip_softc_t * const sc,\n    unsigned offset)\n{\n    unsigned phyaddr;\n\n    for (phyaddr = 1; phyaddr < 32; phyaddr++) {\n\tunsigned status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    continue;\n\tif (offset == 0)\n\t    return phyaddr;\n\toffset--;\n    }\n    if (offset == 0) {\n\tunsigned status = tulip_mii_readreg(sc, 0, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    return TULIP_MII_NOPHY;\n\treturn 0;\n    }\n    return TULIP_MII_NOPHY;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_mii_readreg",
          "args": [
            "sc",
            "0",
            "PHYREG_STATUS"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2044-2066",
          "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_get_phyaddr(\n    tulip_softc_t * const sc,\n    unsigned offset)\n{\n    unsigned phyaddr;\n\n    for (phyaddr = 1; phyaddr < 32; phyaddr++) {\n\tunsigned status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    continue;\n\tif (offset == 0)\n\t    return phyaddr;\n\toffset--;\n    }\n    if (offset == 0) {\n\tunsigned status = tulip_mii_readreg(sc, 0, PHYREG_STATUS);\n\tif (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)\n\t    return TULIP_MII_NOPHY;\n\treturn 0;\n    }\n    return TULIP_MII_NOPHY;\n}"
  },
  {
    "function_name": "tulip_mii_phy_readspecific",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1304-1363",
    "snippet": "static tulip_media_t\ntulip_mii_phy_readspecific(\n    tulip_softc_t * const sc)\n{\n    const tulip_phy_attr_t *attr;\n    u_int16_t data;\n    u_int32_t id;\n    unsigned idx = 0;\n    static const tulip_media_t table[] = {\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET,\n\tTULIP_MEDIA_100BASETX,\n\tTULIP_MEDIA_100BASET4,\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET_FD,\n\tTULIP_MEDIA_100BASETX_FD,\n\tTULIP_MEDIA_UNKNOWN\n    };\n\n    /*\n     * Don't read phy specific registers if link is not up.\n     */\n    data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n    if ((data & (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS)) != (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS))\n\treturn TULIP_MEDIA_UNKNOWN;\n\n    id = (tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDLOW) << 16) |\n\ttulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDHIGH);\n    for (attr = tulip_mii_phy_attrlist;; attr++) {\n\tif (attr->attr_id == 0)\n\t    return TULIP_MEDIA_UNKNOWN;\n\tif ((id & ~0x0F) == attr->attr_id)\n\t    break;\n    }\n\n    if (attr->attr_modes[PHY_MODE_100TX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100TX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 2;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_100T4].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100T4];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 3;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_10T].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_10T];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 1;\n    } \n    if (idx != 0 && attr->attr_modes[PHY_MODE_FULLDUPLEX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_FULLDUPLEX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tidx += ((data & pm->pm_mask) == pm->pm_value ? 4 : 0);\n    }\n    return table[idx];\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);",
      "static const tulip_phy_attr_t tulip_mii_phy_attrlist[] = {\n    { 0x20005c00, 0,\t\t/* 08-00-17 */\n      {\n\t{ 0x19, 0x0040, 0x0040 },\t/* 10TX */\n\t{ 0x19, 0x0040, 0x0000 },\t/* 100TX */\n      },\n#if defined(TULIP_DEBUG)\n      \"NS DP83840\",\n#endif\n    },\n    { 0x0281F400, 0,\t\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Seeq 80C240\"\n#endif\n    },\n#if 0\n    { 0x0015F420, 0,\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Broadcom BCM5000\"\n#endif\n    },\n#endif\n    { 0x0281F400, 0,\t\t/* 00-A0-BE */\n      {\n\t{ 0x11, 0x8000, 0x0000 },\t/* 10T */\n\t{ 0x11, 0x8000, 0x8000 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x11, 0x4000, 0x4000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"ICS 1890\"\n#endif \n    },\n    { 0x78100000, 0,\t\t/* 00-A0-CC */\n      {\n\t{ 0x14, 0x0800, 0x0000 },\t/* 10TX */\n\t{ 0x14, 0x0800, 0x0800 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x14, 0x1000, 0x1000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"LEVEL1 LXT970\"\n#endif \n    },\n    { 0 }\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_mii_readreg",
          "args": [
            "sc",
            "sc->tulip_phyaddr",
            "pm->pm_regno"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2044-2066",
          "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_phy_attr_t tulip_mii_phy_attrlist[] = {\n    { 0x20005c00, 0,\t\t/* 08-00-17 */\n      {\n\t{ 0x19, 0x0040, 0x0040 },\t/* 10TX */\n\t{ 0x19, 0x0040, 0x0000 },\t/* 100TX */\n      },\n#if defined(TULIP_DEBUG)\n      \"NS DP83840\",\n#endif\n    },\n    { 0x0281F400, 0,\t\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Seeq 80C240\"\n#endif\n    },\n#if 0\n    { 0x0015F420, 0,\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Broadcom BCM5000\"\n#endif\n    },\n#endif\n    { 0x0281F400, 0,\t\t/* 00-A0-BE */\n      {\n\t{ 0x11, 0x8000, 0x0000 },\t/* 10T */\n\t{ 0x11, 0x8000, 0x8000 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x11, 0x4000, 0x4000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"ICS 1890\"\n#endif \n    },\n    { 0x78100000, 0,\t\t/* 00-A0-CC */\n      {\n\t{ 0x14, 0x0800, 0x0000 },\t/* 10TX */\n\t{ 0x14, 0x0800, 0x0800 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x14, 0x1000, 0x1000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"LEVEL1 LXT970\"\n#endif \n    },\n    { 0 }\n};\n\nstatic tulip_media_t\ntulip_mii_phy_readspecific(\n    tulip_softc_t * const sc)\n{\n    const tulip_phy_attr_t *attr;\n    u_int16_t data;\n    u_int32_t id;\n    unsigned idx = 0;\n    static const tulip_media_t table[] = {\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET,\n\tTULIP_MEDIA_100BASETX,\n\tTULIP_MEDIA_100BASET4,\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET_FD,\n\tTULIP_MEDIA_100BASETX_FD,\n\tTULIP_MEDIA_UNKNOWN\n    };\n\n    /*\n     * Don't read phy specific registers if link is not up.\n     */\n    data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n    if ((data & (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS)) != (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS))\n\treturn TULIP_MEDIA_UNKNOWN;\n\n    id = (tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDLOW) << 16) |\n\ttulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDHIGH);\n    for (attr = tulip_mii_phy_attrlist;; attr++) {\n\tif (attr->attr_id == 0)\n\t    return TULIP_MEDIA_UNKNOWN;\n\tif ((id & ~0x0F) == attr->attr_id)\n\t    break;\n    }\n\n    if (attr->attr_modes[PHY_MODE_100TX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100TX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 2;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_100T4].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100T4];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 3;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_10T].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_10T];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 1;\n    } \n    if (idx != 0 && attr->attr_modes[PHY_MODE_FULLDUPLEX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_FULLDUPLEX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tidx += ((data & pm->pm_mask) == pm->pm_value ? 4 : 0);\n    }\n    return table[idx];\n}"
  },
  {
    "function_name": "tulip_21041_media_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1077-1229",
    "snippet": "static void\ntulip_21041_media_poll(\n    tulip_softc_t * const sc,\n    const tulip_mediapoll_event_t event)\n{\n    u_int32_t sia_status;\n\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_events[event]++;\n#endif\n\n    if (event == TULIP_MEDIAPOLL_LINKFAIL) {\n\tif (sc->tulip_probe_state != TULIP_PROBE_INACTIVE\n\t\t|| !TULIP_DO_AUTOSENSE(sc))\n\t    return;\n\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\ttulip_reset(sc);\t/* start probe */\n\treturn;\n    }\n\n    /*\n     * If we've been been asked to start a poll or link change interrupt\n     * restart the probe (and reset the tulip to a known state).\n     */\n    if (event == TULIP_MEDIAPOLL_START) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_cmdmode &= ~(TULIP_CMD_FULLDUPLEX|TULIP_CMD_RXRUN);\n#ifdef notyet\n\tif (sc->tulip_revinfo >= 0x20) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t}\n#endif\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n\tsc->tulip_probe_timeout = TULIP_21041_PROBE_10BASET_TIMEOUT;\n\ttulip_media_set(sc, TULIP_MEDIA_10BASET);\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE)\n\treturn;\n\n    if (event == TULIP_MEDIAPOLL_TXPROBE_OK) {\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_txprobes_ok[sc->tulip_probe_media]++;\n#endif\n\ttulip_linkup(sc, sc->tulip_probe_media);\n\treturn;\n    }\n\n    sia_status = TULIP_CSR_READ(sc, csr_sia_status);\n    TULIP_CSR_WRITE(sc, csr_sia_status, sia_status);\n    if ((sia_status & TULIP_SIASTS_LINKFAIL) == 0) {\n\tif (sc->tulip_revinfo >= 0x20) {\n\t    if (sia_status & (PHYSTS_10BASET_FD << (16 - 6)))\n\t\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n\t}\n\t/*\n\t * If the link has passed LinkPass, 10baseT is the\n\t * proper media to use.\n\t */\n\ttulip_linkup(sc, sc->tulip_probe_media);\n\treturn;\n    }\n\n    /*\n     * wait for up to 2.4 seconds for the link to reach pass state.\n     * Only then start scanning the other media for activity.\n     * choose media with receive activity over those without.\n     */\n    if (sc->tulip_probe_media == TULIP_MEDIA_10BASET) {\n\tif (event != TULIP_MEDIAPOLL_TIMER)\n\t    return;\n\tif (sc->tulip_probe_timeout > 0\n\t\t&& (sia_status & TULIP_SIASTS_OTHERRXACTIVITY) == 0) {\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n\tsc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n\tsc->tulip_flags |= TULIP_WANTRXACT;\n\tif (sia_status & TULIP_SIASTS_OTHERRXACTIVITY) {\n\t    sc->tulip_probe_media = TULIP_MEDIA_BNC;\n\t} else {\n\t    sc->tulip_probe_media = TULIP_MEDIA_AUI;\n\t}\n\ttulip_media_set(sc, sc->tulip_probe_media);\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    /*\n     * If we failed, clear the txprobe active flag.\n     */\n    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED)\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\n\n    if (event == TULIP_MEDIAPOLL_TIMER) {\n\t/*\n\t * If we've received something, then that's our link!\n\t */\n\tif (sc->tulip_flags & TULIP_RXACT) {\n\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t    return;\n\t}\n\t/*\n\t * if no txprobe active  \n\t */\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0\n\t\t&& ((sc->tulip_flags & TULIP_WANTRXACT) == 0\n\t\t    || (sia_status & TULIP_SIASTS_RXACTIVITY))) {\n\t    sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n\t    tulip_txprobe(sc);\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n\t/*\n\t * Take 2 passes through before deciding to not\n\t * wait for receive activity.  Then take another\n\t * two passes before spitting out a warning.\n\t */\n\tif (sc->tulip_probe_timeout <= 0) {\n\t    if (sc->tulip_flags & TULIP_WANTRXACT) {\n\t\tsc->tulip_flags &= ~TULIP_WANTRXACT;\n\t\tsc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": autosense failed: cable problem?\\n\",\n\t\t       TULIP_PRINTF_ARGS);\n\t\tif ((sc->tulip_if.if_flags & IFF_UP) == 0) {\n\t\t    sc->tulip_if.if_flags &= ~IFF_RUNNING;\n\t\t    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n    \n    /*\n     * Since this media failed to probe, try the other one.\n     */\n    sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n    if (sc->tulip_probe_media == TULIP_MEDIA_AUI) {\n\tsc->tulip_probe_media = TULIP_MEDIA_BNC;\n    } else {\n\tsc->tulip_probe_media = TULIP_MEDIA_AUI;\n    }\n    tulip_media_set(sc, sc->tulip_probe_media);\n    sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n    tulip_timeout(sc);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_timeout",
          "args": [
            "sc"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "211-219",
          "snippet": "static void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_HZ\t10"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_HZ\t10\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "sc->tulip_probe_media"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": autosense failed: cable problem?\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_txprobe",
          "args": [
            "sc"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_txprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "245-282",
          "snippet": "static int\ntulip_txprobe(\n    tulip_softc_t * const sc)\n{\n    struct mbuf *m;\n    /*\n     * Before we are sure this is the right media we need\n     * to send a small packet to make sure there's carrier.\n     * Strangely, BNC and AUI will \"see\" receive data if\n     * either is connected so the transmit is the only way\n     * to verify the connectivity.\n     */\n    MGETHDR(m, M_DONTWAIT, MT_DATA);\n    if (m == NULL)\n\treturn 0;\n    /*\n     * Construct a LLC TEST message which will point to ourselves.\n     */\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost, 6);\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost, 6);\n    mtod(m, struct ether_header *)->ether_type = htons(3);\n    mtod(m, unsigned char *)[14] = 0;\n    mtod(m, unsigned char *)[15] = 0;\n    mtod(m, unsigned char *)[16] = 0xE3;\t/* LLC Class1 TEST (no poll) */\n    m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n    /*\n     * send it!\n     */\n    sc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n    sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    if ((m = tulip_txput(sc, m)) != NULL)\n\tm_freem(m);\n    sc->tulip_probe.probe_txprobes++;\n    return 1;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_txprobe(\n    tulip_softc_t * const sc)\n{\n    struct mbuf *m;\n    /*\n     * Before we are sure this is the right media we need\n     * to send a small packet to make sure there's carrier.\n     * Strangely, BNC and AUI will \"see\" receive data if\n     * either is connected so the transmit is the only way\n     * to verify the connectivity.\n     */\n    MGETHDR(m, M_DONTWAIT, MT_DATA);\n    if (m == NULL)\n\treturn 0;\n    /*\n     * Construct a LLC TEST message which will point to ourselves.\n     */\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost, 6);\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost, 6);\n    mtod(m, struct ether_header *)->ether_type = htons(3);\n    mtod(m, unsigned char *)[14] = 0;\n    mtod(m, unsigned char *)[15] = 0;\n    mtod(m, unsigned char *)[16] = 0xE3;\t/* LLC Class1 TEST (no poll) */\n    m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n    /*\n     * send it!\n     */\n    sc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n    sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    if ((m = tulip_txput(sc, m)) != NULL)\n\tm_freem(m);\n    sc->tulip_probe.probe_txprobes++;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_linkup",
          "args": [
            "sc",
            "sc->tulip_probe_media"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_linkup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "384-436",
          "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_status",
            "sia_status"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_sia_status"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_DO_AUTOSENSE",
          "args": [
            "sc"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21041_media_poll(\n    tulip_softc_t * const sc,\n    const tulip_mediapoll_event_t event)\n{\n    u_int32_t sia_status;\n\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_events[event]++;\n#endif\n\n    if (event == TULIP_MEDIAPOLL_LINKFAIL) {\n\tif (sc->tulip_probe_state != TULIP_PROBE_INACTIVE\n\t\t|| !TULIP_DO_AUTOSENSE(sc))\n\t    return;\n\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\ttulip_reset(sc);\t/* start probe */\n\treturn;\n    }\n\n    /*\n     * If we've been been asked to start a poll or link change interrupt\n     * restart the probe (and reset the tulip to a known state).\n     */\n    if (event == TULIP_MEDIAPOLL_START) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_cmdmode &= ~(TULIP_CMD_FULLDUPLEX|TULIP_CMD_RXRUN);\n#ifdef notyet\n\tif (sc->tulip_revinfo >= 0x20) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t}\n#endif\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n\tsc->tulip_probe_timeout = TULIP_21041_PROBE_10BASET_TIMEOUT;\n\ttulip_media_set(sc, TULIP_MEDIA_10BASET);\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE)\n\treturn;\n\n    if (event == TULIP_MEDIAPOLL_TXPROBE_OK) {\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_txprobes_ok[sc->tulip_probe_media]++;\n#endif\n\ttulip_linkup(sc, sc->tulip_probe_media);\n\treturn;\n    }\n\n    sia_status = TULIP_CSR_READ(sc, csr_sia_status);\n    TULIP_CSR_WRITE(sc, csr_sia_status, sia_status);\n    if ((sia_status & TULIP_SIASTS_LINKFAIL) == 0) {\n\tif (sc->tulip_revinfo >= 0x20) {\n\t    if (sia_status & (PHYSTS_10BASET_FD << (16 - 6)))\n\t\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n\t}\n\t/*\n\t * If the link has passed LinkPass, 10baseT is the\n\t * proper media to use.\n\t */\n\ttulip_linkup(sc, sc->tulip_probe_media);\n\treturn;\n    }\n\n    /*\n     * wait for up to 2.4 seconds for the link to reach pass state.\n     * Only then start scanning the other media for activity.\n     * choose media with receive activity over those without.\n     */\n    if (sc->tulip_probe_media == TULIP_MEDIA_10BASET) {\n\tif (event != TULIP_MEDIAPOLL_TIMER)\n\t    return;\n\tif (sc->tulip_probe_timeout > 0\n\t\t&& (sia_status & TULIP_SIASTS_OTHERRXACTIVITY) == 0) {\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n\tsc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n\tsc->tulip_flags |= TULIP_WANTRXACT;\n\tif (sia_status & TULIP_SIASTS_OTHERRXACTIVITY) {\n\t    sc->tulip_probe_media = TULIP_MEDIA_BNC;\n\t} else {\n\t    sc->tulip_probe_media = TULIP_MEDIA_AUI;\n\t}\n\ttulip_media_set(sc, sc->tulip_probe_media);\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    /*\n     * If we failed, clear the txprobe active flag.\n     */\n    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED)\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\n\n    if (event == TULIP_MEDIAPOLL_TIMER) {\n\t/*\n\t * If we've received something, then that's our link!\n\t */\n\tif (sc->tulip_flags & TULIP_RXACT) {\n\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t    return;\n\t}\n\t/*\n\t * if no txprobe active  \n\t */\n\tif ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0\n\t\t&& ((sc->tulip_flags & TULIP_WANTRXACT) == 0\n\t\t    || (sia_status & TULIP_SIASTS_RXACTIVITY))) {\n\t    sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n\t    tulip_txprobe(sc);\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n\t/*\n\t * Take 2 passes through before deciding to not\n\t * wait for receive activity.  Then take another\n\t * two passes before spitting out a warning.\n\t */\n\tif (sc->tulip_probe_timeout <= 0) {\n\t    if (sc->tulip_flags & TULIP_WANTRXACT) {\n\t\tsc->tulip_flags &= ~TULIP_WANTRXACT;\n\t\tsc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n\t    } else {\n\t\tprintf(TULIP_PRINTF_FMT \": autosense failed: cable problem?\\n\",\n\t\t       TULIP_PRINTF_ARGS);\n\t\tif ((sc->tulip_if.if_flags & IFF_UP) == 0) {\n\t\t    sc->tulip_if.if_flags &= ~IFF_RUNNING;\n\t\t    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n    \n    /*\n     * Since this media failed to probe, try the other one.\n     */\n    sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;\n    if (sc->tulip_probe_media == TULIP_MEDIA_AUI) {\n\tsc->tulip_probe_media = TULIP_MEDIA_BNC;\n    } else {\n\tsc->tulip_probe_media = TULIP_MEDIA_AUI;\n    }\n    tulip_media_set(sc, sc->tulip_probe_media);\n    sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n    tulip_timeout(sc);\n}"
  },
  {
    "function_name": "tulip_21041_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1066-1075",
    "snippet": "static void\ntulip_21041_media_probe(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_if.if_baudrate = 10000000;\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT\n\t|TULIP_CMD_THRSHLD160|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_intrmask |= TULIP_STS_LINKPASS;\n    tulip_21041_mediainfo_init(sc);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_21041_mediainfo_init",
          "args": [
            "sc"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21041_mediainfo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1035-1054",
          "snippet": "static void\ntulip_21041_mediainfo_init(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t * const mi = sc->tulip_mediainfo;\n\n#ifdef notyet\n    if (sc->tulip_revinfo >= 0x20) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, 10BASET_FD);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, AUI);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, BNC);\n\treturn;\n    }\n#endif\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041, 10BASET);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041, 10BASET_FD);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[2], 21041, AUI);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[3], 21041, BNC);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21041_mediainfo_init(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t * const mi = sc->tulip_mediainfo;\n\n#ifdef notyet\n    if (sc->tulip_revinfo >= 0x20) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, 10BASET_FD);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, AUI);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, BNC);\n\treturn;\n    }\n#endif\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041, 10BASET);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041, 10BASET_FD);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[2], 21041, AUI);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[3], 21041, BNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21041_media_probe(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_if.if_baudrate = 10000000;\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT\n\t|TULIP_CMD_THRSHLD160|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_intrmask |= TULIP_STS_LINKPASS;\n    tulip_21041_mediainfo_init(sc);\n}"
  },
  {
    "function_name": "tulip_21041_media_noprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1056-1064",
    "snippet": "static void\ntulip_21041_media_noprobe(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_if.if_baudrate = 10000000;\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT\n\t|TULIP_CMD_THRSHLD160|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21041_media_noprobe(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_if.if_baudrate = 10000000;\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT\n\t|TULIP_CMD_THRSHLD160|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n}"
  },
  {
    "function_name": "tulip_21041_mediainfo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1035-1054",
    "snippet": "static void\ntulip_21041_mediainfo_init(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t * const mi = sc->tulip_mediainfo;\n\n#ifdef notyet\n    if (sc->tulip_revinfo >= 0x20) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, 10BASET_FD);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, AUI);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, BNC);\n\treturn;\n    }\n#endif\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041, 10BASET);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041, 10BASET_FD);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[2], 21041, AUI);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[3], 21041, BNC);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[3]",
            "21041",
            "BNC"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[2]",
            "21041",
            "AUI"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[1]",
            "21041",
            "10BASET_FD"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[0]",
            "21041",
            "10BASET"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[1]",
            "21041P2",
            "BNC"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[0]",
            "21041P2",
            "AUI"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[1]",
            "21041P2",
            "10BASET_FD"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&mi[0]",
            "21041P2",
            "10BASET"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21041_mediainfo_init(\n    tulip_softc_t * const sc)\n{\n    tulip_media_info_t * const mi = sc->tulip_mediainfo;\n\n#ifdef notyet\n    if (sc->tulip_revinfo >= 0x20) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, 10BASET_FD);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, AUI);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, BNC);\n\treturn;\n    }\n#endif\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041, 10BASET);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041, 10BASET_FD);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[2], 21041, AUI);\n    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[3], 21041, BNC);\n}"
  },
  {
    "function_name": "tulip_21040_auibnc_only_media_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "1006-1012",
    "snippet": "static void\ntulip_21040_auibnc_only_media_select(\n    tulip_softc_t * const sc)\n{\n    tulip_media_set(sc, TULIP_MEDIA_AUIBNC);\n    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "TULIP_MEDIA_AUIBNC"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_auibnc_only_media_select(\n    tulip_softc_t * const sc)\n{\n    tulip_media_set(sc, TULIP_MEDIA_AUIBNC);\n    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n}"
  },
  {
    "function_name": "tulip_21040_auibnc_only_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "996-1004",
    "snippet": "static void\ntulip_21040_auibnc_only_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_AUIBNC);\n    sc->tulip_flags |= TULIP_SQETEST|TULIP_LINKUP;\n    tulip_media_set(sc, TULIP_MEDIA_AUIBNC);\n    sc->tulip_media = TULIP_MEDIA_AUIBNC;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "TULIP_MEDIA_AUIBNC"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_21040_mediainfo_init",
          "args": [
            "sc",
            "TULIP_MEDIA_AUIBNC"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21040_mediainfo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "939-962",
          "snippet": "static void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_auibnc_only_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_AUIBNC);\n    sc->tulip_flags |= TULIP_SQETEST|TULIP_LINKUP;\n    tulip_media_set(sc, TULIP_MEDIA_AUIBNC);\n    sc->tulip_media = TULIP_MEDIA_AUIBNC;\n}"
  },
  {
    "function_name": "tulip_21040_10baset_only_media_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "981-994",
    "snippet": "static void\ntulip_21040_10baset_only_media_select(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_flags |= TULIP_LINKUP;\n    if (sc->tulip_media == TULIP_MEDIA_10BASET_FD) {\n\tsc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\tsc->tulip_flags &= ~TULIP_SQETEST;\n    } else {\n\tsc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\tsc->tulip_flags |= TULIP_SQETEST;\n    }\n    tulip_media_set(sc, sc->tulip_media);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "sc->tulip_media"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_10baset_only_media_select(\n    tulip_softc_t * const sc)\n{\n    sc->tulip_flags |= TULIP_LINKUP;\n    if (sc->tulip_media == TULIP_MEDIA_10BASET_FD) {\n\tsc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\tsc->tulip_flags &= ~TULIP_SQETEST;\n    } else {\n\tsc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\tsc->tulip_flags |= TULIP_SQETEST;\n    }\n    tulip_media_set(sc, sc->tulip_media);\n}"
  },
  {
    "function_name": "tulip_21040_10baset_only_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "972-979",
    "snippet": "static void\ntulip_21040_10baset_only_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_10BASET);\n    tulip_media_set(sc, TULIP_MEDIA_10BASET);\n    sc->tulip_media = TULIP_MEDIA_10BASET;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "TULIP_MEDIA_10BASET"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_21040_mediainfo_init",
          "args": [
            "sc",
            "TULIP_MEDIA_10BASET"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21040_mediainfo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "939-962",
          "snippet": "static void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_10baset_only_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_10BASET);\n    tulip_media_set(sc, TULIP_MEDIA_10BASET);\n    sc->tulip_media = TULIP_MEDIA_10BASET;\n}"
  },
  {
    "function_name": "tulip_21040_media_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "964-970",
    "snippet": "static void\ntulip_21040_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_UNKNOWN);\n    return;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_21040_mediainfo_init",
          "args": [
            "sc",
            "TULIP_MEDIA_UNKNOWN"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21040_mediainfo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "939-962",
          "snippet": "static void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_media_probe(\n    tulip_softc_t * const sc)\n{\n    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_UNKNOWN);\n    return;\n}"
  },
  {
    "function_name": "tulip_21040_mediainfo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "939-962",
    "snippet": "static void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&sc->tulip_mediainfo[3]",
            "21040",
            "EXTSIA"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&sc->tulip_mediainfo[2]",
            "21040",
            "AUIBNC"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&sc->tulip_mediainfo[1]",
            "21040",
            "10BASET_FD"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_MEDIAINFO_SIA_INIT",
          "args": [
            "sc",
            "&sc->tulip_mediainfo[0]",
            "21040",
            "10BASET"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_21040_mediainfo_init(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160\n\t|TULIP_CMD_BACKOFFCTR;\n    sc->tulip_if.if_baudrate = 10000000;\n\n    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);\n\n\tsc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;\n    }\n\n    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);\n    }\n\n    if (media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);\n    }\n}"
  },
  {
    "function_name": "tulip_media_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "916-937",
    "snippet": "static void\ntulip_media_select(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_features & TULIP_HAVE_GPR) {\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpdata);\n    }\n    /*\n     * If this board has no media, just return\n     */\n    if (sc->tulip_features & TULIP_HAVE_NOMEDIA)\n\treturn;\n\n    if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t(*sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_START);\n    } else {\n\ttulip_media_set(sc, sc->tulip_media);\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "sc->tulip_media"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "TULIP_MEDIAPOLL_START"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "sc->tulip_gpdata"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_PINSET|sc->tulip_gpinit"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_select(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_features & TULIP_HAVE_GPR) {\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpdata);\n    }\n    /*\n     * If this board has no media, just return\n     */\n    if (sc->tulip_features & TULIP_HAVE_NOMEDIA)\n\treturn;\n\n    if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t(*sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_START);\n    } else {\n\ttulip_media_set(sc, sc->tulip_media);\n    }\n}"
  },
  {
    "function_name": "tulip_media_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "626-914",
    "snippet": "static void\ntulip_media_poll(\n    tulip_softc_t * const sc,\n    tulip_mediapoll_event_t event)\n{\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_events[event]++;\n#endif\n    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE\n\t    && event == TULIP_MEDIAPOLL_TIMER) {\n\tswitch (tulip_media_link_monitor(sc)) {\n\t    case TULIP_LINK_DOWN: {\n\t\t/*\n\t\t * Link Monitor failed.  Probe for new media.\n\t\t */\n\t\tevent = TULIP_MEDIAPOLL_LINKFAIL;\n\t\tbreak;\n\t    }\n\t    case TULIP_LINK_UP: {\n\t\t/*\n\t\t * Check again soon.\n\t\t */\n\t\ttulip_timeout(sc);\n\t\treturn;\n\t    }\n\t    case TULIP_LINK_UNKNOWN: {\n\t\t/*\n\t\t * We can't tell so don't bother.\n\t\t */\n\t\treturn;\n\t    }\n\t}\n    }\n\n    if (event == TULIP_MEDIAPOLL_LINKFAIL) {\n\tif (sc->tulip_probe_state == TULIP_PROBE_INACTIVE) {\n\t    if (TULIP_DO_AUTOSENSE(sc)) {\n#if defined(TULIP_DEBUG)\n\t\tsc->tulip_dbg.dbg_link_failures++;\n#endif\n\t\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\t\tif (sc->tulip_if.if_flags & IFF_UP)\n\t\t    tulip_reset(sc);\t/* restart probe */\n\t    }\n\t    return;\n\t}\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_link_pollintrs++;\n#endif\n    }\n\n    if (event == TULIP_MEDIAPOLL_START) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tif (sc->tulip_probe_state != TULIP_PROBE_INACTIVE)\n\t    return;\n\tsc->tulip_probe_mediamask = 0;\n\tsc->tulip_probe_passes = 0;\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_media_probes++;\n#endif\n\t/*\n\t * If the SROM contained an explicit media to use, use it.\n\t */\n\tsc->tulip_cmdmode &= ~(TULIP_CMD_RXRUN|TULIP_CMD_FULLDUPLEX);\n\tsc->tulip_flags |= TULIP_TRYNWAY|TULIP_PROBE1STPASS;\n\tsc->tulip_flags &= ~(TULIP_DIDNWAY|TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n\t/*\n\t * connidx is defaulted to a media_unknown type.\n\t */\n\tsc->tulip_probe_media = tulip_srom_conninfo[sc->tulip_connidx].sc_media;\n\tif (sc->tulip_probe_media != TULIP_MEDIA_UNKNOWN) {\n\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n\n\tif (sc->tulip_features & TULIP_HAVE_GPR) {\n\t    sc->tulip_probe_state = TULIP_PROBE_GPRTEST;\n\t    sc->tulip_probe_timeout = 2000;\n\t} else {\n\t    sc->tulip_probe_media = TULIP_MEDIA_MAX;\n\t    sc->tulip_probe_timeout = 0;\n\t    sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t}\n    }\n\n    /*\n     * Ignore txprobe failures or spurious callbacks.\n     */\n    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED\n\t    && sc->tulip_probe_state != TULIP_PROBE_MEDIATEST) {\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\treturn;\n    }\n\n    /*\n     * If we really transmitted a packet, then that's the media we'll use.\n     */\n    if (event == TULIP_MEDIAPOLL_TXPROBE_OK || event == TULIP_MEDIAPOLL_LINKPASS) {\n\tif (event == TULIP_MEDIAPOLL_LINKPASS) {\n\t    /* XXX check media status just to be sure */\n\t    sc->tulip_probe_media = TULIP_MEDIA_10BASET;\n#if defined(TULIP_DEBUG)\n\t} else {\n\t    sc->tulip_dbg.dbg_txprobes_ok[sc->tulip_probe_media]++;\n#endif\n\t}\n\ttulip_linkup(sc, sc->tulip_probe_media);\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    if (sc->tulip_probe_state == TULIP_PROBE_GPRTEST) {\n#if defined(TULIP_DO_GPR_SENSE)\n\t/*\n\t * Check for media via the general purpose register.\n\t *\n\t * Try to sense the media via the GPR.  If the same value\n\t * occurs 3 times in a row then just use that.\n\t */\n\tif (sc->tulip_probe_timeout > 0) {\n\t    tulip_media_t new_probe_media = tulip_21140_gpr_media_sense(sc);\n#if defined(TULIP_DEBUG)\n\t    printf(TULIP_PRINTF_FMT \": media_poll: gpr sensing = %s\\n\",\n\t\t   TULIP_PRINTF_ARGS, tulip_mediums[new_probe_media]);\n#endif\n\t    if (new_probe_media != TULIP_MEDIA_UNKNOWN) {\n\t\tif (new_probe_media == sc->tulip_probe_media) {\n\t\t    if (--sc->tulip_probe_count == 0)\n\t\t\ttulip_linkup(sc, sc->tulip_probe_media);\n\t\t} else {\n\t\t    sc->tulip_probe_count = 10;\n\t\t}\n\t    }\n\t    sc->tulip_probe_media = new_probe_media;\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n#endif /* TULIP_DO_GPR_SENSE */\n\t/*\n\t * Brute force.  We cycle through each of the media types\n\t * and try to transmit a packet.\n\t */\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\tsc->tulip_probe_media = TULIP_MEDIA_MAX;\n\tsc->tulip_probe_timeout = 0;\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    if (sc->tulip_probe_state != TULIP_PROBE_MEDIATEST\n\t   && (sc->tulip_features & TULIP_HAVE_MII)) {\n\ttulip_media_t old_media = sc->tulip_probe_media;\n\ttulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\tswitch (sc->tulip_probe_state) {\n\t    case TULIP_PROBE_FAILED:\n\t    case TULIP_PROBE_MEDIATEST: {\n\t\t/*\n\t\t * Try the next media.\n\t\t */\n\t\tsc->tulip_probe_mediamask |= sc->tulip_mediums[sc->tulip_probe_media]->mi_mediamask;\n\t\tsc->tulip_probe_timeout = 0;\n#ifdef notyet\n\t\tif (sc->tulip_probe_state == TULIP_PROBE_FAILED)\n\t\t    break;\n\t\tif (sc->tulip_probe_media != tulip_mii_phy_readspecific(sc))\n\t\t    break;\n\t\tsc->tulip_probe_timeout = TULIP_IS_MEDIA_TP(sc->tulip_probe_media) ? 2500 : 300;\n#endif\n\t\tbreak;\n\t    }\n\t    case TULIP_PROBE_PHYAUTONEG: {\n\t\treturn;\n\t    }\n\t    case TULIP_PROBE_INACTIVE: {\n\t\t/*\n\t\t * Only probe if we autonegotiated a media that hasn't failed.\n\t\t */\n\t\tsc->tulip_probe_timeout = 0;\n\t\tif (sc->tulip_probe_mediamask & TULIP_BIT(sc->tulip_probe_media)) {\n\t\t    sc->tulip_probe_media = old_media;\n\t\t    break;\n\t\t}\n\t\ttulip_linkup(sc, sc->tulip_probe_media);\n\t\ttulip_timeout(sc);\n\t\treturn;\n\t    }\n\t    default: {\n#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)\n\t\tprintf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED) {\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_txprobes_failed[sc->tulip_probe_media]++;\n#endif\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\treturn;\n    }\n\n    /*\n     * switch to another media if we tried this one enough.\n     */\n    if (/* event == TULIP_MEDIAPOLL_TXPROBE_FAILED || */ sc->tulip_probe_timeout <= 0) {\n#if defined(TULIP_DEBUG)\n\tif (sc->tulip_probe_media == TULIP_MEDIA_UNKNOWN) {\n\t    printf(TULIP_PRINTF_FMT \": poll media unknown!\\n\",\n\t\t   TULIP_PRINTF_ARGS);\n\t    sc->tulip_probe_media = TULIP_MEDIA_MAX;\n\t}\n#endif\n\t/*\n\t * Find the next media type to check for.  Full Duplex\n\t * types are not allowed.\n\t */\n\tdo {\n\t    sc->tulip_probe_media -= 1;\n\t    if (sc->tulip_probe_media == TULIP_MEDIA_UNKNOWN) {\n\t\tif (++sc->tulip_probe_passes == 3) {\n\t\t    printf(TULIP_PRINTF_FMT \": autosense failed: cable problem?\\n\",\n\t\t\t   TULIP_PRINTF_ARGS);\n\t\t    if ((sc->tulip_if.if_flags & IFF_UP) == 0) {\n\t\t\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\t\t\tsc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t\tsc->tulip_flags ^= TULIP_TRYNWAY;\t/* XXX */\n\t\tsc->tulip_probe_mediamask = 0;\n\t\tsc->tulip_probe_media = TULIP_MEDIA_MAX - 1;\n\t    }\n\t} while (sc->tulip_mediums[sc->tulip_probe_media] == NULL\n\t\t || (sc->tulip_probe_mediamask & TULIP_BIT(sc->tulip_probe_media))\n\t\t || TULIP_IS_MEDIA_FD(sc->tulip_probe_media));\n\n#if defined(TULIP_DEBUG)\n\tprintf(TULIP_PRINTF_FMT \": %s: probing %s\\n\", TULIP_PRINTF_ARGS,\n\t       event == TULIP_MEDIAPOLL_TXPROBE_FAILED ? \"txprobe failed\" : \"timeout\",\n\t       tulip_mediums[sc->tulip_probe_media]);\n#endif\n\tsc->tulip_probe_timeout = TULIP_IS_MEDIA_TP(sc->tulip_probe_media) ? 2500 : 1000;\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\tsc->tulip_probe.probe_txprobes = 0;\n\ttulip_reset(sc);\n\ttulip_media_set(sc, sc->tulip_probe_media);\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n    }\n    tulip_timeout(sc);\n\n    /*\n     * If this is hanging off a phy, we know are doing NWAY and we have\n     * forced the phy to a specific speed.  Wait for link up before\n     * before sending a packet.\n     */\n    switch (sc->tulip_mediums[sc->tulip_probe_media]->mi_type) {\n\tcase TULIP_MEDIAINFO_MII: {\n\t    if (sc->tulip_probe_media != tulip_mii_phy_readspecific(sc))\n\t\treturn;\n\t    break;\n\t}\n\tcase TULIP_MEDIAINFO_SIA: {\n\t    if (TULIP_IS_MEDIA_TP(sc->tulip_probe_media)) {\n\t\tif (TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL)\n\t\t    return;\n\t\ttulip_linkup(sc, sc->tulip_probe_media);\n#ifdef notyet\n\t\tif (sc->tulip_features & TULIP_HAVE_MII)\n\t\t    tulip_timeout(sc);\n#endif\n\t\treturn;\n\t    }\n\t    break;\n\t}\n\tcase TULIP_MEDIAINFO_RESET:\n\tcase TULIP_MEDIAINFO_SYM:\n\tcase TULIP_MEDIAINFO_NONE:\n\tcase TULIP_MEDIAINFO_GPR: {\n\t    break;\n\t}\n    }\n    /*\n     * Try to send a packet.\n     */\n    tulip_txprobe(sc);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_txprobe",
          "args": [
            "sc"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_txprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "245-282",
          "snippet": "static int\ntulip_txprobe(\n    tulip_softc_t * const sc)\n{\n    struct mbuf *m;\n    /*\n     * Before we are sure this is the right media we need\n     * to send a small packet to make sure there's carrier.\n     * Strangely, BNC and AUI will \"see\" receive data if\n     * either is connected so the transmit is the only way\n     * to verify the connectivity.\n     */\n    MGETHDR(m, M_DONTWAIT, MT_DATA);\n    if (m == NULL)\n\treturn 0;\n    /*\n     * Construct a LLC TEST message which will point to ourselves.\n     */\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost, 6);\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost, 6);\n    mtod(m, struct ether_header *)->ether_type = htons(3);\n    mtod(m, unsigned char *)[14] = 0;\n    mtod(m, unsigned char *)[15] = 0;\n    mtod(m, unsigned char *)[16] = 0xE3;\t/* LLC Class1 TEST (no poll) */\n    m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n    /*\n     * send it!\n     */\n    sc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n    sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    if ((m = tulip_txput(sc, m)) != NULL)\n\tm_freem(m);\n    sc->tulip_probe.probe_txprobes++;\n    return 1;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_txprobe(\n    tulip_softc_t * const sc)\n{\n    struct mbuf *m;\n    /*\n     * Before we are sure this is the right media we need\n     * to send a small packet to make sure there's carrier.\n     * Strangely, BNC and AUI will \"see\" receive data if\n     * either is connected so the transmit is the only way\n     * to verify the connectivity.\n     */\n    MGETHDR(m, M_DONTWAIT, MT_DATA);\n    if (m == NULL)\n\treturn 0;\n    /*\n     * Construct a LLC TEST message which will point to ourselves.\n     */\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost, 6);\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost, 6);\n    mtod(m, struct ether_header *)->ether_type = htons(3);\n    mtod(m, unsigned char *)[14] = 0;\n    mtod(m, unsigned char *)[15] = 0;\n    mtod(m, unsigned char *)[16] = 0xE3;\t/* LLC Class1 TEST (no poll) */\n    m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n    /*\n     * send it!\n     */\n    sc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n    sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    if ((m = tulip_txput(sc, m)) != NULL)\n\tm_freem(m);\n    sc->tulip_probe.probe_txprobes++;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_timeout",
          "args": [
            "sc"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "211-219",
          "snippet": "static void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_HZ\t10"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_HZ\t10\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_linkup",
          "args": [
            "sc",
            "sc->tulip_probe_media"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_linkup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "384-436",
          "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_sia_status"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_TP",
          "args": [
            "sc->tulip_probe_media"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mii_phy_readspecific",
          "args": [
            "sc"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_phy_readspecific",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1304-1363",
          "snippet": "static tulip_media_t\ntulip_mii_phy_readspecific(\n    tulip_softc_t * const sc)\n{\n    const tulip_phy_attr_t *attr;\n    u_int16_t data;\n    u_int32_t id;\n    unsigned idx = 0;\n    static const tulip_media_t table[] = {\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET,\n\tTULIP_MEDIA_100BASETX,\n\tTULIP_MEDIA_100BASET4,\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET_FD,\n\tTULIP_MEDIA_100BASETX_FD,\n\tTULIP_MEDIA_UNKNOWN\n    };\n\n    /*\n     * Don't read phy specific registers if link is not up.\n     */\n    data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n    if ((data & (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS)) != (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS))\n\treturn TULIP_MEDIA_UNKNOWN;\n\n    id = (tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDLOW) << 16) |\n\ttulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDHIGH);\n    for (attr = tulip_mii_phy_attrlist;; attr++) {\n\tif (attr->attr_id == 0)\n\t    return TULIP_MEDIA_UNKNOWN;\n\tif ((id & ~0x0F) == attr->attr_id)\n\t    break;\n    }\n\n    if (attr->attr_modes[PHY_MODE_100TX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100TX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 2;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_100T4].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100T4];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 3;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_10T].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_10T];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 1;\n    } \n    if (idx != 0 && attr->attr_modes[PHY_MODE_FULLDUPLEX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_FULLDUPLEX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tidx += ((data & pm->pm_mask) == pm->pm_value ? 4 : 0);\n    }\n    return table[idx];\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "static const tulip_phy_attr_t tulip_mii_phy_attrlist[] = {\n    { 0x20005c00, 0,\t\t/* 08-00-17 */\n      {\n\t{ 0x19, 0x0040, 0x0040 },\t/* 10TX */\n\t{ 0x19, 0x0040, 0x0000 },\t/* 100TX */\n      },\n#if defined(TULIP_DEBUG)\n      \"NS DP83840\",\n#endif\n    },\n    { 0x0281F400, 0,\t\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Seeq 80C240\"\n#endif\n    },\n#if 0\n    { 0x0015F420, 0,\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Broadcom BCM5000\"\n#endif\n    },\n#endif\n    { 0x0281F400, 0,\t\t/* 00-A0-BE */\n      {\n\t{ 0x11, 0x8000, 0x0000 },\t/* 10T */\n\t{ 0x11, 0x8000, 0x8000 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x11, 0x4000, 0x4000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"ICS 1890\"\n#endif \n    },\n    { 0x78100000, 0,\t\t/* 00-A0-CC */\n      {\n\t{ 0x14, 0x0800, 0x0000 },\t/* 10TX */\n\t{ 0x14, 0x0800, 0x0800 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x14, 0x1000, 0x1000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"LEVEL1 LXT970\"\n#endif \n    },\n    { 0 }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\nstatic const tulip_phy_attr_t tulip_mii_phy_attrlist[] = {\n    { 0x20005c00, 0,\t\t/* 08-00-17 */\n      {\n\t{ 0x19, 0x0040, 0x0040 },\t/* 10TX */\n\t{ 0x19, 0x0040, 0x0000 },\t/* 100TX */\n      },\n#if defined(TULIP_DEBUG)\n      \"NS DP83840\",\n#endif\n    },\n    { 0x0281F400, 0,\t\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Seeq 80C240\"\n#endif\n    },\n#if 0\n    { 0x0015F420, 0,\t/* 00-A0-7D */\n      {\n\t{ 0x12, 0x0010, 0x0000 },\t/* 10T */\n\t{ },\t\t\t\t/* 100TX */\n\t{ 0x12, 0x0010, 0x0010 },\t/* 100T4 */\n\t{ 0x12, 0x0008, 0x0008 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"Broadcom BCM5000\"\n#endif\n    },\n#endif\n    { 0x0281F400, 0,\t\t/* 00-A0-BE */\n      {\n\t{ 0x11, 0x8000, 0x0000 },\t/* 10T */\n\t{ 0x11, 0x8000, 0x8000 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x11, 0x4000, 0x4000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"ICS 1890\"\n#endif \n    },\n    { 0x78100000, 0,\t\t/* 00-A0-CC */\n      {\n\t{ 0x14, 0x0800, 0x0000 },\t/* 10TX */\n\t{ 0x14, 0x0800, 0x0800 },\t/* 100TX */\n\t{ },\t\t\t\t/* 100T4 */\n\t{ 0x14, 0x1000, 0x1000 },\t/* FULL_DUPLEX */\n      },\n#if defined(TULIP_DEBUG)\n      \"LEVEL1 LXT970\"\n#endif \n    },\n    { 0 }\n};\n\nstatic tulip_media_t\ntulip_mii_phy_readspecific(\n    tulip_softc_t * const sc)\n{\n    const tulip_phy_attr_t *attr;\n    u_int16_t data;\n    u_int32_t id;\n    unsigned idx = 0;\n    static const tulip_media_t table[] = {\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET,\n\tTULIP_MEDIA_100BASETX,\n\tTULIP_MEDIA_100BASET4,\n\tTULIP_MEDIA_UNKNOWN,\n\tTULIP_MEDIA_10BASET_FD,\n\tTULIP_MEDIA_100BASETX_FD,\n\tTULIP_MEDIA_UNKNOWN\n    };\n\n    /*\n     * Don't read phy specific registers if link is not up.\n     */\n    data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n    if ((data & (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS)) != (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS))\n\treturn TULIP_MEDIA_UNKNOWN;\n\n    id = (tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDLOW) << 16) |\n\ttulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDHIGH);\n    for (attr = tulip_mii_phy_attrlist;; attr++) {\n\tif (attr->attr_id == 0)\n\t    return TULIP_MEDIA_UNKNOWN;\n\tif ((id & ~0x0F) == attr->attr_id)\n\t    break;\n    }\n\n    if (attr->attr_modes[PHY_MODE_100TX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100TX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 2;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_100T4].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100T4];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 3;\n    }\n    if (idx == 0 && attr->attr_modes[PHY_MODE_10T].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_10T];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tif ((data & pm->pm_mask) == pm->pm_value)\n\t    idx = 1;\n    } \n    if (idx != 0 && attr->attr_modes[PHY_MODE_FULLDUPLEX].pm_regno) {\n\tconst tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_FULLDUPLEX];\n\tdata = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);\n\tidx += ((data & pm->pm_mask) == pm->pm_value ? 4 : 0);\n    }\n    return table[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "sc->tulip_probe_media"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_TP",
          "args": [
            "sc->tulip_probe_media"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": %s: probing %s\\n\"",
            "TULIP_PRINTF_ARGS",
            "event == TULIP_MEDIAPOLL_TXPROBE_FAILED ? \"txprobe failed\" : \"timeout\"",
            "tulip_mediums[sc->tulip_probe_media]"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_FD",
          "args": [
            "sc->tulip_probe_media"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_BIT",
          "args": [
            "sc->tulip_probe_media"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_BIT",
          "args": [
            "sc->tulip_probe_media"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_TP",
          "args": [
            "sc->tulip_probe_media"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mii_autonegotiate",
          "args": [
            "sc",
            "sc->tulip_phyaddr"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_autonegotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1413-1509",
          "snippet": "static void\ntulip_mii_autonegotiate(\n    tulip_softc_t * const sc,\n    const unsigned phyaddr)\n{\n    switch (sc->tulip_probe_state) {\n        case TULIP_PROBE_MEDIATEST:\n        case TULIP_PROBE_INACTIVE: {\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, PHYCTL_RESET);\n\t    sc->tulip_probe_timeout = 3000;\n\t    sc->tulip_intrmask |= TULIP_STS_ABNRMLINTR|TULIP_STS_NORMALINTR;\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYRESET;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYRESET: {\n\t    u_int32_t status;\n\t    u_int32_t data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n\t    if (data & PHYCTL_RESET) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n\t\tprintf(TULIP_PRINTF_FMT \"(phy%d): error: reset of PHY never completed!\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n\t\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\t\tsc->tulip_probe_state = TULIP_PROBE_FAILED;\n\t\tsc->tulip_if.if_flags &= ~(IFF_UP|IFF_RUNNING);\n\t\treturn;\n\t    }\n\t    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    if ((status & PHYSTS_CAN_AUTONEG) == 0) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation disabled\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    if (tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT) != ((status >> 6) | 0x01))\n\t\ttulip_mii_writereg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT, (status >> 6) | 0x01);\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE);\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n#if defined(TULIP_DEBUG)\n\t    if ((data & PHYCTL_AUTONEG_ENABLE) == 0)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): oops: enable autonegotiation failed: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    else\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation restarted: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    sc->tulip_dbg.dbg_nway_starts++;\n#endif\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYAUTONEG;\n\t    sc->tulip_probe_timeout = 3000;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYAUTONEG: {\n\t    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    u_int32_t data;\n\t    if ((status & PHYSTS_AUTONEG_DONE) == 0) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, status,\n\t\t\t   tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL));\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);\n#if defined(TULIP_DEBUG)\n\t    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation complete: 0x%04x\\n\",\n\t\t       TULIP_PRINTF_ARGS, phyaddr, data);\n#endif\n\t    data = (data << 6) & status;\n\t    if (!tulip_mii_map_abilities(sc, data))\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    return;\n\t}\n\tdefault: {\n#if defined(DIAGNOSTIC)\n\t    printf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t    break;\n\t}\n    }\n#if defined(TULIP_DEBUG)\n    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation failure: state = %d\\n\",\n\t       TULIP_PRINTF_ARGS, phyaddr, sc->tulip_probe_state);\n\t    sc->tulip_dbg.dbg_nway_failures++;\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);",
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_autonegotiate(\n    tulip_softc_t * const sc,\n    const unsigned phyaddr)\n{\n    switch (sc->tulip_probe_state) {\n        case TULIP_PROBE_MEDIATEST:\n        case TULIP_PROBE_INACTIVE: {\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, PHYCTL_RESET);\n\t    sc->tulip_probe_timeout = 3000;\n\t    sc->tulip_intrmask |= TULIP_STS_ABNRMLINTR|TULIP_STS_NORMALINTR;\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYRESET;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYRESET: {\n\t    u_int32_t status;\n\t    u_int32_t data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n\t    if (data & PHYCTL_RESET) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n\t\tprintf(TULIP_PRINTF_FMT \"(phy%d): error: reset of PHY never completed!\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n\t\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\t\tsc->tulip_probe_state = TULIP_PROBE_FAILED;\n\t\tsc->tulip_if.if_flags &= ~(IFF_UP|IFF_RUNNING);\n\t\treturn;\n\t    }\n\t    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    if ((status & PHYSTS_CAN_AUTONEG) == 0) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation disabled\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    if (tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT) != ((status >> 6) | 0x01))\n\t\ttulip_mii_writereg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT, (status >> 6) | 0x01);\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE);\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n#if defined(TULIP_DEBUG)\n\t    if ((data & PHYCTL_AUTONEG_ENABLE) == 0)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): oops: enable autonegotiation failed: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    else\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation restarted: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    sc->tulip_dbg.dbg_nway_starts++;\n#endif\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYAUTONEG;\n\t    sc->tulip_probe_timeout = 3000;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYAUTONEG: {\n\t    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    u_int32_t data;\n\t    if ((status & PHYSTS_AUTONEG_DONE) == 0) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, status,\n\t\t\t   tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL));\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);\n#if defined(TULIP_DEBUG)\n\t    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation complete: 0x%04x\\n\",\n\t\t       TULIP_PRINTF_ARGS, phyaddr, data);\n#endif\n\t    data = (data << 6) & status;\n\t    if (!tulip_mii_map_abilities(sc, data))\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    return;\n\t}\n\tdefault: {\n#if defined(DIAGNOSTIC)\n\t    printf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t    break;\n\t}\n    }\n#if defined(TULIP_DEBUG)\n    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation failure: state = %d\\n\",\n\t       TULIP_PRINTF_ARGS, phyaddr, sc->tulip_probe_state);\n\t    sc->tulip_dbg.dbg_nway_failures++;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_21140_gpr_media_sense",
          "args": [
            "sc"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_21140_gpr_media_sense",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "456-515",
          "snippet": "static tulip_media_t\ntulip_21140_gpr_media_sense(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t maybe_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t last_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t media;\n\n    /*\n     * If one of the media blocks contained a default media flag,\n     * use that.\n     */\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tconst tulip_media_info_t *mi;\n\t/*\n\t * Media is not supported (or is full-duplex).\n\t */\n\tif ((mi = sc->tulip_mediums[media]) == NULL || TULIP_IS_MEDIA_FD(media))\n\t    continue;\n\tif (mi->mi_type != TULIP_MEDIAINFO_GPR)\n\t    continue;\n\n\t/*\n\t * Remember the media is this is the \"default\" media.\n\t */\n\tif (mi->mi_default && maybe_media == TULIP_MEDIA_UNKNOWN)\n\t    maybe_media = media;\n\n\t/*\n\t * No activity mask?  Can't see if it is active if there's no mask.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    continue;\n\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) != mi->mi_actdata)\n\t    continue;\n\n#if defined(TULIP_DEBUG)\n\tprintf(TULIP_PRINTF_FMT \": gpr_media_sense: %s: 0x%02x & 0x%02x == 0x%02x\\n\",\n\t       TULIP_PRINTF_ARGS, tulip_mediums[media],\n\t       TULIP_CSR_READ(sc, csr_gp) & 0xFF,\n\t       mi->mi_actmask, mi->mi_actdata);\n#endif\n\t/*\n\t * It does!  If this is the first media we detected, then \n\t * remember this media.  If isn't the first, then there were\n\t * multiple matches which we equate to no match (since we don't\n\t * which to select (if any).\n\t */\n\tif (last_media == TULIP_MEDIA_UNKNOWN) {\n\t    last_media = media;\n\t} else if (last_media != media) {\n\t    last_media = TULIP_MEDIA_UNKNOWN;\n\t}\n    }\n    return (last_media != TULIP_MEDIA_UNKNOWN) ? last_media : maybe_media;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic tulip_media_t\ntulip_21140_gpr_media_sense(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t maybe_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t last_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t media;\n\n    /*\n     * If one of the media blocks contained a default media flag,\n     * use that.\n     */\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tconst tulip_media_info_t *mi;\n\t/*\n\t * Media is not supported (or is full-duplex).\n\t */\n\tif ((mi = sc->tulip_mediums[media]) == NULL || TULIP_IS_MEDIA_FD(media))\n\t    continue;\n\tif (mi->mi_type != TULIP_MEDIAINFO_GPR)\n\t    continue;\n\n\t/*\n\t * Remember the media is this is the \"default\" media.\n\t */\n\tif (mi->mi_default && maybe_media == TULIP_MEDIA_UNKNOWN)\n\t    maybe_media = media;\n\n\t/*\n\t * No activity mask?  Can't see if it is active if there's no mask.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    continue;\n\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) != mi->mi_actdata)\n\t    continue;\n\n#if defined(TULIP_DEBUG)\n\tprintf(TULIP_PRINTF_FMT \": gpr_media_sense: %s: 0x%02x & 0x%02x == 0x%02x\\n\",\n\t       TULIP_PRINTF_ARGS, tulip_mediums[media],\n\t       TULIP_CSR_READ(sc, csr_gp) & 0xFF,\n\t       mi->mi_actmask, mi->mi_actdata);\n#endif\n\t/*\n\t * It does!  If this is the first media we detected, then \n\t * remember this media.  If isn't the first, then there were\n\t * multiple matches which we equate to no match (since we don't\n\t * which to select (if any).\n\t */\n\tif (last_media == TULIP_MEDIA_UNKNOWN) {\n\t    last_media = media;\n\t} else if (last_media != media) {\n\t    last_media = TULIP_MEDIA_UNKNOWN;\n\t}\n    }\n    return (last_media != TULIP_MEDIA_UNKNOWN) ? last_media : maybe_media;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_DO_AUTOSENSE",
          "args": [
            "sc"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_media_link_monitor",
          "args": [
            "sc"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_link_monitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "518-624",
          "snippet": "static tulip_link_status_t\ntulip_media_link_monitor(\n    tulip_softc_t * const sc)\n{\n    const tulip_media_info_t * const mi = sc->tulip_mediums[sc->tulip_media];\n    tulip_link_status_t linkup = TULIP_LINK_DOWN;\n\n    if (mi == NULL) {\n#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)\n\tprintf(\"tulip_media_link_monitor: %s: botch at line %d\\n\",\n\t      tulip_mediums[sc->tulip_media],__LINE__);\n#endif\n\treturn TULIP_LINK_UNKNOWN;\n    }\n\n\n    /*\n     * Have we seen some packets?  If so, the link must be good.\n     */\n    if ((sc->tulip_flags & (TULIP_RXACT|TULIP_LINKUP)) == (TULIP_RXACT|TULIP_LINKUP)) {\n\tsc->tulip_flags &= ~TULIP_RXACT;\n\tsc->tulip_probe_timeout = 3000;\n\treturn TULIP_LINK_UP;\n    }\n\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_MII) {\n\tu_int32_t status;\n\t/*\n\t * Read the PHY status register.\n\t */\n\tstatus = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n\tif (status & PHYSTS_AUTONEG_DONE) {\n\t    /*\n\t     * If the PHY has completed autonegotiation, see the if the\n\t     * remote systems abilities have changed.  If so, upgrade or\n\t     * downgrade as appropriate.\n\t     */\n\t    u_int32_t abilities = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_AUTONEG_ABILITIES);\n\t    abilities = (abilities << 6) & status;\n\t    if (abilities != sc->tulip_abilities) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, sc->tulip_phyaddr,\n\t\t\t   sc->tulip_abilities, abilities);\n#endif\n\t\tif (tulip_mii_map_abilities(sc, abilities)) {\n\t\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t\t    return TULIP_LINK_UP;\n\t\t}\n\t\t/*\n\t\t * if we had selected media because of autonegotiation,\n\t\t * we need to probe for the new media.\n\t\t */\n\t\tsc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\tif (sc->tulip_flags & TULIP_DIDNWAY)\n\t\t    return TULIP_LINK_DOWN;\n\t    }\n\t}\n\t/*\n\t * The link is now up.  If was down, say its back up.\n\t */\n\tif ((status & (PHYSTS_LINK_UP|PHYSTS_REMOTE_FAULT)) == PHYSTS_LINK_UP)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n\t/*\n\t * No activity sensor?  Assume all's well.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    return TULIP_LINK_UNKNOWN;\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) == mi->mi_actdata)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\t/*\n\t * Assume non TP ok for now.\n\t */\n\tif (!TULIP_IS_MEDIA_TP(sc->tulip_media))\n\t    return TULIP_LINK_UNKNOWN;\n\tif ((TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) == 0)\n\t    linkup = TULIP_LINK_UP;\n#if defined(TULIP_DEBUG)\n\tif (sc->tulip_probe_timeout <= 0)\n\t    printf(TULIP_PRINTF_FMT \": sia status = 0x%08x\\n\", TULIP_PRINTF_ARGS, TULIP_CSR_READ(sc, csr_sia_status));\n#endif\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\treturn TULIP_LINK_UNKNOWN;\n    }\n    /*\n     * We will wait for 3 seconds until the link goes into suspect mode.\n     */\n    if (sc->tulip_flags & TULIP_LINKUP) {\n\tif (linkup == TULIP_LINK_UP)\n\t    sc->tulip_probe_timeout = 3000;\n\tif (sc->tulip_probe_timeout > 0)\n\t    return TULIP_LINK_UP;\n\n\tsc->tulip_flags &= ~TULIP_LINKUP;\n\tprintf(TULIP_PRINTF_FMT \": link down: cable problem?\\n\", TULIP_PRINTF_ARGS);\n    }\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_link_downed++;\n#endif\n    return TULIP_LINK_DOWN;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic tulip_link_status_t\ntulip_media_link_monitor(\n    tulip_softc_t * const sc)\n{\n    const tulip_media_info_t * const mi = sc->tulip_mediums[sc->tulip_media];\n    tulip_link_status_t linkup = TULIP_LINK_DOWN;\n\n    if (mi == NULL) {\n#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)\n\tprintf(\"tulip_media_link_monitor: %s: botch at line %d\\n\",\n\t      tulip_mediums[sc->tulip_media],__LINE__);\n#endif\n\treturn TULIP_LINK_UNKNOWN;\n    }\n\n\n    /*\n     * Have we seen some packets?  If so, the link must be good.\n     */\n    if ((sc->tulip_flags & (TULIP_RXACT|TULIP_LINKUP)) == (TULIP_RXACT|TULIP_LINKUP)) {\n\tsc->tulip_flags &= ~TULIP_RXACT;\n\tsc->tulip_probe_timeout = 3000;\n\treturn TULIP_LINK_UP;\n    }\n\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_MII) {\n\tu_int32_t status;\n\t/*\n\t * Read the PHY status register.\n\t */\n\tstatus = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n\tif (status & PHYSTS_AUTONEG_DONE) {\n\t    /*\n\t     * If the PHY has completed autonegotiation, see the if the\n\t     * remote systems abilities have changed.  If so, upgrade or\n\t     * downgrade as appropriate.\n\t     */\n\t    u_int32_t abilities = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_AUTONEG_ABILITIES);\n\t    abilities = (abilities << 6) & status;\n\t    if (abilities != sc->tulip_abilities) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, sc->tulip_phyaddr,\n\t\t\t   sc->tulip_abilities, abilities);\n#endif\n\t\tif (tulip_mii_map_abilities(sc, abilities)) {\n\t\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t\t    return TULIP_LINK_UP;\n\t\t}\n\t\t/*\n\t\t * if we had selected media because of autonegotiation,\n\t\t * we need to probe for the new media.\n\t\t */\n\t\tsc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\tif (sc->tulip_flags & TULIP_DIDNWAY)\n\t\t    return TULIP_LINK_DOWN;\n\t    }\n\t}\n\t/*\n\t * The link is now up.  If was down, say its back up.\n\t */\n\tif ((status & (PHYSTS_LINK_UP|PHYSTS_REMOTE_FAULT)) == PHYSTS_LINK_UP)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n\t/*\n\t * No activity sensor?  Assume all's well.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    return TULIP_LINK_UNKNOWN;\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) == mi->mi_actdata)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\t/*\n\t * Assume non TP ok for now.\n\t */\n\tif (!TULIP_IS_MEDIA_TP(sc->tulip_media))\n\t    return TULIP_LINK_UNKNOWN;\n\tif ((TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) == 0)\n\t    linkup = TULIP_LINK_UP;\n#if defined(TULIP_DEBUG)\n\tif (sc->tulip_probe_timeout <= 0)\n\t    printf(TULIP_PRINTF_FMT \": sia status = 0x%08x\\n\", TULIP_PRINTF_ARGS, TULIP_CSR_READ(sc, csr_sia_status));\n#endif\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\treturn TULIP_LINK_UNKNOWN;\n    }\n    /*\n     * We will wait for 3 seconds until the link goes into suspect mode.\n     */\n    if (sc->tulip_flags & TULIP_LINKUP) {\n\tif (linkup == TULIP_LINK_UP)\n\t    sc->tulip_probe_timeout = 3000;\n\tif (sc->tulip_probe_timeout > 0)\n\t    return TULIP_LINK_UP;\n\n\tsc->tulip_flags &= ~TULIP_LINKUP;\n\tprintf(TULIP_PRINTF_FMT \": link down: cable problem?\\n\", TULIP_PRINTF_ARGS);\n    }\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_link_downed++;\n#endif\n    return TULIP_LINK_DOWN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_poll(\n    tulip_softc_t * const sc,\n    tulip_mediapoll_event_t event)\n{\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_events[event]++;\n#endif\n    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE\n\t    && event == TULIP_MEDIAPOLL_TIMER) {\n\tswitch (tulip_media_link_monitor(sc)) {\n\t    case TULIP_LINK_DOWN: {\n\t\t/*\n\t\t * Link Monitor failed.  Probe for new media.\n\t\t */\n\t\tevent = TULIP_MEDIAPOLL_LINKFAIL;\n\t\tbreak;\n\t    }\n\t    case TULIP_LINK_UP: {\n\t\t/*\n\t\t * Check again soon.\n\t\t */\n\t\ttulip_timeout(sc);\n\t\treturn;\n\t    }\n\t    case TULIP_LINK_UNKNOWN: {\n\t\t/*\n\t\t * We can't tell so don't bother.\n\t\t */\n\t\treturn;\n\t    }\n\t}\n    }\n\n    if (event == TULIP_MEDIAPOLL_LINKFAIL) {\n\tif (sc->tulip_probe_state == TULIP_PROBE_INACTIVE) {\n\t    if (TULIP_DO_AUTOSENSE(sc)) {\n#if defined(TULIP_DEBUG)\n\t\tsc->tulip_dbg.dbg_link_failures++;\n#endif\n\t\tsc->tulip_media = TULIP_MEDIA_UNKNOWN;\n\t\tif (sc->tulip_if.if_flags & IFF_UP)\n\t\t    tulip_reset(sc);\t/* restart probe */\n\t    }\n\t    return;\n\t}\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_link_pollintrs++;\n#endif\n    }\n\n    if (event == TULIP_MEDIAPOLL_START) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tif (sc->tulip_probe_state != TULIP_PROBE_INACTIVE)\n\t    return;\n\tsc->tulip_probe_mediamask = 0;\n\tsc->tulip_probe_passes = 0;\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_media_probes++;\n#endif\n\t/*\n\t * If the SROM contained an explicit media to use, use it.\n\t */\n\tsc->tulip_cmdmode &= ~(TULIP_CMD_RXRUN|TULIP_CMD_FULLDUPLEX);\n\tsc->tulip_flags |= TULIP_TRYNWAY|TULIP_PROBE1STPASS;\n\tsc->tulip_flags &= ~(TULIP_DIDNWAY|TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n\t/*\n\t * connidx is defaulted to a media_unknown type.\n\t */\n\tsc->tulip_probe_media = tulip_srom_conninfo[sc->tulip_connidx].sc_media;\n\tif (sc->tulip_probe_media != TULIP_MEDIA_UNKNOWN) {\n\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n\n\tif (sc->tulip_features & TULIP_HAVE_GPR) {\n\t    sc->tulip_probe_state = TULIP_PROBE_GPRTEST;\n\t    sc->tulip_probe_timeout = 2000;\n\t} else {\n\t    sc->tulip_probe_media = TULIP_MEDIA_MAX;\n\t    sc->tulip_probe_timeout = 0;\n\t    sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t}\n    }\n\n    /*\n     * Ignore txprobe failures or spurious callbacks.\n     */\n    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED\n\t    && sc->tulip_probe_state != TULIP_PROBE_MEDIATEST) {\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\treturn;\n    }\n\n    /*\n     * If we really transmitted a packet, then that's the media we'll use.\n     */\n    if (event == TULIP_MEDIAPOLL_TXPROBE_OK || event == TULIP_MEDIAPOLL_LINKPASS) {\n\tif (event == TULIP_MEDIAPOLL_LINKPASS) {\n\t    /* XXX check media status just to be sure */\n\t    sc->tulip_probe_media = TULIP_MEDIA_10BASET;\n#if defined(TULIP_DEBUG)\n\t} else {\n\t    sc->tulip_dbg.dbg_txprobes_ok[sc->tulip_probe_media]++;\n#endif\n\t}\n\ttulip_linkup(sc, sc->tulip_probe_media);\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    if (sc->tulip_probe_state == TULIP_PROBE_GPRTEST) {\n#if defined(TULIP_DO_GPR_SENSE)\n\t/*\n\t * Check for media via the general purpose register.\n\t *\n\t * Try to sense the media via the GPR.  If the same value\n\t * occurs 3 times in a row then just use that.\n\t */\n\tif (sc->tulip_probe_timeout > 0) {\n\t    tulip_media_t new_probe_media = tulip_21140_gpr_media_sense(sc);\n#if defined(TULIP_DEBUG)\n\t    printf(TULIP_PRINTF_FMT \": media_poll: gpr sensing = %s\\n\",\n\t\t   TULIP_PRINTF_ARGS, tulip_mediums[new_probe_media]);\n#endif\n\t    if (new_probe_media != TULIP_MEDIA_UNKNOWN) {\n\t\tif (new_probe_media == sc->tulip_probe_media) {\n\t\t    if (--sc->tulip_probe_count == 0)\n\t\t\ttulip_linkup(sc, sc->tulip_probe_media);\n\t\t} else {\n\t\t    sc->tulip_probe_count = 10;\n\t\t}\n\t    }\n\t    sc->tulip_probe_media = new_probe_media;\n\t    tulip_timeout(sc);\n\t    return;\n\t}\n#endif /* TULIP_DO_GPR_SENSE */\n\t/*\n\t * Brute force.  We cycle through each of the media types\n\t * and try to transmit a packet.\n\t */\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\tsc->tulip_probe_media = TULIP_MEDIA_MAX;\n\tsc->tulip_probe_timeout = 0;\n\ttulip_timeout(sc);\n\treturn;\n    }\n\n    if (sc->tulip_probe_state != TULIP_PROBE_MEDIATEST\n\t   && (sc->tulip_features & TULIP_HAVE_MII)) {\n\ttulip_media_t old_media = sc->tulip_probe_media;\n\ttulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\tswitch (sc->tulip_probe_state) {\n\t    case TULIP_PROBE_FAILED:\n\t    case TULIP_PROBE_MEDIATEST: {\n\t\t/*\n\t\t * Try the next media.\n\t\t */\n\t\tsc->tulip_probe_mediamask |= sc->tulip_mediums[sc->tulip_probe_media]->mi_mediamask;\n\t\tsc->tulip_probe_timeout = 0;\n#ifdef notyet\n\t\tif (sc->tulip_probe_state == TULIP_PROBE_FAILED)\n\t\t    break;\n\t\tif (sc->tulip_probe_media != tulip_mii_phy_readspecific(sc))\n\t\t    break;\n\t\tsc->tulip_probe_timeout = TULIP_IS_MEDIA_TP(sc->tulip_probe_media) ? 2500 : 300;\n#endif\n\t\tbreak;\n\t    }\n\t    case TULIP_PROBE_PHYAUTONEG: {\n\t\treturn;\n\t    }\n\t    case TULIP_PROBE_INACTIVE: {\n\t\t/*\n\t\t * Only probe if we autonegotiated a media that hasn't failed.\n\t\t */\n\t\tsc->tulip_probe_timeout = 0;\n\t\tif (sc->tulip_probe_mediamask & TULIP_BIT(sc->tulip_probe_media)) {\n\t\t    sc->tulip_probe_media = old_media;\n\t\t    break;\n\t\t}\n\t\ttulip_linkup(sc, sc->tulip_probe_media);\n\t\ttulip_timeout(sc);\n\t\treturn;\n\t    }\n\t    default: {\n#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)\n\t\tprintf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED) {\n#if defined(TULIP_DEBUG)\n\tsc->tulip_dbg.dbg_txprobes_failed[sc->tulip_probe_media]++;\n#endif\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\treturn;\n    }\n\n    /*\n     * switch to another media if we tried this one enough.\n     */\n    if (/* event == TULIP_MEDIAPOLL_TXPROBE_FAILED || */ sc->tulip_probe_timeout <= 0) {\n#if defined(TULIP_DEBUG)\n\tif (sc->tulip_probe_media == TULIP_MEDIA_UNKNOWN) {\n\t    printf(TULIP_PRINTF_FMT \": poll media unknown!\\n\",\n\t\t   TULIP_PRINTF_ARGS);\n\t    sc->tulip_probe_media = TULIP_MEDIA_MAX;\n\t}\n#endif\n\t/*\n\t * Find the next media type to check for.  Full Duplex\n\t * types are not allowed.\n\t */\n\tdo {\n\t    sc->tulip_probe_media -= 1;\n\t    if (sc->tulip_probe_media == TULIP_MEDIA_UNKNOWN) {\n\t\tif (++sc->tulip_probe_passes == 3) {\n\t\t    printf(TULIP_PRINTF_FMT \": autosense failed: cable problem?\\n\",\n\t\t\t   TULIP_PRINTF_ARGS);\n\t\t    if ((sc->tulip_if.if_flags & IFF_UP) == 0) {\n\t\t\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\t\t\tsc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\t\treturn;\n\t\t    }\n\t\t}\n\t\tsc->tulip_flags ^= TULIP_TRYNWAY;\t/* XXX */\n\t\tsc->tulip_probe_mediamask = 0;\n\t\tsc->tulip_probe_media = TULIP_MEDIA_MAX - 1;\n\t    }\n\t} while (sc->tulip_mediums[sc->tulip_probe_media] == NULL\n\t\t || (sc->tulip_probe_mediamask & TULIP_BIT(sc->tulip_probe_media))\n\t\t || TULIP_IS_MEDIA_FD(sc->tulip_probe_media));\n\n#if defined(TULIP_DEBUG)\n\tprintf(TULIP_PRINTF_FMT \": %s: probing %s\\n\", TULIP_PRINTF_ARGS,\n\t       event == TULIP_MEDIAPOLL_TXPROBE_FAILED ? \"txprobe failed\" : \"timeout\",\n\t       tulip_mediums[sc->tulip_probe_media]);\n#endif\n\tsc->tulip_probe_timeout = TULIP_IS_MEDIA_TP(sc->tulip_probe_media) ? 2500 : 1000;\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\tsc->tulip_probe.probe_txprobes = 0;\n\ttulip_reset(sc);\n\ttulip_media_set(sc, sc->tulip_probe_media);\n\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n    }\n    tulip_timeout(sc);\n\n    /*\n     * If this is hanging off a phy, we know are doing NWAY and we have\n     * forced the phy to a specific speed.  Wait for link up before\n     * before sending a packet.\n     */\n    switch (sc->tulip_mediums[sc->tulip_probe_media]->mi_type) {\n\tcase TULIP_MEDIAINFO_MII: {\n\t    if (sc->tulip_probe_media != tulip_mii_phy_readspecific(sc))\n\t\treturn;\n\t    break;\n\t}\n\tcase TULIP_MEDIAINFO_SIA: {\n\t    if (TULIP_IS_MEDIA_TP(sc->tulip_probe_media)) {\n\t\tif (TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL)\n\t\t    return;\n\t\ttulip_linkup(sc, sc->tulip_probe_media);\n#ifdef notyet\n\t\tif (sc->tulip_features & TULIP_HAVE_MII)\n\t\t    tulip_timeout(sc);\n#endif\n\t\treturn;\n\t    }\n\t    break;\n\t}\n\tcase TULIP_MEDIAINFO_RESET:\n\tcase TULIP_MEDIAINFO_SYM:\n\tcase TULIP_MEDIAINFO_NONE:\n\tcase TULIP_MEDIAINFO_GPR: {\n\t    break;\n\t}\n    }\n    /*\n     * Try to send a packet.\n     */\n    tulip_txprobe(sc);\n}"
  },
  {
    "function_name": "tulip_media_link_monitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "518-624",
    "snippet": "static tulip_link_status_t\ntulip_media_link_monitor(\n    tulip_softc_t * const sc)\n{\n    const tulip_media_info_t * const mi = sc->tulip_mediums[sc->tulip_media];\n    tulip_link_status_t linkup = TULIP_LINK_DOWN;\n\n    if (mi == NULL) {\n#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)\n\tprintf(\"tulip_media_link_monitor: %s: botch at line %d\\n\",\n\t      tulip_mediums[sc->tulip_media],__LINE__);\n#endif\n\treturn TULIP_LINK_UNKNOWN;\n    }\n\n\n    /*\n     * Have we seen some packets?  If so, the link must be good.\n     */\n    if ((sc->tulip_flags & (TULIP_RXACT|TULIP_LINKUP)) == (TULIP_RXACT|TULIP_LINKUP)) {\n\tsc->tulip_flags &= ~TULIP_RXACT;\n\tsc->tulip_probe_timeout = 3000;\n\treturn TULIP_LINK_UP;\n    }\n\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_MII) {\n\tu_int32_t status;\n\t/*\n\t * Read the PHY status register.\n\t */\n\tstatus = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n\tif (status & PHYSTS_AUTONEG_DONE) {\n\t    /*\n\t     * If the PHY has completed autonegotiation, see the if the\n\t     * remote systems abilities have changed.  If so, upgrade or\n\t     * downgrade as appropriate.\n\t     */\n\t    u_int32_t abilities = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_AUTONEG_ABILITIES);\n\t    abilities = (abilities << 6) & status;\n\t    if (abilities != sc->tulip_abilities) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, sc->tulip_phyaddr,\n\t\t\t   sc->tulip_abilities, abilities);\n#endif\n\t\tif (tulip_mii_map_abilities(sc, abilities)) {\n\t\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t\t    return TULIP_LINK_UP;\n\t\t}\n\t\t/*\n\t\t * if we had selected media because of autonegotiation,\n\t\t * we need to probe for the new media.\n\t\t */\n\t\tsc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\tif (sc->tulip_flags & TULIP_DIDNWAY)\n\t\t    return TULIP_LINK_DOWN;\n\t    }\n\t}\n\t/*\n\t * The link is now up.  If was down, say its back up.\n\t */\n\tif ((status & (PHYSTS_LINK_UP|PHYSTS_REMOTE_FAULT)) == PHYSTS_LINK_UP)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n\t/*\n\t * No activity sensor?  Assume all's well.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    return TULIP_LINK_UNKNOWN;\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) == mi->mi_actdata)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\t/*\n\t * Assume non TP ok for now.\n\t */\n\tif (!TULIP_IS_MEDIA_TP(sc->tulip_media))\n\t    return TULIP_LINK_UNKNOWN;\n\tif ((TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) == 0)\n\t    linkup = TULIP_LINK_UP;\n#if defined(TULIP_DEBUG)\n\tif (sc->tulip_probe_timeout <= 0)\n\t    printf(TULIP_PRINTF_FMT \": sia status = 0x%08x\\n\", TULIP_PRINTF_ARGS, TULIP_CSR_READ(sc, csr_sia_status));\n#endif\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\treturn TULIP_LINK_UNKNOWN;\n    }\n    /*\n     * We will wait for 3 seconds until the link goes into suspect mode.\n     */\n    if (sc->tulip_flags & TULIP_LINKUP) {\n\tif (linkup == TULIP_LINK_UP)\n\t    sc->tulip_probe_timeout = 3000;\n\tif (sc->tulip_probe_timeout > 0)\n\t    return TULIP_LINK_UP;\n\n\tsc->tulip_flags &= ~TULIP_LINKUP;\n\tprintf(TULIP_PRINTF_FMT \": link down: cable problem?\\n\", TULIP_PRINTF_ARGS);\n    }\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_link_downed++;\n#endif\n    return TULIP_LINK_DOWN;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": link down: cable problem?\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_sia_status"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_sia_status"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_TP",
          "args": [
            "sc->tulip_media"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_gp"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_linkup",
          "args": [
            "sc",
            "sc->tulip_probe_media"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_linkup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "384-436",
          "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_map_abilities",
          "args": [
            "sc",
            "abilities"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_map_abilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1389-1411",
          "snippet": "static int\ntulip_mii_map_abilities(\n    tulip_softc_t * const sc,\n    unsigned abilities)\n{\n    sc->tulip_abilities = abilities;\n    if (abilities & PHYSTS_100BASETX_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX_FD;\n    } else if (abilities & PHYSTS_100BASET4) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASET4;\n    } else if (abilities & PHYSTS_100BASETX) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX;\n    } else if (abilities & PHYSTS_10BASET_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n    } else if (abilities & PHYSTS_10BASET) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\treturn 0;\n    }\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    return 1;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_mii_map_abilities(\n    tulip_softc_t * const sc,\n    unsigned abilities)\n{\n    sc->tulip_abilities = abilities;\n    if (abilities & PHYSTS_100BASETX_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX_FD;\n    } else if (abilities & PHYSTS_100BASET4) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASET4;\n    } else if (abilities & PHYSTS_100BASETX) {\n\tsc->tulip_probe_media = TULIP_MEDIA_100BASETX;\n    } else if (abilities & PHYSTS_10BASET_FD) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;\n    } else if (abilities & PHYSTS_10BASET) {\n\tsc->tulip_probe_media = TULIP_MEDIA_10BASET;\n    } else {\n\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\treturn 0;\n    }\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "loudprintf",
          "args": [
            "TULIP_PRINTF_FMT \"(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\\n\"",
            "TULIP_PRINTF_ARGS",
            "sc->tulip_phyaddr",
            "sc->tulip_abilities",
            "abilities"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mii_readreg",
          "args": [
            "sc",
            "sc->tulip_phyaddr",
            "PHYREG_AUTONEG_ABILITIES"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2044-2066",
          "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic tulip_link_status_t\ntulip_media_link_monitor(\n    tulip_softc_t * const sc)\n{\n    const tulip_media_info_t * const mi = sc->tulip_mediums[sc->tulip_media];\n    tulip_link_status_t linkup = TULIP_LINK_DOWN;\n\n    if (mi == NULL) {\n#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)\n\tprintf(\"tulip_media_link_monitor: %s: botch at line %d\\n\",\n\t      tulip_mediums[sc->tulip_media],__LINE__);\n#endif\n\treturn TULIP_LINK_UNKNOWN;\n    }\n\n\n    /*\n     * Have we seen some packets?  If so, the link must be good.\n     */\n    if ((sc->tulip_flags & (TULIP_RXACT|TULIP_LINKUP)) == (TULIP_RXACT|TULIP_LINKUP)) {\n\tsc->tulip_flags &= ~TULIP_RXACT;\n\tsc->tulip_probe_timeout = 3000;\n\treturn TULIP_LINK_UP;\n    }\n\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_MII) {\n\tu_int32_t status;\n\t/*\n\t * Read the PHY status register.\n\t */\n\tstatus = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);\n\tif (status & PHYSTS_AUTONEG_DONE) {\n\t    /*\n\t     * If the PHY has completed autonegotiation, see the if the\n\t     * remote systems abilities have changed.  If so, upgrade or\n\t     * downgrade as appropriate.\n\t     */\n\t    u_int32_t abilities = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_AUTONEG_ABILITIES);\n\t    abilities = (abilities << 6) & status;\n\t    if (abilities != sc->tulip_abilities) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, sc->tulip_phyaddr,\n\t\t\t   sc->tulip_abilities, abilities);\n#endif\n\t\tif (tulip_mii_map_abilities(sc, abilities)) {\n\t\t    tulip_linkup(sc, sc->tulip_probe_media);\n\t\t    return TULIP_LINK_UP;\n\t\t}\n\t\t/*\n\t\t * if we had selected media because of autonegotiation,\n\t\t * we need to probe for the new media.\n\t\t */\n\t\tsc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n\t\tif (sc->tulip_flags & TULIP_DIDNWAY)\n\t\t    return TULIP_LINK_DOWN;\n\t    }\n\t}\n\t/*\n\t * The link is now up.  If was down, say its back up.\n\t */\n\tif ((status & (PHYSTS_LINK_UP|PHYSTS_REMOTE_FAULT)) == PHYSTS_LINK_UP)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n\t/*\n\t * No activity sensor?  Assume all's well.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    return TULIP_LINK_UNKNOWN;\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) == mi->mi_actdata)\n\t    linkup = TULIP_LINK_UP;\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\t/*\n\t * Assume non TP ok for now.\n\t */\n\tif (!TULIP_IS_MEDIA_TP(sc->tulip_media))\n\t    return TULIP_LINK_UNKNOWN;\n\tif ((TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) == 0)\n\t    linkup = TULIP_LINK_UP;\n#if defined(TULIP_DEBUG)\n\tif (sc->tulip_probe_timeout <= 0)\n\t    printf(TULIP_PRINTF_FMT \": sia status = 0x%08x\\n\", TULIP_PRINTF_ARGS, TULIP_CSR_READ(sc, csr_sia_status));\n#endif\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\treturn TULIP_LINK_UNKNOWN;\n    }\n    /*\n     * We will wait for 3 seconds until the link goes into suspect mode.\n     */\n    if (sc->tulip_flags & TULIP_LINKUP) {\n\tif (linkup == TULIP_LINK_UP)\n\t    sc->tulip_probe_timeout = 3000;\n\tif (sc->tulip_probe_timeout > 0)\n\t    return TULIP_LINK_UP;\n\n\tsc->tulip_flags &= ~TULIP_LINKUP;\n\tprintf(TULIP_PRINTF_FMT \": link down: cable problem?\\n\", TULIP_PRINTF_ARGS);\n    }\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_link_downed++;\n#endif\n    return TULIP_LINK_DOWN;\n}"
  },
  {
    "function_name": "tulip_21140_gpr_media_sense",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "456-515",
    "snippet": "static tulip_media_t\ntulip_21140_gpr_media_sense(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t maybe_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t last_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t media;\n\n    /*\n     * If one of the media blocks contained a default media flag,\n     * use that.\n     */\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tconst tulip_media_info_t *mi;\n\t/*\n\t * Media is not supported (or is full-duplex).\n\t */\n\tif ((mi = sc->tulip_mediums[media]) == NULL || TULIP_IS_MEDIA_FD(media))\n\t    continue;\n\tif (mi->mi_type != TULIP_MEDIAINFO_GPR)\n\t    continue;\n\n\t/*\n\t * Remember the media is this is the \"default\" media.\n\t */\n\tif (mi->mi_default && maybe_media == TULIP_MEDIA_UNKNOWN)\n\t    maybe_media = media;\n\n\t/*\n\t * No activity mask?  Can't see if it is active if there's no mask.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    continue;\n\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) != mi->mi_actdata)\n\t    continue;\n\n#if defined(TULIP_DEBUG)\n\tprintf(TULIP_PRINTF_FMT \": gpr_media_sense: %s: 0x%02x & 0x%02x == 0x%02x\\n\",\n\t       TULIP_PRINTF_ARGS, tulip_mediums[media],\n\t       TULIP_CSR_READ(sc, csr_gp) & 0xFF,\n\t       mi->mi_actmask, mi->mi_actdata);\n#endif\n\t/*\n\t * It does!  If this is the first media we detected, then \n\t * remember this media.  If isn't the first, then there were\n\t * multiple matches which we equate to no match (since we don't\n\t * which to select (if any).\n\t */\n\tif (last_media == TULIP_MEDIA_UNKNOWN) {\n\t    last_media = media;\n\t} else if (last_media != media) {\n\t    last_media = TULIP_MEDIA_UNKNOWN;\n\t}\n    }\n    return (last_media != TULIP_MEDIA_UNKNOWN) ? last_media : maybe_media;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": gpr_media_sense: %s: 0x%02x & 0x%02x == 0x%02x\\n\"",
            "TULIP_PRINTF_ARGS",
            "tulip_mediums[media]",
            "TULIP_CSR_READ(sc, csr_gp) & 0xFF",
            "mi->mi_actmask",
            "mi->mi_actdata"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_gp"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_gp"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_FD",
          "args": [
            "media"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic tulip_media_t\ntulip_21140_gpr_media_sense(\n    tulip_softc_t * const sc)\n{\n    tulip_media_t maybe_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t last_media = TULIP_MEDIA_UNKNOWN;\n    tulip_media_t media;\n\n    /*\n     * If one of the media blocks contained a default media flag,\n     * use that.\n     */\n    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {\n\tconst tulip_media_info_t *mi;\n\t/*\n\t * Media is not supported (or is full-duplex).\n\t */\n\tif ((mi = sc->tulip_mediums[media]) == NULL || TULIP_IS_MEDIA_FD(media))\n\t    continue;\n\tif (mi->mi_type != TULIP_MEDIAINFO_GPR)\n\t    continue;\n\n\t/*\n\t * Remember the media is this is the \"default\" media.\n\t */\n\tif (mi->mi_default && maybe_media == TULIP_MEDIA_UNKNOWN)\n\t    maybe_media = media;\n\n\t/*\n\t * No activity mask?  Can't see if it is active if there's no mask.\n\t */\n\tif (mi->mi_actmask == 0)\n\t    continue;\n\n\t/*\n\t * Does the activity data match?\n\t */\n\tif ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) != mi->mi_actdata)\n\t    continue;\n\n#if defined(TULIP_DEBUG)\n\tprintf(TULIP_PRINTF_FMT \": gpr_media_sense: %s: 0x%02x & 0x%02x == 0x%02x\\n\",\n\t       TULIP_PRINTF_ARGS, tulip_mediums[media],\n\t       TULIP_CSR_READ(sc, csr_gp) & 0xFF,\n\t       mi->mi_actmask, mi->mi_actdata);\n#endif\n\t/*\n\t * It does!  If this is the first media we detected, then \n\t * remember this media.  If isn't the first, then there were\n\t * multiple matches which we equate to no match (since we don't\n\t * which to select (if any).\n\t */\n\tif (last_media == TULIP_MEDIA_UNKNOWN) {\n\t    last_media = media;\n\t} else if (last_media != media) {\n\t    last_media = TULIP_MEDIA_UNKNOWN;\n\t}\n    }\n    return (last_media != TULIP_MEDIA_UNKNOWN) ? last_media : maybe_media;\n}"
  },
  {
    "function_name": "tulip_media_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "438-453",
    "snippet": "static void\ntulip_media_print(\n    tulip_softc_t * const sc)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\treturn;\n    if (sc->tulip_flags & TULIP_PRINTMEDIA) {\n\tprintf(TULIP_PRINTF_FMT \": enabling %s port\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       tulip_mediums[sc->tulip_media]);\n\tsc->tulip_flags &= ~(TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n    } else if (sc->tulip_flags & TULIP_PRINTLINKUP) {\n\tprintf(TULIP_PRINTF_FMT \": link up\\n\", TULIP_PRINTF_ARGS);\n\tsc->tulip_flags &= ~TULIP_PRINTLINKUP;\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "TULIP_PRINTF_FMT \": link up\\n\"",
            "TULIP_PRINTF_ARGS"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_print(\n    tulip_softc_t * const sc)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\treturn;\n    if (sc->tulip_flags & TULIP_PRINTMEDIA) {\n\tprintf(TULIP_PRINTF_FMT \": enabling %s port\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       tulip_mediums[sc->tulip_media]);\n\tsc->tulip_flags &= ~(TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);\n    } else if (sc->tulip_flags & TULIP_PRINTLINKUP) {\n\tprintf(TULIP_PRINTF_FMT \": link up\\n\", TULIP_PRINTF_ARGS);\n\tsc->tulip_flags &= ~TULIP_PRINTLINKUP;\n    }\n}"
  },
  {
    "function_name": "tulip_linkup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "384-436",
    "snippet": "static void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define TULIP_DEBUG"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_init",
          "args": [
            "sc"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3330-3371",
          "snippet": "static void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_init(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_if.if_flags & IFF_UP) {\n\tif ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {\n\t    /* initialize the media */\n\t    tulip_reset(sc);\n\t}\n\tsc->tulip_if.if_flags |= IFF_RUNNING;\n\tif (sc->tulip_if.if_flags & IFF_PROMISC) {\n\t    sc->tulip_flags |= TULIP_PROMISC;\n\t    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t} else {\n\t    sc->tulip_flags &= ~TULIP_PROMISC;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;\n\t    if (sc->tulip_flags & TULIP_ALLMULTI) {\n\t\tsc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;\n\t    } else {\n\t\tsc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;\n\t    }\n\t}\n\tsc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n\tif ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {\n\t    tulip_rx_intr(sc);\n\t    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;\n\t} else {\n\t    sc->tulip_if.if_flags |= IFF_OACTIVE;\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;\n\t    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;\n\t}\n\tTULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\tTULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n\tif ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)\n\t    tulip_txput_setup(sc);\n    } else {\n\tsc->tulip_if.if_flags &= ~IFF_RUNNING;\n\ttulip_reset(sc);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_media_set",
          "args": [
            "sc",
            "sc->tulip_media"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_media_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "290-382",
          "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
            "#define\tTULIP_SIAGEN_WATCHDOG\t0",
            "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_FD",
          "args": [
            "sc->tulip_media"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_HD_MEDIA_OF",
          "args": [
            "media"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_HD_MEDIA_OF",
          "args": [
            "media"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_FD",
          "args": [
            "media"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_FD_MEDIA_OF",
          "args": [
            "media"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_FD_MEDIA_OF",
          "args": [
            "media"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CAN_MEDIA_FD",
          "args": [
            "media"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_linkup(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    if ((sc->tulip_flags & TULIP_LINKUP) == 0)\n\tsc->tulip_flags |= TULIP_PRINTLINKUP;\n    sc->tulip_flags |= TULIP_LINKUP;\n    sc->tulip_if.if_flags &= ~IFF_OACTIVE;\n#if 0 /* XXX how does with work with ifmedia? */\n    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\tif (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {\n\t    if (TULIP_CAN_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_FD_MEDIA_OF(media);\n\t} else {\n\t    if (TULIP_IS_MEDIA_FD(media)\n\t\t    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)\n\t\tmedia = TULIP_HD_MEDIA_OF(media);\n\t}\n    }\n#endif\n    if (sc->tulip_media != media) {\n#ifdef TULIP_DEBUG\n\tsc->tulip_dbg.dbg_last_media = sc->tulip_media;\n#endif\n\tsc->tulip_media = media;\n\tsc->tulip_flags |= TULIP_PRINTMEDIA;\n\tif (TULIP_IS_MEDIA_FD(sc->tulip_media)) {\n\t    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;\n\t} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;\n\t}\n    }\n    /*\n     * We could set probe_timeout to 0 but setting to 3000 puts this\n     * in one central place and the only matters is tulip_link is\n     * followed by a tulip_timeout.  Therefore setting it should not\n     * result in aberrant behavour.\n     */\n    sc->tulip_probe_timeout = 3000;\n    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;\n    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);\n    if (sc->tulip_flags & TULIP_INRESET) {\n\ttulip_media_set(sc, sc->tulip_media);\n    } else if (sc->tulip_probe_media != sc->tulip_media) {\n\t/*\n\t * No reason to change media if we have the right media.\n\t */\n\ttulip_reset(sc);\n    }\n    tulip_init(sc);\n}"
  },
  {
    "function_name": "tulip_media_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "290-382",
    "snippet": "static void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)",
      "#define\tTULIP_SIAGEN_WATCHDOG\t0",
      "#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tulip_mii_writereg",
          "args": [
            "sc",
            "sc->tulip_phyaddr",
            "PHYREG_CONTROL",
            "data"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_writereg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2068-2089",
          "snippet": "static void\ntulip_mii_writereg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno,\n    unsigned data)\n{\n    unsigned csr;\n\n    csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_WRCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_WRCMD);\n    tulip_mii_writebits(sc, data, 16);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][2] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][3]++;\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_writereg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno,\n    unsigned data)\n{\n    unsigned csr;\n\n    csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_WRCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_WRCMD);\n    tulip_mii_writebits(sc, data, 16);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][2] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][3]++;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_100MB",
          "args": [
            "media"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_IS_MEDIA_FD",
          "args": [
            "media"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_mii_readreg",
          "args": [
            "sc",
            "sc->tulip_phyaddr",
            "PHYREG_CONTROL"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_readreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "2044-2066",
          "snippet": "static unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)",
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic unsigned\ntulip_mii_readreg(\n    tulip_softc_t * const sc,\n    unsigned devaddr,\n    unsigned regno)\n{\n    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);\n    unsigned data;\n\n    csr &= ~(MII_RD|MII_CLK); MII_EMIT;\n    tulip_mii_writebits(sc, MII_PREAMBLE, 32);\n    tulip_mii_writebits(sc, MII_RDCMD, 8);\n    tulip_mii_writebits(sc, devaddr, 5);\n    tulip_mii_writebits(sc, regno, 5);\n    tulip_mii_turnaround(sc, MII_RDCMD);\n\n    data = tulip_mii_readbits(sc);\n#if defined(TULIP_DEBUG)\n    sc->tulip_dbg.dbg_phyregs[regno][0] = data;\n    sc->tulip_dbg.dbg_phyregs[regno][1]++;\n#endif\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tulip_mii_autonegotiate",
          "args": [
            "sc",
            "sc->tulip_phyaddr"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_mii_autonegotiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "1413-1509",
          "snippet": "static void\ntulip_mii_autonegotiate(\n    tulip_softc_t * const sc,\n    const unsigned phyaddr)\n{\n    switch (sc->tulip_probe_state) {\n        case TULIP_PROBE_MEDIATEST:\n        case TULIP_PROBE_INACTIVE: {\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, PHYCTL_RESET);\n\t    sc->tulip_probe_timeout = 3000;\n\t    sc->tulip_intrmask |= TULIP_STS_ABNRMLINTR|TULIP_STS_NORMALINTR;\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYRESET;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYRESET: {\n\t    u_int32_t status;\n\t    u_int32_t data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n\t    if (data & PHYCTL_RESET) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n\t\tprintf(TULIP_PRINTF_FMT \"(phy%d): error: reset of PHY never completed!\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n\t\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\t\tsc->tulip_probe_state = TULIP_PROBE_FAILED;\n\t\tsc->tulip_if.if_flags &= ~(IFF_UP|IFF_RUNNING);\n\t\treturn;\n\t    }\n\t    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    if ((status & PHYSTS_CAN_AUTONEG) == 0) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation disabled\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    if (tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT) != ((status >> 6) | 0x01))\n\t\ttulip_mii_writereg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT, (status >> 6) | 0x01);\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE);\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n#if defined(TULIP_DEBUG)\n\t    if ((data & PHYCTL_AUTONEG_ENABLE) == 0)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): oops: enable autonegotiation failed: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    else\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation restarted: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    sc->tulip_dbg.dbg_nway_starts++;\n#endif\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYAUTONEG;\n\t    sc->tulip_probe_timeout = 3000;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYAUTONEG: {\n\t    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    u_int32_t data;\n\t    if ((status & PHYSTS_AUTONEG_DONE) == 0) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, status,\n\t\t\t   tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL));\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);\n#if defined(TULIP_DEBUG)\n\t    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation complete: 0x%04x\\n\",\n\t\t       TULIP_PRINTF_ARGS, phyaddr, data);\n#endif\n\t    data = (data << 6) & status;\n\t    if (!tulip_mii_map_abilities(sc, data))\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    return;\n\t}\n\tdefault: {\n#if defined(DIAGNOSTIC)\n\t    printf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t    break;\n\t}\n    }\n#if defined(TULIP_DEBUG)\n    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation failure: state = %d\\n\",\n\t       TULIP_PRINTF_ARGS, phyaddr, sc->tulip_probe_state);\n\t    sc->tulip_dbg.dbg_nway_failures++;\n#endif\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);",
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_mii_autonegotiate(\n    tulip_softc_t * const sc,\n    const unsigned phyaddr)\n{\n    switch (sc->tulip_probe_state) {\n        case TULIP_PROBE_MEDIATEST:\n        case TULIP_PROBE_INACTIVE: {\n\t    sc->tulip_flags |= TULIP_DIDNWAY;\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, PHYCTL_RESET);\n\t    sc->tulip_probe_timeout = 3000;\n\t    sc->tulip_intrmask |= TULIP_STS_ABNRMLINTR|TULIP_STS_NORMALINTR;\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYRESET;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYRESET: {\n\t    u_int32_t status;\n\t    u_int32_t data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n\t    if (data & PHYCTL_RESET) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n\t\tprintf(TULIP_PRINTF_FMT \"(phy%d): error: reset of PHY never completed!\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n\t\tsc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;\n\t\tsc->tulip_probe_state = TULIP_PROBE_FAILED;\n\t\tsc->tulip_if.if_flags &= ~(IFF_UP|IFF_RUNNING);\n\t\treturn;\n\t    }\n\t    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    if ((status & PHYSTS_CAN_AUTONEG) == 0) {\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation disabled\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr);\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    if (tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT) != ((status >> 6) | 0x01))\n\t\ttulip_mii_writereg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT, (status >> 6) | 0x01);\n\t    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE);\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);\n#if defined(TULIP_DEBUG)\n\t    if ((data & PHYCTL_AUTONEG_ENABLE) == 0)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): oops: enable autonegotiation failed: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    else\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation restarted: 0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, data);\n\t    sc->tulip_dbg.dbg_nway_starts++;\n#endif\n\t    sc->tulip_probe_state = TULIP_PROBE_PHYAUTONEG;\n\t    sc->tulip_probe_timeout = 3000;\n\t    /* FALL THROUGH */\n\t}\n        case TULIP_PROBE_PHYAUTONEG: {\n\t    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);\n\t    u_int32_t data;\n\t    if ((status & PHYSTS_AUTONEG_DONE) == 0) {\n\t\tif (sc->tulip_probe_timeout > 0) {\n\t\t    tulip_timeout(sc);\n\t\t    return;\n\t\t}\n#if defined(TULIP_DEBUG)\n\t\tloudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\\n\",\n\t\t\t   TULIP_PRINTF_ARGS, phyaddr, status,\n\t\t\t   tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL));\n#endif\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t\tsc->tulip_probe_state = TULIP_PROBE_MEDIATEST;\n\t\treturn;\n\t    }\n\t    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);\n#if defined(TULIP_DEBUG)\n\t    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation complete: 0x%04x\\n\",\n\t\t       TULIP_PRINTF_ARGS, phyaddr, data);\n#endif\n\t    data = (data << 6) & status;\n\t    if (!tulip_mii_map_abilities(sc, data))\n\t\tsc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    return;\n\t}\n\tdefault: {\n#if defined(DIAGNOSTIC)\n\t    printf(\"tulip_media_poll: botch at line %d\\n\", __LINE__);\n#endif\n\t    break;\n\t}\n    }\n#if defined(TULIP_DEBUG)\n    loudprintf(TULIP_PRINTF_FMT \"(phy%d): autonegotiation failure: state = %d\\n\",\n\t       TULIP_PRINTF_ARGS, phyaddr, sc->tulip_probe_state);\n\t    sc->tulip_dbg.dbg_nway_failures++;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "sc->tulip_rombuf[mi->mi_gpr_offset + idx]"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "sc->tulip_rombuf[mi->mi_reset_offset + idx]"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "(dp[0] + 256 * dp[1]) << 16"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "(dp[0] + 256 * dp[1]) << 16"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "mi->mi_gpdata"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "mi->mi_gpcontrol"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_reset",
          "args": [
            "sc"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "3199-3328",
          "snippet": "static void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\n\nstatic void\ntulip_reset(\n    tulip_softc_t * const sc)\n{\n    tulip_ringinfo_t *ri;\n    tulip_desc_t *di;\n    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);\n\n#if defined(TULIP_DEBUG)\n    printf (\"de0: resetting...\\n\");\n#endif\n\n    /*\n     * Brilliant.  Simply brilliant.  When switching modes/speeds\n     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS\n     * bits in CSR6 and then do a software reset to get the 21140\n     * to properly reset its internal pathways to the right places.\n     *   Grrrr.\n     */\n    if (sc->tulip_boardsw->bd_media_preset != NULL)\n\t(*sc->tulip_boardsw->bd_media_preset)(sc);\n\n    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);\n    DELAY(10);\t/* Wait 10 microseconds (actually 50 PCI cycles but at \n\t\t   33MHz that comes to two microseconds but wait a\n\t\t   bit longer anyways) */\n\n    if (!inreset) {\n\tsc->tulip_flags |= TULIP_INRESET;\n\tsc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);\n\tsc->tulip_if.if_flags &= ~IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));\n    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));\n#ifdef powerpc\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (4 << 2)\t/* Descriptor skip length */\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    /*\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)\n\t\t    */\n\t\t    );\n#else\n    TULIP_CSR_WRITE(sc, csr_busmode,\n\t\t    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))\n\t\t    |TULIP_BUSMODE_CACHE_ALIGN8\n\t\t    |TULIP_BUSMODE_READMULTIPLE\n\t\t    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));\n#endif\n\n    sc->tulip_txtimer = 0;\n    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;\n    /*\n     * Free all the mbufs that were on the transmit ring.\n     */\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_txq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    ri = &sc->tulip_txinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++)\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\n    /*\n     * We need to collect all the mbufs were on the \n     * receive ring before we reinit it either to put\n     * them back on or to know if we have to allocate\n     * more.\n     */\n    ri = &sc->tulip_rxinfo;\n    ri->ri_nextin = ri->ri_nextout = ri->ri_first;\n    ri->ri_free = ri->ri_max;\n    for (di = ri->ri_first; di < ri->ri_last; di++) {\n\tdi->d_status = 0; /* no swabbing necessary -dsr */\n\t{ \n\t    tulip_desc_bitfield_t u;\n\n\t    u.f = DESC_BO(di->u.f); /* copy the bitfields */\n\t    u.bd_length1 = 0;\n\t    u.bd_length2 = 0;\n\t    di->u.f = DESC_BO(u.f);\n\t}\n\tdi->d_addr1 = 0; /* no swabbing necessary -dsr */\n\tdi->d_addr2 = 0; /* no swabbing necessary -dsr */\n    }\n    for (;;) {\n\tstruct mbuf *m;\n\tIF_DEQUEUE(&sc->tulip_rxq, m);\n\tif (m == NULL)\n\t    break;\n\tm_freem(m);\n    }\n\n    /*\n     * If tulip_reset is being called recurisvely, exit quickly knowing\n     * that when the outer tulip_reset returns all the right stuff will\n     * have happened.\n     */\n    if (inreset)\n\treturn;\n\n    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR\n\t|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED\n\t|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE\n\t|TULIP_STS_RXSTOPPED;\n\n    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)\n\t(*sc->tulip_boardsw->bd_media_select)(sc);\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)\n\tprintf(TULIP_PRINTF_FMT \": tulip_reset: additional reset needed?!?\\n\",\n\t       TULIP_PRINTF_ARGS);\n#endif\n    tulip_media_print(sc);\n    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)\n\tTULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));\n\n    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET\n\t\t\t |TULIP_RXACT);\n    tulip_addr_filter(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "(u_int8_t) mi->mi_gpdata"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "10"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_gp",
            "TULIP_GP_PINSET|sc->tulip_gpinit"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_READ",
          "args": [
            "sc",
            "csr_command"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_connectivity",
            "mi->mi_sia_connectivity"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DELAY",
          "args": [
            "50"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_general",
            "mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_tx_rx",
            "mi->mi_sia_tx_rx"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_sia_connectivity",
            "TULIP_SIACONN_RESET"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n#define\tTULIP_SIAGEN_WATCHDOG\t0\n#define TULIP_SIAGEN_WATCHDOG\t(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_media_set(\n    tulip_softc_t * const sc,\n    tulip_media_t media)\n{\n    const tulip_media_info_t *mi = sc->tulip_mediums[media];\n\n    if (mi == NULL)\n\treturn;\n\n    /*\n     * If we are switching media, make sure we don't think there's\n     * any stale RX activity\n     */\n    sc->tulip_flags &= ~TULIP_RXACT;\n    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);\n\tTULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t    DELAY(50);\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t} else {\n\t    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {\n#define\tTULIP_GPR_CMDBITS\t(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);\n\tDELAY(10);\n\tTULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {\n\t/*\n\t * If the cmdmode bits don't match the currently operating mode,\n\t * set the cmdmode appropriately and reset the chip.\n\t */\n\tif (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {\n\t    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;\n\t    sc->tulip_cmdmode |= mi->mi_cmdmode;\n\t    tulip_reset(sc);\n\t}\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);\n\tTULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);\n    } else if (mi->mi_type == TULIP_MEDIAINFO_MII\n\t       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {\n\tint idx;\n\tif (sc->tulip_features & TULIP_HAVE_SIAGP) {\n\t    const u_int8_t *dp;\n\t    dp = &sc->tulip_rombuf[mi->mi_reset_offset];\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);\n\t    }\n\t} else {\n\t    for (idx = 0; idx < mi->mi_reset_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);\n\t    }\n\t    sc->tulip_phyaddr = mi->mi_phyaddr;\n\t    for (idx = 0; idx < mi->mi_gpr_length; idx++) {\n\t\tDELAY(10);\n\t\tTULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);\n\t    }\n\t}\n\tif (sc->tulip_flags & TULIP_TRYNWAY) {\n\t    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);\n\t} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {\n\t    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);\n\t    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);\n\t    sc->tulip_flags &= ~TULIP_DIDNWAY;\n\t    if (TULIP_IS_MEDIA_FD(media))\n\t\tdata |= PHYCTL_FULL_DUPLEX;\n\t    if (TULIP_IS_MEDIA_100MB(media))\n\t\tdata |= PHYCTL_SELECT_100MB;\n\t    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);\n\t}\n    }\n}"
  },
  {
    "function_name": "tulip_txprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "245-282",
    "snippet": "static int\ntulip_txprobe(\n    tulip_softc_t * const sc)\n{\n    struct mbuf *m;\n    /*\n     * Before we are sure this is the right media we need\n     * to send a small packet to make sure there's carrier.\n     * Strangely, BNC and AUI will \"see\" receive data if\n     * either is connected so the transmit is the only way\n     * to verify the connectivity.\n     */\n    MGETHDR(m, M_DONTWAIT, MT_DATA);\n    if (m == NULL)\n\treturn 0;\n    /*\n     * Construct a LLC TEST message which will point to ourselves.\n     */\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost, 6);\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost, 6);\n    mtod(m, struct ether_header *)->ether_type = htons(3);\n    mtod(m, unsigned char *)[14] = 0;\n    mtod(m, unsigned char *)[15] = 0;\n    mtod(m, unsigned char *)[16] = 0xE3;\t/* LLC Class1 TEST (no poll) */\n    m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n    /*\n     * send it!\n     */\n    sc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n    sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    if ((m = tulip_txput(sc, m)) != NULL)\n\tm_freem(m);\n    sc->tulip_probe.probe_txprobes++;\n    return 1;\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "m_freem",
          "args": [
            "m"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tulip_txput",
          "args": [
            "sc",
            "m"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "tulip_txput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
          "lines": "4097-4324",
          "snippet": "static struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}",
          "includes": [
            "#include DEVAR_INCLUDE",
            "#include <dev/ic/dc21040reg.h>",
            "#include <dev/pci/pcidevs.h>",
            "#include <dev/pci/pcivar.h>",
            "#include <dev/pci/pcireg.h>",
            "#include <machine/intr.h>",
            "#include <machine/bus.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/if_inarp.h>",
            "#include <net/if_ether.h>",
            "#include <i386/eisa/eisa.h>",
            "#include <eisa.h>",
            "#include <i386/pci/pci.h>",
            "#include <i386/isa/isavar.h>",
            "#include <i386/isa/dma.h>",
            "#include <i386/isa/icu.h>",
            "#include <i386/isa/isa.h>",
            "#include <i386/pci/ic/dc21040reg.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci/dc21040reg.h>",
            "#include <pci/pcivar.h>",
            "#include <netinet/if_ether.h>",
            "#include <pci.h>",
            "#include <vm/pmap.h>",
            "#include <vm/vm_kern.h>",
            "#include <vm/vm_param.h>",
            "#include <vm/vm.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include \"bpfilter.h\"",
            "#include <dev/mii/miivar.h>",
            "#include <dev/mii/mii.h>",
            "#include <net/netisr.h>",
            "#include <net/route.h>",
            "#include <net/if_dl.h>",
            "#include <net/if_types.h>",
            "#include <net/if_media.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <machine/clock.h>",
            "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
            "#include <sys/kernel.h>",
            "#include <sys/malloc.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/socket.h>",
            "#include <sys/protosw.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>"
          ],
          "macros_used": [
            "#define TULIP_DEBUG"
          ],
          "globals_used": [
            "static void tulip_init(tulip_softc_t * const sc);",
            "static void tulip_reset(tulip_softc_t * const sc);",
            "static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);",
            "static void tulip_txput_setup(tulip_softc_t * const sc);",
            "static void tulip_rx_intr(tulip_softc_t * const sc);",
            "static void tulip_addr_filter(tulip_softc_t * const sc);",
            "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
            "static int tulip_srom_decode(tulip_softc_t * const sc);",
            "tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;",
            "tulip_desc_t *eop = ri->ri_nextin;",
            "struct mbuf *m0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define TULIP_DEBUG\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\ntulip_ringinfo_t * const ri = &sc->tulip_rxinfo;\ntulip_desc_t *eop = ri->ri_nextin;\nstruct mbuf *m0;\n\nstatic struct mbuf *\ntulip_txput(\n    tulip_softc_t * const sc,\n    struct mbuf *m)\n{\n    TULIP_PERFSTART(txput)\n    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;\n    tulip_desc_t *eop, *nextout;\n    int segcnt, free;\n    u_int32_t d_status;\n    struct mbuf *m0;\n\n#if defined(TULIP_DEBUG)\n    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {\n\tprintf(TULIP_PRINTF_FMT \": txput%s: tx not running\\n\",\n\t       TULIP_PRINTF_ARGS,\n\t       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? \"(probe)\" : \"\");\n\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\tgoto finish;\n    }\n#endif\n\n    /*\n     * Now we try to fill in our transmit descriptors.  This is\n     * a bit reminiscent of going on the Ark two by two\n     * since each descriptor for the TULIP can describe\n     * two buffers.  So we advance through packet filling\n     * each of the two entries at a time to to fill each\n     * descriptor.  Clear the first and last segment bits\n     * in each descriptor (actually just clear everything\n     * but the end-of-ring or chain bits) to make sure\n     * we don't get messed up by previously sent packets.\n     *\n     * We may fail to put the entire packet on the ring if\n     * there is either not enough ring entries free or if the\n     * packet has more than MAX_TXSEG segments.  In the former\n     * case we will just wait for the ring to empty.  In the\n     * latter case we have to recopy.\n     */\n again:\n    d_status = 0;\n    eop = nextout = ri->ri_nextout;\n    m0 = m;\n    segcnt = 0;\n    free = ri->ri_free;\n    do {\n\tint len = m0->m_len;\n\tcaddr_t addr = mtod(m0, caddr_t);\n\tunsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));\n\n\twhile (len > 0) {\n\t    unsigned slen = min(len, clsize);\n#ifdef BIG_PACKET\n\t    int partial = 0;\n\t    if (slen >= 2048)\n\t\tslen = 2040, partial = 1;\n#endif\n\t    segcnt++;\n\t    if (segcnt > TULIP_MAX_TXSEG) {\n\t\t/*\n\t\t * The packet exceeds the number of transmit buffer\n\t\t * entries that we can use for one packet, so we have\n\t\t * recopy it into one mbuf and then try again.\n\t\t */\n\t\tm = tulip_mbuf_compress(m);\n\t\tif (m == NULL)\n\t\t    goto finish;\n\t\tgoto again;\n\t    }\n\t    if (segcnt & 1) {\n\t\tif (--free == 0) {\n\t\t    /*\n\t\t     * See if there's any unclaimed space in the\n\t\t     * transmit ring.\n\t\t     */\n\t\t    if ((free += tulip_tx_intr(sc)) == 0) {\n\t\t\t/*\n\t\t\t * There's no more room but since nothing\n\t\t\t * has been committed at this point, just\n\t\t\t * show output is active, put back the\n\t\t\t * mbuf and return.\n\t\t\t */\n\t\t\tsc->tulip_flags |= TULIP_WANTTXSTART;\n\t\t\tgoto finish;\n\t\t    }\n\t\t}\n\t\teop = nextout;\n\t\tif (++nextout == ri->ri_last)\n\t\t    nextout = ri->ri_first;\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;\n\t\t    u.bd_length1 = slen;\n\n\t\t    eop->d_status = DESC_BO(d_status);\n\t\t    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    } else {\n\t\t/*\n\t\t *  Fill in second half of descriptor\n\t\t */\n\t\teop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));\n\t\t{\n\t\t    tulip_desc_bitfield_t u;\n\t\t    u.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\t\t    u.bd_length2 = slen;\n\t\t    eop->u.f = DESC_BO(u.f); /* copy the bitfields */\n\t\t}\n\t    }\n#if defined(__mips__)\n\t    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);\n#endif\n\t    d_status = TULIP_DSTS_OWNER;\n\t    len -= slen;\n\t    addr += slen;\n#ifdef BIG_PACKET\n\t    if (partial)\n\t\tcontinue;\n#endif\n\t    clsize = CLBYTES;\n\t}\n    } while ((m0 = m0->m_next) != NULL);\n\n\n    /*\n     * The descriptors have been filled in.  Now get ready\n     * to transmit.\n     */\n    IF_ENQUEUE(&sc->tulip_txq, m);\n    m = NULL;\n\n    /*\n     * Make sure the next descriptor after this packet is owned\n     * by us since it may have been set up above if we ran out\n     * of room in the ring.\n     */\n    nextout->d_status = 0; /* doesn't need swab - dsr */\n\n    /*\n     * If we only used the first segment of the last descriptor,\n     * make sure the second segment will not be used.\n     */\n    if (segcnt & 1) {\n\ttulip_desc_bitfield_t u;\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_length2 = 0;\n\teop->d_addr2 = 0; /* no swab necessary - dsr */\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Mark the last and first segments, indicate we want a transmit\n     * complete interrupt, and tell it to transmit!\n     */\n    { \n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(eop->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;\n\teop->u.f = DESC_BO(u.f);\n    }\n\n    /*\n     * Note that ri->ri_nextout is still the start of the packet\n     * and until we set the OWNER bit, we can still back out of\n     * everything we have done.\n     */\n    {\n\ttulip_desc_bitfield_t u;\n\n\tu.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */\n\tu.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;\n\tri->ri_nextout->u.f = DESC_BO(u.f);\n\tri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);\n    }\n\n    TULIP_CSR_WRITE(sc, csr_txpoll, 1);\n\n    /*\n     * This advances the ring for us.\n     */\n    ri->ri_nextout = nextout;\n    ri->ri_free = free;\n\n    TULIP_PERFEND(txput);\n\n    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tTULIP_PERFEND(txput);\n\treturn NULL;\n    }\n\n    /*\n     * switch back to the single queueing ifstart.\n     */\n    sc->tulip_flags &= ~TULIP_WANTTXSTART;\n    if (sc->tulip_txtimer == 0)\n\tsc->tulip_txtimer = TULIP_TXTIMER;\n\n    /*\n     * If we want a txstart, there must be not enough space in the\n     * transmit ring.  So we want to enable transmit done interrupts\n     * so we can immediately reclaim some space.  When the transmit\n     * interrupt is posted, the interrupt handler will call tx_intr\n     * to reclaim space and then txstart (since WANTTXSTART is set).\n     * txstart will move the packet into the transmit ring and clear\n     * WANTTXSTART thereby causing TXINTR to be cleared.\n     */\n finish:\n    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {\n\tsc->tulip_if.if_flags |= IFF_OACTIVE;\n\tsc->tulip_if.if_start = tulip_ifstart;\n\tif ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {\n\t    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {\n\tif (sc->tulip_intrmask & TULIP_STS_TXINTR) {\n\t    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;\n\t    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n\t}\n    }\n    TULIP_PERFEND(txput);\n    return m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_intr",
            "sc->tulip_intrmask"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_CSR_WRITE",
          "args": [
            "sc",
            "csr_command",
            "sc->tulip_cmdmode"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "unsignedchar *"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "unsignedchar *"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "unsignedchar *"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "3"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bcopy",
          "args": [
            "sc->tulip_enaddr",
            "mtod(m, struct ether_header *)->ether_shost",
            "6"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "tr_bcopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/ic/tropic.c",
          "lines": "1618-1663",
          "snippet": "void \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}",
          "includes": [
            "#include <dev/ic/tropicvar.h>",
            "#include <dev/ic/tropicreg.h>",
            "#include <machine/bus.h>",
            "#include <machine/cpu.h>",
            "#include <net/bpfdesc.h>",
            "#include <net/bpf.h>",
            "#include <netns/ns_if.h>",
            "#include <netns/ns.h>",
            "#include <net/if_token.h>",
            "#include <netinet/in_var.h>",
            "#include <netinet/ip.h>",
            "#include <netinet/if_ether.h>",
            "#include <netinet/in_systm.h>",
            "#include <netinet/in.h>",
            "#include <net/route.h>",
            "#include <net/netisr.h>",
            "#include <net/if_media.h>",
            "#include <net/if_llc.h>",
            "#include <net/if.h>",
            "#include <sys/device.h>",
            "#include <sys/errno.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/syslog.h>",
            "#include <sys/socket.h>",
            "#include <sys/buf.h>",
            "#include <sys/mbuf.h>",
            "#include <sys/proc.h>",
            "#include <sys/kernel.h>",
            "#include <sys/systm.h>",
            "#include <sys/param.h>",
            "#include \"bpfilter.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void\ttr_bcopy",
            "struct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <dev/ic/tropicvar.h>\n#include <dev/ic/tropicreg.h>\n#include <machine/bus.h>\n#include <machine/cpu.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <net/if_token.h>\n#include <netinet/in_var.h>\n#include <netinet/ip.h>\n#include <netinet/if_ether.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/route.h>\n#include <net/netisr.h>\n#include <net/if_media.h>\n#include <net/if_llc.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/syslog.h>\n#include <sys/socket.h>\n#include <sys/buf.h>\n#include <sys/mbuf.h>\n#include <sys/proc.h>\n#include <sys/kernel.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n#include \"bpfilter.h\"\n\nvoid\ttr_bcopy;\nstruct mbuf *\ntr_get(sc, totlen, ifp)\nstruct tr_softc *sc;\n\nvoid \ntr_bcopy(sc, dest, len)\nstruct tr_softc *sc;\t/* pointer to softc struct for this adapter */\nu_char *dest;\t\t/* destination address */\nint len;\t\t/* number of bytes to copy */\n{\n\tstruct rbcb *rbc = &sc->rbc;\t/* pointer to rec buf ctl blk */\n\n\t/* While amount of data needed >= amount in current receive buffer. */\n\twhile (len >= rbc->data_len) {\n\t\t/* Copy all data from receive buffer to destination. */\n\n\t\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t\t    rbc->rbuf_datap, dest, (bus_size_t)rbc->data_len);\n\t\tlen -= rbc->data_len;\t/* update length left to transfer */\n\t\tdest += rbc->data_len;\t/* update destination address */\n\n\t\t/* Make next receive buffer current receive buffer. */\n\t\trbc->rbufp = rbc->rbufp_next;\n\t\tif (rbc->rbufp != 0) { /* More receive buffers? */\n\n\t\t\t/* Calculate pointer to next receive buffer. */\n\t\t\trbc->rbufp_next = RB_INW(sc, rbc->rbufp, RB_NEXTBUF);\n\t\t\tif (rbc->rbufp_next != 0)\n\t\t\t\trbc->rbufp_next -= RB_NEXTBUF;\n\n\t\t\t/* Get pointer to data in current receive buffer. */\n\t\t\trbc->rbuf_datap = rbc->rbufp + RB_DATA;\n\n\t\t\t/* Get length of data in current receive buffer. */\n\t\t\trbc->data_len = RB_INW(sc, rbc->rbufp, RB_BUFLEN);\n\t\t}\n\t\telse {\n\t\t\tif (len != 0)\t/* len should equal zero. */\n\t\t\t\tprintf(\"tr_bcopy: residual data not copied\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Amount of data needed is < amount in current receive buffer. */\n\n\tbus_space_read_region_1(sc->sc_memt, sc->sc_sramh,\n\t    rbc->rbuf_datap, dest, (bus_size_t)len);\n\trbc->data_len -= len;\t/* Update count of data in receive buffer. */\n\trbc->rbuf_datap += len;\t/* Update pointer to receive buffer data. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtod",
          "args": [
            "m",
            "structether_header*"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MGETHDR",
          "args": [
            "m",
            "M_DONTWAIT",
            "MT_DATA"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic int\ntulip_txprobe(\n    tulip_softc_t * const sc)\n{\n    struct mbuf *m;\n    /*\n     * Before we are sure this is the right media we need\n     * to send a small packet to make sure there's carrier.\n     * Strangely, BNC and AUI will \"see\" receive data if\n     * either is connected so the transmit is the only way\n     * to verify the connectivity.\n     */\n    MGETHDR(m, M_DONTWAIT, MT_DATA);\n    if (m == NULL)\n\treturn 0;\n    /*\n     * Construct a LLC TEST message which will point to ourselves.\n     */\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost, 6);\n    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost, 6);\n    mtod(m, struct ether_header *)->ether_type = htons(3);\n    mtod(m, unsigned char *)[14] = 0;\n    mtod(m, unsigned char *)[15] = 0;\n    mtod(m, unsigned char *)[16] = 0xE3;\t/* LLC Class1 TEST (no poll) */\n    m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;\n    /*\n     * send it!\n     */\n    sc->tulip_cmdmode |= TULIP_CMD_TXRUN;\n    sc->tulip_intrmask |= TULIP_STS_TXINTR;\n    sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;\n    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);\n    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);\n    if ((m = tulip_txput(sc, m)) != NULL)\n\tm_freem(m);\n    sc->tulip_probe.probe_txprobes++;\n    return 1;\n}"
  },
  {
    "function_name": "tulip_fasttimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "234-242",
    "snippet": "static void\ntulip_fasttimeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_FASTTIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_FASTTIMEOUTPENDING;\n    timeout(tulip_fasttimeout_callback, sc, 1);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "tulip_fasttimeout_callback",
            "sc",
            "1"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_fasttimeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_FASTTIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_FASTTIMEOUTPENDING;\n    timeout(tulip_fasttimeout_callback, sc, 1);\n}"
  },
  {
    "function_name": "tulip_fasttimeout_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "222-232",
    "snippet": "static void\ntulip_fasttimeout_callback(\n    void *arg)\n{\n    tulip_softc_t * const sc = arg;\n    tulip_spl_t s = TULIP_RAISESPL();\n\n    sc->tulip_flags &= ~TULIP_FASTTIMEOUTPENDING;\n    (sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_FASTTIMER);\n    TULIP_RESTORESPL(s);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static tulip_intrfunc_t tulip_intr_shared(void *arg);",
      "static tulip_intrfunc_t tulip_intr_normal(void *arg);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_RESTORESPL",
          "args": [
            "s"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "TULIP_MEDIAPOLL_FASTTIMER"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_RAISESPL",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\nstatic tulip_intrfunc_t tulip_intr_shared(void *arg);\nstatic tulip_intrfunc_t tulip_intr_normal(void *arg);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_fasttimeout_callback(\n    void *arg)\n{\n    tulip_softc_t * const sc = arg;\n    tulip_spl_t s = TULIP_RAISESPL();\n\n    sc->tulip_flags &= ~TULIP_FASTTIMEOUTPENDING;\n    (sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_FASTTIMER);\n    TULIP_RESTORESPL(s);\n}"
  },
  {
    "function_name": "tulip_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "211-219",
    "snippet": "static void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_HZ\t10"
    ],
    "globals_used": [
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timeout",
          "args": [
            "tulip_timeout_callback",
            "sc",
            "(hz + TULIP_HZ / 2) / TULIP_HZ"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "midi_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/midi.c",
          "lines": "478-486",
          "snippet": "void\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}",
          "includes": [
            "#include <dev/midivar.h>",
            "#include <dev/midi_if.h>",
            "#include <dev/audio_if.h>",
            "#include <sys/device.h>",
            "#include <sys/midiio.h>",
            "#include <sys/audioio.h>",
            "#include <sys/conf.h>",
            "#include <sys/signalvar.h>",
            "#include <sys/kernel.h>",
            "#include <sys/syslog.h>",
            "#include <sys/systm.h>",
            "#include <sys/proc.h>",
            "#include <sys/malloc.h>",
            "#include <sys/poll.h>",
            "#include <sys/select.h>",
            "#include <sys/vnode.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/param.h>",
            "#include \"sequencer.h\"",
            "#include \"midi.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <dev/midivar.h>\n#include <dev/midi_if.h>\n#include <dev/audio_if.h>\n#include <sys/device.h>\n#include <sys/midiio.h>\n#include <sys/audioio.h>\n#include <sys/conf.h>\n#include <sys/signalvar.h>\n#include <sys/kernel.h>\n#include <sys/syslog.h>\n#include <sys/systm.h>\n#include <sys/proc.h>\n#include <sys/malloc.h>\n#include <sys/poll.h>\n#include <sys/select.h>\n#include <sys/vnode.h>\n#include <sys/fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/param.h>\n#include \"sequencer.h\"\n#include \"midi.h\"\n\nvoid\nmidi_timeout(arg)\n\tvoid *arg;\n{\n\tstruct midi_softc *sc = arg;\n\n\tDPRINTFN(3,(\"midi_timeout: %p\\n\", sc));\n\tmidi_start_output(sc, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_HZ\t10\n\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_timeout(\n    tulip_softc_t * const sc)\n{\n    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)\n\treturn;\n    sc->tulip_flags |= TULIP_TIMEOUTPENDING;\n    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);\n}"
  },
  {
    "function_name": "tulip_timeout_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/pci/if_de.c",
    "lines": "198-209",
    "snippet": "static void\ntulip_timeout_callback(\n    void *arg)\n{\n    tulip_softc_t * const sc = arg;\n    tulip_spl_t s = TULIP_RAISESPL();\n\n    sc->tulip_flags &= ~TULIP_TIMEOUTPENDING;\n    sc->tulip_probe_timeout -= 1000 / TULIP_HZ;\n    (sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_TIMER);\n    TULIP_RESTORESPL(s);\n}",
    "includes": [
      "#include DEVAR_INCLUDE",
      "#include <dev/ic/dc21040reg.h>",
      "#include <dev/pci/pcidevs.h>",
      "#include <dev/pci/pcivar.h>",
      "#include <dev/pci/pcireg.h>",
      "#include <machine/intr.h>",
      "#include <machine/bus.h>",
      "#include <netinet/if_ether.h>",
      "#include <netinet/if_inarp.h>",
      "#include <net/if_ether.h>",
      "#include <i386/eisa/eisa.h>",
      "#include <eisa.h>",
      "#include <i386/pci/pci.h>",
      "#include <i386/isa/isavar.h>",
      "#include <i386/isa/dma.h>",
      "#include <i386/isa/icu.h>",
      "#include <i386/isa/isa.h>",
      "#include <i386/pci/ic/dc21040reg.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci/dc21040reg.h>",
      "#include <pci/pcivar.h>",
      "#include <netinet/if_ether.h>",
      "#include <pci.h>",
      "#include <vm/pmap.h>",
      "#include <vm/vm_kern.h>",
      "#include <vm/vm_param.h>",
      "#include <vm/vm.h>",
      "#include <netns/ns_if.h>",
      "#include <netns/ns.h>",
      "#include <netinet/ip.h>",
      "#include <netinet/in_var.h>",
      "#include <netinet/in_systm.h>",
      "#include <netinet/in.h>",
      "#include <net/bpfdesc.h>",
      "#include <net/bpf.h>",
      "#include \"bpfilter.h\"",
      "#include <dev/mii/miivar.h>",
      "#include <dev/mii/mii.h>",
      "#include <net/netisr.h>",
      "#include <net/route.h>",
      "#include <net/if_dl.h>",
      "#include <net/if_types.h>",
      "#include <net/if_media.h>",
      "#include <net/if.h>",
      "#include <sys/device.h>",
      "#include <machine/clock.h>",
      "#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */",
      "#include <sys/kernel.h>",
      "#include <sys/malloc.h>",
      "#include <sys/errno.h>",
      "#include <sys/ioctl.h>",
      "#include <sys/socket.h>",
      "#include <sys/protosw.h>",
      "#include <sys/mbuf.h>",
      "#include <sys/systm.h>",
      "#include <sys/param.h>"
    ],
    "macros_used": [
      "#define\tTULIP_HZ\t10"
    ],
    "globals_used": [
      "static tulip_intrfunc_t tulip_intr_shared(void *arg);",
      "static tulip_intrfunc_t tulip_intr_normal(void *arg);",
      "static void tulip_init(tulip_softc_t * const sc);",
      "static void tulip_reset(tulip_softc_t * const sc);",
      "static void tulip_txput_setup(tulip_softc_t * const sc);",
      "static void tulip_rx_intr(tulip_softc_t * const sc);",
      "static void tulip_addr_filter(tulip_softc_t * const sc);",
      "static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);",
      "static int tulip_srom_decode(tulip_softc_t * const sc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "TULIP_RESTORESPL",
          "args": [
            "s"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "sc",
            "TULIP_MEDIAPOLL_TIMER"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TULIP_RAISESPL",
          "args": [],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include DEVAR_INCLUDE\n#include <dev/ic/dc21040reg.h>\n#include <dev/pci/pcidevs.h>\n#include <dev/pci/pcivar.h>\n#include <dev/pci/pcireg.h>\n#include <machine/intr.h>\n#include <machine/bus.h>\n#include <netinet/if_ether.h>\n#include <netinet/if_inarp.h>\n#include <net/if_ether.h>\n#include <i386/eisa/eisa.h>\n#include <eisa.h>\n#include <i386/pci/pci.h>\n#include <i386/isa/isavar.h>\n#include <i386/isa/dma.h>\n#include <i386/isa/icu.h>\n#include <i386/isa/isa.h>\n#include <i386/pci/ic/dc21040reg.h>\n#include <netinet/if_ether.h>\n#include <pci/dc21040reg.h>\n#include <pci/pcivar.h>\n#include <netinet/if_ether.h>\n#include <pci.h>\n#include <vm/pmap.h>\n#include <vm/vm_kern.h>\n#include <vm/vm_param.h>\n#include <vm/vm.h>\n#include <netns/ns_if.h>\n#include <netns/ns.h>\n#include <netinet/ip.h>\n#include <netinet/in_var.h>\n#include <netinet/in_systm.h>\n#include <netinet/in.h>\n#include <net/bpfdesc.h>\n#include <net/bpf.h>\n#include \"bpfilter.h\"\n#include <dev/mii/miivar.h>\n#include <dev/mii/mii.h>\n#include <net/netisr.h>\n#include <net/route.h>\n#include <net/if_dl.h>\n#include <net/if_types.h>\n#include <net/if_media.h>\n#include <net/if.h>\n#include <sys/device.h>\n#include <machine/clock.h>\n#include <sys/proc.h>\t/* only for declaration of wakeup() used by vm.h */\n#include <sys/kernel.h>\n#include <sys/malloc.h>\n#include <sys/errno.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/protosw.h>\n#include <sys/mbuf.h>\n#include <sys/systm.h>\n#include <sys/param.h>\n\n#define\tTULIP_HZ\t10\n\nstatic tulip_intrfunc_t tulip_intr_shared(void *arg);\nstatic tulip_intrfunc_t tulip_intr_normal(void *arg);\nstatic void tulip_init(tulip_softc_t * const sc);\nstatic void tulip_reset(tulip_softc_t * const sc);\nstatic void tulip_txput_setup(tulip_softc_t * const sc);\nstatic void tulip_rx_intr(tulip_softc_t * const sc);\nstatic void tulip_addr_filter(tulip_softc_t * const sc);\nstatic tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);\nstatic int tulip_srom_decode(tulip_softc_t * const sc);\n\nstatic void\ntulip_timeout_callback(\n    void *arg)\n{\n    tulip_softc_t * const sc = arg;\n    tulip_spl_t s = TULIP_RAISESPL();\n\n    sc->tulip_flags &= ~TULIP_TIMEOUTPENDING;\n    sc->tulip_probe_timeout -= 1000 / TULIP_HZ;\n    (sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_TIMER);\n    TULIP_RESTORESPL(s);\n}"
  }
]