[
  {
    "function_name": "PrintLockedStripes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "603-665",
    "snippet": "static void \nPrintLockedStripes(lockTable)\n\tRF_LockTableEntry_t *lockTable;\n{\n\tint     i, j, foundone = 0, did;\n\tRF_StripeLockDesc_t *p;\n\tRF_LockReqDesc_t *q;\n\n\tRF_LOCK_MUTEX(rf_printf_mutex);\n\tprintf(\"Locked stripes:\\n\");\n\tfor (i = 0; i < rf_lockTableSize; i++)\n\t\tif (lockTable[i].descList) {\n\t\t\tfoundone = 1;\n\t\t\tfor (p = lockTable[i].descList; p; p = p->next) {\n\t\t\t\tprintf(\"Stripe ID 0x%lx (%d) nWriters %d\\n\",\n\t\t\t\t    (long) p->stripeID, (int) p->stripeID, p->nWriters);\n\n\t\t\t\tif (!(p->granted))\n\t\t\t\t\tprintf(\"Granted: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Granted:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->granted; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"  %c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2,\n\t\t\t\t\t\t    (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tif (!(p->waitersH))\n\t\t\t\t\tprintf(\"Waiting: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Waiting:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->waitersH; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"%c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2, (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n         \");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\tif (!foundone)\n\t\tprintf(\"(none)\\n\");\n\telse\n\t\tprintf(\"\\n\");\n\tRF_UNLOCK_MUTEX(rf_printf_mutex);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
      "static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);",
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "rf_printf_mutex"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "rf_printf_mutex"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void FreeStripeLockDesc(RF_StripeLockDesc_t * p);\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nstatic void \nPrintLockedStripes(lockTable)\n\tRF_LockTableEntry_t *lockTable;\n{\n\tint     i, j, foundone = 0, did;\n\tRF_StripeLockDesc_t *p;\n\tRF_LockReqDesc_t *q;\n\n\tRF_LOCK_MUTEX(rf_printf_mutex);\n\tprintf(\"Locked stripes:\\n\");\n\tfor (i = 0; i < rf_lockTableSize; i++)\n\t\tif (lockTable[i].descList) {\n\t\t\tfoundone = 1;\n\t\t\tfor (p = lockTable[i].descList; p; p = p->next) {\n\t\t\t\tprintf(\"Stripe ID 0x%lx (%d) nWriters %d\\n\",\n\t\t\t\t    (long) p->stripeID, (int) p->stripeID, p->nWriters);\n\n\t\t\t\tif (!(p->granted))\n\t\t\t\t\tprintf(\"Granted: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Granted:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->granted; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"  %c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2,\n\t\t\t\t\t\t    (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tif (!(p->waitersH))\n\t\t\t\t\tprintf(\"Waiting: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Waiting:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->waitersH; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"%c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2, (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n         \");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\tif (!foundone)\n\t\tprintf(\"(none)\\n\");\n\telse\n\t\tprintf(\"\\n\");\n\tRF_UNLOCK_MUTEX(rf_printf_mutex);\n}"
  },
  {
    "function_name": "FreeStripeLockDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "597-601",
    "snippet": "static void \nFreeStripeLockDesc(RF_StripeLockDesc_t * p)\n{\n\tRF_FREELIST_FREE(rf_stripelock_freelist, p, next);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);",
      "static RF_FreeList_t *rf_stripelock_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_FREE",
          "args": [
            "rf_stripelock_freelist",
            "p",
            "next"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void FreeStripeLockDesc(RF_StripeLockDesc_t * p);\nstatic RF_FreeList_t *rf_stripelock_freelist;\n\nstatic void \nFreeStripeLockDesc(RF_StripeLockDesc_t * p)\n{\n\tRF_FREELIST_FREE(rf_stripelock_freelist, p, next);\n}"
  },
  {
    "function_name": "AllocStripeLockDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "585-595",
    "snippet": "static RF_StripeLockDesc_t *\nAllocStripeLockDesc(RF_StripeNum_t stripeID)\n{\n\tRF_StripeLockDesc_t *p;\n\n\tRF_FREELIST_GET(rf_stripelock_freelist, p, next, (RF_StripeLockDesc_t *));\n\tif (p) {\n\t\tp->stripeID = stripeID;\n\t}\n\treturn (p);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
      "static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);",
      "static RF_FreeList_t *rf_stripelock_freelist;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_GET",
          "args": [
            "rf_stripelock_freelist",
            "p",
            "next",
            "(RF_StripeLockDesc_t *)"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void FreeStripeLockDesc(RF_StripeLockDesc_t * p);\nstatic RF_FreeList_t *rf_stripelock_freelist;\n\nstatic RF_StripeLockDesc_t *\nAllocStripeLockDesc(RF_StripeNum_t stripeID)\n{\n\tRF_StripeLockDesc_t *p;\n\n\tRF_FREELIST_GET(rf_stripelock_freelist, p, next, (RF_StripeLockDesc_t *));\n\tif (p) {\n\t\tp->stripeID = stripeID;\n\t}\n\treturn (p);\n}"
  },
  {
    "function_name": "AddToWaitersQueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "565-583",
    "snippet": "static void \nAddToWaitersQueue(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeLockDesc_t * lockDesc,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tint     tid;\n\n\tif (rf_stripeLockDebug) {\n\t\tDprintf3(\"[%d] Waiting on lock for stripe %ld table 0x%lx\\n\", tid, lockDesc->stripeID, (unsigned long) lockTable);\n\t\tFLUSH;\n\t}\n\tif (!lockDesc->waitersH) {\n\t\tlockDesc->waitersH = lockDesc->waitersT = lockReqDesc;\n\t} else {\n\t\tlockDesc->waitersT->next = lockReqDesc;\n\t\tlockDesc->waitersT = lockReqDesc;\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define FLUSH"
    ],
    "globals_used": [
      "static void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);",
      "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"[%d] Waiting on lock for stripe %ld table 0x%lx\\n\"",
            "tid",
            "lockDesc->stripeID",
            "(unsigned long) lockTable"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\n#define FLUSH\n\nstatic void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nstatic void \nAddToWaitersQueue(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeLockDesc_t * lockDesc,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tint     tid;\n\n\tif (rf_stripeLockDebug) {\n\t\tDprintf3(\"[%d] Waiting on lock for stripe %ld table 0x%lx\\n\", tid, lockDesc->stripeID, (unsigned long) lockTable);\n\t\tFLUSH;\n\t}\n\tif (!lockDesc->waitersH) {\n\t\tlockDesc->waitersH = lockDesc->waitersT = lockReqDesc;\n\t} else {\n\t\tlockDesc->waitersT->next = lockReqDesc;\n\t\tlockDesc->waitersT = lockReqDesc;\n\t}\n}"
  },
  {
    "function_name": "rf_ReleaseStripeLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "332-563",
    "snippet": "void \nrf_ReleaseStripeLock(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeNum_t stripeID,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tRF_StripeLockDesc_t *lockDesc, *ld_t;\n\tRF_LockReqDesc_t *lr, *lr_t, *callbacklist, *t;\n\tRF_IoType_t type = lockReqDesc->type;\n\tint     tid = 0, hashval = HASH_STRIPEID(stripeID);\n\tint     release_it, consider_it;\n\tRF_LockReqDesc_t *candidate, *candidate_t, *predecessor;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (rf_stripeLockDebug) {\n\t\tif (stripeID == -1)\n\t\t\tDprintf1(\"[%d] Lock release supressed (stripeID == -1)\\n\", tid);\n\t\telse {\n\t\t\tDprintf8(\"[%d] Releasing stripe lock on stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2, lockTable);\n\t\t\tFLUSH;\n\t\t}\n\t}\n\tif (stripeID == -1)\n\t\treturn;\n\n\tRF_LOCK_MUTEX(lockTable[hashval].mutex);\n\n\t/* find the stripe lock descriptor */\n\tfor (ld_t = NULL, lockDesc = lockTable[hashval].descList; lockDesc; ld_t = lockDesc, lockDesc = lockDesc->next) {\n\t\tif (lockDesc->stripeID == stripeID)\n\t\t\tbreak;\n\t}\n\tRF_ASSERT(lockDesc);\t/* major error to release a lock that doesn't\n\t\t\t\t * exist */\n\n\t/* find the stripe lock request descriptor & delete it from the list */\n\tfor (lr_t = NULL, lr = lockDesc->granted; lr; lr_t = lr, lr = lr->next)\n\t\tif (lr == lockReqDesc)\n\t\t\tbreak;\n\n\tRF_ASSERT(lr && (lr == lockReqDesc));\t/* major error to release a\n\t\t\t\t\t\t * lock that hasn't been\n\t\t\t\t\t\t * granted */\n\tif (lr_t)\n\t\tlr_t->next = lr->next;\n\telse {\n\t\tRF_ASSERT(lr == lockDesc->granted);\n\t\tlockDesc->granted = lr->next;\n\t}\n\tlr->next = NULL;\n\n\tif (lockReqDesc->type == RF_IO_TYPE_WRITE)\n\t\tlockDesc->nWriters--;\n\n\t/* search through the waiters list to see if anyone needs to be woken\n\t * up. for each such descriptor in the wait list, we check it against\n\t * everything granted and against everything _in front_ of it in the\n\t * waiters queue.  If it conflicts with none of these, we release it.\n\t * \n\t * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST HERE.\n\t * This will roach the case where the callback tries to acquire a new\n\t * lock in the same stripe.  There are some asserts to try and detect\n\t * this.\n\t * \n\t * We apply 2 performance optimizations: (1) if releasing this lock\n\t * results in no more writers to this stripe, we just release\n\t * everybody waiting, since we place no restrictions on the number of\n\t * concurrent reads. (2) we consider as candidates for wakeup only\n\t * those waiters that have a range overlap with either the descriptor\n\t * being woken up or with something in the callbacklist (i.e.\n\t * something we've just now woken up). This allows us to avoid the\n\t * long evaluation for some descriptors. */\n\n\tcallbacklist = NULL;\n\tif (lockDesc->nWriters == 0) {\t/* performance tweak (1) */\n\t\twhile (lockDesc->waitersH) {\n\n\t\t\tlr = lockDesc->waitersH;\t/* delete from waiters\n\t\t\t\t\t\t\t * list */\n\t\t\tlockDesc->waitersH = lr->next;\n\n\t\t\tRF_ASSERT(lr->type == RF_IO_TYPE_READ);\n\n\t\t\tlr->next = lockDesc->granted;\t/* add to granted list */\n\t\t\tlockDesc->granted = lr;\n\n\t\t\tRF_ASSERT(!lr->templink);\n\t\t\tlr->templink = callbacklist;\t/* put on callback list\n\t\t\t\t\t\t\t * so that we'll invoke\n\t\t\t\t\t\t\t * callback below */\n\t\t\tcallbacklist = lr;\n\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\tDprintf8(\"[%d] No writers: granting lock stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t    tid, stripeID, lr->type, lr->start, lr->stop, lr->start2, lr->stop2, (unsigned long) lockTable);\n\t\t\t\tFLUSH;\n\t\t\t}\n\t\t}\n\t\tlockDesc->waitersT = NULL;\t/* we've purged the whole\n\t\t\t\t\t\t * waiters list */\n\n\t} else\n\t\tfor (candidate_t = NULL, candidate = lockDesc->waitersH; candidate;) {\n\n\t\t\t/* performance tweak (2) */\n\t\t\tconsider_it = 0;\n\t\t\tif (RANGE_OVERLAP(lockReqDesc, candidate))\n\t\t\t\tconsider_it = 1;\n\t\t\telse\n\t\t\t\tfor (t = callbacklist; t; t = t->templink)\n\t\t\t\t\tif (RANGE_OVERLAP(t, candidate)) {\n\t\t\t\t\t\tconsider_it = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!consider_it) {\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf8(\"[%d] No overlap: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t\tcandidate_t = candidate;\n\t\t\t\tcandidate = candidate->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* we have a candidate for release.  check to make\n\t\t\t * sure it is not blocked by any granted locks */\n\t\t\trelease_it = 1;\n\t\t\tfor (predecessor = lockDesc->granted; predecessor; predecessor = predecessor->next) {\n\t\t\t\tif (STRIPELOCK_CONFLICT(candidate, predecessor)) {\n\t\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\t\tDprintf8(\"[%d] Conflicts with granted lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\t\tFLUSH;\n\t\t\t\t\t}\n\t\t\t\t\trelease_it = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* now check to see if the candidate is blocked by any\n\t\t\t * waiters that occur before it it the wait queue */\n\t\t\tif (release_it)\n\t\t\t\tfor (predecessor = lockDesc->waitersH; predecessor != candidate; predecessor = predecessor->next) {\n\t\t\t\t\tif (STRIPELOCK_CONFLICT(candidate, predecessor)) {\n\t\t\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\t\t\tDprintf8(\"[%d] Conflicts with waiting lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\t\t\tFLUSH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trelease_it = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t/* release it if indicated */\n\t\t\tif (release_it) {\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf8(\"[%d] Granting lock to candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t\tif (candidate_t) {\n\t\t\t\t\tcandidate_t->next = candidate->next;\n\t\t\t\t\tif (lockDesc->waitersT == candidate)\n\t\t\t\t\t\tlockDesc->waitersT = candidate_t;\t/* cannot be waitersH\n\t\t\t\t\t\t\t\t\t\t\t * since candidate_t is\n\t\t\t\t\t\t\t\t\t\t\t * not NULL */\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(candidate == lockDesc->waitersH);\n\t\t\t\t\tlockDesc->waitersH = lockDesc->waitersH->next;\n\t\t\t\t\tif (!lockDesc->waitersH)\n\t\t\t\t\t\tlockDesc->waitersT = NULL;\n\t\t\t\t}\n\t\t\t\tcandidate->next = lockDesc->granted;\t/* move it to the\n\t\t\t\t\t\t\t\t\t * granted list */\n\t\t\t\tlockDesc->granted = candidate;\n\n\t\t\t\tRF_ASSERT(!candidate->templink);\n\t\t\t\tcandidate->templink = callbacklist;\t/* put it on the list of\n\t\t\t\t\t\t\t\t\t * things to be called\n\t\t\t\t\t\t\t\t\t * after we release the\n\t\t\t\t\t\t\t\t\t * mutex */\n\t\t\t\tcallbacklist = candidate;\n\n\t\t\t\tif (!candidate_t)\n\t\t\t\t\tcandidate = lockDesc->waitersH;\n\t\t\t\telse\n\t\t\t\t\tcandidate = candidate_t->next;\t/* continue with the\n\t\t\t\t\t\t\t\t\t * rest of the list */\n\t\t\t} else {\n\t\t\t\tcandidate_t = candidate;\n\t\t\t\tcandidate = candidate->next;\t/* continue with the\n\t\t\t\t\t\t\t\t * rest of the list */\n\t\t\t}\n\t\t}\n\n\t/* delete the descriptor if no one is waiting or active */\n\tif (!lockDesc->granted && !lockDesc->waitersH) {\n\t\tRF_ASSERT(lockDesc->nWriters == 0);\n\t\tif (rf_stripeLockDebug) {\n\t\t\tDprintf3(\"[%d] Last lock released (table 0x%lx): deleting desc for stripeID %ld\\n\", tid, (unsigned long) lockTable, stripeID);\n\t\t\tFLUSH;\n\t\t}\n\t\tif (ld_t)\n\t\t\tld_t->next = lockDesc->next;\n\t\telse {\n\t\t\tRF_ASSERT(lockDesc == lockTable[hashval].descList);\n\t\t\tlockTable[hashval].descList = lockDesc->next;\n\t\t}\n\t\tFreeStripeLockDesc(lockDesc);\n\t\tlockDesc = NULL;/* only for the ASSERT below */\n\t}\n\tRF_UNLOCK_MUTEX(lockTable[hashval].mutex);\n\n\t/* now that we've unlocked the mutex, invoke the callback on all the\n\t * descriptors in the list */\n\tRF_ASSERT(!((callbacklist) && (!lockDesc)));\t/* if we deleted the\n\t\t\t\t\t\t\t * descriptor, we should\n\t\t\t\t\t\t\t * have no callbacks to\n\t\t\t\t\t\t\t * do */\n\tfor (candidate = callbacklist; candidate;) {\n\t\tt = candidate;\n\t\tcandidate = candidate->templink;\n\t\tt->templink = NULL;\n\t\t(t->cbFunc) (t->cbArg);\n\t}\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define FLUSH"
    ],
    "globals_used": [
      "static void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);",
      "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "t->cbArg"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!((callbacklist) && (!lockDesc))"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "lockTable[hashval].mutex"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeStripeLockDesc",
          "args": [
            "lockDesc"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "FreeStripeLockDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "597-601",
          "snippet": "static void \nFreeStripeLockDesc(RF_StripeLockDesc_t * p)\n{\n\tRF_FREELIST_FREE(rf_stripelock_freelist, p, next);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);",
            "static RF_FreeList_t *rf_stripelock_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void FreeStripeLockDesc(RF_StripeLockDesc_t * p);\nstatic RF_FreeList_t *rf_stripelock_freelist;\n\nstatic void \nFreeStripeLockDesc(RF_StripeLockDesc_t * p)\n{\n\tRF_FREELIST_FREE(rf_stripelock_freelist, p, next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "lockDesc == lockTable[hashval].descList"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"[%d] Last lock released (table 0x%lx): deleting desc for stripeID %ld\\n\"",
            "tid",
            "(unsigned long) lockTable",
            "stripeID"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "lockDesc->nWriters == 0"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!candidate->templink"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "candidate == lockDesc->waitersH"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf8",
          "args": [
            "\"[%d] Granting lock to candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\"",
            "tid",
            "stripeID",
            "candidate->type",
            "candidate->start",
            "candidate->stop",
            "candidate->start2",
            "candidate->stop2",
            "(unsigned long) lockTable"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf8",
          "args": [
            "\"[%d] Conflicts with waiting lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\"",
            "tid",
            "stripeID",
            "candidate->type",
            "candidate->start",
            "candidate->stop",
            "candidate->start2",
            "candidate->stop2",
            "(unsigned long) lockTable"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRIPELOCK_CONFLICT",
          "args": [
            "candidate",
            "predecessor"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf8",
          "args": [
            "\"[%d] Conflicts with granted lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\"",
            "tid",
            "stripeID",
            "candidate->type",
            "candidate->start",
            "candidate->stop",
            "candidate->start2",
            "candidate->stop2",
            "(unsigned long) lockTable"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRIPELOCK_CONFLICT",
          "args": [
            "candidate",
            "predecessor"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf8",
          "args": [
            "\"[%d] No overlap: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\"",
            "tid",
            "stripeID",
            "candidate->type",
            "candidate->start",
            "candidate->stop",
            "candidate->start2",
            "candidate->stop2",
            "(unsigned long) lockTable"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_OVERLAP",
          "args": [
            "t",
            "candidate"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RANGE_OVERLAP",
          "args": [
            "lockReqDesc",
            "candidate"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf8",
          "args": [
            "\"[%d] No writers: granting lock stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\"",
            "tid",
            "stripeID",
            "lr->type",
            "lr->start",
            "lr->stop",
            "lr->start2",
            "lr->stop2",
            "(unsigned long) lockTable"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "!lr->templink"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "lr->type == RF_IO_TYPE_READ"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "lr == lockDesc->granted"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "lr && (lr == lockReqDesc)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "lockDesc"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "lockTable[hashval].mutex"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf8",
          "args": [
            "\"[%d] Releasing stripe lock on stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\"",
            "tid",
            "stripeID",
            "lockReqDesc->type",
            "lockReqDesc->start",
            "lockReqDesc->stop",
            "lockReqDesc->start2",
            "lockReqDesc->stop2",
            "lockTable"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf1",
          "args": [
            "\"[%d] Lock release supressed (stripeID == -1)\\n\"",
            "tid"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(type)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "type"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_STRIPEID",
          "args": [
            "stripeID"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\n#define FLUSH\n\nstatic void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nvoid \nrf_ReleaseStripeLock(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeNum_t stripeID,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tRF_StripeLockDesc_t *lockDesc, *ld_t;\n\tRF_LockReqDesc_t *lr, *lr_t, *callbacklist, *t;\n\tRF_IoType_t type = lockReqDesc->type;\n\tint     tid = 0, hashval = HASH_STRIPEID(stripeID);\n\tint     release_it, consider_it;\n\tRF_LockReqDesc_t *candidate, *candidate_t, *predecessor;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(type));\n\n\tif (rf_stripeLockDebug) {\n\t\tif (stripeID == -1)\n\t\t\tDprintf1(\"[%d] Lock release supressed (stripeID == -1)\\n\", tid);\n\t\telse {\n\t\t\tDprintf8(\"[%d] Releasing stripe lock on stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2, lockTable);\n\t\t\tFLUSH;\n\t\t}\n\t}\n\tif (stripeID == -1)\n\t\treturn;\n\n\tRF_LOCK_MUTEX(lockTable[hashval].mutex);\n\n\t/* find the stripe lock descriptor */\n\tfor (ld_t = NULL, lockDesc = lockTable[hashval].descList; lockDesc; ld_t = lockDesc, lockDesc = lockDesc->next) {\n\t\tif (lockDesc->stripeID == stripeID)\n\t\t\tbreak;\n\t}\n\tRF_ASSERT(lockDesc);\t/* major error to release a lock that doesn't\n\t\t\t\t * exist */\n\n\t/* find the stripe lock request descriptor & delete it from the list */\n\tfor (lr_t = NULL, lr = lockDesc->granted; lr; lr_t = lr, lr = lr->next)\n\t\tif (lr == lockReqDesc)\n\t\t\tbreak;\n\n\tRF_ASSERT(lr && (lr == lockReqDesc));\t/* major error to release a\n\t\t\t\t\t\t * lock that hasn't been\n\t\t\t\t\t\t * granted */\n\tif (lr_t)\n\t\tlr_t->next = lr->next;\n\telse {\n\t\tRF_ASSERT(lr == lockDesc->granted);\n\t\tlockDesc->granted = lr->next;\n\t}\n\tlr->next = NULL;\n\n\tif (lockReqDesc->type == RF_IO_TYPE_WRITE)\n\t\tlockDesc->nWriters--;\n\n\t/* search through the waiters list to see if anyone needs to be woken\n\t * up. for each such descriptor in the wait list, we check it against\n\t * everything granted and against everything _in front_ of it in the\n\t * waiters queue.  If it conflicts with none of these, we release it.\n\t * \n\t * DON'T TOUCH THE TEMPLINK POINTER OF ANYTHING IN THE GRANTED LIST HERE.\n\t * This will roach the case where the callback tries to acquire a new\n\t * lock in the same stripe.  There are some asserts to try and detect\n\t * this.\n\t * \n\t * We apply 2 performance optimizations: (1) if releasing this lock\n\t * results in no more writers to this stripe, we just release\n\t * everybody waiting, since we place no restrictions on the number of\n\t * concurrent reads. (2) we consider as candidates for wakeup only\n\t * those waiters that have a range overlap with either the descriptor\n\t * being woken up or with something in the callbacklist (i.e.\n\t * something we've just now woken up). This allows us to avoid the\n\t * long evaluation for some descriptors. */\n\n\tcallbacklist = NULL;\n\tif (lockDesc->nWriters == 0) {\t/* performance tweak (1) */\n\t\twhile (lockDesc->waitersH) {\n\n\t\t\tlr = lockDesc->waitersH;\t/* delete from waiters\n\t\t\t\t\t\t\t * list */\n\t\t\tlockDesc->waitersH = lr->next;\n\n\t\t\tRF_ASSERT(lr->type == RF_IO_TYPE_READ);\n\n\t\t\tlr->next = lockDesc->granted;\t/* add to granted list */\n\t\t\tlockDesc->granted = lr;\n\n\t\t\tRF_ASSERT(!lr->templink);\n\t\t\tlr->templink = callbacklist;\t/* put on callback list\n\t\t\t\t\t\t\t * so that we'll invoke\n\t\t\t\t\t\t\t * callback below */\n\t\t\tcallbacklist = lr;\n\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\tDprintf8(\"[%d] No writers: granting lock stripe ID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t    tid, stripeID, lr->type, lr->start, lr->stop, lr->start2, lr->stop2, (unsigned long) lockTable);\n\t\t\t\tFLUSH;\n\t\t\t}\n\t\t}\n\t\tlockDesc->waitersT = NULL;\t/* we've purged the whole\n\t\t\t\t\t\t * waiters list */\n\n\t} else\n\t\tfor (candidate_t = NULL, candidate = lockDesc->waitersH; candidate;) {\n\n\t\t\t/* performance tweak (2) */\n\t\t\tconsider_it = 0;\n\t\t\tif (RANGE_OVERLAP(lockReqDesc, candidate))\n\t\t\t\tconsider_it = 1;\n\t\t\telse\n\t\t\t\tfor (t = callbacklist; t; t = t->templink)\n\t\t\t\t\tif (RANGE_OVERLAP(t, candidate)) {\n\t\t\t\t\t\tconsider_it = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!consider_it) {\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf8(\"[%d] No overlap: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t\tcandidate_t = candidate;\n\t\t\t\tcandidate = candidate->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* we have a candidate for release.  check to make\n\t\t\t * sure it is not blocked by any granted locks */\n\t\t\trelease_it = 1;\n\t\t\tfor (predecessor = lockDesc->granted; predecessor; predecessor = predecessor->next) {\n\t\t\t\tif (STRIPELOCK_CONFLICT(candidate, predecessor)) {\n\t\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\t\tDprintf8(\"[%d] Conflicts with granted lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\t\tFLUSH;\n\t\t\t\t\t}\n\t\t\t\t\trelease_it = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* now check to see if the candidate is blocked by any\n\t\t\t * waiters that occur before it it the wait queue */\n\t\t\tif (release_it)\n\t\t\t\tfor (predecessor = lockDesc->waitersH; predecessor != candidate; predecessor = predecessor->next) {\n\t\t\t\t\tif (STRIPELOCK_CONFLICT(candidate, predecessor)) {\n\t\t\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\t\t\tDprintf8(\"[%d] Conflicts with waiting lock: rejecting candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\t\t\tFLUSH;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trelease_it = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t/* release it if indicated */\n\t\t\tif (release_it) {\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf8(\"[%d] Granting lock to candidate stripeID %ld, type %c range %ld-%ld %ld-%ld table 0x%lx\\n\",\n\t\t\t\t\t    tid, stripeID, candidate->type, candidate->start, candidate->stop, candidate->start2, candidate->stop2,\n\t\t\t\t\t    (unsigned long) lockTable);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t\tif (candidate_t) {\n\t\t\t\t\tcandidate_t->next = candidate->next;\n\t\t\t\t\tif (lockDesc->waitersT == candidate)\n\t\t\t\t\t\tlockDesc->waitersT = candidate_t;\t/* cannot be waitersH\n\t\t\t\t\t\t\t\t\t\t\t * since candidate_t is\n\t\t\t\t\t\t\t\t\t\t\t * not NULL */\n\t\t\t\t} else {\n\t\t\t\t\tRF_ASSERT(candidate == lockDesc->waitersH);\n\t\t\t\t\tlockDesc->waitersH = lockDesc->waitersH->next;\n\t\t\t\t\tif (!lockDesc->waitersH)\n\t\t\t\t\t\tlockDesc->waitersT = NULL;\n\t\t\t\t}\n\t\t\t\tcandidate->next = lockDesc->granted;\t/* move it to the\n\t\t\t\t\t\t\t\t\t * granted list */\n\t\t\t\tlockDesc->granted = candidate;\n\n\t\t\t\tRF_ASSERT(!candidate->templink);\n\t\t\t\tcandidate->templink = callbacklist;\t/* put it on the list of\n\t\t\t\t\t\t\t\t\t * things to be called\n\t\t\t\t\t\t\t\t\t * after we release the\n\t\t\t\t\t\t\t\t\t * mutex */\n\t\t\t\tcallbacklist = candidate;\n\n\t\t\t\tif (!candidate_t)\n\t\t\t\t\tcandidate = lockDesc->waitersH;\n\t\t\t\telse\n\t\t\t\t\tcandidate = candidate_t->next;\t/* continue with the\n\t\t\t\t\t\t\t\t\t * rest of the list */\n\t\t\t} else {\n\t\t\t\tcandidate_t = candidate;\n\t\t\t\tcandidate = candidate->next;\t/* continue with the\n\t\t\t\t\t\t\t\t * rest of the list */\n\t\t\t}\n\t\t}\n\n\t/* delete the descriptor if no one is waiting or active */\n\tif (!lockDesc->granted && !lockDesc->waitersH) {\n\t\tRF_ASSERT(lockDesc->nWriters == 0);\n\t\tif (rf_stripeLockDebug) {\n\t\t\tDprintf3(\"[%d] Last lock released (table 0x%lx): deleting desc for stripeID %ld\\n\", tid, (unsigned long) lockTable, stripeID);\n\t\t\tFLUSH;\n\t\t}\n\t\tif (ld_t)\n\t\t\tld_t->next = lockDesc->next;\n\t\telse {\n\t\t\tRF_ASSERT(lockDesc == lockTable[hashval].descList);\n\t\t\tlockTable[hashval].descList = lockDesc->next;\n\t\t}\n\t\tFreeStripeLockDesc(lockDesc);\n\t\tlockDesc = NULL;/* only for the ASSERT below */\n\t}\n\tRF_UNLOCK_MUTEX(lockTable[hashval].mutex);\n\n\t/* now that we've unlocked the mutex, invoke the callback on all the\n\t * descriptors in the list */\n\tRF_ASSERT(!((callbacklist) && (!lockDesc)));\t/* if we deleted the\n\t\t\t\t\t\t\t * descriptor, we should\n\t\t\t\t\t\t\t * have no callbacks to\n\t\t\t\t\t\t\t * do */\n\tfor (candidate = callbacklist; candidate;) {\n\t\tt = candidate;\n\t\tcandidate = candidate->templink;\n\t\tt->templink = NULL;\n\t\t(t->cbFunc) (t->cbArg);\n\t}\n}"
  },
  {
    "function_name": "rf_AcquireStripeLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "225-330",
    "snippet": "int \nrf_AcquireStripeLock(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeNum_t stripeID,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tRF_StripeLockDesc_t *lockDesc;\n\tRF_LockReqDesc_t *p;\n\tint     tid = 0, hashval = HASH_STRIPEID(stripeID);\n\tint     retcode = 0;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(lockReqDesc->type));\n\n\tif (rf_stripeLockDebug) {\n\t\tif (stripeID == -1)\n\t\t\tDprintf1(\"[%d] Lock acquisition supressed (stripeID == -1)\\n\", tid);\n\t\telse {\n\t\t\tDprintf8(\"[%d] Trying to acquire stripe lock table 0x%lx SID %ld type %c range %ld-%ld, range2 %ld-%ld hashval %d\\n\",\n\t\t\t    tid, (unsigned long) lockTable, stripeID, lockReqDesc->type, lockReqDesc->start,\n\t\t\t    lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\tDprintf3(\"[%d] lock %ld hashval %d\\n\", tid, stripeID, hashval);\n\t\t\tFLUSH;\n\t\t}\n\t}\n\tif (stripeID == -1)\n\t\treturn (0);\n\tlockReqDesc->next = NULL;\t/* just to be sure */\n\n\tRF_LOCK_MUTEX(lockTable[hashval].mutex);\n\tfor (lockDesc = lockTable[hashval].descList; lockDesc; lockDesc = lockDesc->next) {\n\t\tif (lockDesc->stripeID == stripeID)\n\t\t\tbreak;\n\t}\n\n\tif (!lockDesc) {\t/* no entry in table => no one reading or\n\t\t\t\t * writing */\n\t\tlockDesc = AllocStripeLockDesc(stripeID);\n\t\tlockDesc->next = lockTable[hashval].descList;\n\t\tlockTable[hashval].descList = lockDesc;\n\t\tif (lockReqDesc->type == RF_IO_TYPE_WRITE)\n\t\t\tlockDesc->nWriters++;\n\t\tlockDesc->granted = lockReqDesc;\n\t\tif (rf_stripeLockDebug) {\n\t\t\tDprintf7(\"[%d] no one waiting: lock %ld %c %ld-%ld %ld-%ld granted\\n\",\n\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\tFLUSH;\n\t\t}\n\t} else {\n\n\t\tif (lockReqDesc->type == RF_IO_TYPE_WRITE)\n\t\t\tlockDesc->nWriters++;\n\n\t\tif (lockDesc->nWriters == 0) {\t/* no need to search any lists\n\t\t\t\t\t\t * if there are no writers\n\t\t\t\t\t\t * anywhere */\n\t\t\tlockReqDesc->next = lockDesc->granted;\n\t\t\tlockDesc->granted = lockReqDesc;\n\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\tDprintf7(\"[%d] no writers: lock %ld %c %ld-%ld %ld-%ld granted\\n\",\n\t\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\t\tFLUSH;\n\t\t\t}\n\t\t} else {\n\n\t\t\t/* search the granted & waiting lists for a conflict.\n\t\t\t * stop searching as soon as we find one */\n\t\t\tretcode = 0;\n\t\t\tfor (p = lockDesc->granted; p; p = p->next)\n\t\t\t\tif (STRIPELOCK_CONFLICT(lockReqDesc, p)) {\n\t\t\t\t\tretcode = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!retcode)\n\t\t\t\tfor (p = lockDesc->waitersH; p; p = p->next)\n\t\t\t\t\tif (STRIPELOCK_CONFLICT(lockReqDesc, p)) {\n\t\t\t\t\t\tretcode = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!retcode) {\n\t\t\t\tlockReqDesc->next = lockDesc->granted;\t/* no conflicts found =>\n\t\t\t\t\t\t\t\t\t * grant lock */\n\t\t\t\tlockDesc->granted = lockReqDesc;\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf7(\"[%d] no conflicts: lock %ld %c %ld-%ld %ld-%ld granted\\n\",\n\t\t\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop,\n\t\t\t\t\t    lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf6(\"[%d] conflict: lock %ld %c %ld-%ld hashval=%d not granted\\n\",\n\t\t\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop,\n\t\t\t\t\t    hashval);\n\t\t\t\t\tDprintf3(\"[%d] lock %ld retcode=%d\\n\", tid, stripeID, retcode);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t\tAddToWaitersQueue(lockTable, lockDesc, lockReqDesc);\t/* conflict => the\n\t\t\t\t\t\t\t\t\t\t\t * current access must\n\t\t\t\t\t\t\t\t\t\t\t * wait */\n\t\t\t}\n\t\t}\n\t}\n\n\tRF_UNLOCK_MUTEX(lockTable[hashval].mutex);\n\treturn (retcode);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define FLUSH"
    ],
    "globals_used": [
      "static void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);",
      "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
      "static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);",
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_UNLOCK_MUTEX",
          "args": [
            "lockTable[hashval].mutex"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddToWaitersQueue",
          "args": [
            "lockTable",
            "lockDesc",
            "lockReqDesc"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "AddToWaitersQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "565-583",
          "snippet": "static void \nAddToWaitersQueue(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeLockDesc_t * lockDesc,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tint     tid;\n\n\tif (rf_stripeLockDebug) {\n\t\tDprintf3(\"[%d] Waiting on lock for stripe %ld table 0x%lx\\n\", tid, lockDesc->stripeID, (unsigned long) lockTable);\n\t\tFLUSH;\n\t}\n\tif (!lockDesc->waitersH) {\n\t\tlockDesc->waitersH = lockDesc->waitersT = lockReqDesc;\n\t} else {\n\t\tlockDesc->waitersT->next = lockReqDesc;\n\t\tlockDesc->waitersT = lockReqDesc;\n\t}\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define FLUSH"
          ],
          "globals_used": [
            "static void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);",
            "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
            "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\n#define FLUSH\n\nstatic void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nstatic void \nAddToWaitersQueue(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeLockDesc_t * lockDesc,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tint     tid;\n\n\tif (rf_stripeLockDebug) {\n\t\tDprintf3(\"[%d] Waiting on lock for stripe %ld table 0x%lx\\n\", tid, lockDesc->stripeID, (unsigned long) lockTable);\n\t\tFLUSH;\n\t}\n\tif (!lockDesc->waitersH) {\n\t\tlockDesc->waitersH = lockDesc->waitersT = lockReqDesc;\n\t} else {\n\t\tlockDesc->waitersT->next = lockReqDesc;\n\t\tlockDesc->waitersT = lockReqDesc;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"[%d] lock %ld retcode=%d\\n\"",
            "tid",
            "stripeID",
            "retcode"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf6",
          "args": [
            "\"[%d] conflict: lock %ld %c %ld-%ld hashval=%d not granted\\n\"",
            "tid",
            "stripeID",
            "lockReqDesc->type",
            "lockReqDesc->start",
            "lockReqDesc->stop",
            "hashval"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf7",
          "args": [
            "\"[%d] no conflicts: lock %ld %c %ld-%ld %ld-%ld granted\\n\"",
            "tid",
            "stripeID",
            "lockReqDesc->type",
            "lockReqDesc->start",
            "lockReqDesc->stop",
            "lockReqDesc->start2",
            "lockReqDesc->stop2"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRIPELOCK_CONFLICT",
          "args": [
            "lockReqDesc",
            "p"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRIPELOCK_CONFLICT",
          "args": [
            "lockReqDesc",
            "p"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf7",
          "args": [
            "\"[%d] no writers: lock %ld %c %ld-%ld %ld-%ld granted\\n\"",
            "tid",
            "stripeID",
            "lockReqDesc->type",
            "lockReqDesc->start",
            "lockReqDesc->stop",
            "lockReqDesc->start2",
            "lockReqDesc->stop2"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf7",
          "args": [
            "\"[%d] no one waiting: lock %ld %c %ld-%ld %ld-%ld granted\\n\"",
            "tid",
            "stripeID",
            "lockReqDesc->type",
            "lockReqDesc->start",
            "lockReqDesc->stop",
            "lockReqDesc->start2",
            "lockReqDesc->stop2"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AllocStripeLockDesc",
          "args": [
            "stripeID"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "AllocStripeLockDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "585-595",
          "snippet": "static RF_StripeLockDesc_t *\nAllocStripeLockDesc(RF_StripeNum_t stripeID)\n{\n\tRF_StripeLockDesc_t *p;\n\n\tRF_FREELIST_GET(rf_stripelock_freelist, p, next, (RF_StripeLockDesc_t *));\n\tif (p) {\n\t\tp->stripeID = stripeID;\n\t}\n\treturn (p);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
            "static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);",
            "static RF_FreeList_t *rf_stripelock_freelist;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void FreeStripeLockDesc(RF_StripeLockDesc_t * p);\nstatic RF_FreeList_t *rf_stripelock_freelist;\n\nstatic RF_StripeLockDesc_t *\nAllocStripeLockDesc(RF_StripeNum_t stripeID)\n{\n\tRF_StripeLockDesc_t *p;\n\n\tRF_FREELIST_GET(rf_stripelock_freelist, p, next, (RF_StripeLockDesc_t *));\n\tif (p) {\n\t\tp->stripeID = stripeID;\n\t}\n\treturn (p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_LOCK_MUTEX",
          "args": [
            "lockTable[hashval].mutex"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf3",
          "args": [
            "\"[%d] lock %ld hashval %d\\n\"",
            "tid",
            "stripeID",
            "hashval"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf8",
          "args": [
            "\"[%d] Trying to acquire stripe lock table 0x%lx SID %ld type %c range %ld-%ld, range2 %ld-%ld hashval %d\\n\"",
            "tid",
            "(unsigned long) lockTable",
            "stripeID",
            "lockReqDesc->type",
            "lockReqDesc->start",
            "lockReqDesc->stop",
            "lockReqDesc->start2",
            "lockReqDesc->stop2"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Dprintf1",
          "args": [
            "\"[%d] Lock acquisition supressed (stripeID == -1)\\n\"",
            "tid"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_ASSERT",
          "args": [
            "RF_IO_IS_R_OR_W(lockReqDesc->type)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_IO_IS_R_OR_W",
          "args": [
            "lockReqDesc->type"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HASH_STRIPEID",
          "args": [
            "stripeID"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\n#define FLUSH\n\nstatic void AddToWaitersQueue(RF_LockTableEntry_t * lockTable, RF_StripeLockDesc_t * lockDesc, RF_LockReqDesc_t * lockReqDesc);\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void FreeStripeLockDesc(RF_StripeLockDesc_t * p);\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nint \nrf_AcquireStripeLock(\n    RF_LockTableEntry_t * lockTable,\n    RF_StripeNum_t stripeID,\n    RF_LockReqDesc_t * lockReqDesc)\n{\n\tRF_StripeLockDesc_t *lockDesc;\n\tRF_LockReqDesc_t *p;\n\tint     tid = 0, hashval = HASH_STRIPEID(stripeID);\n\tint     retcode = 0;\n\n\tRF_ASSERT(RF_IO_IS_R_OR_W(lockReqDesc->type));\n\n\tif (rf_stripeLockDebug) {\n\t\tif (stripeID == -1)\n\t\t\tDprintf1(\"[%d] Lock acquisition supressed (stripeID == -1)\\n\", tid);\n\t\telse {\n\t\t\tDprintf8(\"[%d] Trying to acquire stripe lock table 0x%lx SID %ld type %c range %ld-%ld, range2 %ld-%ld hashval %d\\n\",\n\t\t\t    tid, (unsigned long) lockTable, stripeID, lockReqDesc->type, lockReqDesc->start,\n\t\t\t    lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\tDprintf3(\"[%d] lock %ld hashval %d\\n\", tid, stripeID, hashval);\n\t\t\tFLUSH;\n\t\t}\n\t}\n\tif (stripeID == -1)\n\t\treturn (0);\n\tlockReqDesc->next = NULL;\t/* just to be sure */\n\n\tRF_LOCK_MUTEX(lockTable[hashval].mutex);\n\tfor (lockDesc = lockTable[hashval].descList; lockDesc; lockDesc = lockDesc->next) {\n\t\tif (lockDesc->stripeID == stripeID)\n\t\t\tbreak;\n\t}\n\n\tif (!lockDesc) {\t/* no entry in table => no one reading or\n\t\t\t\t * writing */\n\t\tlockDesc = AllocStripeLockDesc(stripeID);\n\t\tlockDesc->next = lockTable[hashval].descList;\n\t\tlockTable[hashval].descList = lockDesc;\n\t\tif (lockReqDesc->type == RF_IO_TYPE_WRITE)\n\t\t\tlockDesc->nWriters++;\n\t\tlockDesc->granted = lockReqDesc;\n\t\tif (rf_stripeLockDebug) {\n\t\t\tDprintf7(\"[%d] no one waiting: lock %ld %c %ld-%ld %ld-%ld granted\\n\",\n\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\tFLUSH;\n\t\t}\n\t} else {\n\n\t\tif (lockReqDesc->type == RF_IO_TYPE_WRITE)\n\t\t\tlockDesc->nWriters++;\n\n\t\tif (lockDesc->nWriters == 0) {\t/* no need to search any lists\n\t\t\t\t\t\t * if there are no writers\n\t\t\t\t\t\t * anywhere */\n\t\t\tlockReqDesc->next = lockDesc->granted;\n\t\t\tlockDesc->granted = lockReqDesc;\n\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\tDprintf7(\"[%d] no writers: lock %ld %c %ld-%ld %ld-%ld granted\\n\",\n\t\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop, lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\t\tFLUSH;\n\t\t\t}\n\t\t} else {\n\n\t\t\t/* search the granted & waiting lists for a conflict.\n\t\t\t * stop searching as soon as we find one */\n\t\t\tretcode = 0;\n\t\t\tfor (p = lockDesc->granted; p; p = p->next)\n\t\t\t\tif (STRIPELOCK_CONFLICT(lockReqDesc, p)) {\n\t\t\t\t\tretcode = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (!retcode)\n\t\t\t\tfor (p = lockDesc->waitersH; p; p = p->next)\n\t\t\t\t\tif (STRIPELOCK_CONFLICT(lockReqDesc, p)) {\n\t\t\t\t\t\tretcode = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!retcode) {\n\t\t\t\tlockReqDesc->next = lockDesc->granted;\t/* no conflicts found =>\n\t\t\t\t\t\t\t\t\t * grant lock */\n\t\t\t\tlockDesc->granted = lockReqDesc;\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf7(\"[%d] no conflicts: lock %ld %c %ld-%ld %ld-%ld granted\\n\",\n\t\t\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop,\n\t\t\t\t\t    lockReqDesc->start2, lockReqDesc->stop2);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rf_stripeLockDebug) {\n\t\t\t\t\tDprintf6(\"[%d] conflict: lock %ld %c %ld-%ld hashval=%d not granted\\n\",\n\t\t\t\t\t    tid, stripeID, lockReqDesc->type, lockReqDesc->start, lockReqDesc->stop,\n\t\t\t\t\t    hashval);\n\t\t\t\t\tDprintf3(\"[%d] lock %ld retcode=%d\\n\", tid, stripeID, retcode);\n\t\t\t\t\tFLUSH;\n\t\t\t\t}\n\t\t\t\tAddToWaitersQueue(lockTable, lockDesc, lockReqDesc);\t/* conflict => the\n\t\t\t\t\t\t\t\t\t\t\t * current access must\n\t\t\t\t\t\t\t\t\t\t\t * wait */\n\t\t\t}\n\t\t}\n\t}\n\n\tRF_UNLOCK_MUTEX(lockTable[hashval].mutex);\n\treturn (retcode);\n}"
  },
  {
    "function_name": "rf_ConfigureStripeLocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "200-219",
    "snippet": "int \nrf_ConfigureStripeLocks(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\traidPtr->lockTable = rf_MakeLockTable();\n\tif (raidPtr->lockTable == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_RaidShutdownStripeLocks, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownStripeLocks(raidPtr->lockTable);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);",
      "static void rf_RaidShutdownStripeLocks(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ShutdownStripeLocks",
          "args": [
            "raidPtr->lockTable"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownStripeLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "178-190",
          "snippet": "void \nrf_ShutdownStripeLocks(RF_LockTableEntry_t * lockTable)\n{\n\tint     i;\n\n\tif (rf_stripeLockDebug) {\n\t\tPrintLockedStripes(lockTable);\n\t}\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trf_mutex_destroy(&lockTable[i].mutex);\n\t}\n\tRF_Free(lockTable, rf_lockTableSize * sizeof(RF_LockTableEntry_t));\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nvoid \nrf_ShutdownStripeLocks(RF_LockTableEntry_t * lockTable)\n{\n\tint     i;\n\n\tif (rf_stripeLockDebug) {\n\t\tPrintLockedStripes(lockTable);\n\t}\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trf_mutex_destroy(&lockTable[i].mutex);\n\t}\n\tRF_Free(lockTable, rf_lockTableSize * sizeof(RF_LockTableEntry_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_RaidShutdownStripeLocks",
            "raidPtr"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_MakeLockTable",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "rf_MakeLockTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "157-176",
          "snippet": "RF_LockTableEntry_t *\nrf_MakeLockTable()\n{\n\tRF_LockTableEntry_t *lockTable;\n\tint     i, rc;\n\n\tRF_Calloc(lockTable, ((int) rf_lockTableSize), sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));\n\tif (lockTable == NULL)\n\t\treturn (NULL);\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trc = rf_mutex_init(&lockTable[i].mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\t/* XXX clean up other mutexes */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\treturn (lockTable);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nRF_LockTableEntry_t *\nrf_MakeLockTable()\n{\n\tRF_LockTableEntry_t *lockTable;\n\tint     i, rc;\n\n\tRF_Calloc(lockTable, ((int) rf_lockTableSize), sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));\n\tif (lockTable == NULL)\n\t\treturn (NULL);\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trc = rf_mutex_init(&lockTable[i].mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\t/* XXX clean up other mutexes */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\treturn (lockTable);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\nstatic void rf_RaidShutdownStripeLocks(void *);\n\nint \nrf_ConfigureStripeLocks(\n    RF_ShutdownList_t ** listp,\n    RF_Raid_t * raidPtr,\n    RF_Config_t * cfgPtr)\n{\n\tint     rc;\n\n\traidPtr->lockTable = rf_MakeLockTable();\n\tif (raidPtr->lockTable == NULL)\n\t\treturn (ENOMEM);\n\trc = rf_ShutdownCreate(listp, rf_RaidShutdownStripeLocks, raidPtr);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownStripeLocks(raidPtr->lockTable);\n\t\treturn (rc);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_RaidShutdownStripeLocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "192-198",
    "snippet": "static void \nrf_RaidShutdownStripeLocks(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) arg;\n\trf_ShutdownStripeLocks(raidPtr->lockTable);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);",
      "static void rf_RaidShutdownStripeLocks(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rf_ShutdownStripeLocks",
          "args": [
            "raidPtr->lockTable"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownStripeLocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "178-190",
          "snippet": "void \nrf_ShutdownStripeLocks(RF_LockTableEntry_t * lockTable)\n{\n\tint     i;\n\n\tif (rf_stripeLockDebug) {\n\t\tPrintLockedStripes(lockTable);\n\t}\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trf_mutex_destroy(&lockTable[i].mutex);\n\t}\n\tRF_Free(lockTable, rf_lockTableSize * sizeof(RF_LockTableEntry_t));\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nvoid \nrf_ShutdownStripeLocks(RF_LockTableEntry_t * lockTable)\n{\n\tint     i;\n\n\tif (rf_stripeLockDebug) {\n\t\tPrintLockedStripes(lockTable);\n\t}\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trf_mutex_destroy(&lockTable[i].mutex);\n\t}\n\tRF_Free(lockTable, rf_lockTableSize * sizeof(RF_LockTableEntry_t));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\nstatic void rf_RaidShutdownStripeLocks(void *);\n\nstatic void \nrf_RaidShutdownStripeLocks(arg)\n\tvoid   *arg;\n{\n\tRF_Raid_t *raidPtr = (RF_Raid_t *) arg;\n\trf_ShutdownStripeLocks(raidPtr->lockTable);\n}"
  },
  {
    "function_name": "rf_ShutdownStripeLocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "178-190",
    "snippet": "void \nrf_ShutdownStripeLocks(RF_LockTableEntry_t * lockTable)\n{\n\tint     i;\n\n\tif (rf_stripeLockDebug) {\n\t\tPrintLockedStripes(lockTable);\n\t}\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trf_mutex_destroy(&lockTable[i].mutex);\n\t}\n\tRF_Free(lockTable, rf_lockTableSize * sizeof(RF_LockTableEntry_t));\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_Free",
          "args": [
            "lockTable",
            "rf_lockTableSize * sizeof(RF_LockTableEntry_t)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_destroy",
          "args": [
            "&lockTable[i].mutex"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintLockedStripes",
          "args": [
            "lockTable"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "PrintLockedStripes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "603-665",
          "snippet": "static void \nPrintLockedStripes(lockTable)\n\tRF_LockTableEntry_t *lockTable;\n{\n\tint     i, j, foundone = 0, did;\n\tRF_StripeLockDesc_t *p;\n\tRF_LockReqDesc_t *q;\n\n\tRF_LOCK_MUTEX(rf_printf_mutex);\n\tprintf(\"Locked stripes:\\n\");\n\tfor (i = 0; i < rf_lockTableSize; i++)\n\t\tif (lockTable[i].descList) {\n\t\t\tfoundone = 1;\n\t\t\tfor (p = lockTable[i].descList; p; p = p->next) {\n\t\t\t\tprintf(\"Stripe ID 0x%lx (%d) nWriters %d\\n\",\n\t\t\t\t    (long) p->stripeID, (int) p->stripeID, p->nWriters);\n\n\t\t\t\tif (!(p->granted))\n\t\t\t\t\tprintf(\"Granted: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Granted:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->granted; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"  %c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2,\n\t\t\t\t\t\t    (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tif (!(p->waitersH))\n\t\t\t\t\tprintf(\"Waiting: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Waiting:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->waitersH; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"%c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2, (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n         \");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\tif (!foundone)\n\t\tprintf(\"(none)\\n\");\n\telse\n\t\tprintf(\"\\n\");\n\tRF_UNLOCK_MUTEX(rf_printf_mutex);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);",
            "static void FreeStripeLockDesc(RF_StripeLockDesc_t * p);",
            "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic RF_StripeLockDesc_t *AllocStripeLockDesc(RF_StripeNum_t stripeID);\nstatic void FreeStripeLockDesc(RF_StripeLockDesc_t * p);\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nstatic void \nPrintLockedStripes(lockTable)\n\tRF_LockTableEntry_t *lockTable;\n{\n\tint     i, j, foundone = 0, did;\n\tRF_StripeLockDesc_t *p;\n\tRF_LockReqDesc_t *q;\n\n\tRF_LOCK_MUTEX(rf_printf_mutex);\n\tprintf(\"Locked stripes:\\n\");\n\tfor (i = 0; i < rf_lockTableSize; i++)\n\t\tif (lockTable[i].descList) {\n\t\t\tfoundone = 1;\n\t\t\tfor (p = lockTable[i].descList; p; p = p->next) {\n\t\t\t\tprintf(\"Stripe ID 0x%lx (%d) nWriters %d\\n\",\n\t\t\t\t    (long) p->stripeID, (int) p->stripeID, p->nWriters);\n\n\t\t\t\tif (!(p->granted))\n\t\t\t\t\tprintf(\"Granted: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Granted:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->granted; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"  %c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2,\n\t\t\t\t\t\t    (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\n\t\t\t\tif (!(p->waitersH))\n\t\t\t\t\tprintf(\"Waiting: (none)\\n\");\n\t\t\t\telse\n\t\t\t\t\tprintf(\"Waiting:\\n\");\n\t\t\t\tfor (did = 1, j = 0, q = p->waitersH; q; j++, q = q->next) {\n\t\t\t\t\tprintf(\"%c(%ld-%ld\", q->type, (long) q->start, (long) q->stop);\n\t\t\t\t\tif (q->start2 != -1)\n\t\t\t\t\t\tprintf(\",%ld-%ld) \", (long) q->start2, (long) q->stop2);\n\t\t\t\t\telse\n\t\t\t\t\t\tprintf(\") \");\n\t\t\t\t\tif (j && !(j % 4)) {\n\t\t\t\t\t\tprintf(\"\\n         \");\n\t\t\t\t\t\tdid = 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tdid = 0;\n\t\t\t\t}\n\t\t\t\tif (!did)\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\tif (!foundone)\n\t\tprintf(\"(none)\\n\");\n\telse\n\t\tprintf(\"\\n\");\n\tRF_UNLOCK_MUTEX(rf_printf_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nvoid \nrf_ShutdownStripeLocks(RF_LockTableEntry_t * lockTable)\n{\n\tint     i;\n\n\tif (rf_stripeLockDebug) {\n\t\tPrintLockedStripes(lockTable);\n\t}\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trf_mutex_destroy(&lockTable[i].mutex);\n\t}\n\tRF_Free(lockTable, rf_lockTableSize * sizeof(RF_LockTableEntry_t));\n}"
  },
  {
    "function_name": "rf_MakeLockTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "157-176",
    "snippet": "RF_LockTableEntry_t *\nrf_MakeLockTable()\n{\n\tRF_LockTableEntry_t *lockTable;\n\tint     i, rc;\n\n\tRF_Calloc(lockTable, ((int) rf_lockTableSize), sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));\n\tif (lockTable == NULL)\n\t\treturn (NULL);\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trc = rf_mutex_init(&lockTable[i].mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\t/* XXX clean up other mutexes */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\treturn (lockTable);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void PrintLockedStripes(RF_LockTableEntry_t * lockTable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to init mutex file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_mutex_init",
          "args": [
            "&lockTable[i].mutex"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "rf_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_threadstuff.c",
          "lines": "173-186",
          "snippet": "int \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_general.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\nint \nrf_mutex_init(m)\ndecl_simple_lock_data(, *m)\n{\n\tsimple_lock_init(m);\n\treturn (0);\n}\n\nint \nrf_mutex_destroy(m)\ndecl_simple_lock_data(, *m)\n{\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_Calloc",
          "args": [
            "lockTable",
            "((int) rf_lockTableSize)",
            "sizeof(RF_LockTableEntry_t)",
            "(RF_LockTableEntry_t *)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic void PrintLockedStripes(RF_LockTableEntry_t * lockTable);\n\nRF_LockTableEntry_t *\nrf_MakeLockTable()\n{\n\tRF_LockTableEntry_t *lockTable;\n\tint     i, rc;\n\n\tRF_Calloc(lockTable, ((int) rf_lockTableSize), sizeof(RF_LockTableEntry_t), (RF_LockTableEntry_t *));\n\tif (lockTable == NULL)\n\t\treturn (NULL);\n\tfor (i = 0; i < rf_lockTableSize; i++) {\n\t\trc = rf_mutex_init(&lockTable[i].mutex);\n\t\tif (rc) {\n\t\t\tRF_ERRORMSG3(\"Unable to init mutex file %s line %d rc=%d\\n\", __FILE__,\n\t\t\t    __LINE__, rc);\n\t\t\t/* XXX clean up other mutexes */\n\t\t\treturn (NULL);\n\t\t}\n\t}\n\treturn (lockTable);\n}"
  },
  {
    "function_name": "rf_ConfigureStripeLockFreeList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "129-155",
    "snippet": "int \nrf_ConfigureStripeLockFreeList(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tunsigned mask;\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_stripelock_freelist, RF_MAX_FREE_STRIPELOCK,\n\t    RF_STRIPELOCK_INITIAL, sizeof(RF_StripeLockDesc_t));\n\trc = rf_ShutdownCreate(listp, rf_ShutdownStripeLockFreeList, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownStripeLockFreeList(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME(rf_stripelock_freelist, RF_STRIPELOCK_INITIAL, next,\n\t    (RF_StripeLockDesc_t *));\n\tfor (mask = 0x1; mask; mask <<= 1)\n\t\tif (rf_lockTableSize == mask)\n\t\t\tbreak;\n\tif (!mask) {\n\t\tprintf(\"[WARNING:  lock table size must be a power of two.  Setting to %d.]\\n\", RF_DEFAULT_LOCK_TABLE_SIZE);\n\t\trf_lockTableSize = RF_DEFAULT_LOCK_TABLE_SIZE;\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [
      "#define RF_STRIPELOCK_INITIAL   32",
      "#define RF_MAX_FREE_STRIPELOCK 128"
    ],
    "globals_used": [
      "static RF_FreeList_t *rf_stripelock_freelist;",
      "static void rf_ShutdownStripeLockFreeList(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"[WARNING:  lock table size must be a power of two.  Setting to %d.]\\n\"",
            "RF_DEFAULT_LOCK_TABLE_SIZE"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "rf_debug_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_debugprint.c",
          "lines": "82-108",
          "snippet": "void \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}",
          "includes": [
            "#include <sys/param.h>",
            "#include \"rf_options.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_threadstuff.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [
            "#define BUFMASK  (BUFSIZE-1)"
          ],
          "globals_used": [
            "static struct RF_Entry_s rf_debugprint_buf[BUFSIZE];",
            "static int rf_debugprint_index = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/param.h>\n#include \"rf_options.h\"\n#include \"rf_general.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_threadstuff.h\"\n#include \"rf_types.h\"\n\n#define BUFMASK  (BUFSIZE-1)\n\nstatic struct RF_Entry_s rf_debugprint_buf[BUFSIZE];\nstatic int rf_debugprint_index = 0;\n\nvoid \nrf_debug_printf(s, a1, a2, a3, a4, a5, a6, a7, a8)\n\tchar   *s;\n\tvoid   *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;\n{\n\tint     idx;\n\n\tif (rf_debugPrintUseBuffer) {\n\n\t\tRF_LOCK_MUTEX(rf_debug_print_mutex);\n\t\tidx = rf_debugprint_index;\n\t\trf_debugprint_index = (rf_debugprint_index + 1) & BUFMASK;\n\t\tRF_UNLOCK_MUTEX(rf_debug_print_mutex);\n\n\t\trf_debugprint_buf[idx].cstring = s;\n\t\trf_debugprint_buf[idx].a1 = a1;\n\t\trf_debugprint_buf[idx].a2 = a2;\n\t\trf_debugprint_buf[idx].a3 = a3;\n\t\trf_debugprint_buf[idx].a4 = a4;\n\t\trf_debugprint_buf[idx].a5 = a5;\n\t\trf_debugprint_buf[idx].a6 = a6;\n\t\trf_debugprint_buf[idx].a7 = a7;\n\t\trf_debugprint_buf[idx].a8 = a8;\n\t} else {\n\t\tprintf(s, a1, a2, a3, a4, a5, a6, a7, a8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_PRIME",
          "args": [
            "rf_stripelock_freelist",
            "RF_STRIPELOCK_INITIAL",
            "next",
            "(RF_StripeLockDesc_t *)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownStripeLockFreeList",
          "args": [
            "NULL"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "rf_ShutdownStripeLockFreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
          "lines": "122-127",
          "snippet": "static void \nrf_ShutdownStripeLockFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_stripelock_freelist, next, (RF_StripeLockDesc_t *));\n}",
          "includes": [
            "#include \"rf_shutdown.h\"",
            "#include \"rf_driver.h\"",
            "#include \"rf_debugprint.h\"",
            "#include \"rf_freelist.h\"",
            "#include \"rf_general.h\"",
            "#include \"rf_alloclist.h\"",
            "#include \"rf_stripelocks.h\"",
            "#include \"rf_raid.h\"",
            "#include \"rf_types.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static RF_FreeList_t *rf_stripelock_freelist;",
            "static void rf_ShutdownStripeLockFreeList(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_stripelock_freelist;\nstatic void rf_ShutdownStripeLockFreeList(void *);\n\nstatic void \nrf_ShutdownStripeLockFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_stripelock_freelist, next, (RF_StripeLockDesc_t *));\n}"
        }
      },
      {
        "call_info": {
          "callee": "RF_ERRORMSG3",
          "args": [
            "\"Unable to add to shutdown list file %s line %d rc=%d\\n\"",
            "__FILE__",
            "__LINE__",
            "rc"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rf_ShutdownCreate",
          "args": [
            "listp",
            "rf_ShutdownStripeLockFreeList",
            "NULL"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RF_FREELIST_CREATE",
          "args": [
            "rf_stripelock_freelist",
            "RF_MAX_FREE_STRIPELOCK",
            "RF_STRIPELOCK_INITIAL",
            "sizeof(RF_StripeLockDesc_t)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\n#define RF_STRIPELOCK_INITIAL   32\n#define RF_MAX_FREE_STRIPELOCK 128\n\nstatic RF_FreeList_t *rf_stripelock_freelist;\nstatic void rf_ShutdownStripeLockFreeList(void *);\n\nint \nrf_ConfigureStripeLockFreeList(listp)\n\tRF_ShutdownList_t **listp;\n{\n\tunsigned mask;\n\tint     rc;\n\n\tRF_FREELIST_CREATE(rf_stripelock_freelist, RF_MAX_FREE_STRIPELOCK,\n\t    RF_STRIPELOCK_INITIAL, sizeof(RF_StripeLockDesc_t));\n\trc = rf_ShutdownCreate(listp, rf_ShutdownStripeLockFreeList, NULL);\n\tif (rc) {\n\t\tRF_ERRORMSG3(\"Unable to add to shutdown list file %s line %d rc=%d\\n\",\n\t\t    __FILE__, __LINE__, rc);\n\t\trf_ShutdownStripeLockFreeList(NULL);\n\t\treturn (rc);\n\t}\n\tRF_FREELIST_PRIME(rf_stripelock_freelist, RF_STRIPELOCK_INITIAL, next,\n\t    (RF_StripeLockDesc_t *));\n\tfor (mask = 0x1; mask; mask <<= 1)\n\t\tif (rf_lockTableSize == mask)\n\t\t\tbreak;\n\tif (!mask) {\n\t\tprintf(\"[WARNING:  lock table size must be a power of two.  Setting to %d.]\\n\", RF_DEFAULT_LOCK_TABLE_SIZE);\n\t\trf_lockTableSize = RF_DEFAULT_LOCK_TABLE_SIZE;\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "rf_ShutdownStripeLockFreeList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2023-40216/repo/sys/dev/raidframe/rf_stripelocks.c",
    "lines": "122-127",
    "snippet": "static void \nrf_ShutdownStripeLockFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_stripelock_freelist, next, (RF_StripeLockDesc_t *));\n}",
    "includes": [
      "#include \"rf_shutdown.h\"",
      "#include \"rf_driver.h\"",
      "#include \"rf_debugprint.h\"",
      "#include \"rf_freelist.h\"",
      "#include \"rf_general.h\"",
      "#include \"rf_alloclist.h\"",
      "#include \"rf_stripelocks.h\"",
      "#include \"rf_raid.h\"",
      "#include \"rf_types.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static RF_FreeList_t *rf_stripelock_freelist;",
      "static void rf_ShutdownStripeLockFreeList(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RF_FREELIST_DESTROY",
          "args": [
            "rf_stripelock_freelist",
            "next",
            "(RF_StripeLockDesc_t *)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rf_shutdown.h\"\n#include \"rf_driver.h\"\n#include \"rf_debugprint.h\"\n#include \"rf_freelist.h\"\n#include \"rf_general.h\"\n#include \"rf_alloclist.h\"\n#include \"rf_stripelocks.h\"\n#include \"rf_raid.h\"\n#include \"rf_types.h\"\n\nstatic RF_FreeList_t *rf_stripelock_freelist;\nstatic void rf_ShutdownStripeLockFreeList(void *);\n\nstatic void \nrf_ShutdownStripeLockFreeList(ignored)\n\tvoid   *ignored;\n{\n\tRF_FREELIST_DESTROY(rf_stripelock_freelist, next, (RF_StripeLockDesc_t *));\n}"
  }
]